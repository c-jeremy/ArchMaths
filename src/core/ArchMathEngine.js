
     const NEW_WORKSPACE_THUMBNAIL_BASE64 = ""; 


 const Mat4 = {
        create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
        perspective: (out, fovy, aspect, near, far) => {
            const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            return out;
        },
        lookAt: (out, eye, center, up) => {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex=eye.x, eyey=eye.y, eyez=eye.z;
            let upx=up.x, upy=up.y, upz=up.z;
            let centerx=center.x, centery=center.y, centerz=center.z;
            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;
            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0=0; x1=0; x2=0; } else { len=1/len; x0*=len; x1*=len; x2*=len; }
            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0=0; y1=0; y2=0; } else { len=1/len; y0*=len; y1*=len; y2*=len; }
            out[0]=x0; out[1]=y0; out[2]=z0; out[3]=0;
            out[4]=x1; out[5]=y1; out[6]=z1; out[7]=0;
            out[8]=x2; out[9]=y2; out[10]=z2; out[11]=0;
            out[12]=-(x0*eyex + x1*eyey + x2*eyez);
            out[13]=-(y0*eyex + y1*eyey + y2*eyez);
            out[14]=-(z0*eyex + z1*eyey + z2*eyez);
            out[15]=1;
            return out;
        },
        multiply: (out, a, b) => {
            let a00=a[0], a01=a[1], a02=a[2], a03=a[3];
            let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
            let a20=a[8], a21=a[9], a22=a[10], a23=a[11];
            let a30=a[12], a31=a[13], a32=a[14], a33=a[15];
            let b0=b[0], b1=b[1], b2=b[2], b3=b[3];
            out[0]=b0*a00+b1*a10+b2*a20+b3*a30; out[1]=b0*a01+b1*a11+b2*a21+b3*a31; out[2]=b0*a02+b1*a12+b2*a22+b3*a32; out[3]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
            out[4]=b0*a00+b1*a10+b2*a20+b3*a30; out[5]=b0*a01+b1*a11+b2*a21+b3*a31; out[6]=b0*a02+b1*a12+b2*a22+b3*a32; out[7]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
            out[8]=b0*a00+b1*a10+b2*a20+b3*a30; out[9]=b0*a01+b1*a11+b2*a21+b3*a31; out[10]=b0*a02+b1*a12+b2*a22+b3*a32; out[11]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
            out[12]=b0*a00+b1*a10+b2*a20+b3*a30; out[13]=b0*a01+b1*a11+b2*a21+b3*a31; out[14]=b0*a02+b1*a12+b2*a22+b3*a32; out[15]=b0*a03+b1*a13+b2*a23+b3*a33;
            return out;
        },
        invert: (out, a) => {
            let a00=a[0], a01=a[1], a02=a[2], a03=a[3],
                a10=a[4], a11=a[5], a12=a[6], a13=a[7],
                a20=a[8], a21=a[9], a22=a[10], a23=a[11],
                a30=a[12], a31=a[13], a32=a[14], a33=a[15],
                b00=a00*a11-a01*a10, b01=a00*a12-a02*a10, b02=a00*a13-a03*a10,
                b03=a01*a12-a02*a11, b04=a01*a13-a03*a11, b05=a02*a13-a03*a12,
                b06=a20*a31-a21*a30, b07=a20*a32-a22*a30, b08=a20*a33-a23*a30,
                b09=a21*a32-a22*a31, b10=a21*a33-a23*a31, b11=a22*a33-a23*a32,
                det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;
            if(!det)return null;
            det=1.0/det;
            out[0]=(a11*b11-a12*b10+a13*b09)*det; out[1]=(a02*b10-a01*b11-a03*b09)*det; out[2]=(a31*b05-a32*b04+a33*b03)*det; out[3]=(a22*b04-a21*b05-a23*b03)*det;
            out[4]=(a12*b08-a10*b11-a13*b07)*det; out[5]=(a00*b11-a02*b08+a03*b07)*det; out[6]=(a32*b02-a30*b05-a33*b01)*det; out[7]=(a20*b05-a22*b02+a23*b01)*det;
            out[8]=(a10*b10-a11*b08+a13*b06)*det; out[9]=(a01*b08-a00*b10-a03*b06)*det; out[10]=(a30*b04-a31*b02+a33*b00)*det; out[11]=(a21*b02-a20*b04-a23*b00)*det;
            out[12]=(a11*b07-a10*b09-a12*b06)*det; out[13]=(a00*b09-a01*b07+a02*b06)*det; out[14]=(a31*b01-a30*b03-a32*b00)*det; out[15]=(a20*b03-a21*b01+a22*b00)*det;
            return out;
        },
        transpose: (out, a) => {
            let a01 = a[1], a02 = a[2], a03 = a[3];
            let a12 = a[6], a13 = a[7];
            let a23 = a[11];
            out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
            out[4] = a01; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
            out[8] = a02; out[9] = a12; out[10] = a[10]; out[11] = a[14];
            out[12] = a03; out[13] = a13; out[14] = a23; out[15] = a[15];
            return out;
        },
        transformVec3: (out, a, m) => {
            let x = a[0], y = a[1], z = a[2];
            let w = m[3] * x + m[7] * y + m[11] * z + m[15];
            w = w || 1.0;
            out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
            out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
            out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
            return out;
        }
        
    };



const edgeTable = new Int32Array([
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
]);

const triTable = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
];


const ADVANCED_FUNCTION_DEFINITIONS = [
{
    name: 'pow',
    params: ["in1","in2"],
    bodyJsString: `
const list1 = [
            66666667, 40000000, 80000000, 28571429, 57142857, 85714286, 22222222, 44444444, 88888889,
            18181818, 36363636, 54545455, 72727273, 90909091, 15384615, 30769231, 46153846, 61538462,
            76923077, 92307692, 13333333, 26666667, 53333333, 93333333, 11764706, 23529412, 35294118,
            47058824, 58823529, 70588235, 82352941, 94117647, 10526316, 21052632, 31578947, 42105263,
            52631579, 63157895, 73684211, 84210526, 94736842, 9523810, 19047619, 38095238, 47619048,
            76190476, 95238095, 8695652, 17391304, 26086957, 34782609, 43478261, 52173913, 60869565,
            69565217, 78260870, 86956522, 95652174, 8000000, 16000000, 24000000, 32000000, 48000000,
            56000000, 64000000, 72000000, 88000000, 96000000, 7407407, 14814815, 29629630, 37037037,
            51851852, 59259259, 74074074, 81481481, 96296296, 6896552, 13793103, 20689655, 27586207,
            34482759, 41379310, 48275862, 55172414, 62068966, 68965517, 75862069, 82758621, 89655172,
            96551724, 6451613, 12903226, 19354839, 25806452, 32258065, 38709677, 45161290, 51612903,
            58064516, 64516129, 70967742, 77419355, 83870968, 90322581, 96774194, 6060606, 12121212,
            24242424, 30303030, 42424242, 48484848, 60606061, 78787879, 84848485, 96969697, 5714286,
            11428571, 17142857, 22857143, 34285714, 45714286, 51428571, 62857143, 68571429, 74285714,
            91428571, 97142857, 5405405, 10810811, 16216216, 21621622, 27027027, 32432432, 37837838,
            43243243, 48648649, 54054054, 59459459, 64864865, 70270270, 75675676, 81081081, 86486486,
            91891892, 97297297, 5128205, 10256410, 20512821, 25641026, 35897436, 41025641, 51282051,
            56410256, 71794872, 82051282, 87179487, 97435897, 4878049, 9756098, 14634146, 19512195,
            24390244, 29268293, 34146341, 39024390, 43902439, 48780488, 53658537, 58536585, 63414634,
            68292683, 73170732, 78048780, 82926829, 87804878, 92682927, 97560976
        ];

        const list2 = [
            33333333, 20000000, 60000000, 14285714, 42857143, 71428571, 11111111, 55555556, 77777778,
            9090909, 27272727, 45454545, 63636364, 81818182, 7692308, 23076923, 38461538, 53846154,
            69230769, 84615385, 6666667, 46666667, 73333333, 86666667, 5882353, 17647059, 29411765,
            41176471, 52941176, 64705882, 76470588, 88235294, 5263158, 15789474, 26315789, 36842105,
            47368421, 57894737, 68421053, 78947368, 89473684, 4761905, 23809524, 52380952, 61904762,
            80952381, 90476190, 4347826, 13043478, 21739130, 30434783, 39130435, 47826087, 56521739,
            65217391, 73913043, 82608696, 91304348, 4000000, 12000000, 28000000, 36000000, 44000000,
            52000000, 68000000, 76000000, 84000000, 92000000, 3703704, 18518519, 25925926, 40740741,
            48148148, 62962963, 70370370, 85185185, 92592593, 3448276, 10344828, 17241379, 24137931,
            31034483, 37931034, 44827586, 51724138, 58620690, 65517241, 72413793, 79310345, 86206897,
            93103448, 3225806, 9677419, 16129032, 22580645, 29032258, 35483871, 41935484, 48387097,
            54838710, 61290323, 67741935, 74193548, 80645161, 87096774, 93548387, 3030303, 15151515,
            21212121, 39393939, 51515152, 57575758, 69696970, 75757576, 87878788, 93939394, 2857143,
            8571429, 25714286, 31428571, 37142857, 48571429, 54285714, 65714286, 77142857, 82857143,
            88571429, 94285714, 2702703, 8108108, 13513514, 18918919, 24324324, 29729730, 35135135,
            40540541, 45945946, 51351351, 56756757, 62162162, 67567568, 72972973, 78378378, 83783784,
            89189189, 94594595, 2564103, 12820513, 17948718, 28205128, 43589744, 48717949, 58974359,
            64102564, 74358974, 79487179, 89743590, 94871795, 2439024, 7317073, 12195122, 17073171,
            21951220, 26829268, 31707317, 36585366, 41463415, 46341463, 51219512, 56097561, 60975610,
            65853659, 70731707, 75609756, 80487805, 85365854, 90243902, 95121951
        ];
const base = Number(in1);
const exp1 = Number(in2);
let result;


if (base > 0) {
    result = Math.exp(Math.log(base) * exp1);
} 

else if (base === 0) {
    if (exp1 > 0) result = 0;
    else if (exp1 === 0) result = 1;
    else result = NaN; 
} 

else {

    if (Math.round(exp1) === exp1) {
        result = Math.pow(Math.abs(base), exp1);

        if (Math.abs(exp1 % 2) === 1) {
            result = 0 - result;
        }
    } 

    else {
        const absExp = Math.abs(exp1);
        

        const MAX_DENOM = 25; 
        const EPSILON = 1e-9; 
        
        let n = 0; // 分子
        let d = 0; // 分母
        let found = false; // 是否找到符合条件的“漂亮分数”
        
        // --- 连分数算法 ---
        let h1 = 1, k1 = 0; 
        let h2 = 0, k2 = 1;
        let b = absExp;
        
        // 迭代寻找
        for (let i = 0; i < 20; i++) {
            let a = Math.floor(b);
            
            // 递推计算
            let h = a * h1 + h2;
            let k = a * k1 + k2;
            
            // 【关键修改 1】如果在逼近过程中分母超过 13，直接停止，视为无效小数
            if (k > MAX_DENOM) {
                break;
            }
            
            // 【关键修改 2】检查当前分数 h/k 是否足够接近原指数
            // 只有误差极小时才采纳，防止 1.3456 被强行匹配成某个粗糙的分数
            if (Math.abs(absExp - h / k) < EPSILON) {
                n = h;
                d = k;
                found = true;
                break; // 找到了符合限制且足够精确的分数，跳出
            }
            
            // 更新变量进行下一次逼近
            h2 = h1; k2 = k1;
            h1 = h; k1 = k;
            
            if (Math.abs(b - a) < 1e-15) break; // 处理整数边界
            b = 1 / (b - a);
        }

        // --- 计算结果 ---
        // 只有找到了分母 <= 13 的分数，且分母是奇数时，负底数幂才有实数解
        if (found && d % 2 !== 0) {
            // 1. 先计算绝对值的幂
            result = Math.exp(Math.log(Math.abs(base)) * exp1);
            
            // 2. 符号判断：如果分子 n 是奇数，结果取负
            // 注意：Math.exp算出来永远是正数，需手动加负号
            // 例如 (-8)^(1/3) -> n=1(奇), d=3(奇) -> 结果 -2
            // 例如 (-2)^(2/3) -> n=2(偶), d=3(奇) -> 结果 +1.587...
            if (n % 2 !== 0) {
                result = 0 - result;
            }
        } else {
            // 没找到合适的分数（如 1.3456），或者分母是偶数（如 0.5=1/2），返回 NaN
            result = NaN;
        }
    }
}

return result;
    `
},{
        name: 'gamma',
        params: ['input'],
        bodyJsString: `
let count0;
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN; 
}


if (numInput <= 0 && numInput === Math.floor(numInput)) {
    return Infinity; 
}

if (numInput < 0.5) {
    const inputtemp = 1 - numInput; 
    if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
         if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
             return NaN;
         }
    }
    let gammaOfInputtemp = 2.5066282746310002 *
                           Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * 
                           Math.exp(-inputtemp - 6.5) *
                           (0.99999999999980993 +
                            676.5203681218851 / inputtemp -
                            1259.1392167224028 / (inputtemp + 1) +
                            771.32342877765313 / (inputtemp + 2) -
                            176.61502916214059 / (inputtemp + 3) +
                            12.507343278686905 / (inputtemp + 4) -
                            0.13857109526572012 / (inputtemp + 5) +
                            0.0000099843695780195716 / (inputtemp + 6) +
                            0.00000015056327351493116 / (inputtemp + 7));

    const sinOfPiInput = Math.sin(3.141592653589793 * numInput);

    if (Math.abs(sinOfPiInput) < 1e-15) { 
        return Infinity; 
    }
    if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
        return NaN; 
    }


    count0 = 3.141592653589793 / (gammaOfInputtemp * sinOfPiInput);

} else { 
    const inputtemp = numInput; 
    count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *Math.exp(0 -inputtemp - 6.5) *(0.99999999999980993 +676.5203681218851 / inputtemp -
              1259.1392167224028 / (inputtemp + 1) +
              771.32342877765313 / (inputtemp + 2) -
              176.61502916214059 / (inputtemp + 3) +
              12.507343278686905 / (inputtemp + 4) -
              0.13857109526572012 / (inputtemp + 5) +
              0.0000099843695780195716 / (inputtemp + 6) +
              0.00000015056327351493116 / (inputtemp + 7));
}

if (!isFinite(count0)) {
    if (numInput <= 0 && numInput === Math.floor(numInput)) {
        return Infinity;
    }
    return NaN; 
}
if (Math.abs(count0) < 1e-15) { 
    count0 = 0;
}
return count0;
        `
    },{
        name: 'erf',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
const intList1 = [0.9862838086968123,0.9284348836635736,0.827201315069765,0.6872929048116855,0.5152486363581541,0.31911236892788974,0.10805494870734365,-0.10805494870734365,-0.31911236892788974,-0.5152486363581541,-0.6872929048116855,-0.827201315069765,-0.9284348836635736,-0.9862838086968123];
const intList2 = [0.035119460331752,0.08015808715976036,0.12151857068790316,0.15720316715819357,0.18553839747793788,0.20519846372129574,0.21526385346315768,0.21526385346315768,0.20519846372129574,0.18553839747793788,0.15720316715819357,0.12151857068790316,0.08015808715976036,0.035119460331752];
let ram41 = 0;
let ram4205 = 0;
let ram42 = 0;
for (let i=0; i<intList1.length; i++){
ram4205 = 0.5*Math.atan(numInput)*(1+intList1[i]);
ram42 = Math.tan(ram4205);
ram41 += intList2[i]*Math.exp(-ram42*ram42)*(1+Math.tan(ram4205)*Math.tan(ram4205));
}
ram4205 =  ram41*0.5*Math.atan(numInput);
ram41 = 1.12837916709551257*ram4205;
return ram41;
        `
    },
    {
        name: 'erfc',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
const intList1 = [0.9862838086968123,0.9284348836635736,0.827201315069765,0.6872929048116855,0.5152486363581541,0.31911236892788974,0.10805494870734365,-0.10805494870734365,-0.31911236892788974,-0.5152486363581541,-0.6872929048116855,-0.827201315069765,-0.9284348836635736,-0.9862838086968123];
const intList2 = [0.035119460331752,0.08015808715976036,0.12151857068790316,0.15720316715819357,0.18553839747793788,0.20519846372129574,0.21526385346315768,0.21526385346315768,0.20519846372129574,0.18553839747793788,0.15720316715819357,0.12151857068790316,0.08015808715976036,0.035119460331752];
let ram41 = 0;
let ram4205 = 0;
let ram42 = 0;
for (let i=0; i<intList1.length; i++){
ram4205 = 0.5*Math.atan(numInput)*(1+intList1[i]);
ram42 = Math.tan(ram4205);
ram41 += intList2[i]*Math.exp(-ram42*ram42)*(1+Math.tan(ram4205)*Math.tan(ram4205));
}
ram4205 =  ram41*0.5*Math.atan(numInput);
ram41 = 1-1.12837916709551257*ram4205;
return ram41;
        `
    },{
        name: 'elliptice',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
    let ram41 = 0;
    let ram42 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = 0.5*((intList1[i]+1)*1.5707963267948966);
        ram41 += intList2[i] * 0.7853981633974483 * Math.sqrt(1-(numInput*Math.sin(ram42))*(numInput*Math.sin(ram42)));
    }
return ram41;
        `
    },
    {
        name: 'elliptick',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
    let ram41 = 0;
    let ram42 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = 0.5*((intList1[i]+1)*1.5707963267948966);
        ram41 += intList2[i] * 0.7853981633974483 / Math.sqrt(1-(numInput*Math.sin(ram42))*(numInput*Math.sin(ram42)));
    }
return ram41;
        `
    },{
        name: 'sign',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput < 0) {
    return -1;
} else if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'heaviside',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'sgn',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput < 0) {
    return -1;
} else if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'fresnels',
        params: ['input'],
        bodyJsString: `
const intList5 = [0, -0.11833633389852105, 0.11833633389852105, -0.23501148310291813, 0.23501148310291813, -0.34838758198902867, 0.34838758198902867, -0.4568730756140824, 0.4568730756140824, -0.5589450609425611, 0.5589450609425611, -0.6531706636968095, 0.6531706636968095, -0.7382271498464599, 0.7382271498464599, -0.8129204868958123, 0.8129204868958123, -0.8762020862145225, 0.8762020862145225, -0.9271834587251158, 0.9271834587251158, -0.9651484024508189, 0.9651484024508189, -0.9895609637285506, 0.9895609637285506, -1.0, 1.0];
const intList6 = [0.11861397766276303, 0.11778143658595616, 0.11778143658595616, 0.11529550025465198, 0.11529550025465198, 0.11119106525743703, 0.11119106525743703, 0.10552574782125301, 0.10552574782125301, 0.09837907458595276, 0.09837907458595276, 0.08985136525929056, 0.08985136525929056, 0.08006232197053846, 0.08006232197053846, 0.06914934236004328, 0.06914934236004328, 0.05726556968016273, 0.05726556968016273, 0.0445776579330617, 0.0445776579330617, 0.031262951735202384, 0.031262951735202384, 0.01750197487606558, 0.01750197487606558, 0.002849002849002849, 0.002849002849002849];
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN;
}

function sfnintsub(alpha) {
    const inputsfnint = Number(alpha);
    if (inputsfnint > 4.59) {
        return (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.318309886183791) + 0.0967546032995985) * inputsfnint * inputsfnint * inputsfnint * inputsfnint - 0.343115182520605) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 3.44171880544581) / Math.exp(13 * Math.log(inputsfnint)) * Math.cos(1.5707963267948966 * inputsfnint * inputsfnint) + 0.5 + (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.101321183642338) + 0.153989733820265) * inputsfnint * inputsfnint * inputsfnint * inputsfnint - 0.982952592264580) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 14.2419305760949) / Math.exp(15 * Math.log(inputsfnint)) * Math.sin(1.5707963267948966 * inputsfnint * inputsfnint);
    } else {
        let ram41 = 0;
        let ram42 = 0;
        for (let i = 0; i < intList5.length; i++) {
            ram42 = 0.5 * ((intList5[i] + 1) * inputsfnint);
            ram41 += intList6[i] * 0.5 * inputsfnint * Math.sin(ram42 * ram42 * 1.5707963267948966);
        }
        return ram41;
    }
}

if (numInput > 10000000) {
    return 0.5;
} else if (numInput < -10000000) {
    return -0.5;
} else if (numInput < 0) {
    return -sfnintsub(-numInput);
} else {
    return sfnintsub(numInput);
}
        `
    },{
        name: 'fresnelc',
        params: ['input'],
        bodyJsString: `
const intList5 = [0, -0.11833633389852105, 0.11833633389852105, -0.23501148310291813, 0.23501148310291813, -0.34838758198902867, 0.34838758198902867, -0.4568730756140824, 0.4568730756140824, -0.5589450609425611, 0.5589450609425611, -0.6531706636968095, 0.6531706636968095, -0.7382271498464599, 0.7382271498464599, -0.8129204868958123, 0.8129204868958123, -0.8762020862145225, 0.8762020862145225, -0.9271834587251158, 0.9271834587251158, -0.9651484024508189, 0.9651484024508189, -0.9895609637285506, 0.9895609637285506, -1.0, 1.0];
const intList6 = [0.11861397766276303, 0.11778143658595616, 0.11778143658595616, 0.11529550025465198, 0.11529550025465198, 0.11119106525743703, 0.11119106525743703, 0.10552574782125301, 0.10552574782125301, 0.09837907458595276, 0.09837907458595276, 0.08985136525929056, 0.08985136525929056, 0.08006232197053846, 0.08006232197053846, 0.06914934236004328, 0.06914934236004328, 0.05726556968016273, 0.05726556968016273, 0.0445776579330617, 0.0445776579330617, 0.031262951735202384, 0.031262951735202384, 0.01750197487606558, 0.01750197487606558, 0.002849002849002849, 0.002849002849002849];
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN;
}

function cfnintsub(alpha) {
    const inputsfnint = Number(alpha);
    if (inputsfnint > 4.59) {
        return (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.101321183642338) +0.153989733820265) * inputsfnint * inputsfnint * inputsfnint * inputsfnint -0.98295259226458) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 14.2419305760949) / Math.exp(15 * Math.log(inputsfnint)) * Math.cos(1.5707963267948966 * inputsfnint * inputsfnint) + 0.5 + (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * 0.318309886183791 -0.096754603299598) * inputsfnint * inputsfnint * inputsfnint * inputsfnint +0.343115182520605) * inputsfnint * inputsfnint * inputsfnint * inputsfnint -3.44171880544581) / Math.exp(13 * Math.log(inputsfnint)) * Math.sin(1.5707963267948966 * inputsfnint * inputsfnint);
    } else {
        let ram41 = 0;
        let ram42 = 0;
        for (let i = 0; i < intList5.length; i++) {
            ram42 = 0.5 * ((intList5[i] + 1) * inputsfnint);
            ram41 += intList6[i] * 0.5 * inputsfnint * Math.cos(ram42 * ram42 * 1.5707963267948966);
        }
        return ram41;
    }
}

if (numInput > 10000000) {
    return 0.5;
} else if (numInput < -10000000) {
    return -0.5;
} else if (numInput < 0) {
    return -cfnintsub(-numInput);
} else {
    return cfnintsub(numInput);
}
        `
    },{
        name: 'psi',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
    function calculateGamma(gammaInput) {
        const numInputGamma = Number(gammaInput);

        if (isNaN(numInputGamma)) {
            return NaN;
        }

        if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
            return Infinity;
        }

        let count0;
        if (numInputGamma < 0.5) {
            const inputtemp = 1 - numInputGamma;
            if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
                if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
                    return NaN;
                }
            }
            let gammaOfInputtemp = 2.5066282746310002 *
                Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *
                Math.exp(-inputtemp - 6.5) *
                (0.99999999999980993 +
                    676.5203681218851 / inputtemp -
                    1259.1392167224028 / (inputtemp + 1) +
                    771.32342877765313 / (inputtemp + 2) -
                    176.61502916214059 / (inputtemp + 3) +
                    12.507343278686905 / (inputtemp + 4) -
                    0.13857109526572012 / (inputtemp + 5) +
                    0.0000099843695780195716 / (inputtemp + 6) +
                    0.00000015056327351493116 / (inputtemp + 7));

            const sinOfPiInput = Math.sin(Math.PI * numInputGamma);

            if (Math.abs(sinOfPiInput) < 1e-15) {
                return Infinity;
            }
            if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
                return NaN;
            }
            count0 = Math.PI / (gammaOfInputtemp * sinOfPiInput);
        } else {
            const inputtemp = numInputGamma;
            count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * Math.exp(0 - inputtemp - 6.5) * (0.99999999999980993 + 676.5203681218851 / inputtemp -
                1259.1392167224028 / (inputtemp + 1) +
                771.32342877765313 / (inputtemp + 2) -
                176.61502916214059 / (inputtemp + 3) +
                12.507343278686905 / (inputtemp + 4) -
                0.13857109526572012 / (inputtemp + 5) +
                0.0000099843695780195716 / (inputtemp + 6) +
                0.00000015056327351493116 / (inputtemp + 7));
        }

        if (!isFinite(count0)) {
            if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
                return Infinity;
            }
            return NaN;
        }
        if (Math.abs(count0) < 1e-15) {
            count0 = 0;
        }
        return count0;
    }

if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < 0 && numInput % 2 > 1) {
    return NaN;
}
const ram48 = Math.log(calculateGamma(numInput+0.0000001));
const ram49 = Math.log(calculateGamma(numInput-0.0000001));
const ram50 = (ram48-ram49)/0.0000002;
return ram50;
        `
    },
    {
        name: 'lambertw',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < -0.3698) {
    return NaN; 
}
let ram48 = 0;
let ram4801 = 0;
if (numInput > 1) {
ram48 = Math.log(0.367879441171+Math.sqrt(0.735758882343*(0.367879441171+numInput))+0.30406826609*(0.367879441171+numInput));
} else if (numInput <=0) {
ram48 = 0.5;
} else {
ram48 = 0.5*Math.exp(Math.log(numInput)/3);
}
for (let i=0; i<6; i++){
    if (numInput > 1) {
        ram48 = ram48 - (ram48*Math.log(ram48)-numInput)/(Math.log(ram48)+1);
    } else {
        ram48 = ram48 - (ram48*Math.exp(ram48)-numInput)/(Math.exp(ram48)*(ram48+1));
    }
}
if (numInput > 1) {
    ram48 = Math.log(ram48);
}
return ram48;
        `
    },
    {
        name: 'ltw',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < -0.3698) {
    return NaN; 
}
let ram48 = 0;
let ram4801 = 0;
if (numInput > 1) {
ram48 = Math.log(0.367879441171+Math.sqrt(0.735758882343*(0.367879441171+numInput))+0.30406826609*(0.367879441171+numInput));
} else if (numInput <=0) {
ram48 = 0.5;
} else {
ram48 = 0.5*Math.exp(Math.log(numInput)/3);
}
for (let i=0; i<6; i++){
    if (numInput > 1) {
        ram48 = ram48 - (ram48*Math.log(ram48)-numInput)/(Math.log(ram48)+1);
    } else {
        ram48 = ram48 - (ram48*Math.exp(ram48)-numInput)/(Math.exp(ram48)*(ram48+1));
    }
}
if (numInput > 1) {
    ram48 = Math.log(ram48);
}
return ram48;
        `
    },{
        name: 'li',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
let anstemp;
function Ei(inputValue) {
    let ram39;
    let ram40;
    let ram41;
    let ram42;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput === 0) {
        return -Infinity;
    }

    if (numericInput < 0) {
        ram41 = 0;
        ram39 = 1.5707963266948965;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -ram41;
    } else { 
        ram41 = 0;
        ram39 = -0.09966865249116204;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -1.62281281396928 - ram41;
    }
    return ram41;
}

const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
if (numInput < 1){
    let ram41 = 0;
    let ram42 = 0;
    ram41 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = Math.tan(0.5*((intList1[i]+1)*Math.atan(numInput)));
        ram41 += intList2[i] / Math.log(ram42) * (1 + ram42 * ram42);
    }
    anstemp = ram41*0.5*Math.atan(numInput);
} else {
    anstemp = Ei(Math.log(numInput));
}
return anstemp;
        `
    },
    {
        name: 'zeta',
        params: ['input'],
        bodyJsString: `
function zeta(input) {
    const intList3 = [-3767.07295202344238794, 20718.90129135376820461, -54269.3950178977148402, 89585.7044308550386081, -104281.5200530007626999, 90823.1555035673480261, -61337.2850255043749233, 32857.2738403674460368, -14173.10630299342443144, 4967.16480612721712562, -1424.318629211626147828, 332.985035713196841030, -65.1540800052316053923, 9.05528272984254832110, -2.27838421479562171980, -0.869333702853347646837, -1.010605698722239028067, -0.999327686833876549310, -1.000032388528751445375, -1.000000132160679152173, -1.000001970769606935476, -0.999879298988036314809, -1.000785194482447799159, -1.003178227954262160056, -0.918938533204672809162, -0.499999999999999999975];
    const intList4 = [1.3083048186768757010e-24, -1.7999869864062488602e-22, 1.1931012369756043030e-20, -5.0751802223521389106e-19, 1.5570752325465378835e-17, -3.6713955155400826896e-16, 6.922805756662876691e-15, -1.0725610525682801118e-13, 1.3922618091090791236e-12, -1.5364814246219452810e-11, 1.4579564085640510737e-10, -1.2001975969275128697e-9, 8.633561918653007587e-9, -5.4594868401656446764e-8, 3.0503075328141795841e-7, -1.5125434905810207720e-6, 6.684076591078296649e-6, -0.000026431136828897944873, 0.00009393159806725266375, -0.00030149203693227594249, 0.0008792353824119747563, -0.0023471823395646685576, 0.005789968439669778913, -0.013349584800389788883, 0.029149267728612186032, -0.06110256079651455023, 0.12443817580896012489, -0.24813667949159626221, 0.48506436189962881445, -0.9222804836540180001, 1.6692184480209623179, -2.7428447125055807821, 3.6757500000505673416, -1.9999996917015266665];

    function calculateGamma(gammaInput) {
        const numInputGamma = Number(gammaInput);

        if (isNaN(numInputGamma)) {
            return NaN;
        }

        if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
            return Infinity;
        }

        let count0;
        if (numInputGamma < 0.5) {
            const inputtemp = 1 - numInputGamma;
            if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
                if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
                    return NaN;
                }
            }
            let gammaOfInputtemp = 2.5066282746310002 *
                Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *
                Math.exp(-inputtemp - 6.5) *
                (0.99999999999980993 +
                    676.5203681218851 / inputtemp -
                    1259.1392167224028 / (inputtemp + 1) +
                    771.32342877765313 / (inputtemp + 2) -
                    176.61502916214059 / (inputtemp + 3) +
                    12.507343278686905 / (inputtemp + 4) -
                    0.13857109526572012 / (inputtemp + 5) +
                    0.0000099843695780195716 / (inputtemp + 6) +
                    0.00000015056327351493116 / (inputtemp + 7));

            const sinOfPiInput = Math.sin(Math.PI * numInputGamma);

            if (Math.abs(sinOfPiInput) < 1e-15) {
                return Infinity;
            }
            if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
                return NaN;
            }
            count0 = Math.PI / (gammaOfInputtemp * sinOfPiInput);
        } else {
            const inputtemp = numInputGamma;
            count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * Math.exp(0 - inputtemp - 6.5) * (0.99999999999980993 + 676.5203681218851 / inputtemp -
                1259.1392167224028 / (inputtemp + 1) +
                771.32342877765313 / (inputtemp + 2) -
                176.61502916214059 / (inputtemp + 3) +
                12.507343278686905 / (inputtemp + 4) -
                0.13857109526572012 / (inputtemp + 5) +
                0.0000099843695780195716 / (inputtemp + 6) +
                0.00000015056327351493116 / (inputtemp + 7));
        }

        if (!isFinite(count0)) {
            if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
                return Infinity;
            }
            return NaN;
        }
        if (Math.abs(count0) < 1e-15) {
            count0 = 0;
        }
        return count0;
    }

    if (input === 1) {
        return Infinity;
    }

    let ram48;

    if (input < 0) {
        const oneMinusInput = 1 - input;
        const ramzeta = calculateGamma(oneMinusInput);
        const term_2pi_pow_s_minus_1 = Math.exp(Math.log(2 * Math.PI) * (input - 1));
        const sin_pi_s_div_2 = Math.cos((1 - input) * (Math.PI / 2)); 
        const reflectionFactor = 2 * ramzeta * sin_pi_s_div_2 * term_2pi_pow_s_minus_1;
        
        const zetaOneMinusInput = zeta(oneMinusInput);
        ram48 = zetaOneMinusInput * reflectionFactor;
        return ram48;
    } else if (input < 1) { 
        if (input > 0.5) { 
            const oneMinusInput = 1 - input;
            const zetaOneMinusInput = zeta(oneMinusInput); 
            const ramzeta = calculateGamma(oneMinusInput);
            
            const factor_2_s_pi_s_minus_1 = Math.exp(Math.LN2 * input + Math.log(Math.PI) * (input - 1));
            const sin_pi_s_div_2 = Math.sin(input * (Math.PI / 2));
            
            ram48 = factor_2_s_pi_s_minus_1 * ramzeta * zetaOneMinusInput * sin_pi_s_div_2;
            return ram48;
        } else { 
            ram48 = intList3[0];
            for (let i = 1; i < intList3.length; i++) {
                ram48 = ram48 * input + intList3[i];
            }
            return ram48;
        }
    } else { 
        if (input < 6) {
            ram48 = intList4[0];
            for (let i = 1; i < intList4.length; i++) {
                ram48 = ram48 * input + intList4[i];
            }
            ram48 = 1 / ram48;
            return ram48;
        } else {
            let ram51 = 0;
            let ram46 = 1;
            let ram37 = 1;
            const limit = Math.ceil(75 / input) + 2;
            for (let i = 1; i < limit; i++) {
                ram51 += ram37 / Math.pow(ram46, input);
                ram46 += 1;
                ram37 = -ram37;
            }
            ram48 = ram51 / (1 - Math.pow(2, 1 - input));
            return ram48;
        }
    }
}
const numInputz2 = Number(input);
const anstemp = zeta(numInputz2);
return anstemp;
        `
    },
    {
        name: 'sinintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Si(inputValue) {
    let ram41;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput < 0) {
        const ram4105 = Si(-numericInput);
        ram41 = -ram4105;
    } else {
        if (numericInput > 21.991148575128552) {
            ram41 = Math.PI / 2 +
                Math.sin(numericInput) * (
                    -1 / Math.pow(numericInput, 2) +
                    6 / Math.pow(numericInput, 4) -
                    120 / Math.pow(numericInput, 6) +
                    5040 / Math.pow(numericInput, 8)
                ) +
                Math.cos(numericInput) * (
                    -1 / numericInput +
                    2 / Math.pow(numericInput, 3) -
                    24 / Math.pow(numericInput, 5) +
                    720 / Math.pow(numericInput, 7)
                );
        } else {
            let ram42 = 0;
            ram41 = 0;
            for (let i = 0; i < intList1.length; i++) {
                ram42 = 0.5 * (numericInput + numericInput * intList1[i]);
                if (ram42 === 0) {
                    ram41 += intList2[i] * numericInput / 2;
                } else {
                    ram41 += intList2[i] * 0.5 * numericInput * Math.sin(ram42) / ram42;
                }
            }
        }
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Si(numInputsi);
return anstemp;
        `
    },
    {
        name: 'cosintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Ci(inputValue) {
    let ram41;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput < 0) {
        return NaN;
    } else {
        if (numericInput > 21.991148575128552) {
            ram41 = 
                Math.cos(numericInput) * (
                    -1 / Math.pow(numericInput, 2) +
                    6 / Math.pow(numericInput, 4) -
                    120 / Math.pow(numericInput, 6) +
                    5040 / Math.pow(numericInput, 8)
                ) -
                Math.sin(numericInput) * (
                    -1 / numericInput +
                    2 / Math.pow(numericInput, 3) -
                    24 / Math.pow(numericInput, 5) +
                    720 / Math.pow(numericInput, 7)
                );
        } else {
            let ram42 = 0;
            ram41 = 0;
            for (let i = 0; i < intList1.length; i++) {
                ram42 = 0.5 * (numericInput + numericInput * intList1[i]);
                if (ram42 === 0) {
                    ram41 += intList2[i] * numericInput / 2;
                } else {
                    ram41 += intList2[i] * 0.5 * numericInput * (Math.cos(ram42)-1) / ram42;
                }
            }
            ram41+=Math.log(numericInput);
            ram41+=0.577215664901532;
        }
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Ci(numInputsi);
return anstemp;
        `
    },
    {
        name: 'expintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Ei(inputValue) {
    let ram39;
    let ram40;
    let ram41;
    let ram42;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput === 0) {
        return -Infinity;
    }

    if (numericInput < 0) {
        ram41 = 0;
        ram39 = 1.5707963266948965;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -ram41;
    } else {
        ram41 = 0;
        ram39 = -0.09966865249116204;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -1.62281281396928 - ram41;
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Ei(numInputsi);
return anstemp;
        `
    },{name: 'range',
      params: [
        "x",
        "m",
        "n"
      ],
      bodyJsString: "const num = Number(x);\nconst min = Number(m);\nconst max = Number(n);\n\n\nif (num<min || num>max){\nreturn NaN;\n} else {\nreturn 0;\n}"
    },
    {
      name: "llim",
      params: [
        "x",
        "n"
      ],
      bodyJsString: "const a = Number(x);\nconst b = Number(n);\nif (a<b){\nreturn NaN;\n} else {\nreturn 0;\n}"
    },
    {
      name: "ulim",
      params: [
        "x",
        "n"
      ],
      bodyJsString: "const a = Number(x);\nconst b = Number(n);\nif (a>b){\nreturn NaN;\n} else {\nreturn 0;\n}"
    }
];

class CustomSlider {
    constructor(containerId, options = {}) {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            console.error(`Slider container #${containerId} not found.`);
            return;
        }

        this.options = {
            min: 0,
            max: 1,
            step: 0.01,
            value: 0.5,
            onInput: () => {},
            onChange: () => {},
            type: 'default'
        };
        Object.assign(this.options, options);

        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container.innerHTML = '';
        this.container.appendChild(this.canvas);
        
        this.isDragging = false;
        this.visualValue = this.options.value;
        this.visualRadiusMultiplier = 1.0;
        this.targetRadiusMultiplier = 1.0;
        this.animationId = null;
        this.resizeObserver = new ResizeObserver(() => this.resizeCanvas());
        this.resizeObserver.observe(this.container);

        this.setupEventListeners();
        this.resizeCanvas();
    }

    resizeCanvas() {
        const rect = this.container.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width * window.devicePixelRatio;
        this.canvas.height = this.height * window.devicePixelRatio;
        this.canvas.style.width = `${this.width}px`;
        this.canvas.style.height = `${this.height}px`;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        this.draw();
    }
    
    setValue(newValue, triggerCallbacks = false) {
        const { min, max, step } = this.options;
        let value = Math.max(min, Math.min(max, newValue));
        if (step > 0) {
            value = min + Math.round((value - min) / step) * step;
        }
        
        if (this.options.value !== value) {
            this.options.value = value;
            if (triggerCallbacks) {
                this.options.onInput({ target: this });
                this.options.onChange({ target: this });
            }
        }
        this.startAnimation();
    }

      
draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        const { min, max, type, context } = this.options;
        const normalizedValue = (this.visualValue - min) / (max - min);

        const w = this.width;
        const h = this.height;
        const radius = h / 2;
        const rootStyle = getComputedStyle(document.documentElement);
        const trackBgColor = rootStyle.getPropertyValue('--input-range-track-bg').trim();

        this.ctx.fillStyle = trackBgColor;
        this.ctx.beginPath();
        this.ctx.arc(radius, radius, radius, Math.PI / 2, 3 * Math.PI / 2);
        this.ctx.lineTo(w - radius, 0);
        this.ctx.arc(w - radius, radius, radius, 3 * Math.PI / 2, Math.PI / 2);
        this.ctx.closePath();
        this.ctx.fill();
        
        let fillStyle;
        const gradient = this.ctx.createLinearGradient(radius, 0, w - radius, 0);

        switch(type) {
            case 'hue':
                gradient.addColorStop(0, 'hsl(0, 100%, 50%)');
                gradient.addColorStop(0.16, 'hsl(60, 100%, 50%)');
                gradient.addColorStop(0.33, 'hsl(120, 100%, 50%)');
                gradient.addColorStop(0.5, 'hsl(180, 100%, 50%)');
                gradient.addColorStop(0.66, 'hsl(240, 100%, 50%)');
                gradient.addColorStop(0.83, 'hsl(300, 100%, 50%)');
                gradient.addColorStop(1, 'hsl(360, 100%, 50%)');
                fillStyle = gradient;
                break;
            case 'saturation':
                if (context) {
                    gradient.addColorStop(0, `hsl(${context.h * 3.6}, 0%, 50%)`);
                    gradient.addColorStop(1, `hsl(${context.h * 3.6}, 100%, 50%)`);
                    fillStyle = gradient;
                }
                break;
            case 'brightness':
                if (context) {
                    gradient.addColorStop(0, `hsl(${context.h * 3.6}, 100%, 0%)`);
                    gradient.addColorStop(1, `hsl(${context.h * 3.6}, 100%, 50%)`);
                    fillStyle = gradient;
                }
                break;
            case 'alpha':
                // 修改：强制使用蓝色 (Hue=56, 对应角度约201度)
                const alphaGradient = this.ctx.createLinearGradient(radius, 0, w - radius, 0);
                // 56 * 3.6 = 201.6度
                alphaGradient.addColorStop(0, `hsla(201.6, 100%, 50%, 1)`);
                alphaGradient.addColorStop(1, `hsla(201.6, 100%, 50%, 0)`);
                fillStyle = alphaGradient;
                break;
            default:
                const isDark = rootStyle.getPropertyValue('--bg-color').trim() < '#888';
                const preferredHue = parseFloat(rootStyle.getPropertyValue('--preferred-hue')) || 0;

                if (!isDark && preferredHue !== 0) {
                    gradient.addColorStop(0, `hsl(${preferredHue}, 100%, 50%)`);
                    gradient.addColorStop(1, `hsl(${preferredHue}, 100%, 50%)`);
                } else {
                    const accentColor = rootStyle.getPropertyValue('--text-color-accent').trim();
                    gradient.addColorStop(0, accentColor);
                    gradient.addColorStop(1, accentColor);
                }
                fillStyle = gradient;
        }

        const knobCenterX = radius + (w - h) * normalizedValue;
        if (knobCenterX > radius) {
            this.ctx.save();
            this.ctx.fillStyle = fillStyle || '#007bff'; 
            this.ctx.beginPath();
            this.ctx.arc(radius, radius, radius, Math.PI / 2, 3 * Math.PI / 2); 
            this.ctx.lineTo(knobCenterX, 0); 
            this.ctx.arc(knobCenterX, radius, radius, 3 * Math.PI / 2, Math.PI / 2); 
            this.ctx.closePath(); 
            this.ctx.fill();
            this.ctx.restore();
        }

        const knobSize = h * 0.675 * 0.75 * this.visualRadiusMultiplier;
        const knobRadius = knobSize / 2;
        this.ctx.fillStyle = 'rgb(255, 255, 255)';
        this.ctx.beginPath();
        this.ctx.arc(knobCenterX, radius, knobRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    startAnimation() {
        if (!this.animationId) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }

    animate() {
        const deltaValue = this.options.value - this.visualValue;
        const deltaRadius = this.targetRadiusMultiplier - this.visualRadiusMultiplier;
        
        const EASING_FACTOR = 0.2;
        if (Math.abs(deltaValue) < (this.options.max - this.options.min) * 0.001 && Math.abs(deltaRadius) < 0.01) {
            this.visualValue = this.options.value;
            this.visualRadiusMultiplier = this.targetRadiusMultiplier;
            this.draw();
            this.animationId = null;
            return;
        }

        this.visualValue += deltaValue * EASING_FACTOR;
        this.visualRadiusMultiplier += deltaRadius * EASING_FACTOR;
        this.draw();
        this.animationId = requestAnimationFrame(() => this.animate());
    }

             handleInteraction(event) {
        event.preventDefault();
        const { min, max, step } = this.options;
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = (event.clientX ?? event.touches[0].clientX) - rect.left;
        
        const travelRange = this.width - this.height;
        const startOffset = this.height / 2;
        
        let normalizedValue = (mouseX - startOffset) / travelRange;
        normalizedValue = Math.max(0, Math.min(1, normalizedValue));
        
        let newValue = min + normalizedValue * (max - min);
        if (step > 0) {
            newValue = min + Math.round((newValue - min) / step) * step;
        }
        
        if (this.options.value !== newValue) {
            this.options.value = newValue;
            this.options.onInput({ target: this });
        }
        this.startAnimation();
    }

    setupEventListeners() {
        const handleDown = (event) => {
            this.isDragging = true;
            this.targetRadiusMultiplier = 1.2;
            this.startAnimation();
            this.handleInteraction(event);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('mouseup', handleUp);
            window.addEventListener('touchend', handleUp);
        };

        const handleMove = (event) => {
            if (this.isDragging) {
                this.handleInteraction(event);
            }
        };

        const handleUp = () => {
            if (this.isDragging) {
                this.isDragging = false;
                this.targetRadiusMultiplier = 1.0;
                this.startAnimation();
                this.options.onChange({ target: this });
                window.removeEventListener('mousemove', handleMove);
                window.removeEventListener('touchmove', handleMove);
                window.removeEventListener('mouseup', handleUp);
                window.removeEventListener('touchend', handleUp);
            }
        };

        this.container.addEventListener('mousedown', handleDown);
        this.container.addEventListener('touchstart', handleDown, { passive: false });
    }

    disconnect() {
        this.resizeObserver.disconnect();
    }
}

class ArchEngine {
    constructor() {
        this.canvas = document.getElementById('plot-canvas');
        this.axisCanvas = document.getElementById('axis-canvas');
        this.axisCtx = this.axisCanvas.getContext('2d');
        this.gl = null;
        this.shaderProgramLines = null;
        this.attributeLocations = {};
        this.uniformLocations = {};
        this.lineVertexBuffer = null;

        this.sidebar = document.getElementById('sidebar');
        this.entryList = document.getElementById('entry-list');
        this.canvasContainer = document.getElementById('canvas-container');
        this.fpsDisplay = document.getElementById('fps-display');
        this.entries = [];
        this.variables = new Map();

        this.allowedVariableKeys = new Set('abcdfghijklmnopqrsuvw'.split(''));
        this.disallowedVariableKeys = new Set('etxyz'.split('')); 

        this.globalPlayState = 0;
        this.rafId = null;
        this.lastAnimationTime = 0;
        this.needsRedraw = false;
        this.lastFPSUpdateTime = 0;
        this.fps = 0;
        this.frameCounter = 0;
        this.editingEntryIndex = -1;

        this.scale = 50;
        this.offset = { x: 0, y: 0 };
        this.dragging = false;
        this.lastPos = { x: 0, y: 0 };
        this.minScale = 0.05;
        this.maxScale = 50000;

        this.isResizingSidebar = false;
        this.initialResizeX = 0;
        this.initialResizeY = 0;
        this.resizeHandleWidth = 10;
        this.touchResizePadding = 20;

        this.isResizingSidebarTouch = false;
        this.initialResizeTouchX = 0;
        this.initialResizeTouchY = 0;
        this.isPortraitMode = false;

        this.highlightedObject = null;
        this.highlightTimeout = null;
        this.snapTargetObject = null;
        this.mouseMoved = false;

        this.selectedPointIndex = -1;
        this.draggingPoint = false;
        this.dragHitboxRadiusMouse = 12;
        this.dragHitboxRadiusTouch = 24;
        this.infoDisplay = null;
        this.infoDisplayTimeout = null;
        this.highlightedObject = null;
        this.snapTargetObject = null;
        this.mouseMoved = false;
        this.currentCodeEditIndex = -1;
        this.defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral','pow','range','llim','ulim']);

        this.touchState = {
            panning: false,
            pinching: false,
            lastPanPos: { x: 0, y: 0 },
            initialPinchDist: 0,
            initialPinch: {
                center: { x: 0, y: 0 },
                scale: 1,
                offset: { x: 0, y: 0 }
            }
        };
        this.isTransformingCache = false;
        this.transformInitialState = {
            offset: { x: 0, y: 0 },
            scale: 1
        };
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        this.isUsingPanOptimization = true;
        this.panStartOffset = { x: 0, y: 0 };
        this.touchMoved = false; 
        this.touchStartPos = { x: 0, y: 0 }; 
        this.interactionWasPinch = false;
        this.isSmoothZoomingActive = false;
this.smoothZoomVelocity = 1.0;
this.smoothZoomTarget = { x: 0, y: 0 };
this.mouseZoomInertiaScale = 0.3;
this.touchZoomInertiaScale = 0.3;
this.zoomEventHistory = [];
this.currentUIMode = 'plot'; 
this.filename = "Arch Graph 1";
        this.appVersion = 11900;
        this.fileNameDisplay = document.getElementById('file-name-display');


        this.is3DMode = false;
        this.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
        this.center3D = { x:0, y:0, z:0 };
        this.offset3D = { x: 0, y: 0 };
        this.bounds3D = 8;
        this.scale3D = 1.0; 
        this.isDragging3D = false;
        this.lastMouse3D = { x: 0, y: 0 };
        this.pinchStartDist3D = 0;
        this.pinchStartScale3D = 1;
        this.viewport3D = { x: 0, y: 0, w: 0, h: 0 };
        

        this.cache3D = {
            axes: null,
            grid: null,
            box: null,
            meshes: new Map(), 
            lines: new Map(),
            ticks: null,
            labels: []
        };
        
 
        this.shaderProgram3D = null;
        this.shaderProgram3DLine = null;
        this.attribLoc3D = {};
        this.uniformLoc3D = {};

        this.geometryInteractionState = {
            active: false,
            type: null, 
            prompt: '',
            clicksNeeded: 0,
            pointsSelected: [],
        };
        this.geometryPanel = document.getElementById('geometry-panel');
        this.lastGeometryTouchTime = 0; 
        this.geometryTouchDelay = 500; 
        this.traceState = {
            active: false,
            targetName: null,
            path: []
        };
                this.globalScript = "";
              
        this.globalScriptIntervalId = null;
        this.pen = {
            color: [1, 0, 0, 1],
            thickness: 2,
            isDown: false,
            x: 0,
            y: 0,
            segments: []
        };


        this.explicitPrecisionSlider = null;
        this.implicitPrecisionSlider = null;
        this.integralPrecisionSlider = null;
        this.preferredColorSlider = null;
        this.activeSliders = []; 

        this.categoryFilterMode = 0; 
        this.categoryIcons = [
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzQuNjUxOTcsMTg1LjM0ODAzdi0xMC42OTYwNmgxMC42OTYwNnYxMC42OTYwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMTU2OSIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM1LjM5NzI3LDE3Ni41NTQ2NmMwLC0wLjEyMjY0IDAuMDIyOTksLTAuMjI5OTQgMC4wNjg5OCwtMC4zMzcyNWMwLjA0NTk5LC0wLjEwNzMxIDAuMTA3MzEsLTAuMTk5MjkgMC4xODM5NiwtMC4yNzU5M2MwLjA3NjY1LC0wLjA3NjY1IDAuMTY4NjIsLTAuMTM3OTcgMC4yNzU5MywtMC4xODM5NmMwLjEwNzMxLC0wLjA0NTk5IDAuMjE0NjIsLTAuMDY4OTggMC4zMzcyNSwtMC4wNjg5OGg3LjQ3MzIxYzAuMTIyNjQsMCAwLjIyOTk0LDAuMDIyOTkgMC4zMzcyNSwwLjA2ODk4YzAuMTA3MzEsMC4wNDU5OSAwLjE5OTI5LDAuMTA3MzEgMC4yNzU5MywwLjE4Mzk2YzAuMDc2NjUsMC4wNzY2NSAwLjEzNzk3LDAuMTY4NjIgMC4xODM5NiwwLjI3NTkzYzAuMDQ1OTksMC4xMDczMSAwLjA2ODk4LDAuMjE0NjIgMC4wNjg5OCwwLjMzNzI1YzAsMC4yNDUyOCAtMC4wOTE5NywwLjQ1MjIzIC0wLjI2ODI3LDAuNjIwODVsLTIuOTEyNjMsMi43NzQ2N2MtMC4wMzgzMywwLjAzODMzIC0wLjA3NjY1LDAuMDg0MzEgLTAuMTE0OTgsMC4xMzc5N2MtMC4wMzgzMywwLjA1MzY1IC0wLjA2MTMyLDAuMDk5NjQgLTAuMDg0MzEsMC4xNDU2M2MtMC4wNDU5OSwwLjEwNzMxIC0wLjA2ODk4LDAuMjIyMjggLTAuMDY4OTgsMC4zNDQ5MnYzLjQ0OTE3YzAsMC4wNzY2NSAtMC4wMzA2NiwwLjE0NTYzIC0wLjA4NDMxLDAuMTk5MjljLTAuMDUzNjUsMC4wNTM2NSAtMC4xMjI2NCwwLjA4NDMxIC0wLjE5OTI5LDAuMDg0MzFjLTAuMDUzNjUsMCAtMC4xMDczMSwtMC4wMTUzMyAtMC4xNjA5NiwtMC4wNDU5OWwtMS43MjQ1OSwtMS4xNDk3M2MtMC4wODQzMSwtMC4wNTM2NSAtMC4xMzAzLC0wLjEzNzk3IC0wLjEzMDMsLTAuMjM3NnYtMi4yOTk0NWMwLC0wLjEyMjY0IC0wLjAyMjk5LC0wLjIyOTk0IC0wLjA2ODk4LC0wLjM0NDkyYy0wLjAyMjk5LC0wLjA1MzY1IC0wLjA1MzY1LC0wLjEwNzMxIC0wLjA4NDMxLC0wLjE1MzI5Yy0wLjAzMDY2LC0wLjA0NTk5IC0wLjA2ODk4LC0wLjA5MTk3IC0wLjExNDk4LC0wLjEzMDNsLTIuOTEyNjMsLTIuNzc0NjdjLTAuMTkxNjIsLTAuMTY4NjIgLTAuMjc1OTMsLTAuMzc1NTcgLTAuMjc1OTMsLTAuNjIwODV6TTI0NC4wMjAxOSwxNzYuNTU0NjZjMCwtMC4wNzY2NSAtMC4wMzA2NiwtMC4xNDU2MyAtMC4wODQzMSwtMC4xOTkyOWMtMC4wNTM2NSwtMC4wNTM2NSAtMC4xMjI2NCwtMC4wODQzMSAtMC4xOTkyOSwtMC4wODQzMWgtNy40NzMyMWMtMC4wNzY2NSwwIC0wLjE0NTYzLDAuMDMwNjYgLTAuMTk5MjksMC4wODQzMWMtMC4wNTM2NSwwLjA1MzY1IC0wLjA4NDMxLDAuMTIyNjQgLTAuMDg0MzEsMC4xOTkyOWMwLDAuMDg0MzEgMC4wMzA2NiwwLjE2MDk2IDAuMDkxOTcsMC4yMTQ2MmwyLjkxMjYzLDIuNzc0NjdjMC4xMzc5NywwLjEzNzk3IDAuMjUyOTQsMC4yOTEyNiAwLjMyOTU5LDAuNDc1MjJjMC4wNzY2NSwwLjE4Mzk2IDAuMTE0OTgsMC4zNjc5MSAwLjExNDk4LDAuNTY3MnYyLjE0NjE1bDEuMTQ5NzMsMC43NjY0OHYtMi45MTI2M2MwLC0wLjE5MTYyIDAuMDM4MzMsLTAuMzgzMjUgMC4xMTQ5OCwtMC41NjcyYzAuMDc2NjUsLTAuMTgzOTYgMC4xODM5NiwtMC4zNDQ5MiAwLjMyOTU5LC0wLjQ3NTIybDIuOTEyNjMsLTIuNzc0NjdjMC4wNTM2NSwtMC4wNjEzMiAwLjA4NDMxLC0wLjEzMDMgMC4wODQzMSwtMC4yMTQ2MnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo1LjM0ODAyOTI3ODMwODUzOjUuMzQ4MDI5Mjc4MzA4NTMtLT4=",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzUuMTUyNjMsMTgxLjUwNTY4YzAsLTEuMDg2ODkgMC44ODExLC0xLjk2OCAxLjk2OCwtMS45NjhjMS4wODY4OSwwIDEuOTY4LDAuODgxMSAxLjk2OCwxLjk2OGMwLDEuMDg2ODkgLTAuODgxMSwxLjk2OCAtMS45NjgsMS45NjhjLTEuMDg2ODksMCAtMS45NjgsLTAuODgxMSAtMS45NjgsLTEuOTY4eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0MS42MDU5NiwxODEuOTY3OThjMCwtMC44OTUwOSAwLjcyNTYyLC0xLjYyMDcgMS42MjA3LC0xLjYyMDdjMC44OTUwOSwwIDEuNjIwNywwLjcyNTYyIDEuNjIwNywxLjYyMDdjMCwwLjg5NTA5IC0wLjcyNTYyLDEuNjIwNyAtMS42MjA3LDEuNjIwN2MtMC44OTUwOSwwIC0xLjYyMDcsLTAuNzI1NjIgLTEuNjIwNywtMS42MjA3eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOS4wNTkxNSwxNzkuMjY2ODJsMC4wNzcxOCw0LjMyMTg3IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4yMjAwOCwxODMuNjY1ODd2LTcuMzMxNzQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM0LjY1MTk3LDE4NS4zNDgwM3YtMTAuNjk2MDZoMTAuNjk2MDZ2MTAuNjk2MDZ6IiBmaWxsLW9wYWNpdHk9IjAuMDE1NjkiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzQ4MDI5OTk5OTk5OTk0OjUuMzQ4MDI5OTk5OTk5OTk0LS0+",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzYuODgyMjUsMTc4LjIzMTg0Yy0wLjAwMjEsLTAuMDMyNjEgLTAuMDAzMTcsLTAuMDY1NSAtMC4wMDMxNywtMC4wOTg2NGMwLC0wLjgzMjg4IDAuNjc1MTgsLTEuNTA4MDYgMS41MDgwNiwtMS41MDgwNmMwLjEzMzEyLDAgMC4yNjIxOSwwLjAxNzI2IDAuMzg1MTQsMC4wNDk2MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOC43MDkwNywxNzYuNjU5MDJsMC4zMDUsMC4xMDE2NiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuODc5MDgsMTc4LjIxNzkzdjUuMTUxMTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM1Ljg2MjQxLDE3OS4yMDA3aDIuMTAxMTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQzLjU3NSwxODAuMjQxODRjMC4zNDk0NCwwLjM4MjU1IDAuNTYyNTksMC44OTE3NCAwLjU2MjU5LDEuNDUwNzFjMCwwLjU3MTYyIC0wLjIyMjkyLDEuMDkxMiAtMC41ODY1NiwxLjQ3NjUzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjYyMzU0LDE4My4wOTEzMWMtMC4zMzcxMywtMC4zNzk4NiAtMC41NDE4OSwtMC44Nzk4NiAtMC41NDE4OSwtMS40Mjc3MWMwLC0wLjUzNDU3IDAuMTk0OTMsLTEuMDIzNjEgMC41MTc2LC0xLjM5OTg4IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjgxNjUsMTgzLjMxNjk2bC0wLjIzMTU4LC0wLjI2MDUyIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOS41NTU5OCwxODAuMzA2NDlsMC4yMzE1NywtMC4yODk0OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuMzc2OTYsMTc5Ljk4ODA3bDAuMjAyNjIsMC4yMzE1OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuNjM3NDYsMTgzLjA1NjQ0bC0wLjMxODQyLDAuMzE4NDIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjg2MTE2LDE4MC43NTQ0M2wxLjY3Nzg4LDEuNzYzMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuODMyNzEsMTgyLjUxNzYxbDEuNjIxMDMsLTEuNjc3ODgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM0LjY1MTk3LDE4NS4zNDgwM3YtMTAuNjk2MDZoMTAuNjk2MDZ2MTAuNjk2MDZ6IiBmaWxsLW9wYWNpdHk9IjAuMDE1NjkiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzQ4MDI5OTk5OTk5OTk0OjUuMzQ4MDI5OTk5OTk5OTk0LS0+",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzYuMDQzMDEsMTc4LjI3NDU2djUuNzMxNzIiLz48cGF0aCBkPSJNMjM2LjA0OTEyLDE4NC4xNDU1MWg1Ljk3NTYyIi8+PHBhdGggZD0iTTI0Mi4wMjQ3NCwxODQuMDA2MjhsLTUuNjA5NzcsLTUuODUzNjciLz48L2c+PHBhdGggZD0iTTIzOS45MzAxMywxNzcuODY3OTJjMCwtMS4xMTE5OSAwLjkwMTQ0LC0yLjAxMzQzIDIuMDEzNDMsLTIuMDEzNDNjMS4xMTE5OSwwIDIuMDEzNDMsMC45MDE0NCAyLjAxMzQzLDIuMDEzNDNjMCwxLjExMTk5IC0wLjkwMTQ0LDIuMDEzNDMgLTIuMDEzNDMsMi4wMTM0M2MtMS4xMTE5OSwwIC0yLjAxMzQzLC0wLjkwMTQ0IC0yLjAxMzQzLC0yLjAxMzQzeiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNC42NTE5NywxODUuMzQ4MDN2LTEwLjY5NjA2aDEwLjY5NjA2djEwLjY5NjA2eiIgZmlsbC1vcGFjaXR5PSIwLjAxNTY5IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo1LjM0ODAyOTk5OTk5OTk5NDo1LjM0ODAyOTk5OTk5OTk5NC0tPg=="
        ];
        this.categoryFilterBtn = document.getElementById('category-filter-btn');
        this.categoryFilterIcon = document.getElementById('category-filter-icon');
        
        if (this.categoryFilterBtn) {
            this.categoryFilterBtn.addEventListener('click', () => {
                this.categoryFilterMode = (this.categoryFilterMode + 1) % 4;
                this.updateCategoryButtonIcon();
                this.updateEntryList();
            });
            this.updateCategoryButtonIcon();
        }


        this.explicitPrecisionValueSpan = document.getElementById('explicit-precision-value');
        this.implicitPrecisionValueSpan = document.getElementById('implicit-precision-value');
        this.explicitPrecisionStep = 2; 
        this.implicitPrecisionStep = 5; 
        
        this.highPerformancePlottingToggle = document.getElementById('high-performance-plotting-toggle');
        this.highPerformancePlottingEnabled = false; 
        this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;

        this.smoothPanningEnabled = false;
        this.smoothPanningToggle = document.getElementById('smooth-panning-toggle');
        this.baseAccsmooth = 0.15; 
        this.maxAccsmooth = 0.50; 
        this.accsmoothVelocityFactor = 0.1; 
        this.accsmooth = this.baseAccsmooth; 

        this.isSmoothPanningActive = false;
        this.smoothPanVelocity = { x: 0, y: 0 };
        this.panEventHistory = [];
        this.minFlickVelocityMagnitude = 500; 
        this.lastPanEventTime = 0;
        this.lastSmoothPanTime = 0;


        this.tmin = -2 * Math.PI;
        this.tmax = 2 * Math.PI;
        this.tminValueSpan = document.getElementById('tmin-value');
        this.tmaxValueSpan = document.getElementById('tmax-value');


        this.developerMode = false;
        this.devModeToggle = document.getElementById('dev-mode-toggle');
        this.preferredColorValue = 0;
        this.preferredColorValueSpan = document.getElementById('preferred-color-value');
        this.darkModeToggle = document.getElementById('dark-mode-toggle');
        this.isDarkModeActive = false;
        this.colorInversionEnabled = false;
        this.showAxes = true;
        this.showAxisNumbers = true;
        this.gridStyle = 'grid'; 
        this.showPointLabels = true;
        this.showHiddenMath = false;
        this.showHiddenGeo = false;

        this.blocks01 = new Set();
        this.implictplotindex = [];
        this.implictplotindex.push(0);
        this.implictplotdata = [];
        this.implicttempdata = [];
        this.implictjump = 1;
        this.orderedBlocks01ForImplicitProcessing = [];
        this.currentUnitStep = 0;

this.isPanning = false;
        this.isZooming = false;
        this.performanceModeEnabled = true; 
        this.overlayDrawingEnabled = true;
        this.lowPrecisionBufferEnabled = true;
        this.isUsingLowPrecisionBuffer = true;
        this.originalExplicitPrecision = 2;
        this.originalImplicitPrecision = 5; 
        this.zoomEndTimeout = null;
        this.overlayDrawingToggle = document.getElementById('overlay-drawing-toggle');
        this.lowPrecisionBufferToggle = document.getElementById('low-precision-buffer-toggle');
        this.integralPrecisionValueSpan = document.getElementById('integral-precision-value');
        this.integralNumSteps = 100; 
        this.autoBreakpointDetectionEnabled = true;
                this.showPlaybackControls = false;
        this.currentFrame = 0;
        this.totalFrames = 100;
        this.playbackFPS = 10;
        this.isFramePlaying = false;
        this.frameAccumulator = 0;
this.adaptiveExtendEnabled = true;
        this.geometryMeasurementDisplayEnabled = true;
        this.lastValidSidebarRight = 415;

const settingsPanelFeatures = document.getElementById('settings-panel-features');
        if (settingsPanelFeatures) {
            const toggleHtml = `
                <div class="settings-item"><div class="settings-item-row"><label for="show-playback-controls-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNC45Mjk5NiIgaGVpZ2h0PSIxNC45Mjk5NiIgdmlld0JveD0iMCwwLDE0LjkyOTk2LDE0LjkyOTk2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjUzNTAyLC0xNzIuNTM1MDIpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzMuMjg1MDIsMTgwYzAsLTMuNzA4NTggMy4wMDY0LC02LjcxNDk4IDYuNzE0OTgsLTYuNzE0OThjMy43MDg1OCwwIDYuNzE0OTgsMy4wMDY0IDYuNzE0OTgsNi43MTQ5OGMwLDMuNzA4NTggLTMuMDA2NCw2LjcxNDk4IC02LjcxNDk4LDYuNzE0OThjLTMuNzA4NTgsMCAtNi43MTQ5OCwtMy4wMDY0IC02LjcxNDk4LC02LjcxNDk4eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM4Ljk3Mjc0LDE4MS4zMTg1OHYtMy4wNTI0NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuMjI2OTgsMTgwLjA2NDgzbC0yLjE4MzI2LC0xLjk0MDY3IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4wMzEzNywxODAuMTgyNzlsLTIuMDU4NjMsMS40MTk3NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzguODkyNjUsMTc5LjgxMjUyYzAsLTAuNTE2NTEgMC40MTg3MiwtMC45MzUyNCAwLjkzNTI0LC0wLjkzNTI0YzAuNTE2NTEsMCAwLjkzNTI0LDAuNDE4NzIgMC45MzUyNCwwLjkzNTI0YzAsMC41MTY1MSAtMC40MTg3MiwwLjkzNTI0IC0wLjkzNTI0LDAuOTM1MjRjLTAuNTE2NTEsMCAtMC45MzUyNCwtMC40MTg3MiAtMC45MzUyNCwtMC45MzUyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo3LjQ2NDk3OTk5OTk5OTk5Nzo3LjQ2NDk3OTk5OTk5OTk5Ny0tPg==" class="settings-item-icon" alt="">显示播放控制</label><label class="custom-switch-container"><input type="checkbox" id="show-playback-controls-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">在函数列表顶部显示逐帧动画控制卡片</p></div>
            `;
            settingsPanelFeatures.insertAdjacentHTML('afterbegin', toggleHtml);
        }

        this.showPlaybackControlsToggle = document.getElementById('show-playback-controls-toggle');
        if (this.showPlaybackControlsToggle) {
            this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
            this.showPlaybackControlsToggle.addEventListener('change', e => {
                this.showPlaybackControls = e.target.checked;
                this.updateEntryList();
                this.requestDraw();
            });
        }
        this.adaptivePlottingToggle = document.getElementById('adaptive-plotting-toggle');
        this.adaptiveExtendToggle = document.getElementById('adaptive-extend-toggle');
        this.geometrySnapEnabled = true;
        this.autoBreakpointDetectionToggle = document.getElementById('auto-breakpoint-detection-toggle');
        this.isAnimatingWithPerformanceMode = false; 
        this.plottedFunctionPoints = [];
         this.lastValidSidebarRight = 422; 
this.geometryKeywords = new Set(['point', 'midpoint', 'intercept', 'segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'circle', 'ellipse', 'parabola', 'hyperbola', 'polygon', 'length', 'angle', 'area', 'isparallel', 'isperpendicular', 'isconcyclic', 'rotate', 'reflect', 'translate', 'fitline', 'circulararc', 'tangent']);
        this.builtinFuncNames = [];


        this.annotations = [];
        this.annotationMenu = null;
this.annotationState = {
            mode: 'pen',
            isDrawing: false,
            currentDrawingPath: [],
            pen: {
                color: { h: 0, s: 100, b: 0, a: 0 },
                thickness: 0.1, 
                fontSize: 0.5   
            },

            currentPos: { x: 0, y: 0 }
        };
        this.penFontSizeSlider = null;
        this.selectedAnnotationIndex = -1;
        this.annotationInteraction = {
            type: null, 
            startX: 0,
            startY: 0,
            original: {}
        };
        this.penColorSliders = {};
        this.penThicknessSlider = null;


this.calcJSUtils = {
            calc1: ['ln', 'lg', 'log', 'exp', 'sqrt', 'cbrt', 'abs', 'floor', 'ceil', 'round', 'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh', 'sum', 'prod', 'int','diff','diffat'],
            calc2: ['+', '-', '*', '/', '^', ','],
            calc3: [], 
            customFunctions: {}, 
            advancedCustomFunctions: {},
            advancedCustomFunctionNames: [],
            constants: { 'e': Math.E, 'π': Math.PI, 'pi': Math.PI },
            getAdvancedFuncsMap: function() {
                const map = {};
                for (const name in this.advancedCustomFunctions) {
                    if (this.advancedCustomFunctions.hasOwnProperty(name)) {
                        map[name] = this.advancedCustomFunctions[name].compiledFunc;
                    }
                }
                return map;
            },
            isNumericString: function(str) {
                if (typeof str !== 'string') return false;
                return !isNaN(str) && !isNaN(parseFloat(str));
            },
isLetter: function(str) {
                return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str);
            },
            tokenize: function(expression_input) {
    let expression = expression_input;
    if (typeof expression !== 'string') {
        if (expression === null || expression === undefined) expression = "";
        else expression = String(expression);
    }
    
    expression = expression.toLowerCase().replace(/\s+/g, '');
    if (!expression) return [];

    const allOpsOriginalCase = [
        ...this.calc1, 
        ...this.calc3, 
        ...this.advancedCustomFunctionNames, 
        'sum', 'prod', 'int', 'diff', 'diffat' 
    ];

    const opDetails = [];
    const seenLcOps = new Set();
    const constantLcKeys = Object.keys(this.constants).map(c => c.toLowerCase());

    for (const op of allOpsOriginalCase) {
        if (!op || typeof op !== 'string') continue;
        const lcOp = op.toLowerCase();
        if (constantLcKeys.includes(lcOp)) continue;
        
        if (!seenLcOps.has(lcOp)) {
            opDetails.push({ lc: lcOp, original: op, len: lcOp.length });
            seenLcOps.add(lcOp);
        }
    }

    opDetails.sort((a, b) => b.len - a.len); 

    let segments = [expression]; 

    for (const opDetail of opDetails) {
        const lcOp = opDetail.lc;
        const originalOp = opDetail.original;

        const newSegmentsAccumulator = [];
        for (const segment of segments) {
            if (typeof segment !== 'string' || allOpsOriginalCase.includes(segment)) {
                newSegmentsAccumulator.push(segment);
                continue;
            }

            const parts = [];
            let lastIndex = 0;
            let k = 0;
            while (k < segment.length) {
                if (segment.substring(k).startsWith(lcOp) && (k + lcOp.length < segment.length && segment[k + lcOp.length] === '(')) {
                    if (k > lastIndex) {
                        parts.push(segment.substring(lastIndex, k)); 
                    }
                    parts.push(originalOp); 
                    lastIndex = k + lcOp.length;
                    k = lastIndex; 
                } else {
                    k++;
                }
            }
            if (lastIndex < segment.length) {
                parts.push(segment.substring(lastIndex)); 
            }
            newSegmentsAccumulator.push(...parts.filter(p => p !== ""));
        }
        segments = newSegmentsAccumulator;
    }
    
    const finalTokens = [];
    const sortedConstantsDetails = Object.keys(this.constants)
        .map(c => ({ lc: c.toLowerCase(), original: c, len: c.length }))
        .sort((a, b) => b.len - a.len);

    for (const segmentItem of segments) {
        if (typeof segmentItem !== 'string' || allOpsOriginalCase.includes(segmentItem) ) {
            finalTokens.push(segmentItem);
            continue;
        }

        let i = 0;
        const currentSegmentLc = segmentItem; 

        while (i < currentSegmentLc.length) {
            let char = currentSegmentLc[i];
            let matchedInPhase2 = false;

            for (const cnstDetail of sortedConstantsDetails) {
                if (currentSegmentLc.substring(i).startsWith(cnstDetail.lc)) {
                    finalTokens.push(cnstDetail.original); 
                    i += cnstDetail.len;
                    matchedInPhase2 = true;
                    break;
                }
            }
            if (matchedInPhase2) continue;

            if (char.match(/[0-9.]/)) {
                let numStr = '';
                while (i < currentSegmentLc.length && currentSegmentLc[i].match(/[0-9.]/)) {
                    numStr += currentSegmentLc[i];
                    i++;
                }
                finalTokens.push(numStr);
                matchedInPhase2 = true;
            } 
            else if (this.calc2.includes(char) || char === '(' || char === ')') { 
                finalTokens.push(char);
                i++;
                matchedInPhase2 = true;
            } 
            else if (this.isLetter(char)) { 
                let identifier = '';
                while (i < currentSegmentLc.length && /[a-z0-9]/.test(currentSegmentLc[i])) {
                    identifier += currentSegmentLc[i];
                    i++;
                }
                finalTokens.push(identifier);
                matchedInPhase2 = true;
            } 
            else {
                throw new Error("输入的表达式语法有误，请检查！");
            }
        }
    }
    return finalTokens.filter(t => t !== "");
},
            processTokensForEval: function(inputTokens) {
                let result = [];
                const tokens = [...inputTokens];

                for (let i = 0; i < tokens.length; i++) {
                    let token = tokens[i];
                    let nextToken = (i + 1 < tokens.length) ? tokens[i + 1] : null;

                    result.push(token);

                    const isCurrentNumber = this.isNumericString(token);
                    const isCurrentClosingParen = token === ')';
                    
                    const isCurrentKnownName = this.calc1.includes(token) || this.calc3.includes(token) || this.advancedCustomFunctionNames.includes(token) || Object.keys(this.constants).includes(token);
                    const isCurrentVariable = this.isLetter(token) && !isCurrentKnownName && !Object.keys(this.constants).includes(token);
                    if (nextToken && !this.calc2.includes(nextToken) && nextToken !== ')') {
                        const nextIsNumber = this.isNumericString(nextToken);
                        const nextIsKnownName = this.calc1.includes(nextToken) || this.calc3.includes(nextToken) || this.advancedCustomFunctionNames.includes(nextToken) || Object.keys(this.constants).includes(nextToken);
                        const nextIsVariable = this.isLetter(nextToken) && !nextIsKnownName && !Object.keys(this.constants).includes(nextToken);

                        const nextIsOpeningParen = nextToken === '(';

                        const currentCanMultiply = isCurrentNumber ||
                                                   isCurrentClosingParen ||
                                                   isCurrentVariable ||
                                                   (isCurrentKnownName && token !== '(' && !this.calc1.includes(token) && !this.calc3.includes(token) && !this.advancedCustomFunctionNames.includes(token)) || 
                                                   (Object.keys(this.constants).includes(token));


                        const nextCanBeMultiplied = nextIsNumber ||
                                                    nextIsVariable ||
                                                    (nextIsKnownName && !this.calc1.includes(nextToken) && !this.calc3.includes(nextToken) && !this.advancedCustomFunctionNames.includes(nextToken)) || 
                                                    (Object.keys(this.constants).includes(nextToken)) ||
                                                    nextIsOpeningParen ||
                                                    this.calc1.includes(nextToken) || 
                                                    this.calc3.includes(nextToken) ||
                                                    this.advancedCustomFunctionNames.includes(nextToken);  

                        const isCurrentFuncName = this.calc1.includes(token) || this.calc3.includes(token) || this.advancedCustomFunctionNames.includes(token);

                        if (isCurrentFuncName && nextToken === '(') {
                        } else if (currentCanMultiply && nextCanBeMultiplied) {
                             result.push('*');
                        }
                    }
                }
                
                const findMatchingParenBackwards = (toks, endIdx) => {
                    let balance = 0;
                    for (let i = endIdx; i >= 0; i--) {
                        if (toks[i] === ')') balance++;
                        else if (toks[i] === '(') balance--;
                        if (balance === 0) return i;
                    }
                    return -1;
                };
                
                let i = result.length - 1;
                while (i >= 0) {
                    if (result[i] === '^') {
                        let rightStart = i + 1;
                        let rightEnd = rightStart;

                        const prevTokenForUnaryCheck = i > 0 ? result[i - 1] : null;
                        if (result[rightStart] === '-' && (prevTokenForUnaryCheck === null || ['(', '^', ',', '*', '/', '+', '-'].includes(prevTokenForUnaryCheck))) {
                            rightStart++;
                            rightEnd++;
                        }

                        if (result[rightStart] === '(') {
                            rightEnd = this.findMatchingParen(result, rightStart);
                        } else {
                            const funcNames = [...this.calc1, ...this.calc3, ...this.advancedCustomFunctionNames];
                            if (funcNames.includes(result[rightStart]) && result[rightStart + 1] === '(') {
                                rightEnd = this.findMatchingParen(result, rightStart + 1);
                            }
                        }

                        let leftEnd = i - 1;
                        let leftStart = leftEnd;
                        if (result[leftEnd] === ')') {
                            leftStart = findMatchingParenBackwards(result, leftEnd);
                            if (leftStart > 0) {
                                const funcNames = [...this.calc1, ...this.calc3, ...this.advancedCustomFunctionNames];
                                if (funcNames.includes(result[leftStart - 1])) {
                                    leftStart--;
                                }
                            }
                        }


                        
                        const leftTokens = result.slice(leftStart, leftEnd + 1);
                        const rightTokens = result.slice(i + 1, rightEnd + 1);
                        
                        const replacement = ['__advanced__.pow', '(', ...leftTokens, ',', ...rightTokens, ')'];
                        result.splice(leftStart, (rightEnd - leftStart + 1), ...replacement);
                        
                        i = result.length;
                    }
                    i--;
                }

                return result.map(token => {
                    if (['sum', 'prod', 'int'].includes(token)) return token;
                    if (this.calc1.includes(token)) {
                        if (token === 'ln') return 'Math.log';
                        if (token === 'lg') return 'Math.log10';
                        if (token === 'log') return 'Math.log10';
                        return `Math.${token}`;
                    }
                    if (this.advancedCustomFunctionNames.includes(token) || token === '__advanced__.pow') {
                         return `__advanced__.${token.replace('__advanced__.', '')}`;
                    }
                    if (this.constants[token]) return this.constants[token].toString();
                    return token;
                });
            },
            findMatchingParen: function(tokens, startIndex) {
                let balance = 0;
                for (let i = startIndex; i < tokens.length; i++) {
                    if (tokens[i] === '(') balance++;
                    else if (tokens[i] === ')') balance--;
                    if (balance === 0) return i;
                }
                return -1;
            },
            extractArguments: function(tokens, openParenIdx, closeParenIdx, expectedParamCount) {
                const argTokens = tokens.slice(openParenIdx + 1, closeParenIdx);
                
                if (expectedParamCount === 0) {
                    if (argTokens.length > 0) throw new Error("语法错误-参数数量有误！");
                    return [];
                }
                if (argTokens.length === 0 && expectedParamCount > 0) throw new Error("语法错误-参数数量有误！");

                let args = [];
                let currentArg = [];
                let parenBalance = 0;

                for (let i = 0; i < argTokens.length; i++) {
                    const token = argTokens[i];
                    if (token === '(') parenBalance++;
                    else if (token === ')') parenBalance--;

                    if (token === ',' && parenBalance === 0) {
                        if (currentArg.length === 0) throw new Error("语法错误-参数输入错误！");
                        args.push(currentArg);
                        currentArg = [];
                    } else {
                        currentArg.push(token);
                    }
                }
                if (currentArg.length > 0 || args.length < expectedParamCount ) { 
                     if (currentArg.length === 0 && args.length === expectedParamCount -1 && expectedParamCount > 0) {
                         throw new Error("语法错误-参数输入错误！");
                     }
                    args.push(currentArg);
                }

                if (args.length !== expectedParamCount) {
                    throw new Error("语法错误-参数输入错误！");
                }
                return args.map(arg => (arg.length === 0 ? [''] : arg) );
            },
                        expandDiffOperations: function(initialTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames) {
            let tokens = JSON.parse(JSON.stringify(initialTokens));
            let expandedSomething = true;
            let iterationGuard = 0;
            const MAX_EXPANSION_ITERATIONS = 50; 

            const h_str = '0.00001';
            const h_inv_2h_str = '50000'; 

            while (expandedSomething && iterationGuard < MAX_EXPANSION_ITERATIONS) {
                expandedSomething = false;
                iterationGuard++;
                let i = 0;
                while (i < tokens.length) {
                    const token = tokens[i];
                    if (token === 'diff' || token === 'diffat') {
                        const opName = token;
                        if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                            throw new Error("语法错误-括号匹配错误！");
                        }
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.findMatchingParen(tokens, openParenIdx);
                        if (closeParenIdx === -1) {
                            throw new Error("语法错误-括号匹配错误！");
                        }

                        const expectedArgs = (opName === 'diff') ? 2 : 3;
                        const argListTokenArrays = this.extractArguments(tokens, openParenIdx, closeParenIdx, expectedArgs);

                        let exprTokens = argListTokenArrays[0];
                        let varNameTokenArrayForCheck = argListTokenArrays[1]; 
                        let varNameTokenArrayActual = argListTokenArrays[1];

                        if (varNameTokenArrayActual.length === 3 &&
                            varNameTokenArrayActual[0] === '(' &&
                            varNameTokenArrayActual[2] === ')' &&
                            this.isLetter(varNameTokenArrayActual[1]) &&
                            varNameTokenArrayActual[1].length === 1) {
                            varNameTokenArrayActual = [varNameTokenArrayActual[1]];
                        }
                        
                        if (varNameTokenArrayActual.length !== 1 || !this.isLetter(varNameTokenArrayActual[0]) || calc1_list.includes(varNameTokenArrayActual[0]) || calc3_list.includes(varNameTokenArrayActual[0]) || Object.keys(constants_obj).includes(varNameTokenArrayActual[0])) {
                            throw new Error("语法错误-变量语法错误，请检查算式！");
                        }
                        const varName = varNameTokenArrayActual[0];

                        let pointExprTokens = null;
                        if (opName === 'diffat') {
                            pointExprTokens = argListTokenArrays[2];
                            let preProcessedPointTokens = this.expandCustomFunctions(pointExprTokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames);
                            pointExprTokens = this.expandDiffOperations(preProcessedPointTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames);
                        }

                        const substituteInTokens = (targetTokens, variableToReplace, replacementValueTokens) => {
                            let result = [];
                            for (const t of targetTokens) {
                                if (t === variableToReplace) {
                                    result.push('('); 
                                    result.push(...replacementValueTokens);
                                    result.push(')');
                                } else {
                                    result.push(t);
                                }
                            }
                            return result;
                        };

                        let finalExpansion = [];

                        finalExpansion.push('('); 

                        finalExpansion.push('('); 
                        let varPlusH_Tokens;
                        if (opName === 'diff') {
                            varPlusH_Tokens = ['(', varName, '+', h_str, ')'];
                        } else { 
                            varPlusH_Tokens = ['(', ...pointExprTokens, '+', h_str, ')'];
                        }
                        finalExpansion.push(...substituteInTokens(exprTokens, varName, varPlusH_Tokens));
                        finalExpansion.push(')'); 

                        finalExpansion.push('-'); 

                        finalExpansion.push('('); 
                        let varMinusH_Tokens;
                        if (opName === 'diff') {
                            varMinusH_Tokens = ['(', varName, '-', h_str, ')'];
                        } else { 
                            varMinusH_Tokens = ['(', ...pointExprTokens, '-', h_str, ')'];
                        }
                        finalExpansion.push(...substituteInTokens(exprTokens, varName, varMinusH_Tokens));
                        finalExpansion.push(')'); 
                        
                        finalExpansion.push(')'); 
                        finalExpansion.push('*');
                        finalExpansion.push(h_inv_2h_str);

                        tokens.splice(i, closeParenIdx - i + 1, ...finalExpansion);
                        expandedSomething = true;
                        i = -1; 
                    }
                    i++;
                }
            }
            if (iterationGuard >= MAX_EXPANSION_ITERATIONS && expandedSomething) {
                throw new Error("语法错误-循环解析错误，请检查！");
            }
            return tokens;
        },

            expandCustomFunctions: function(initialTokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames) {
                let tokens = JSON.parse(JSON.stringify(initialTokens)); 
                let expandedSomething = true;
                let iterationGuard = 0; 
                const MAX_EXPANSION_ITERATIONS = 50;


                while (expandedSomething && iterationGuard < MAX_EXPANSION_ITERATIONS) {
                    expandedSomething = false;
                    iterationGuard++;
                    let i = 0;
                    while (i < tokens.length) {
                        const token = tokens[i];
                        if (calc3_list.includes(token) && !advancedCustomFunctionNames.includes(token)) {
                            const funcName = token;
                            const funcData = customFunctions[funcName];

                            if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                                throw new Error(`自定义函数 '${funcName}' 后面必须是 '('。`);
                            }

                            const openParenIdx = i + 1;
                            const closeParenIdx = this.findMatchingParen(tokens, openParenIdx);

                            if (closeParenIdx === -1) {
                                throw new Error(`函数调用 '${funcName}' 的括号不匹配。`);
                            }

                            const argValues = this.extractArguments(tokens, openParenIdx, closeParenIdx, funcData.params.length);

                            let bodyCopy = JSON.parse(JSON.stringify(funcData.bodyTokens));

                            let substitutedBody = [];
                            for (const bodyToken of bodyCopy) {
                                const paramIndex = funcData.params.indexOf(bodyToken);
                                if (paramIndex !== -1) {
                                    substitutedBody.push('('); 
                                    substitutedBody.push(...argValues[paramIndex]);
                                    substitutedBody.push(')');
                                } else {
                                    substitutedBody.push(bodyToken);
                                }
                            }
                            
                            const finalExpansionForCustomFunc = ['(', ...substitutedBody, ')'];
                            tokens.splice(i, closeParenIdx - i + 1, ...finalExpansionForCustomFunc);
                            expandedSomething = true;
                            i = -1; 
                        }
                        i++;
                    }
                }
                if (iterationGuard >= MAX_EXPANSION_ITERATIONS && expandedSomething) {
                    throw new Error("语法错误-循环解析错误，请检查！");
                }
                return tokens;

            },
            evaluateScopedExpression: function(tokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap) {
                let currentTokens = this.expandCustomFunctions(tokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames);
                currentTokens = this.expandDiffOperations(currentTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames);
                currentTokens = JSON.parse(JSON.stringify(currentTokens));
                
                const replaceVarInTokens = (targetTokens, varName, val) => {
                    const result = [];
                    const valStr = val.toString();
                    const replacement = val < 0 ? ['(', valStr, ')'] : [valStr]; 
                    for (let i = 0; i < targetTokens.length; i++) {
                        if (targetTokens[i] === varName) {
                            for(let k = 0; k < replacement.length; k++) result.push(replacement[k]);
                        } else {
                            result.push(targetTokens[i]);
                        }
                    }
                    return result;
                };

                let hasOps = true;
                let iterationGuard = 0;
                const MAX_MACRO_EXPANSION_PASSES = 20; 
                const MAX_LOOP_ITERATIONS = 1000000; 

                while (hasOps && iterationGuard < MAX_MACRO_EXPANSION_PASSES) {
                    hasOps = false;
                    iterationGuard++;
                    let foundOpIndex = -1;

                    for (let i = currentTokens.length - 1; i >= 0; i--) {
                        if (['sum', 'prod', 'int'].includes(currentTokens[i])) {
                            if (i + 1 < currentTokens.length && currentTokens[i+1] === '(') {
                                foundOpIndex = i;
                                break;
                            }
                        }
                    }

                    if (foundOpIndex !== -1) {
                        const i = foundOpIndex;
                        const token = currentTokens[i];
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.findMatchingParen(currentTokens, openParenIdx);

                        if (closeParenIdx === -1) {
                            throw new Error(`${token} 的括号不匹配`);
                        }

                        const argList = this.extractArguments(currentTokens, openParenIdx, closeParenIdx, 4);
                        const bodyTokens = argList[0];
                        const varNameTokens = argList[1];
                        const startTokens = argList[2];
                        const endTokens = argList[3];

                        if (varNameTokens.length !== 1 || !this.isLetter(varNameTokens[0])) {
                            throw new Error(`${token} 的第二个参数必须是变量名`);
                        }
                        const varName = varNameTokens[0];

                        const startVal = this.evaluateScopedExpression(startTokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap);
                        const endVal = this.evaluateScopedExpression(endTokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap);

                        if (!Number.isFinite(startVal) || !Number.isFinite(endVal)) {
                            throw new Error(`${token} 的范围必须是有效数字`);
                        }

                        let expandedTokens = [];

                        if (token === 'sum' || token === 'prod') {
                            const s = Math.round(startVal);
                            const e = Math.round(endVal);
                            const isSum = token === 'sum';
                            const op = isSum ? '+' : '*';
                            const identity = isSum ? '0' : '1';

                            if (Math.abs(e - s) > MAX_LOOP_ITERATIONS) {
                                throw new Error(`${token} 循环次数过多 (${Math.abs(e - s)})`);
                            }

                            if (s > e) {
                                expandedTokens.push(identity);
                            } else {
                                expandedTokens.push('(');
                                for (let k = s; k <= e; k++) {
                                    if (k > s) expandedTokens.push(op);
                                    
                                    const replacedBody = replaceVarInTokens(bodyTokens, varName, k);
                                    
                                    for(let m = 0; m < replacedBody.length; m++) expandedTokens.push(replacedBody[m]);
                                }
                                expandedTokens.push(')');
                            }
                        } else if (token === 'int') {
                            const N = integralNumSteps_param || 50;
                            const a = startVal;
                            const b = endVal;
                            const h = (b - a) / N;

                            if (Math.abs(h) < 1e-15) {
                                expandedTokens.push('0');
                            } else {
                                expandedTokens.push('(');
                                expandedTokens.push(h.toString());
                                expandedTokens.push('*');
                                expandedTokens.push('(');
                                
                                for (let k = 0; k <= N; k++) {
                                    if (k > 0) expandedTokens.push('+');
                                    
                                    const currentX = a + k * h;
                                    
                                    if (k === 0 || k === N) {
                                        expandedTokens.push('0.5');
                                        expandedTokens.push('*');
                                    }
                                    
                                    expandedTokens.push('(');
                                    const replacedBody = replaceVarInTokens(bodyTokens, varName, currentX);
                                    for(let m = 0; m < replacedBody.length; m++) expandedTokens.push(replacedBody[m]);
                                    expandedTokens.push(')');
                                }
                                
                                expandedTokens.push(')'); 
                                expandedTokens.push(')'); 
                            }
                        }

                        const before = currentTokens.slice(0, i);
                        const after = currentTokens.slice(closeParenIdx + 1);
                        currentTokens = before.concat(expandedTokens).concat(after);
                        
                        hasOps = true; 
                    }
                }

                let tokensForFinalEval = [];
                for (let i = 0; i < currentTokens.length; i++) {
                    const token = currentTokens[i];
                    
                    if (scopeVars[token] !== undefined && this.isLetter(token) && 
                        !calc1_list.includes(token) && 
                        !calc3_list.includes(token) && 
                        !Object.keys(constants_obj).includes(token) && 
                        !advancedCustomFunctionNames.includes(token)) {
                        
                        const value = scopeVars[token];
                        const prevToken = i > 0 ? currentTokens[i-1] : null;
                        
                        if (typeof value === 'number' && value < 0 && prevToken === '-') {
                             tokensForFinalEval.push('(');
                             tokensForFinalEval.push(value.toString());
                             tokensForFinalEval.push(')');
                        } else {
                            tokensForFinalEval.push(value.toString());
                        }
                    } else {
                        tokensForFinalEval.push(token);
                    }
                }
                
                let processedFinalTokens = this.processTokensForEval(tokensForFinalEval); 
                let finalExprStringToEvaluate = processedFinalTokens.join('');

                if (finalExprStringToEvaluate.trim() === "") return 0; 

                try {
                    const executor = new Function('__advanced__', 'return ' + finalExprStringToEvaluate);
                    return executor(advancedFuncsMap);
                } catch (e) {
                    return NaN;
                }
            }, };
        this.init();
    }

    getRayPlaneIntersection(mouseX, mouseY) {
        const aspect = this.canvas.width / this.canvas.height;
        const proj = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta) + this.center3D.x,
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta) + this.center3D.y,
            z: cam.rho * Math.cos(cam.phi) + this.center3D.z
        };
        const view = Mat4.lookAt(Mat4.create(), eye, this.center3D, {x:0, y:0, z:1});
        
        const vp = Mat4.multiply(Mat4.create(), proj, view);
        const invVP = Mat4.invert(Mat4.create(), vp);
        if (!invVP) return null;

        const x = (mouseX / (this.canvas.width / window.devicePixelRatio)) * 2 - 1;
        const y = -(mouseY / (this.canvas.height / window.devicePixelRatio)) * 2 + 1;
        
        const near = [x, y, -1], far = [x, y, 1];
        Mat4.transformVec3(near, near, invVP);
        Mat4.transformVec3(far, far, invVP);

        const dirZ = far[2] - near[2];
        if (Math.abs(dirZ) < 1e-6) return null;
        
        const planeZ = this.center3D.z;
        const t = (planeZ - near[2]) / dirZ;
        
        if (t < 0 || t > 1) return null;
        
        return { 
            x: near[0] + t * (far[0] - near[0]), 
            y: near[1] + t * (far[1] - near[1]) 
        };
    }

    getAdaptiveStep3D(visibleRangeMath) {
        const targetTickCount = 8;
        const rawStep = visibleRangeMath / targetTickCount;
        const mag = Math.floor(Math.log10(rawStep));
        const base = Math.pow(10, mag);
        const ratio = rawStep / base;
        
        let step;
        if (ratio <= 1) step = base;
        else if (ratio <= 2) step = 2 * base;
        else if (ratio <= 5) step = 5 * base;
        else step = 10 * base;
        
        return { step, precision: mag < 0 ? -mag : 0 };
    }

    pushBox(vertices, x1, y1, z1, x2, y2, z2, r, g, b) {
        const w = 0.05;
        const minX = Math.min(x1, x2)-(x1===x2?w:0), maxX = Math.max(x1, x2)+(x1===x2?w:0);
        const minY = Math.min(y1, y2)-(y1===y2?w:0), maxY = Math.max(y1, y2)+(y1===y2?w:0);
        const minZ = Math.min(z1, z2)-(z1===z2?w:0), maxZ = Math.max(z1, z2)+(z1===z2?w:0);
        const p = [[minX,minY,minZ],[maxX,minY,minZ],[maxX,maxY,minZ],[minX,maxY,minZ],[minX,minY,maxZ],[maxX,minY,maxZ],[maxX,maxY,maxZ],[minX,maxY,maxZ]];
        const faces = [[0,1,2,3],[4,7,6,5],[0,4,5,1],[3,2,6,7],[0,3,7,4],[1,5,6,2]];
        const normals = [[0,0,-1],[0,0,1],[0,-1,0],[0,1,0],[-1,0,0],[1,0,0]];
        faces.forEach((f, fi) => {
            const n = normals[fi];
            const idx = [f[0], f[1], f[2], f[0], f[2], f[3]];
            idx.forEach(i => vertices.push(p[i][0], p[i][1], p[i][2], n[0], n[1], n[2]));
        });
    }

    initializeAdvancedCalcJSFunctions() {
        this.calcJSUtils.advancedCustomFunctions = {};
        this.calcJSUtils.advancedCustomFunctionNames = [];

        ADVANCED_FUNCTION_DEFINITIONS.forEach(def => {
            try {
                const compiledFunc = new Function(...def.params, def.bodyJsString);
                this.calcJSUtils.advancedCustomFunctions[def.name] = {
                    params: def.params,
                    bodyJsString: def.bodyJsString,
                    compiledFunc: compiledFunc
                };
                if (!this.calcJSUtils.advancedCustomFunctionNames.includes(def.name)) {
                    this.calcJSUtils.advancedCustomFunctionNames.push(def.name);
                }
            } catch (e) {
                console.error(`函数语法编译错误！`);
            }
        });
        this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
    }


    autoname() {
        let i = 1;
        while (true) {
            const funcName = 'f' + i;
            if (!this.calcJSUtils.customFunctions.hasOwnProperty(funcName) && !this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(funcName)) {
                return funcName;
            }
            i++;
            if (i > 10000) { 
                return 'f_error_' + Date.now(); 
            }
        }
    }
    autonameConstant() {
        let i = 1;
        while (true) {
            const constName = 'value' + i;
            const constNameLower = constName.toLowerCase();
            const isNameTaken = this.entries.some(entry =>
                (entry.type === 'constant' && entry.name.toLowerCase() === constNameLower) ||
                (entry.type === 'variable' && entry.key === constNameLower) ||
                (entry.type === 'custom_function_definition' && entry.name.toLowerCase() === constNameLower) ||
                (entry.type === 'advanced_custom_function_definition' && entry.name.toLowerCase() === constNameLower)
            ) || this.calcJSUtils.constants.hasOwnProperty(constNameLower) || this.calcJSUtils.calc1.includes(constNameLower);

            if (!isNameTaken) {
                return constName;
            }
            i++;
            if (i > 10000) {
                return 'value_error_' + Date.now();
            }
        }
    }



startEditEntry(index) {
        if (index < 0 || index >= this.entries.length) return;
        this.editingEntryIndex = index;
        const entry = this.entries[index];
        let stringToEdit = "";

        if (entry.type === 'variable') {
            const parts = entry.expr.split('=');
            stringToEdit = parts.length > 1 ? parts.slice(1).join('=').trim() : (entry.isEditableIndependent ? String(entry.value) : '');
        } else if (entry.type === 'geometry') {
            stringToEdit = entry.expr;
          } else if (entry.type === 'custom_function_definition') {
            stringToEdit = entry.body || "";
        } else if (entry.type === 'advanced_custom_function_definition') {
            stringToEdit = entry.bodyJs || "";
        } else if (entry.type === 'function') {

            const explicitTypes = ['x', 'y', 'z', 'x3d', 'y3d'];
            

            if (explicitTypes.includes(entry.plotType) && entry.expr.includes('=')) {

                stringToEdit = entry.expr.substring(entry.expr.indexOf('=') + 1).trim();
            } else {

                stringToEdit = entry.expr;
            }

        } else if (entry.type === 'constant') {

            stringToEdit = entry.expr;
        } else if (entry.type === 'text') {
            stringToEdit = '//' + entry.content;
        }

        if (typeof window.globalOpenKeyboardForEdit === 'function') {
            window.globalOpenKeyboardForEdit(stringToEdit);
        } else {
            console.error("globalOpenKeyboardForEdit function is not defined on window.");
        }
    }




applyEditToEntry(editedString) {
        if (this.editingEntryIndex < 0 || this.editingEntryIndex >= this.entries.length) {
            this.editingEntryIndex = -1;
            return;
        }

        const originalEntryIndex = this.editingEntryIndex;
        const entryBeingEdited = this.entries[originalEntryIndex];
        const oldIdentifier = entryBeingEdited.name || entryBeingEdited.expr;

        const originalAllEntriesBackup = JSON.parse(JSON.stringify(this.entries));
        const originalCustomFunctionsBackup = JSON.parse(JSON.stringify(this.calcJSUtils.customFunctions));
        const originalCalc3Backup = [...this.calcJSUtils.calc3];
        const originalAdvancedCustomFunctionsBackup = JSON.parse(JSON.stringify(this.calcJSUtils.advancedCustomFunctions, (k, v) => k === 'compiledFunc' ? undefined : v));
        const originalAdvancedCustomFunctionNamesBackup = [...this.calcJSUtils.advancedCustomFunctionNames];
        const originalVariablesBackup = new Map(this.variables);

        const _preserveEntryState = (target, source) => {
            if (!target || !source) return;
            if ('color' in source) target.color = source.color;
            if ('visible' in source) target.visible = source.visible;
            if ('expanded' in source) target.expanded = source.expanded;
            if ('sliderActive' in source) target.sliderActive = source.sliderActive;
            if ('displayFrame' in source) target.displayFrame = source.displayFrame;
            if ('extendTo3D' in source) target.extendTo3D = source.extendTo3D;
            if ('sliceAxis' in source) target.sliceAxis = source.sliceAxis;
            if ('sliceVal' in source) target.sliceVal = source.sliceVal;

            if (source.isEditableIndependent) {
                let newMin = source.min;
                let newMax = source.max;
                const newValue = target.value;
                if (Number.isFinite(newValue) && Number.isFinite(newMin) && newValue < newMin) newMin = newValue;
                if (Number.isFinite(newValue) && Number.isFinite(newMax) && newValue > newMax) newMax = newValue;
                target.min = newMin; target.max = newMax; target.step = source.step;
                target.playState = source.playState; target.playDirection = source.playDirection; target.playMode = source.playMode;
            }
        };

        let newExpr = "";
        let definitionChanged = false;
        let geoNameChangeInfo = null;

        try {
            if (entryBeingEdited.type === 'point_list') {
                newExpr = editedString;
                const parsedEntry = this.parsePointList(newExpr, originalEntryIndex);
                if (!parsedEntry) throw new Error("编辑后的点列表达式无效。");
                _preserveEntryState(parsedEntry, entryBeingEdited);
                parsedEntry.name = entryBeingEdited.name; 
                this.entries[originalEntryIndex] = parsedEntry;
            } else if (entryBeingEdited.type === 'variable') {
                newExpr = `${entryBeingEdited.name}=${editedString}`;
                const updatedEntryData = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (updatedEntryData && updatedEntryData.type === 'variable' && updatedEntryData.key === entryBeingEdited.key) {
                    _preserveEntryState(updatedEntryData, entryBeingEdited);
                    this.entries[originalEntryIndex] = updatedEntryData;
                } else {
                    throw new Error("编辑后变量类型或名称不匹配，或解析失败。");
                }
            } else if (entryBeingEdited.type === 'geometry') {
                newExpr = editedString;
                const parsedEntry = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (!parsedEntry || parsedEntry.type !== 'geometry') throw new Error("编辑后的表达式无效或不是一个有效的几何对象。");
                if (parsedEntry.geometryType !== entryBeingEdited.geometryType) throw new Error(`几何对象类型不能更改 (从 ${entryBeingEdited.geometryType} 到 ${parsedEntry.geometryType})。`);
                
                const oldName = entryBeingEdited.name;
                const newName = parsedEntry.name;
                if (oldName.toLowerCase() !== newName.toLowerCase()) {
                    definitionChanged = true;
                    geoNameChangeInfo = { oldName, newName, oldNameLower: oldName.toLowerCase() };
                }
                _preserveEntryState(parsedEntry, entryBeingEdited);
                this.entries[originalEntryIndex] = parsedEntry;
            } else if (entryBeingEdited.type === 'custom_function_definition' || entryBeingEdited.type === 'advanced_custom_function_definition') {
                const functionSignature = `${entryBeingEdited.name}(${entryBeingEdited.params.join(',')})`;
                newExpr = entryBeingEdited.type === 'custom_function_definition' ? `${functionSignature}=${editedString}` : `${functionSignature}={${editedString}}`;
                
                // 传入 allowOverwriteName，允许重新定义自己
                const newFuncData = this.defineCalcJSFunction(newExpr, true, entryBeingEdited.name); 
                
                if (!newFuncData) throw new Error("编辑后的函数定义无效或导致错误。");
                
                let updatedEntryData;
                if (newFuncData.type === 'custom_function_definition') {
                    updatedEntryData = {
                        type: 'custom_function_definition',
                        name: newFuncData.name, params: newFuncData.params, body: newFuncData.rawBodyString, expr: newFuncData.originalExpression,
                        dependencies: this._extractDependenciesFromTokensWithLargeOps(
                            newFuncData.bodyTokens, newFuncData.params,
                            this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                            this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                            this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames
                        ),
                        compilationError: undefined, hasLargeOps: newFuncData.bodyTokens.some(t => ['sum', 'prod', 'int'].includes(t))
                    };
                } else {
                     updatedEntryData = { type: 'advanced_custom_function_definition', name: newFuncData.name, params: newFuncData.params, bodyJs: newFuncData.bodyJsString, expr: `${newFuncData.name}(${newFuncData.params.join(',')}) { /* JS body */ }`, dependencies: [], compilationError: undefined };
                }
                _preserveEntryState(updatedEntryData, entryBeingEdited);
                this.entries[originalEntryIndex] = updatedEntryData;
                definitionChanged = true;

            } else if (entryBeingEdited.type === 'function') {
                newExpr = editedString;
                const explicitTypes = ['x', 'y', 'z', 'x3d', 'y3d'];

                if (explicitTypes.includes(entryBeingEdited.plotType) && entryBeingEdited.expr.includes('=')) {
                    const hasEquals = newExpr.includes('=');
                    const hasInequality = newExpr.match(/>=|<=|>|</);

                    // 修复 Bug 3：无条件补全头部，除非用户自己输入了等号/不等号
                    // 这样输入 xy-z 会补全为 z=xy-z，然后交给 parseInputInternal 智能判断是否自引用
                    if (!hasEquals && !hasInequality) {
                        const originalHeader = entryBeingEdited.expr.substring(0, entryBeingEdited.expr.indexOf('=') + 1);
                        newExpr = originalHeader + newExpr;
                    }
                }

                const parsedEntry = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (parsedEntry && parsedEntry.type === 'function') {
                    _preserveEntryState(parsedEntry, entryBeingEdited);
                    this.entries[originalEntryIndex] = parsedEntry; 
                } else {
                    const funcDefAttempt = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                    if (funcDefAttempt && (funcDefAttempt.type === 'custom_function_definition' || funcDefAttempt.type === 'advanced_custom_function_definition')) {
                         _preserveEntryState(funcDefAttempt, entryBeingEdited);
                         this.entries[originalEntryIndex] = funcDefAttempt;
                         definitionChanged = true;
                    } else {
                        throw new Error("编辑后的表达式无效或解析失败。");
                    }
                }
            } else if (entryBeingEdited.type === 'text') {
                 if (!editedString.startsWith('//')) throw new Error("文本条目必须以 // 开头。");
                entryBeingEdited.content = editedString.substring(2).trim();
                entryBeingEdited.expr = editedString;
            }

            if (definitionChanged) {
                let currentEntriesSnapshot = JSON.parse(JSON.stringify(this.entries));
                if (geoNameChangeInfo) {
                    currentEntriesSnapshot.forEach(snapEntry => {
                        if (snapEntry.dependencies && snapEntry.dependencies.includes(geoNameChangeInfo.oldNameLower)) {
                            const oldNameRegex = new RegExp(`\\b${geoNameChangeInfo.oldName}\\b`, 'g');
                            snapEntry.expr = snapEntry.expr.replace(oldNameRegex, geoNameChangeInfo.newName);
                        }
                    });
                } else if (entryBeingEdited.type === 'custom_function_definition' || entryBeingEdited.type === 'advanced_custom_function_definition') {
                    const updatedEntryInSnapshot = currentEntriesSnapshot[originalEntryIndex];
                    if (updatedEntryInSnapshot && updatedEntryInSnapshot.name === entryBeingEdited.name) {
                        if (updatedEntryInSnapshot.type === 'custom_function_definition') {
                            updatedEntryInSnapshot.expr = `${updatedEntryInSnapshot.name}(${updatedEntryInSnapshot.params.join(',')})=${updatedEntryInSnapshot.body}`;
                        } else {
                            updatedEntryInSnapshot.expr = `${updatedEntryInSnapshot.name}(${updatedEntryInSnapshot.params.join(',')}) = {${updatedEntryInSnapshot.bodyJs}}`;
                        }
                    }
                }

                this.entries = []; 
                this.calcJSUtils.customFunctions = {};
                this.calcJSUtils.calc3 = [];
                this.calcJSUtils.advancedCustomFunctions = {};
                this.calcJSUtils.advancedCustomFunctionNames = [];
                this.initializeAdvancedCalcJSFunctions();
                this.initializeCalcJSBuiltinFunctions();
                
                const definitions = currentEntriesSnapshot.filter(e => e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition');
                const existingUserSymbolNames = new Set(currentEntriesSnapshot.map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean));

                definitions.forEach(snapEntry => {
                    const funcDefMatch = snapEntry.expr.match(/^([a-zA-Z_][\w]*)\s*\(/);
                    if (funcDefMatch) {
                        const funcName = funcDefMatch[1];
                        if (snapEntry.type === 'custom_function_definition') {
                            if (!this.calcJSUtils.calc3.includes(funcName)) this.calcJSUtils.calc3.push(funcName);
                        } else {
                            if (!this.calcJSUtils.advancedCustomFunctionNames.includes(funcName)) this.calcJSUtils.advancedCustomFunctionNames.push(funcName);
                        }
                    }
                });
                this.calcJSUtils.calc3.sort((a, b) => b.length - a.length);
                this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
            
                for (const snapEntry of definitions) {
                    const parsed = this.parseInputInternal(snapEntry.expr.toLowerCase(), snapEntry.expr, -1, existingUserSymbolNames);
                    if (parsed) {
                        _preserveEntryState(parsed, snapEntry);
                        this.entries.push(parsed);
                    } else {
                        snapEntry.compilationError = "依赖更新后解析失败";
                        this.entries.push(snapEntry);
                    }
                }
                const others = currentEntriesSnapshot.filter(e => e.type !== 'custom_function_definition' && e.type !== 'advanced_custom_function_definition');
                for (const snapEntry of others) {
                    const normalizedSnapExpr = snapEntry.expr.replace(/\s+/g, '').toLowerCase();
                    const existingIndex = this.entries.findIndex(e => e.type === snapEntry.type && e.expr.replace(/\s+/g, '').toLowerCase() === normalizedSnapExpr);
                    if (existingIndex !== -1) {
                        _preserveEntryState(this.entries[existingIndex], snapEntry);
                    } else {
                        const parsed = this.parseInputInternal(snapEntry.expr.toLowerCase(), snapEntry.expr, -1, existingUserSymbolNames);
                        if (parsed) {
                            _preserveEntryState(parsed, snapEntry);
                            this.entries.push(parsed);
                        }
                    }
                }
            }
            
            const updatedEntry = this.entries[originalEntryIndex];
            const newIdentifier = updatedEntry.name || updatedEntry.expr;
            if (oldIdentifier && newIdentifier && oldIdentifier !== newIdentifier) {
                this.annotations.forEach(anno => {
                    if (anno.type === 'checkbox' && anno.controlledNames) {
                        const idx = anno.controlledNames.indexOf(oldIdentifier);
                        if (idx !== -1) anno.controlledNames[idx] = newIdentifier;
                    }
                });
            }
            this.recalculateAll();
        } catch (err) {
            alert(`编辑失败: ${err.message}\n更改将被撤销。`);
            this.entries = originalAllEntriesBackup;
            this.calcJSUtils.customFunctions = originalCustomFunctionsBackup;
            this.calcJSUtils.calc3 = originalCalc3Backup;
            this.calcJSUtils.advancedCustomFunctions = originalAdvancedCustomFunctionsBackup;
            this.calcJSUtils.advancedCustomFunctionNames = originalAdvancedCustomFunctionNamesBackup;
            this.variables = new Map(originalVariablesBackup); 
            this.recalculateAll(); 
        }
        this.editingEntryIndex = -1;
    }
    initializeCalcJSBuiltinFunctions() {
        this.builtinFuncNames = [];
        const builtinfunc = [
            'root(m,n,p,q)=(-n+q*sqrt(n*n-4*m*p))/(2*m)',
            'cot(a)=1/tan(a)',
            'sec(a)=(1/cos(a))',
            'csc(a)=(1/sin(a))',
            'acot(b)=(1.57079632679-atan(b))',
            'asec(b)=(acos(1/b))',
            'acsc(b)=(asin(1/b))',
            'csch(a)=(1/sinh(a))',
            'sech(a)=(1/cosh(a))',
            'coth(a)=(1/tanh(a))',
            'acoth(b)=(atanh(1/b))',
            'asech(b)=(acosh(1/b))',
            'acsch(b)=(asinh(1/b))',
            'max(a,b)=(0.5*(a+b+abs(a-b)))',
            'min(a,b)=(0.5*(a+b-abs(a-b)))',
            'beta(a,b)=gamma(a)*gamma(b)/gamma(a+b)',
            'gammadist(a,b,c)=(c^(a-1)*e^(0-c/b))/(b^a*gamma(a))',
            'normdist(a,b,c,m)=m*0.5*(1+erf((c-a)/(sqrt(2)*abs(b))))+(1-m)*((e^(0-(c-a)^2)/(2*b*b))/(sqrt(2*3.1415926*abs(b))))',
            'tdist(a,b)=(gamma(0.5*(a+1))*(b*b/a+1)^(0-0.5*(a+1)))/gamma(a/2)/sqrt(3.1415926536*a)',
            'chisqdist(a,b)=0.5*(sgn(b)+1)*(e^(0-0.5*b)*b^(0.5*a-1))/(2^(0.5*a)*gamma(0.5*a))',
            'lognormdist(a,b,c,m)=0.5*(1+sgn(c))*((erf((ln(c)-a)/(1.4142135*abs(b)))*0.5+0.5)*m+(e^(0-(ln(c)-a)^2/2/(b*b))/(abs(b)*c*sqrt(2*3.1415926)))*(1-m))'
        ];
        builtinfunc.forEach(def => {
            const funcDefMatch = def.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
            if (funcDefMatch) {
                this.builtinFuncNames.push(funcDefMatch[1]);
            }
            this.defineCalcJSFunction(def, true)
        });
    }
    
    defineCalcJSFunction(defString, silentAlerts = false, allowOverwriteName = null) {
        const funcDefMatchOriginal = defString.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
        if (!funcDefMatchOriginal) {
            if (!silentAlerts) alert("无效的函数定义格式。请使用: 名称(参数1,参数2,...)=表达式 或 名称(参数1,...) { JS 主体 }");
            return false;
        }

        let name = funcDefMatchOriginal[1];
        const paramsStr = funcDefMatchOriginal[2];
        let bodyStr = funcDefMatchOriginal[3];
        
        const nameLower = name.toLowerCase();
        
        // 检查是否允许覆盖（编辑模式）
        if (allowOverwriteName && nameLower === allowOverwriteName.toLowerCase()) {
            // 允许覆盖自身，跳过重名检查
        } else {
            const isBuiltInMath = this.calcJSUtils.calc1.includes(nameLower);
            const isExistingSimpleCustom = this.calcJSUtils.customFunctions.hasOwnProperty(nameLower);
            const isExistingAdvancedCustom = this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(nameLower);
            const isExistingConstant = this.calcJSUtils.constants.hasOwnProperty(nameLower);

            // 修复 Bug 2：强制检查重名
            if (isBuiltInMath || isExistingConstant || isExistingSimpleCustom || isExistingAdvancedCustom) {
                if (nameLower !== 'x' && nameLower !== 'y' && nameLower !== 't') {
                     if (!silentAlerts) alert(`函数名 '${name}' 与现有函数或内置对象冲突，将作为方程处理。`);
                     return false; 
                }
            }
        }

        if (this.calcJSUtils.calc2.some(op => name.includes(op))) {
            if (!silentAlerts) alert(`函数名 '${name}' 不能包含运算符 (+-*/^,)。`);
            return false;
        }
        if (this.calcJSUtils.isNumericString(name[0])) {
             if (!silentAlerts) alert(`函数名 '${name}' 不能以数字开头。`);
            return false;
        }

        const params = paramsStr.split(',').map(p => p.trim()).filter(p => p);
        if (new Set(params).size !== params.length) {
            if (!silentAlerts) alert(`函数 '${name}' 中存在重复的参数名。`);
            return false;
        }
        let paramError = false;
        params.forEach(param => {
            if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                if (!silentAlerts) alert(`参数名如 '${param}' 必须是有效的JS标识符。`);
                paramError = true;
            }
            if (this.calcJSUtils.constants[param.toLowerCase()] || this.calcJSUtils.calc1.includes(param.toLowerCase()) || ['e'].includes(param.toLowerCase())) {
                if (!silentAlerts) alert(`参数名 '${param}' 是保留的常量或内置函数名。`);
                paramError = true;
            }
        });
        if(paramError) return false;

        const bodyTrimmed = bodyStr.trim();
        const looksLikeAdvancedJs = bodyTrimmed.startsWith('{') && bodyTrimmed.endsWith('}') && bodyTrimmed.length > 2;

        if (looksLikeAdvancedJs) {
            try {
                const actualJsBody = bodyTrimmed.substring(1, bodyTrimmed.length - 1);
                const compiledFunc = new Function(...params, actualJsBody); 

                this.calcJSUtils.advancedCustomFunctions[nameLower] = { params, bodyJsString: actualJsBody, compiledFunc };
                if (!this.calcJSUtils.advancedCustomFunctionNames.includes(nameLower)) {
                    this.calcJSUtils.advancedCustomFunctionNames.push(nameLower);
                    this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
                }
                return { type: 'advanced_custom_function_definition', name, params, bodyJs: actualJsBody, originalExpression: defString };
            } catch (e) {
                if (!silentAlerts) alert(`定义高级JS函数 '${name}' 时出错: ${e.message}`);
                return false;
            }
        } else {
           try {
                const contextSymbols = new Set([
                    ...this.calcJSUtils.calc1,
                    ...this.calcJSUtils.calc3,
                    ...this.calcJSUtils.advancedCustomFunctionNames,
                    ...Object.keys(this.calcJSUtils.constants),
                    ...this.entries.map(e => e.name || e.key),
                    ...params
                ].filter(Boolean).map(n => n.toLowerCase()));

                let bodyTokens = this.improvedTokenize(bodyStr, contextSymbols);
                const paramsLower = params.map(p => p.toLowerCase());

                this.calcJSUtils.customFunctions[nameLower] = { params: paramsLower, bodyTokens, rawBodyString: bodyStr };

                if (!this.calcJSUtils.calc3.includes(nameLower)) {
                    this.calcJSUtils.calc3.push(nameLower);
                    this.calcJSUtils.calc3.sort((a,b) => b.length - a.length);
                }
                return { type: 'custom_function_definition', name, params, body: bodyStr, rawBodyString: bodyStr, bodyTokens, originalExpression: defString };
            } catch (e) {
                if (!silentAlerts) alert(`定义函数 '${name}' 时出错: ${e.message}`);
                return false;
            }
        }
    }

_extractDependenciesFromTokensWithLargeOps(tokens, excludeParams = [], customFunctions, calc3_list, constants_obj, calc1_list, allowedVarKeys, advancedCustomFunctions, advancedCustomFunctionNames, existingUserSymbolNames = new Set()) {
        const dependencies = new Set();
        // 预处理：将排除参数转换为小写 Set
        const currentExcludeParams = new Set(excludeParams.map(p => p.toLowerCase()));
        
        // 这是一个递归辅助函数，用于处理嵌套结构
        const recurse = (subTokens, localExcludes) => {
            let i = 0;
            while (i < subTokens.length) {
                const token = subTokens[i];
                const lowerToken = token.toLowerCase();

                // 检查是否为大型运算符 sum/prod/int
                if (['sum', 'prod', 'int'].includes(lowerToken)) {
                    // 检查括号结构
                    if (i + 1 >= subTokens.length || subTokens[i + 1] !== '(') {
                        i++; continue; 
                    }
                    const openParenIdx = i + 1;
                    const closeParenIdx = this.calcJSUtils.findMatchingParen(subTokens, openParenIdx);
                    if (closeParenIdx === -1) {
                        i++; continue; 
                    }

                    try {
                        // 提取 4 个参数：[表达式, 变量名, 起始值, 终止值]
                        // 注意：这里我们使用 calcJSUtils 的提取工具
                        const args = this.calcJSUtils.extractArguments(subTokens, openParenIdx, closeParenIdx, 4);
                        
                        const bodyTokens = args[0];
                        const varNameToken = args[1]; // 这是一个 token 数组
                        const startTokens = args[2];
                        const endTokens = args[3];

                        // 获取循环变量名 (例如 'n')
                        let loopVarName = null;
                        if (varNameToken && varNameToken.length === 1 && this.calcJSUtils.isLetter(varNameToken[0])) {
                            loopVarName = varNameToken[0].toLowerCase();
                        }

                        // 关键逻辑：
                        // 1. 分析主体 (bodyTokens)：排除当前的 localExcludes 加上 新的 loopVarName
                        //    因为在 sum(n, n, 1, a) 中，第一个 n 是局部变量
                        const nextLevelExcludes = loopVarName ? new Set([...localExcludes, loopVarName]) : localExcludes;
                        recurse(bodyTokens, nextLevelExcludes);

                        // 2. 分析起始和结束值 (startTokens, endTokens)：只能排除 localExcludes
                        //    因为 sum(..., n, 1, a) 中的 a 是外部依赖，不能被 n 屏蔽
                        recurse(startTokens, localExcludes);
                        recurse(endTokens, localExcludes);

                    } catch (e) {
                        // 如果参数解析失败（比如用户还没输完），忽略并继续
                    }
                    
                    // 跳过整个 sum(...) 结构
                    i = closeParenIdx + 1; 
                    continue;

                } else if (['diff', 'diffat'].includes(lowerToken)) {
                    // 处理导数 diff(expr, var)
                    if (i + 1 >= subTokens.length || subTokens[i + 1] !== '(') { i++; continue; }
                    const openParenIdx = i + 1;
                    const closeParenIdx = this.calcJSUtils.findMatchingParen(subTokens, openParenIdx);
                    if (closeParenIdx === -1) { i++; continue; }

                    try {
                        const expectedArgs = (lowerToken === 'diff') ? 2 : 3;
                        const args = this.calcJSUtils.extractArguments(subTokens, openParenIdx, closeParenIdx, expectedArgs);
                        
                        const bodyTokens = args[0];
                        const varNameToken = args[1];
                        let diffVarName = null;
                        if (varNameToken && varNameToken.length === 1) diffVarName = varNameToken[0].toLowerCase();

                        // 导数变量也是局部的
                        const nextLevelExcludes = diffVarName ? new Set([...localExcludes, diffVarName]) : localExcludes;
                        recurse(bodyTokens, nextLevelExcludes);
                        
                        // diffat 的第三个参数是求值点，它依赖外部变量
                        if (args.length === 3) {
                            recurse(args[2], localExcludes);
                        }

                    } catch (e) {}
                    i = closeParenIdx + 1;
                    continue;
                }

                // 常规 Token 处理
                // 如果是变量名（字母开头），且不在已知函数/常量/排除列表中，则视为依赖
                if (this.calcJSUtils.isLetter(token)) {
                    const isKnownFunc = calc1_list.includes(lowerToken) || calc3_list.includes(lowerToken) || advancedCustomFunctionNames.includes(lowerToken);
                    const isKnownConst = constants_obj.hasOwnProperty(lowerToken);
                    
                    if (!isKnownFunc && !isKnownConst && !localExcludes.has(lowerToken)) {
                        dependencies.add(lowerToken);
                    }
                }
                i++;
            }
        };

        // 启动递归
        recurse(tokens, currentExcludeParams);

        return Array.from(dependencies);
    }    
evaluateExpressionWithCalcJS(tokensOrString, scopeVars, customMap) {
    let tokens;
    if (typeof tokensOrString === 'string') {
        tokens = this.calcJSUtils.tokenize.call(this.calcJSUtils, tokensOrString);
    } else {
        // 避免昂贵的 JSON 序列化
        tokens = tokensOrString; 
    }
    
    // 关键修复：将 Map 转换为 Object 才能进行解构合并
    const variablesObj = Object.fromEntries(this.variables);
    const fullScope = { ...variablesObj, ...scopeVars };

    return this.calcJSUtils.evaluateScopedExpression.call(
        this.calcJSUtils, 
        tokens,
        fullScope,
        this.calcJSUtils.customFunctions,
        this.calcJSUtils.calc3,
        this.calcJSUtils.constants,
        this.calcJSUtils.calc1,
        this.integralNumSteps,
        this.calcJSUtils.advancedCustomFunctions,
        this.calcJSUtils.advancedCustomFunctionNames,
        customMap || this.calcJSUtils.getAdvancedFuncsMap()
    );
}


initWebGL() {
        this.gl = this.canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true }) || this.canvas.getContext('experimental-webgl', { antialias: true, preserveDrawingBuffer: true });
        if (!this.gl) {
            alert('WebGL 不支持。程序将崩溃');
            throw new Error('WebGL 不支持');
        }
        const gl = this.gl;


        const vsSource = document.getElementById('line-vertex-shader').textContent;
        const fsSource = document.getElementById('line-fragment-shader').textContent;
        this.shaderProgramLines = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSource), this.createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        this.attributeLocations.vertexPosition = gl.getAttribLocation(this.shaderProgramLines, 'a_vertexPosition');
        this.uniformLocations.canvasCssSize = gl.getUniformLocation(this.shaderProgramLines, 'u_canvasCssSize');
        this.uniformLocations.viewOffset = gl.getUniformLocation(this.shaderProgramLines, 'u_viewOffset');
        this.uniformLocations.viewScale = gl.getUniformLocation(this.shaderProgramLines, 'u_viewScale');
        this.uniformLocations.color = gl.getUniformLocation(this.shaderProgramLines, 'u_color');


        const vsSource3D = document.getElementById('shader-3d-vertex').textContent;
        const fsSource3D = document.getElementById('shader-3d-fragment').textContent;
        this.shaderProgram3D = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSource3D), this.createShader(gl, gl.FRAGMENT_SHADER, fsSource3D));
        this.attribLoc3D.position = gl.getAttribLocation(this.shaderProgram3D, 'a_position');
        this.attribLoc3D.normal = gl.getAttribLocation(this.shaderProgram3D, 'a_normal');
        this.uniformLoc3D.mvp = gl.getUniformLocation(this.shaderProgram3D, 'u_modelViewProjection');
        this.uniformLoc3D.normalMat = gl.getUniformLocation(this.shaderProgram3D, 'u_normalMatrix');
        this.uniformLoc3D.color = gl.getUniformLocation(this.shaderProgram3D, 'u_color');
        this.uniformLoc3D.lightDir = gl.getUniformLocation(this.shaderProgram3D, 'u_lightDirection');
        this.uniformLoc3D.bounds = gl.getUniformLocation(this.shaderProgram3D, 'u_bounds');


        const vsSourceLine3D = `attribute vec3 a_position; uniform mat4 u_mvp; varying vec3 v_position; void main() { v_position = a_position; gl_Position = u_mvp * vec4(a_position, 1.0); }`;
        const fsSourceLine3D = `precision mediump float; uniform vec4 u_color; uniform float u_bounds; varying vec3 v_position; void main() { if (abs(v_position.x) > u_bounds || abs(v_position.y) > u_bounds || abs(v_position.z) > u_bounds) discard; gl_FragColor = u_color; }`;
        this.shaderProgram3DLine = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSourceLine3D), this.createShader(gl, gl.FRAGMENT_SHADER, fsSourceLine3D));
        this.attribLoc3D.linePos = gl.getAttribLocation(this.shaderProgram3DLine, 'a_position');
        this.uniformLoc3D.lineMvp = gl.getUniformLocation(this.shaderProgram3DLine, 'u_mvp');
        this.uniformLoc3D.lineColor = gl.getUniformLocation(this.shaderProgram3DLine, 'u_color');
        this.uniformLoc3D.lineBounds = gl.getUniformLocation(this.shaderProgram3DLine, 'u_bounds');

        const vsSourceThick = document.getElementById('shader-3d-thick-line-vertex').textContent;
        const fsSourceThick = document.getElementById('shader-3d-thick-line-fragment').textContent;
        this.shaderProgram3DThick = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSourceThick), this.createShader(gl, gl.FRAGMENT_SHADER, fsSourceThick));
        this.attribLoc3D.thickPos = gl.getAttribLocation(this.shaderProgram3DThick, 'a_pos');
        this.attribLoc3D.thickOther = gl.getAttribLocation(this.shaderProgram3DThick, 'a_other');
        this.attribLoc3D.thickSide = gl.getAttribLocation(this.shaderProgram3DThick, 'a_side');
        this.uniformLoc3D.thickMvp = gl.getUniformLocation(this.shaderProgram3DThick, 'u_mvp');
        this.uniformLoc3D.thickViewport = gl.getUniformLocation(this.shaderProgram3DThick, 'u_viewport');
        this.uniformLoc3D.thickThickness = gl.getUniformLocation(this.shaderProgram3DThick, 'u_thickness');
        this.uniformLoc3D.thickColor = gl.getUniformLocation(this.shaderProgram3DThick, 'u_color');


        this.lineVertexBuffer = gl.createBuffer();
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  this.implicitFillData = new Map();
    }

  autonamePointList() {
        return this.autonameByPrefix('array');
    }

parsePointList(originalInput, ignoreIndex = -1) {
        const name = this.autonamePointList();
        const entry = {
            type: 'point_list',
            expr: originalInput,
            name: name,
            pointCache: [],
            segments: [],
            dependencies: [],
            color: { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 },
            visible: true,
            thickness: 3,
            displayFrame: 0,
            webglVertices: null,
            compilationError: undefined,
            hasLargeOps: false,
        };

        const existingUserSymbolNamesForDepExtraction = new Set(
            this.entries.filter((e, i) => i !== ignoreIndex).map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean)
        );

        const content = originalInput.substring(3).trim();
        
        const items = [];
        let currentStr = '';
        let parenLevel = 0;
        
        for (let i = 0; i < content.length; i++) {
            const char = content[i];
            
            if (char === '(') {
                if (parenLevel === 0 && currentStr.trim() === '') {
                    currentStr = '(';
                } else {
                    currentStr += char;
                }
                parenLevel++;
            } else if (char === ')') {
                parenLevel--;
                currentStr += char;
                if (parenLevel === 0) {
                    items.push(currentStr.trim());
                    currentStr = '';
                } else if (parenLevel < 0) {
                     throw new Error("点列语法无效: 括号不匹配。");
                }
            } else if (char === '/' && parenLevel === 0) {
                 items.push('/');
                 currentStr = '';
            } else {
                if (parenLevel > 0 || char.trim() !== '') {
                    currentStr += char;
                }
            }
        }
        
        if (parenLevel !== 0) throw new Error("点列语法无效: 括号不匹配。");
        if (items.length === 0) throw new Error("点列语法无效: 未找到任何点或分隔符。");

        let currentSegmentIndices = [];
        const allDependencies = new Set();

        const parseCoordinates = (str) => {
            const inner = str.substring(1, str.length - 1);
            let pLevel = 0;
            let splitIndex = -1;
            for(let i = 0; i < inner.length; i++) {
                if (inner[i] === '(') pLevel++;
                else if (inner[i] === ')') pLevel--;
                else if (inner[i] === ',' && pLevel === 0) {
                    splitIndex = i;
                    break;
                }
            }
            if (splitIndex === -1) throw new Error(`点坐标格式错误: ${str}`);
            return [inner.substring(0, splitIndex).trim(), inner.substring(splitIndex + 1).trim()];
        };

        for (const item of items) {
            const isBreak = item === '/' || item.toLowerCase() === '(x,x)';
            if (isBreak) {
                if (currentSegmentIndices.length > 0) {
                    entry.segments.push(currentSegmentIndices);
                }
                currentSegmentIndices = [];
            } else {
                let rawX, rawY;
                try {
                    [rawX, rawY] = parseCoordinates(item);
                } catch (e) {
                     throw new Error(`点坐标格式错误: ${item}`);
                }

                const isNumericX = this.calcJSUtils.isNumericString(rawX);
                const isNumericY = this.calcJSUtils.isNumericString(rawY);
                
                const dependenciesX = isNumericX ? [] : this._extractDependenciesFromTokensWithLargeOps(
                    this.calcJSUtils.tokenize.call(this.calcJSUtils, rawX), [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingUserSymbolNamesForDepExtraction
                );
                const dependenciesY = isNumericY ? [] : this._extractDependenciesFromTokensWithLargeOps(
                    this.calcJSUtils.tokenize.call(this.calcJSUtils, rawY), [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingUserSymbolNamesForDepExtraction
                );

                dependenciesX.forEach(dep => allDependencies.add(dep));
                dependenciesY.forEach(dep => allDependencies.add(dep));

                const pointCacheEntry = {
                    rawX,
                    rawY,
                    isNumericX,
                    isNumericY,
                    valueX: isNumericX ? parseFloat(rawX) : NaN,
                    valueY: isNumericY ? parseFloat(rawY) : NaN,
                    dependenciesX,
                    dependenciesY,
                };

                const cacheIndex = entry.pointCache.length;
                entry.pointCache.push(pointCacheEntry);
                currentSegmentIndices.push(cacheIndex);
            }
        }
        if (currentSegmentIndices.length > 0) {
            entry.segments.push(currentSegmentIndices);
        }
        
        entry.dependencies = Array.from(allDependencies);
        return entry;
    }

    recalculatePointLists() {
        this.entries.forEach(entry => {
            if (entry.type !== 'point_list') return;

            let changed = false;
            entry.pointCache.forEach(point => {
                if (!point.isNumericX) {
                    const newValueX = this.evaluateExpressionWithCalcJS(point.rawX, Object.fromEntries(this.variables));
                    if (point.valueX !== newValueX) {
                        point.valueX = newValueX;
                        changed = true;
                    }
                }
                if (!point.isNumericY) {
                    const newValueY = this.evaluateExpressionWithCalcJS(point.rawY, Object.fromEntries(this.variables));
                    if (point.valueY !== newValueY) {
                        point.valueY = newValueY;
                        changed = true;
                    }
                }
            });

            if (changed) {
                entry.webglVertices = null;
            }
        });
    }

    plotPointListGL(entry, cssWidth, cssHeight) {
        if (this.is3DMode) return;
        const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && !this.showHiddenMath) return; if (entry.compilationError || !entry.color) return;


        const gl = this.gl;
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);

        if (!entry.webglVertices) {
            const vertices = [];
            for (const segment of entry.segments) {
                for (let i = 0; i < segment.length - 1; i++) {
                    const p1_cache = entry.pointCache[segment[i]];
                    const p2_cache = entry.pointCache[segment[i + 1]];

                    if (Number.isFinite(p1_cache.valueX) && Number.isFinite(p1_cache.valueY) &&
                        Number.isFinite(p2_cache.valueX) && Number.isFinite(p2_cache.valueY)) {
                        
                        if (useQuads) {
                            vertices.push(...this.generateQuadVertices(p1_cache.valueX, p1_cache.valueY, p2_cache.valueX, p2_cache.valueY, lineThicknessMath));
                        } else {
                            vertices.push(p1_cache.valueX, p1_cache.valueY, p2_cache.valueX, p2_cache.valueY);
                        }
                    }
                }
            }
            entry.webglVertices = new Float32Array(vertices);
        }

        if (entry.webglVertices && entry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            
            const plotColorArray = this.hsbToRgbaArray(entry.color.h, entry.color.s, entry.color.b, entry.color.a);
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);

            if (useQuads) {
                gl.drawArrays(gl.TRIANGLES, 0, entry.webglVertices.length / 2);
            } else {
                gl.lineWidth(1.5);
                gl.drawArrays(gl.LINES, 0, entry.webglVertices.length / 2);
            }
        }
    }



    createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    updateCategoryButtonIcon() {
        if (this.categoryFilterIcon) {
            this.categoryFilterIcon.src = this.categoryIcons[this.categoryFilterMode];
        }
    }


updateOverlayPositions() {
        if (!this.fpsDisplay || !this.infoDisplay) return;

        this.fpsDisplay.style.display = 'block';

        if (!this.isTransparencyEnabled) {
            this.infoDisplay.style.display = 'none';
            return;
        } else {
            this.infoDisplay.style.display = '';
        }

        const isSidebarHidden = document.body.classList.contains('sidebar-hidden');
        const isPortrait = this.isPortraitMode;
        const sidebarBg = document.getElementById('sidebar-background');
        const isFullscreen = sidebarBg && sidebarBg.classList.contains('fullscreen');

        if (isSidebarHidden || isPortrait || isFullscreen || !sidebarBg) {
            this.infoDisplay.style.left = '10px';
        } else {
            const sidebarRect = sidebarBg.getBoundingClientRect();
            const newLeft = sidebarRect.right + 10;
            this.infoDisplay.style.left = `${newLeft}px`;
        }
    }
getEffectiveVisibility(entry) {
        
        const id = entry.name || entry.expr;
        for (const anno of this.annotations) {
            if (anno.type === 'checkbox' && anno.controlledNames && anno.controlledNames.includes(id)) {
                return anno.checked;
            }
        }
        return entry.visible;
    }
     init() {
    this.initializeAdvancedCalcJSFunctions();
    this.initializeCalcJSBuiltinFunctions();
    this.initWebGL();
    this.clearPlotData();
    this.updateLayout();
    this.centerCanvas();
    

    this.colorInversionToggle = document.getElementById('color-inversion-toggle');
    this.showAxesToggle = document.getElementById('show-axes-toggle');
    this.showAxisNumbersToggle = document.getElementById('show-axis-numbers-toggle');
    this.showPointLabelsToggle = document.getElementById('show-point-labels-toggle');
    this.showHiddenMathToggle = document.getElementById('show-hidden-math-toggle');
    this.showHiddenGeoToggle = document.getElementById('show-hidden-geo-toggle');
    this.geometrySnapToggle = document.getElementById('geometry-snap-toggle');
    this.geometryMeasurementDisplayToggle = document.getElementById('geometry-measurement-display-toggle');
    this.infoDisplay = document.getElementById('info-display');
    this.codePanel = document.getElementById('code-panel');
    this.windowTransparencyToggle = document.getElementById('window-transparency-toggle');
    this.isTransparencyEnabled = true; 
this.annotationMenu = document.getElementById('annotation-menu');
this.variableCardInteraction = { active: false, entryIndex: -1, type: null, offset: { x: 0, y: 0 }, startVal: 0 };
    this.isAnnotationMenuExpanded = false; // 新增状态追踪

    this.penColorSliders.h = new CustomSlider('pen-color-slider-h', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.h, type: 'hue', onInput: e => { this.annotationState.pen.color.h = e.target.options.value; Object.values(this.penColorSliders).forEach(s => { s.options.context = this.annotationState.pen.color; s.draw(); }); } });
    this.penColorSliders.s = new CustomSlider('pen-color-slider-s', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.s, type: 'saturation', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.s = e.target.options.value; } });
    this.penColorSliders.b = new CustomSlider('pen-color-slider-b', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.b, type: 'brightness', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.b = e.target.options.value; } });
    this.penColorSliders.a = new CustomSlider('pen-color-slider-a', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.a, type: 'alpha', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.a = e.target.options.value; } });
    
    this.annotationEditTextBtn = document.getElementById('annotation-edit-text-btn');
    this.annotationDeleteBtn = document.getElementById('annotation-delete-btn');
    this.annotationModeSwitchBtns = document.querySelectorAll('.annotation-mode-switch-btn');
    this.annotationColorBtn = document.getElementById('annotation-color-btn'); // 新增颜色按钮引用

    this.penThicknessSlider = new CustomSlider('pen-thickness-slider', { min: 0.01, max: 0.5, step: 0.01, value: 0.05, type: 'default', onInput: e => { this.annotationState.pen.thickness = e.target.options.value; this.requestDraw(); } });
    this.penFontSizeSlider = new CustomSlider('text-size-slider', { min: 0.1, max: 2.0, step: 0.1, value: 0.5, type: 'default', onInput: e => { this.annotationState.pen.fontSize = e.target.options.value; this.requestDraw(); } });

    // 绑定颜色按钮的折叠/展开逻辑
    if (this.annotationColorBtn) {
        this.annotationColorBtn.addEventListener('click', () => {
            this.isAnnotationMenuExpanded = !this.isAnnotationMenuExpanded;
            this.annotationMenu.classList.toggle('expanded', this.isAnnotationMenuExpanded);
            this.annotationColorBtn.classList.toggle('active', this.isAnnotationMenuExpanded);
        });
    }

    this.penThicknessSlider = new CustomSlider('pen-thickness-slider', { min: 0.01, max: 0.5, step: 0.01, value: 0.05, type: 'default', onInput: e => { this.annotationState.pen.thickness = e.target.options.value; this.requestDraw(); } });

    this.penFontSizeSlider = new CustomSlider('text-size-slider', { min: 0.1, max: 2.0, step: 0.1, value: 0.5, type: 'default', onInput: e => { this.annotationState.pen.fontSize = e.target.options.value; this.requestDraw(); } });
    
    if (this.fileNameDisplay) {
        this.fileNameDisplay.textContent = this.filename;
        this.fileNameDisplay.addEventListener('click', () => {
            const newName = prompt("请输入存档名称:", this.filename);
            if (newName && newName.trim() !== "") {
                this.filename = newName.trim();
                this.fileNameDisplay.textContent = this.filename;
            }
        });
    }
    
const viewModeCircle = document.getElementById('view-mode-toggle-circle');
    if (viewModeCircle) {
        viewModeCircle.addEventListener('click', () => {
            if (this.is3DMode) {
                this.is3DMode = false;
                viewModeCircle.textContent = "3D";
                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) navBtnGeometry.style.display = 'flex';
            } else {
                this.is3DMode = true;
                this.stopTracing();
                viewModeCircle.textContent = "2D";
               if (this.currentUIMode === 'geometry') {
                    this.setUIMode('plot');
                    const navBtnGeometry = document.getElementById('nav-btn-geometry');
                    const navBtnPlot = document.getElementById('nav-btn-plot');
                    if (navBtnPlot && navBtnGeometry) {
                        navBtnGeometry.classList.remove('selected');
                        navBtnPlot.classList.add('selected');
                    }
                    if (typeof updateInterfaceState === 'function') {
                        updateInterfaceState();
                    }
                }
                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) navBtnGeometry.style.display = 'none';
                this.recalculate3D();
            }
            this.requestDraw();
            this.updateTopBarLayout(); 
        });
    }

    const resetViewBtn = document.getElementById('reset-view-btn');
    if (resetViewBtn) {
        resetViewBtn.addEventListener('click', () => {
            if (this.is3DMode) {

                this.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
                this.center3D = { x: 0, y: 0, z: 0 };
                this.offset3D = { x: 0, y: 0 };
                this.scale3D = 1.0;
                this.bounds3D = 8;

                this.recalculate3D();
            } else {

                this.scale = 100; 
                this.centerCanvas(); 
            }
            

            this.clearPlotData();
            this.requestDraw();

        });
    }


this.setupEventListeners();
    
this.isAnnotationEditingEnabled = true;
        const annoSplitLeft = document.getElementById('anno-split-left');
        const annoSplitRight = document.getElementById('anno-split-right');
        const iconEditOn = document.getElementById('icon-edit-on');
        const iconEditOff = document.getElementById('icon-edit-off');


        const updateEditIcon = () => {
            if (iconEditOn && iconEditOff) {
                iconEditOn.style.display = this.isAnnotationEditingEnabled ? 'block' : 'none';
                iconEditOff.style.display = this.isAnnotationEditingEnabled ? 'none' : 'block';
            }
        };

        if (annoSplitLeft) {
            updateEditIcon();
            
            annoSplitLeft.addEventListener('click', (e) => {
                e.stopPropagation();
                this.isAnnotationEditingEnabled = !this.isAnnotationEditingEnabled;
                updateEditIcon();
                
                if (!this.isAnnotationEditingEnabled && this.selectedAnnotationIndex !== -1) {
                    this.selectedAnnotationIndex = -1;
                    this.updateAnnotationEditMenu();
                    this.requestDraw();
                }
            });
        }

 if (annoSplitRight) {
            annoSplitRight.addEventListener('click', (e) => {
                e.stopPropagation();
                
                let returnMode = archInstance.currentUIMode;
                
                if (archInstance.currentUIMode === 'plot') {
                    returnMode = 'geometry'; 
                    archInstance.setUIMode('geometry');
                }
                
                archInstance.enterAnnotationMode(returnMode);
            });
        }

    this.applyTransparency(this.isTransparencyEnabled);

    this.updatePrecisionLabels();
    this.updateParametricRangeLabels();
    this.updatePreferredColorValueLabel();
    this.updateIntegralPrecisionLabel();
    this.applyThemeColors();
    
    this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    if (this.overlayDrawingToggle) this.overlayDrawingToggle.checked = this.overlayDrawingEnabled;
    this.lowPrecisionBufferToggle.checked = this.lowPrecisionBufferEnabled;
    this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;

    this.darkModeToggle.checked = this.isDarkModeActive;
    this.applyDarkMode(this.isDarkModeActive);
    this.geometrySnapToggle.checked = this.geometrySnapEnabled;
    this.geometryMeasurementDisplayToggle.checked = this.geometryMeasurementDisplayEnabled;
    this.colorInversionToggle.checked = this.colorInversionEnabled;
    this.showAxesToggle.checked = this.showAxes;
    this.showAxisNumbersToggle.checked = this.showAxisNumbers;
    document.querySelectorAll('#grid-style-buttons button').forEach(b => {
        b.classList.toggle('active', b.dataset.style === this.gridStyle);
    });
    this.showPointLabelsToggle.checked = this.showPointLabels;
    this.showHiddenMathToggle.checked = this.showHiddenMath;
    this.showHiddenGeoToggle.checked = this.showHiddenGeo;
    this.windowTransparencyToggle.checked = this.isTransparencyEnabled;
    document.getElementById('global-script-toggle-btn').addEventListener('click', () => this.toggleGlobalScriptView());
    document.getElementById('global-script-run-btn').addEventListener('click', () => this.executeGlobalScript());
    document.getElementById('global-script-stop-btn').addEventListener('click', () => this.stopGlobalScript());

    this.checkTouchSupport();
    if (this.isTouchDevice) document.body.classList.add('is-touch-device');
    this.smoothPanningEnabled = this.isTouchDevice;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    
    this.updateOverlayPositions();
    this.recalculateAll();
}  

  getRayPlaneIntersection(mouseX, mouseY) {
        const gl = this.gl;
        const canvasHeight = this.canvas.height / window.devicePixelRatio;

        const viewportBottomScreenY = canvasHeight - this.viewport3D.y;

        const viewportTopScreenY = canvasHeight - (this.viewport3D.y + this.viewport3D.h);

        const ndcX = ((mouseX - this.viewport3D.x) / this.viewport3D.w) * 2 - 1;
  
        const ndcY = ((canvasHeight - mouseY - this.viewport3D.y) / this.viewport3D.h) * 2 - 1;

        const aspect = this.viewport3D.w / this.viewport3D.h;
        const proj = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta) + this.center3D.x,
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta) + this.center3D.y,
            z: cam.rho * Math.cos(cam.phi) + this.center3D.z
        };
        const view = Mat4.lookAt(Mat4.create(), eye, this.center3D, {x:0, y:0, z:1});
        
        const vp = Mat4.multiply(Mat4.create(), proj, view);
        const invVP = Mat4.invert(Mat4.create(), vp);
        if (!invVP) return null;

        const near = [ndcX, ndcY, -1];
        const far = [ndcX, ndcY, 1];
        Mat4.transformVec3(near, near, invVP);
        Mat4.transformVec3(far, far, invVP);

        const dirZ = far[2] - near[2];
        if (Math.abs(dirZ) < 1e-6) return null;
        

        const t = (0 - near[2]) / dirZ;
        

        
        return { 
            x: near[0] + t * (far[0] - near[0]), 
            y: near[1] + t * (far[1] - near[1]) 
        };
    }

clearPlotData() {
        this.blocks01.clear();
        this.implictplotindex.length = 0;
        this.implictplotindex.push(0);
        this.implictplotdata.length = 0;
        this.orderedBlocks01ForImplicitProcessing.length = 0;
        if (this.implicitFillData) this.implicitFillData.clear();
        if(this.plottedFunctionPoints) this.plottedFunctionPoints.length = 0;
        this.entries.forEach(entry => {
            entry.webglVertices = null;
            if (entry.plotType === 'parametric') {
                entry.cachedPoints = [];
            }
        });
    }
    updateGeometryMeasurementDisplay() {
    const displayContainer = document.getElementById('geometry-measurement-display');
    if (!displayContainer) return;

    if (!this.geometryMeasurementDisplayEnabled) {
        displayContainer.innerHTML = '';
        displayContainer.style.display = 'none';
        return;
    }

    const measurementEntries = this.entries.filter(e =>
        e.type === 'geometry' &&
        ['length', 'angle', 'area', 'isparallel', 'isperpendicular', 'isconcyclic'].includes(e.geometryType) &&
        e.isMeaningful &&
        e.visible
    );

    if (measurementEntries.length === 0) {
        displayContainer.innerHTML = '';
        displayContainer.style.display = 'none';
        return;
    }

    displayContainer.style.display = 'block';
    displayContainer.innerHTML = measurementEntries
        .map(entry => `<div>${entry.detailsString || ''}</div>`)
        .join('');
}


         updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const sidebar = this.sidebar;
            const sidebarBg = document.getElementById('sidebar-background');

            sidebar.style.width = '';
            sidebar.style.height = '';
            sidebarBg.style.width = '';
            sidebarBg.style.height = '';
            sidebar.style.top = '';
            sidebarBg.style.top = '';

            this.isPortraitMode = w / h < 0.75;
            document.body.classList.toggle('portrait-mode', this.isPortraitMode);

            const infoModes = ['settings', 'file', 'about'];

            if (this.isPortraitMode) {
                sidebar.classList.add('fullscreen');
                sidebarBg.classList.add('fullscreen');
                if (this.currentUIMode === 'plot' || this.currentUIMode === 'geometry') {
                    sidebar.style.height = '50vh';
                    sidebarBg.style.height = '50vh';
                    sidebar.style.top = 'auto';
                    sidebarBg.style.top = 'auto';
                }
            } else {
                if (infoModes.includes(this.currentUIMode)) {
                    sidebar.classList.add('fullscreen');
                    sidebarBg.classList.add('fullscreen');
                } else {
                    sidebar.classList.remove('fullscreen');
                    sidebarBg.classList.remove('fullscreen');
                }
            }
            
if (!this.isPortraitMode) {
                document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
                document.getElementById('keyboard-toggle-container').classList.remove('hidden-by-nav');
                const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
                if (portraitBtn) {
                    portraitBtn.classList.remove('active');
                    portraitBtn.style.display = '';
                }
            }
            this.sidebar.style.cursor = 'default';
            document.body.style.cursor = 'default';
            this.updateOverlayPositions();
const topMask = document.getElementById('top-blur-mask');
        if (topMask) {
           
            const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
            const isMainMode = ['plot', 'geometry', 'code'].includes(this.currentUIMode);
            
            if (isSidebarVisible && !isMainMode && !this.isPortraitMode) {
                topMask.classList.add('hidden');
            } else {
                topMask.classList.remove('hidden');
            }
        }
            this.clearPlotData();
            this.updateCanvasPosition();
            this.updateTopBarLayout();
        }

updateTopBarLayout() {
        const fileName = document.getElementById('file-name-display');
        const resetViewBtn = document.getElementById('reset-view-btn'); 
        const viewToggle = document.getElementById('view-mode-toggle-circle');
        const stageToggle = document.getElementById('stage-mode-toggle-btn');
        const annoSplitBtn = document.getElementById('annotation-split-btn');
        const stopTraceBtn = document.getElementById('stop-trace-btn');
        const sidebarBg = document.getElementById('sidebar-background');

        const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
        const mode = this.currentUIMode;

        if (isSidebarVisible && sidebarBg && !this.isPortraitMode && ['plot', 'geometry', 'code'].includes(mode)) {
            const rect = sidebarBg.getBoundingClientRect();
            this.lastValidSidebarRight = rect.right;
        }

        if (fileName) {
            const showTitle = isSidebarVisible && ['plot', 'geometry', 'code'].includes(mode);
            fileName.style.display = showTitle ? 'block' : 'none';

            if (showTitle && sidebarBg) {
                if (this.isPortraitMode) {
                    fileName.style.left = '20px';
                } else {
                    fileName.style.left = '430px';
                }
            }
        }


        const baseRight = 15;
        const gap = 10;
        const circleBtnWidth = 36;
        const splitBtnWidth = 100; 


        const showAnnoBtn = !this.is3DMode && ['plot', 'geometry'].includes(mode);
        

        let currentRight = baseRight;


        if (annoSplitBtn) {
            if (showAnnoBtn) {
                annoSplitBtn.style.display = 'flex';
                annoSplitBtn.style.right = `${baseRight}px`;

                requestAnimationFrame(() => {
                    annoSplitBtn.style.opacity = '1';
                    annoSplitBtn.style.visibility = 'visible';
                });

                currentRight += splitBtnWidth + gap;
            } else {
                annoSplitBtn.style.opacity = '0';
                annoSplitBtn.style.visibility = 'hidden';
                setTimeout(() => {
                    if (annoSplitBtn.style.opacity === '0') {
                        annoSplitBtn.style.display = 'none';
                    }
                }, 300);

            }
        }


        if (resetViewBtn) {

            const showReset = isSidebarVisible && ['plot', 'geometry'].includes(mode);
            
            if (showReset) {
                resetViewBtn.style.display = 'flex';
                resetViewBtn.style.right = `${currentRight}px`; 
                resetViewBtn.style.zIndex = '101';
                setTimeout(() => {
                    resetViewBtn.style.opacity = '1';
                    resetViewBtn.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                resetViewBtn.style.display = 'none';
            }
        }

        if (viewToggle) {
            const showToggle = isSidebarVisible && ['plot', 'geometry'].includes(mode);
            if (showToggle) {
                viewToggle.style.display = 'flex';
                viewToggle.style.right = `${currentRight}px`; 
                setTimeout(() => {
                    viewToggle.style.opacity = '1';
                    viewToggle.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                viewToggle.style.display = 'none';
            }
        }

        if (stageToggle) {
            const showStageBtn = isSidebarVisible && ['plot', 'geometry'].includes(mode) && !this.isPortraitMode;
            if (showStageBtn) {
                stageToggle.style.display = 'flex';
                stageToggle.style.right = `${currentRight}px`; 
                setTimeout(() => {
                    stageToggle.style.opacity = '1';
                    stageToggle.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                stageToggle.style.opacity = '0';
                stageToggle.style.visibility = 'hidden';
                setTimeout(() => {
                    if (stageToggle.style.opacity === '0') {
                        stageToggle.style.display = 'none';
                    }
                }, 300);
            }
        }

        if (stopTraceBtn && this.traceState.active) {
            stopTraceBtn.style.right = `${currentRight}px`;
        }

if (this.categoryFilterBtn) {
    // 仅通过 display 属性控制显示/隐藏，位置完全交给 CSS Flex
    if (!this.isPortraitMode && ['plot'].includes(mode) && isSidebarVisible) {
        this.categoryFilterBtn.style.display = 'flex';
        // ！！！重要：删除之前所有设置 this.categoryFilterBtn.style.left = ... 的代码！！！
    } else {
        this.categoryFilterBtn.style.display = 'none';
    }
}  }
   
    resizeCanvas() {
        const container = this.canvasContainer;
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();

        const cssWidth = Math.max(1, rect.width);
        const cssHeight = Math.max(1, rect.height);

        if (this.canvas.width !== cssWidth * dpr || this.canvas.height !== cssHeight * dpr) {
            this.canvas.width = cssWidth * dpr;
            this.canvas.height = cssHeight * dpr;
            this.canvas.style.width = `${cssWidth}px`;
            this.canvas.style.height = `${cssHeight}px`;

            this.axisCanvas.width = cssWidth * dpr;
            this.axisCanvas.height = cssHeight * dpr;
            this.axisCanvas.style.width = `${cssWidth}px`;
            this.axisCanvas.style.height = `${cssHeight}px`;

            if (this.gl) {
                this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
            }
        }
         this.requestDraw();
    }

    updateCanvasPosition() {
        const isSidebarHidden = document.body.classList.contains('sidebar-hidden');
        const isPortrait = this.isPortraitMode;
        const sidebarBg = document.getElementById('sidebar-background');

        if (this.isTransparencyEnabled || isSidebarHidden || isPortrait || !sidebarBg) {
            this.canvasContainer.style.left = '0px';
            this.canvasContainer.style.width = '100%';
        } else {
            const sidebarRect = sidebarBg.getBoundingClientRect();
            this.canvasContainer.style.left = `${sidebarRect.right}px`;
            this.canvasContainer.style.width = `${window.innerWidth - sidebarRect.right}px`;
        }
        this.resizeCanvas();
    }

    centerCanvas() {
        const cssWidth = this.canvas.clientWidth;
        const cssHeight = this.canvas.clientHeight;
        if (cssWidth > 0 && cssHeight > 0) {
            this.offset.x = cssWidth / 2;
            this.offset.y = cssHeight / 2;
        }
        this.clearPlotData();
    }


     setupEventListeners() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            archInstance.updateLayout();
        }, 100);
    });

    this.canvas.addEventListener('mousedown', e => this.handleInteractionStart(e));
    window.addEventListener('mousemove', e => this.handleInteractionMove(e));
    window.addEventListener('mouseup', e => this.handleInteractionEnd(e));
    this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    this.canvas.addEventListener('wheel', e => this.onZoom(e), { passive: false });
    this.canvas.addEventListener('touchstart', e => this.handleInteractionStart(e), { passive: false });
    this.canvas.addEventListener('touchmove', e => this.handleInteractionMove(e), { passive: false });
    this.canvas.addEventListener('touchend', e => this.handleInteractionEnd(e));
    this.canvas.addEventListener('touchcancel', e => this.handleInteractionEnd(e));
    this.sidebar.addEventListener('mousedown', e => this.startSidebarResize(e));
    this.sidebar.addEventListener('touchstart', e => this.startSidebarResizeTouch(e), { passive: false });
    window.addEventListener('mousemove', e => {
        if (this.isResizingSidebar) this.doSidebarResize(e);
        else this.updateSidebarCursor(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', () => this.stopSidebarResize());
    window.addEventListener('touchmove', e => { if (this.isResizingSidebarTouch) this.doSidebarResizeTouch(e); }, { passive: false });
    window.addEventListener('touchend', () => this.stopSidebarResizeTouch());
    window.addEventListener('touchcancel', () => this.stopSidebarResizeTouch());
    this.sidebar.addEventListener('mouseleave', () => { if (!this.isResizingSidebar) this.sidebar.style.cursor = 'default'; });
    this.entryList.addEventListener('click', e => this.handleEntryListClick(e));

    this.preferredColorSlider = new CustomSlider('preferred-color-slider-container', { min: 0, max: 100, step: 1, value: this.preferredColorValue, type: 'hue', onInput: e => { this.preferredColorValue = e.target.options.value; this.updatePreferredColorValueLabel(); this.applyThemeColors(); }});
    this.explicitPrecisionSlider = new CustomSlider('explicit-precision-slider-container', { min: 0.5, max: 20, step: 0.1, value: this.explicitPrecisionStep, type: 'default', onInput: e => { this.explicitPrecisionStep = e.target.options.value; if (!this.isZooming || !this.performanceModeEnabled) this.originalExplicitPrecision = this.explicitPrecisionStep; this.updatePrecisionLabels(); this.clearPlotData(); this.requestDraw(); }});
    this.implicitPrecisionSlider = new CustomSlider('implicit-precision-slider-container', { min: 0.5, max: 20, step: 0.1, value: 20 / this.implicitPrecisionStep, type: 'default', onInput: e => { this.implicitPrecisionStep = 20 / e.target.options.value; if (!this.isZooming || !this.performanceModeEnabled) this.originalImplicitPrecision = this.implicitPrecisionStep; this.updatePrecisionLabels(); this.clearPlotData(); this.requestDraw(); }});
    this.integralPrecisionSlider = new CustomSlider('integral-precision-slider-container', { min: 10, max: 1000, step: 10, value: this.integralNumSteps, type: 'default', onInput: e => { this.integralNumSteps = e.target.options.value; this.updateIntegralPrecisionLabel(); }, onChange: () => this.recalculateAll() });

    this.explicitPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.explicitPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.implicitPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.implicitPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.integralPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.integralPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.preferredColorValueSpan.addEventListener('click', () => { 
        const slider = this.preferredColorSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = parseFloat(valStr); 
                if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                    slider.setValue(newValue, true); 
                } else { 
                    alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                } 
            }); 
        } 
    });


    
    document.getElementById('dark-mode-toggle').addEventListener('change', e => this.applyDarkMode(e.target.checked));
    document.getElementById('window-transparency-toggle').addEventListener('change', e => this.applyTransparency(e.target.checked));
    document.getElementById('color-inversion-toggle').addEventListener('change', e => { this.colorInversionEnabled = e.target.checked; this.requestDraw(); });
    this.overlayDrawingToggle.addEventListener('change', e => { 
        this.overlayDrawingEnabled = e.target.checked; 
        this.clearPlotData(); 
        this.recalculateAll();
        this.requestDraw(); 
    });
        this.performanceModeToggle = document.getElementById('performance-mode-toggle');
    if (this.performanceModeToggle) {
        this.performanceModeToggle.checked = this.performanceModeEnabled;
        this.performanceModeToggle.addEventListener('change', e => { 
            this.performanceModeEnabled = e.target.checked; 
            if (!this.performanceModeEnabled && this.isZooming) { 
                this.restoreOriginalPrecisions(); 
                this.isZooming = false; 
                this.clearPlotData(); 
                this.recalculateAll(); 
            } 
        });
    }

    this.lowPrecisionBufferToggle.addEventListener('change', e => { this.lowPrecisionBufferEnabled = e.target.checked; });
    this.highPerformancePlottingToggle.addEventListener('change', e => { this.highPerformancePlottingEnabled = e.target.checked; this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2; this.clearPlotData(); this.requestDraw(); });
    this.tminValueSpan.addEventListener('click', () => this.promptEditParametricRange('tmin'));
    this.tmaxValueSpan.addEventListener('click', () => this.promptEditParametricRange('tmax'));
    document.getElementById('show-axes-toggle').addEventListener('change', e => { this.showAxes = e.target.checked; this.requestDraw(); });
    document.getElementById('show-axis-numbers-toggle').addEventListener('change', e => { this.showAxisNumbers = e.target.checked; this.requestDraw(); });
    document.getElementById('grid-style-buttons').addEventListener('click', e => { const btn = e.target.closest('button'); if(btn){ this.gridStyle = btn.dataset.style; document.querySelectorAll('#grid-style-buttons button').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); this.requestDraw(); }});
    document.getElementById('show-point-labels-toggle').addEventListener('change', e => { this.showPointLabels = e.target.checked; this.requestDraw(); });
    document.getElementById('show-hidden-math-toggle').addEventListener('change', e => { this.showHiddenMath = e.target.checked; this.requestDraw(); });
    document.getElementById('show-hidden-geo-toggle').addEventListener('change', e => { this.showHiddenGeo = e.target.checked; this.requestDraw(); });
    this.autoBreakpointDetectionToggle.addEventListener('change', e => { this.autoBreakpointDetectionEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
        this.adaptiveExtendToggle.addEventListener('change', e => { this.adaptiveExtendEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
    this.geometrySnapToggle.addEventListener('change', e => { this.geometrySnapEnabled = e.target.checked; });
    this.adaptivePlottingToggle.addEventListener('change', e => { this.adaptivePlottingEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
    this.geometryMeasurementDisplayToggle.addEventListener('change', e => { this.geometryMeasurementDisplayEnabled = e.target.checked; this.updateGeometryMeasurementDisplay(); });
    this.smoothPanningToggle.addEventListener('change', e => { this.smoothPanningEnabled = e.target.checked; if (!this.smoothPanningEnabled && this.isSmoothPanningActive) { this.isSmoothPanningActive = false; this.finalizePanInteraction(); }});

    document.getElementById('load-js-op-btn').addEventListener('click', () => this.loadJsOperator());
    document.getElementById('code-new-btn').addEventListener('click', () => this.showCodeEditor(-1));
    document.getElementById('code-upload-btn').addEventListener('click', () => this.loadJsOperator());
    document.getElementById('code-add-btn').addEventListener('click', () => this.saveCodeFromEditor());
    document.getElementById('code-download-btn').addEventListener('click', () => this.downloadCodeFromEditor());
    document.getElementById('code-editor-exit-btn').addEventListener('click', () => this.hideCodeEditor());
    document.getElementById('code-entry-list').addEventListener('click', e => this.handleCodeListClick(e));
    
    
    document.getElementById('annotation-exit-btn').addEventListener('click', () => this.exitAnnotationMode());
    document.getElementById('annotation-pen-btn').addEventListener('click', () => this.setAnnotationMode('pen'));
    document.getElementById('annotation-text-btn').addEventListener('click', () => this.setAnnotationMode('text'));
    document.getElementById('annotation-image-btn').addEventListener('click', () => this.setAnnotationMode('image'));
document.getElementById('annotation-pdf-btn').addEventListener('click', () => this.setAnnotationMode('pdf'));
 document.getElementById('annotation-audio-btn').addEventListener('click', () => this.setAnnotationMode('audio'));
    document.getElementById('annotation-eraser-btn').addEventListener('click', () => this.setAnnotationMode('eraser'));
    
    const stopTraceBtn = document.getElementById('stop-trace-btn');
    const handleStopTrace = (e) => {
        if (e.type === 'touchstart') e.preventDefault();
        this.stopTracing();
    };
    stopTraceBtn.addEventListener('click', handleStopTrace);
    stopTraceBtn.addEventListener('touchstart', handleStopTrace, { passive: false });

    this.canvas.addEventListener('mousemove', (e) => {
        if (this.currentUIMode === 'annotation' && this.annotationState.mode === 'eraser') {
            const coords = this.getEventCoordinates(e);
            this.requestDraw();
        }
    });


    document.addEventListener('keydown', (e) => {
        if (e.key === 'Backspace' && this.selectedAnnotationIndex !== -1) {
            e.preventDefault();
            this.annotations.splice(this.selectedAnnotationIndex, 1);
            this.selectedAnnotationIndex = -1;
            this.requestDraw();
        }
    });
    
    
    
    this.geometryPanel.addEventListener('click', e => {
        const button = e.target.closest('.geo-btn');
        if (button) this.handleGeometryButtonClick(button.dataset.geoType);
    });




    const settingsPanel = document.getElementById('settings-panel');
    if (settingsPanel) {
        settingsPanel.addEventListener('click', e => {
            const navBtn = e.target.closest('.settings-nav-btn');
            if (navBtn && navBtn.parentElement.classList.contains('settings-nav-buttons')) {
                const panelId = navBtn.dataset.panel;
                if (!panelId) return;

                settingsPanel.querySelectorAll('.settings-nav-btn').forEach(btn => btn.classList.remove('active'));
                settingsPanel.querySelectorAll('.settings-panel-content').forEach(panel => panel.classList.remove('active'));
                
                navBtn.classList.add('active');
                const contentPanel = document.getElementById(`settings-panel-${panelId}`);
                if (contentPanel) {
                    contentPanel.classList.add('active');
                }
            }
        });
    }
}



    _parseOrEvaluateInput(inputString) {
        if (inputString === null) return null;
        const trimmedInput = inputString.trim();
        if (trimmedInput === "") return null;

        if (this.calcJSUtils.isNumericString(trimmedInput)) {
            return parseFloat(trimmedInput);
        } else {
            try {
                const result = this.evaluateExpressionWithCalcJS(trimmedInput, {});
                if (Number.isFinite(result)) {
                    return result;
                } else {
                    alert(`表达式 "${trimmedInput}" 的计算结果无效 (NaN or Infinity)。`);
                    return null;
                }
            } catch (e) {
                alert(`计算表达式 "${trimmedInput}" 时出错: ${e.message}`);
                return null;
            }
        }
    }

_rebindAnnotationControlsToGlobalState() {
    const rebindColorSlider = (slider, prop) => {
        if (!slider) return;
        slider.options.context = this.annotationState.pen.color;
        slider.setValue(this.annotationState.pen.color[prop]);
        slider.options.onInput = (e) => {
            this.annotationState.pen.color[prop] = e.target.options.value;
            Object.values(this.penColorSliders).forEach(s => {
                s.options.context = this.annotationState.pen.color;
                s.draw();
            });
        };
        slider.draw();
    };

    if (this.penColorSliders.h) rebindColorSlider(this.penColorSliders.h, 'h');
    if (this.penColorSliders.s) rebindColorSlider(this.penColorSliders.s, 's');
    if (this.penColorSliders.b) rebindColorSlider(this.penColorSliders.b, 'b');
    if (this.penColorSliders.a) rebindColorSlider(this.penColorSliders.a, 'a');

    if (this.penThicknessSlider) {
        this.penThicknessSlider.setValue(this.annotationState.pen.thickness);
        this.penThicknessSlider.options.onInput = (e) => {
            this.annotationState.pen.thickness = e.target.options.value;
            this.requestDraw();
        };
        this.penThicknessSlider.draw();
    }

    if (this.penFontSizeSlider) {
        this.penFontSizeSlider.setValue(this.annotationState.pen.fontSize);
        this.penFontSizeSlider.options.onInput = (e) => {
            this.annotationState.pen.fontSize = e.target.options.value;
        };
        this.penFontSizeSlider.draw();
    }

    const exitBtn = document.getElementById('annotation-exit-btn');
    if (exitBtn) {
        exitBtn.onclick = () => {
            if (this.currentUIMode === 'annotation') {
                this.exitAnnotationMode();
            } else {
                this.selectedAnnotationIndex = -1;
                // 退出编辑模式时，恢复到批注模式的UI状态（可能会折叠）
                if (this.annotationColorBtn) {
                    this.annotationColorBtn.style.display = 'flex';
                }
                this.updateAnnotationEditMenu();
                this.requestDraw();
            }
        };
    }
}
 
    updateSidebarCursor(clientX, clientY) {
        const rect = this.sidebar.getBoundingClientRect();
        let onResizeHandle = false;

        if (this.isPortraitMode) {
             onResizeHandle = clientY <= rect.top + this.resizeHandleWidth && clientY >= rect.top - 3;
        } else {
             onResizeHandle = clientX >= rect.right - this.resizeHandleWidth && clientX <= rect.right + 3;
        }


         if (onResizeHandle) {
             this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
         } else {
              const isOverSidebar = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
              if (isOverSidebar) {
                   this.sidebar.style.cursor = 'default';
              } else {
                    this.sidebar.style.cursor = 'default';
              }
         }
    }


    getEventCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
        } else {
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
    }

    getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    autonameText() {
        let i = 1;
        while (true) {
            const textName = 'text' + i;
            const isNameTaken = this.entries.some(entry =>
                entry.type === 'text' && entry.name === textName
            );

            if (!isNameTaken) {
                return textName;
            }
            i++;
            if (i > 10000) {
                return 'text_error_' + Date.now();
            }
        }
    }
    getPinchCenter(touches) {
        const rect = this.canvas.getBoundingClientRect();
        const x1 = touches[0].clientX - rect.left;
        const y1 = touches[0].clientY - rect.top;
        const x2 = touches[1].clientX - rect.left;
        const y2 = touches[1].clientY - rect.top;
        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
    }

startPerformanceZoom() {
        if (!this.isZooming) {
            this.originalExplicitPrecision = this.explicitPrecisionStep;
            this.originalImplicitPrecision = this.implicitPrecisionStep;
        }
        this.isZooming = true;

        this.explicitPrecisionStep = 0.5;
        this.implicitPrecisionStep = (this.originalImplicitPrecision < 4) ? 7 : 10;


        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep);
        this.updatePrecisionLabels();
    }
restoreOriginalPrecisions() {
        this.explicitPrecisionStep = this.originalExplicitPrecision;
        this.implicitPrecisionStep = this.originalImplicitPrecision;


        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep);
        this.updatePrecisionLabels();
    }

       handleZoomEnd() {
        if (this.isZooming) {
            this.isTransformingCache = false;
            
            this.clearPlotData();
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);

            this.restoreOriginalPrecisions();
            this.isZooming = false;
            this.isUsingLowPrecisionBuffer = false;
            this.entries.forEach(entry => {
                if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                    entry.webglVertices = null;
                }
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            });
            this.clearPlotData();
            this.recalculateAll();
        }
    }
 handleInteractionStart(e) {
        // 1. 3D 模式优先处理
        if (this.is3DMode) {
            this.stopAllAudio();
            if (e.target !== this.canvas && !e.target.closest('#canvas-container')) return;
            if (e.cancelable) e.preventDefault();

            const coords = this.getEventCoordinates(e);
            this.lastMouse3D = coords;

            if (e.touches && e.touches.length === 2) {
                this.isDragging3D = true;
                this.dragMode3D = 'pinch';
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                this.pinchStartDist3D = Math.sqrt(dx * dx + dy * dy);
                this.pinchStartScale3D = this.scale3D;
                return;
            }

            this.isDragging3D = true;

            const hit = this.getRayPlaneIntersection(coords.x, coords.y);
            const b = this.bounds3D;

            if (hit && Math.abs(hit.x) <= b && Math.abs(hit.y) <= b) {
                this.dragMode3D = 'pan';
                this.panStartHit3D = hit;
                this.panStartOffset3D = { ...this.offset3D };
                this.canvas.style.cursor = 'move';
            } else {
                this.dragMode3D = 'rotate';
                this.canvas.style.cursor = 'grabbing';
            }
            return;
        }

        // 2. 复选框交互 (最高优先级：必须在任何其他 2D 交互之前)
        // 这样可以确保开关点击不会被底层的画布拖动或通用批注选中逻辑覆盖
        const coords = this.getEventCoordinates(e);
        
        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const anno = this.annotations[i];
            if (anno.type === 'checkbox') {
                const screenX = this.offset.x + anno.x * this.scale;
                const screenY = this.offset.y - anno.y * this.scale;
                // 使用固定像素尺寸进行判定，与绘制逻辑一致
                const width = 160; 
                const height = 40;

                // 简单的 AABB 碰撞检测
                if (coords.x >= screenX && coords.x <= screenX + width &&
                    coords.y >= screenY && coords.y <= screenY + height) {
                    
                    // 定义右侧开关区域的宽度 (大约 60px)
                    const switchClickAreaWidth = 60;
                    const switchInteractionX = screenX + width - switchClickAreaWidth;

                    if (coords.x >= switchInteractionX) {
 

                        anno.checked = !anno.checked;
                        this.requestDraw(); // 重绘以更新视觉和受控对象的可见性
                        if (e.cancelable) e.preventDefault();
                        return; // 立即返回，阻止所有后续逻辑
                    } else {
                        // --- 情况 B: 点击了左侧标题区域 ---
                        if (this.isAnnotationEditingEnabled) {
                            // 如果开启了编辑模式 -> 触发移动
                            this.selectedAnnotationIndex = i;
                            this.annotationInteraction = {
                                type: 'move',
                                startX: coords.x,
                                startY: coords.y,
                                original: { x: anno.x, y: anno.y }
                            };
                            this.updateAnnotationEditMenu();
                            this.requestDraw();
                            if (e.cancelable) e.preventDefault();
                            return; // 阻止后续逻辑
                        } else {
                            // 如果未开启编辑模式 -> 吞掉事件，防止拖动画布
                            if (e.cancelable) e.preventDefault();
                            return; 
                        }
                    }
                }
            }
        }

        // 3. 批注绘制模式处理 (画笔/文字/橡皮等)
        if (this.currentUIMode === 'annotation') {
            this.handleAnnotationInteractionStart(e);
            return;
        }

        if (this.currentUIMode === 'geometry' || this.currentUIMode === 'plot') {
            const clickCoords = this.getEventCoordinates(e);
            
            // 变量卡片交互
            const clickX = clickCoords.x;
            const clickY = clickCoords.y;
            for (let i = this.entries.length - 1; i >= 0; i--) {
                const entry = this.entries[i];
                if (entry.type === 'variable' && entry.isEditableIndependent && entry.showOnPlot) {
                    const x = this.offset.x + entry.cardX * this.scale;
                    const y = this.offset.y - entry.cardY * this.scale;
                    const w = entry.cardW;
                    const h = entry.cardH;

                    if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
                        const btnX = x + w - 15 - 16;
                        const btnY = y + 15 + 16; 
                        if (Math.hypot(clickX - btnX, clickY - btnY) <= 20) {
                            this.variableCardInteraction = { active: true, entryIndex: i, type: 'play' };
                            entry.playState = entry.playState === 1 ? 0 : 1;
                            if (entry.playState === 1) this.recalculateAll();
                            this.updateGlobalPlayState();
                            this.updateEntryList();
                            this.requestDraw();
                            if (e.cancelable) e.preventDefault();
                            return;
                        }

                        const sliderY = y + 65; 
                        const sliderH = 20; 
                        if (clickY >= sliderY - 10 && clickY <= sliderY + sliderH + 10 && clickX >= x + 15 && clickX <= x + w - 15) {
                            this.variableCardInteraction = { active: true, entryIndex: i, type: 'slider', offset: { x: clickX - x }, startVal: entry.value };
                            this.handleInteractionMove(e);
                            if (e.cancelable) e.preventDefault();
                            return;
                        }

                        this.variableCardInteraction = { active: true, entryIndex: i, type: 'move', offset: { x: clickX - x, y: clickY - y } };
                        if (e.cancelable) e.preventDefault();
                        return;
                    }
                }
            }
            
            // 批注编辑模式下的常规对象选择
            if (this.isAnnotationEditingEnabled) {
                const coordsForSelection = this.getEventCoordinates(e);

                // 处理 PDF/Audio 的特定按钮点击
                if (this.selectedAnnotationIndex !== -1) {
                    const anno = this.annotations[this.selectedAnnotationIndex];
                    if (anno.type !== 'checkbox') { // 跳过 checkbox，上面已处理
                        const screenX = this.offset.x + anno.x * this.scale;
                        const screenY = this.offset.y - anno.y * this.scale;
                        const width = anno.width * anno.scaleX * this.scale;
                        const height = anno.height * anno.scaleY * this.scale;
                        const topY = (anno.type === 'pen' || anno.type === 'text') ? screenY - height : screenY;
                        const bottomY = topY + height;

                        if (anno.type === 'pdf') {
                            const btnSize = 36;
                            const prevX = screenX + width / 2 - 40;
                            const nextX = screenX + width / 2 + 10;
                            const btnY = bottomY + 25; 
                            
                            const distPrev = Math.hypot(coordsForSelection.x - (prevX + btnSize/2), coordsForSelection.y - btnY);
                            const distNext = Math.hypot(coordsForSelection.x - (nextX + btnSize/2), coordsForSelection.y - btnY);
                            const radius = btnSize / 2 + 5; 

                            if (distPrev <= radius) {
                                if (anno.page > 1) {
                                    anno.page--;
                                    this.renderPdfPage(anno);
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                            if (distNext <= radius) {
                                if (anno.page < anno.totalPages) {
                                    anno.page++;
                                    this.renderPdfPage(anno);
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                        } else if (anno.type === 'audio') {
                            const controlsY = bottomY + 20; 
                            const playSize = 24;
                            const playX = screenX + playSize/2;
                            const playRadius = 12 + 5; 

                            if (Math.hypot(coordsForSelection.x - playX, coordsForSelection.y - controlsY) <= playRadius) {
                                if (anno.audioElem.paused) {
                                    anno.audioElem.play();
                                    anno.isPlaying = true;
                                } else {
                                    anno.audioElem.pause();
                                    anno.isPlaying = false;
                                }
                                this.requestDraw();
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                            
                            const barX = playX + 20;
                            const barY = controlsY - 4;
                            const barW = Math.max(120, width - 30);
                            const barH = 8;
                            const barHitPadding = 10;
                            
                            if (coordsForSelection.x >= barX - barHitPadding && 
                                coordsForSelection.x <= barX + barW + barHitPadding &&
                                coordsForSelection.y >= barY - barHitPadding && 
                                coordsForSelection.y <= barY + barH + barHitPadding) {
                                
                                const ratio = Math.max(0, Math.min(1, (coordsForSelection.x - barX) / barW));
                                if (anno.audioElem.duration) {
                                    anno.audioElem.currentTime = ratio * anno.audioElem.duration;
                                    this.requestDraw();
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                        }
                    }
                }

                // 查找其他类型的批注
                const hitResult = this.findAnnotationAt(coordsForSelection);
                if (hitResult.index !== -1) {
                    // 如果点到了非 checkbox 的其他批注
                    const selectedAnno = this.annotations[hitResult.index];
                    if (selectedAnno.type !== 'checkbox') {
                         this.selectedAnnotationIndex = hitResult.index;
                        if (selectedAnno.type === 'text' || selectedAnno.type === 'pen') {
                            this.isAnnotationMenuExpanded = false;
                        } else {
                            this.isAnnotationMenuExpanded = true;
                        }

                        this.annotationInteraction.type = hitResult.handle || 'move';
                        this.annotationInteraction.startX = coordsForSelection.x;
                        this.annotationInteraction.startY = coordsForSelection.y;
                        
                        this.annotationInteraction.original = {
                            x: selectedAnno.x,
                            y: selectedAnno.y,
                            width: selectedAnno.width,
                            height: selectedAnno.height,
                            scaleX: selectedAnno.scaleX || 1,
                            scaleY: selectedAnno.scaleY || 1
                        };
                        
                        this.requestDraw();
                        if (e.cancelable) e.preventDefault();
                        this.updateAnnotationEditMenu();
                        return;
                    }
                } else if (this.selectedAnnotationIndex !== -1) {
                    // 点击空白处取消选中
                    this.selectedAnnotationIndex = -1;
                    this._rebindAnnotationControlsToGlobalState();
                    this.requestDraw();
                    this.updateAnnotationEditMenu();
                }
            }
        }

        // 5. 阻止事件冒泡到 UI 元素
        if (e.target.closest('#annotation-edit-toggle-container') || e.target.closest('#main-menu') || e.target.closest('#main-button-container') || e.target.closest('#keyboard') || e.target.closest('#keyboard-toggle-container') || this.isResizingSidebar || this.isResizingSidebarTouch || (e.target !== this.canvas && !e.target.closest('#canvas-container') && !e.target.closest('#fps-display'))) {
            return;
        }

        // 6. 几何交互 (点击创建点等)
        if (this.geometryInteractionState.active) {
            if (e.target === this.canvas) {
                if (e.type === 'mousedown') {
                    this.handleGeometryClick(e);
                } else if (e.type === 'touchstart') {
                    this.touchMoved = false;
                    this.touchStartPos = this.getEventCoordinates(e);
                    if (e.cancelable) e.preventDefault();
                }
            }
            return;
        }

        // 7. 几何点拖动逻辑
        const eventType = e.type;

        const hitRadius = (eventType === 'touchstart') ? this.dragHitboxRadiusTouch : this.dragHitboxRadiusMouse;

        for (let i = this.entries.length - 1; i >= 0; i--) {
            const entry = this.entries[i];
            if (entry.type === 'geometry' && entry.geometryType === 'point' && entry.isMeaningful && entry.visible) {
                const isDraggable = (entry.pointOnObject) ||
                    (entry.x_expr && this.calcJSUtils.isNumericString(entry.x_expr) &&
                        entry.y_expr && this.calcJSUtils.isNumericString(entry.y_expr));

                if (isDraggable) {
                    const pointScreenX = this.offset.x + entry.x_val * this.scale;
                    const pointScreenY = this.offset.y - entry.y_val * this.scale;
                    const dist = Math.sqrt((coords.x - pointScreenX) ** 2 + (coords.y - pointScreenY) ** 2);
                    if (dist <= hitRadius) {
                        this.selectedPointIndex = i;
                        this.draggingPoint = true;
                        this.canvas.style.cursor = 'move';
                        entry.isSelected = true;
                        this.requestDraw();
                        if (e.cancelable) e.preventDefault();
                        if (eventType === 'touchstart') {
                            this.touchMoved = false;
                            this.touchStartPos = this.getEventCoordinates(e);
                        }
                        return;
                    }
                }
            }
        }

        // 8. 平移和缩放逻辑
        clearTimeout(this.zoomEndTimeout);

        if (this.isSmoothPanningActive) {
            this.isSmoothPanningActive = false;
        }

        if (eventType === 'touchstart') {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length === 1 && !this.touchState.pinching) {
                this.interactionWasPinch = false;
                this.isPanning = true;
                this.touchState.panning = true;
                this.touchState.lastPanPos = this.getEventCoordinates(e);
                this.canvas.style.cursor = 'grabbing';
                this.panEventHistory = [];
                this.panEventHistory.push({ x: this.touchState.lastPanPos.x, y: this.touchState.lastPanPos.y, time: performance.now() });
                this.lastPanEventTime = performance.now();
                this.startPanOptimization();
            } else if (e.touches.length === 2) {
                this.interactionWasPinch = true;
                this.isPanning = false;
                this.touchState.panning = false;
                this.touchState.pinching = true;
                this.zoomEventHistory = [];
                if (this.performanceModeEnabled) {
                    this.captureCanvasStateForTransform();
                    this.startPerformanceZoom();
                } else {
                    this.entries.forEach(entry => {
                        if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    });
                    this.clearPlotData();
                }
                this.touchState.initialPinchDist = this.getPinchDistance(e.touches);
                this.touchState.initialPinch.center = this.getPinchCenter(e.touches);
                this.touchState.initialPinch.scale = this.scale;
                this.touchState.initialPinch.offset = { ...this.offset };
                this.canvas.style.cursor = 'move';
            }
        } else if (eventType === 'mousedown') {
            if (e.button !== 0) return;
            if (e.target !== this.canvas) return;
            this.interactionWasPinch = false;
            this.mouseMoved = false;
            this.isPanning = true;
            this.dragging = true;
            this.lastPos = this.getEventCoordinates(e);
            this.canvas.style.cursor = 'grabbing';
            this.panEventHistory = [];
            this.panEventHistory.push({ x: this.lastPos.x, y: this.lastPos.y, time: performance.now() });
            this.lastPanEventTime = performance.now();
            this.startPanOptimization();
        }
    } 
    handleInteractionMove(e) {
        if (this.is3DMode) {
            if (this.isDragging3D) {
                if(e.cancelable) e.preventDefault();
                
                if (this.dragMode3D === 'pinch' && e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (this.pinchStartDist3D > 0) {
                        const scaleFactor = dist / this.pinchStartDist3D;
                
                        this.scale3D = this.pinchStartScale3D / scaleFactor;
                        
                        if (this.scale3D < 0.01) this.scale3D = 0.01;
                        if (this.scale3D > 100.0) this.scale3D = 100.0;
                        this.recalculate3D();
                        this.requestDraw();
                    }
                    return;
                }

                const coords = this.getEventCoordinates(e);
                const dx = coords.x - this.lastMouse3D.x;
                const dy = coords.y - this.lastMouse3D.y;
                this.lastMouse3D = coords;

                if (this.dragMode3D === 'rotate') {
                    this.camera3D.theta -= dx * 0.01;
                    this.camera3D.phi -= dy * 0.01;

                    if (this.camera3D.phi < 0.1) this.camera3D.phi = 0.1;
                    if (this.camera3D.phi > Math.PI - 0.1) this.camera3D.phi = Math.PI - 0.1;
                    this.requestDraw(); 
                } else if (this.dragMode3D === 'pan') {
                    const currentHit = this.getRayPlaneIntersection(coords.x, coords.y);
                    if (currentHit && this.panStartHit3D) {
                        
                        const deltaX = currentHit.x - this.panStartHit3D.x;
                        const deltaY = currentHit.y - this.panStartHit3D.y;
                        
                        this.offset3D.x -= deltaX;
                        this.offset3D.y -= deltaY;
                        
                        this.recalculate3D(); 

                        const newHit = this.getRayPlaneIntersection(coords.x, coords.y);
                        if (newHit) this.panStartHit3D = newHit;
                    }
                    this.requestDraw();
                }
            }
            return;
        }

        if (this.currentUIMode === 'annotation') {
            this.handleAnnotationInteractionMove(e);
            return;
        }

        if (this.annotationInteraction.type) {
            this.handleAnnotationResizeOrMove(e);
            return;
        }
        if (this.variableCardInteraction.active) {
    if (e.cancelable) e.preventDefault();
    const coords = this.getEventCoordinates(e);
    const entry = this.entries[this.variableCardInteraction.entryIndex];

if (this.variableCardInteraction.type === 'move') {
                // 计算新的屏幕坐标
                const newScreenX = coords.x - this.variableCardInteraction.offset.x;
                const newScreenY = coords.y - this.variableCardInteraction.offset.y;
                
                // 将屏幕坐标反算回数学坐标并存储
                entry.cardX = (newScreenX - this.offset.x) / this.scale;
                entry.cardY = (this.offset.y - newScreenY) / this.scale;
     } else if (this.variableCardInteraction.type === 'slider') {
                // 计算当前卡片的屏幕X坐标
                const currentScreenCardX = this.offset.x + entry.cardX * this.scale;
                
                const sliderMargin = 15;
                const sliderW = entry.cardW - sliderMargin * 2;
                // 使用计算出的屏幕坐标
                const relX = Math.max(0, Math.min(1, (coords.x - currentScreenCardX - sliderMargin) / sliderW));

        const min = Number.isFinite(entry.min) ? entry.min : 0;
        const max = Number.isFinite(entry.max) ? entry.max : 10;
        const step = Number.isFinite(entry.step) && entry.step > 0 ? entry.step : 0.01;
        let val = min + relX * (max - min);
        val = Math.round(val / step) * step;
        entry.value = val;
        entry.playDirection = 1;
        this.recalculateForAnimation();
        this.updateEntryVariableValuesDisplay();
    }
    this.requestDraw();
    return;
}
        const eventType = e.type;

         if (eventType === 'mousemove' && this.isResizingSidebar) {
              this.doSidebarResize(e);
              return;
         }
         if (eventType === 'touchmove' && this.isResizingSidebarTouch) {
              this.doSidebarResizeTouch(e);
              return;
         }
         if (eventType === 'touchmove' && (this.geometryInteractionState.active || this.draggingPoint)) {
            if (!this.touchMoved) { 
                const currentPos = this.getEventCoordinates(e);
                const dx = currentPos.x - this.touchStartPos.x;
                const dy = currentPos.y - this.touchStartPos.y;
             
                if (Math.hypot(dx, dy) > 10) {
                    this.touchMoved = true;
                }
            }
        }
 
        if (eventType === 'touchmove' && this.draggingPoint && this.touchMoved) {
            this.dragSelectedPoint(e);
            return;
        }

        if (this.draggingPoint) {
            this.dragSelectedPoint(e);
            return;
        }

        if (eventType === 'touchmove' && (this.touchState.panning || this.touchState.pinching)) {
            if(e.cancelable) e.preventDefault();

            if (this.touchState.pinching && e.touches.length === 2) {
                 clearTimeout(this.zoomEndTimeout);

                if (!this.isZooming) {
                    this.isZooming = true;
                    if (this.performanceModeEnabled) {
                        this.captureCanvasStateForTransform();
                        this.startPerformanceZoom();
                    } else if (this.lowPrecisionBufferEnabled) {
                        if (!this.isUsingLowPrecisionBuffer) {
                            this.originalExplicitPrecision = this.explicitPrecisionStep;
                            this.originalImplicitPrecision = this.implicitPrecisionStep;
                            this.isUsingLowPrecisionBuffer = true;
                        }
                        this.explicitPrecisionStep = 1;
                        this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
                        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
                        this.implicitPrecisionSlider.setValue(this.implicitPrecisionStep);
                        this.updatePrecisionLabels();
                    }
                }
                
                if (!this.performanceModeEnabled) {
                    this.clearPlotData();
                    this.entries.forEach(entry => {
                        if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                            entry.webglVertices = null;
                            if (entry.plotType === 'parametric') entry.cachedPoints = [];
                        }
                    });
                }

                this.zoomEndTimeout = setTimeout(() => this.handleZoomEnd(), 300);
                
                const currentDist = this.getPinchDistance(e.touches);
                const currentCenter = this.getPinchCenter(e.touches);

                if (this.touchState.initialPinchDist <= 0) return;

                const zoomFactor = currentDist / this.touchState.initialPinchDist;
                this.zoomEventHistory.push({ factor: zoomFactor, time: performance.now() });
                if (this.zoomEventHistory.length > 10) this.zoomEventHistory.shift();

                const initialScale = this.touchState.initialPinch.scale;
                let newScale = initialScale * zoomFactor;
                newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));

                const initialOffset = this.touchState.initialPinch.offset;
                const initialCenterMathX = (this.touchState.initialPinch.center.x - initialOffset.x) / initialScale;
                const initialCenterMathY = (initialOffset.y - this.touchState.initialPinch.center.y) / initialScale;

                this.offset.x = currentCenter.x - initialCenterMathX * newScale;
                this.offset.y = currentCenter.y + initialCenterMathY * newScale;

                this.scale = newScale;
                this.requestDraw();

            } else if (this.touchState.panning && e.touches.length === 1) {
                const currentPos = this.getEventCoordinates(e);
                this.offset.x += currentPos.x - this.touchState.lastPanPos.x;
                this.offset.y += currentPos.y - this.touchState.lastPanPos.y;
                this.touchState.lastPanPos = currentPos;
                const currentTime = performance.now();
                this.panEventHistory.push({ x: currentPos.x, y: currentPos.y, time: currentTime });
                if (this.panEventHistory.length > 10) this.panEventHistory.shift();
                this.lastPanEventTime = currentTime;

                this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') {
                            entry.cachedPoints = [];
                        }
                    }
                });
                this.requestDraw();
            }
        }
        else if (eventType === 'mousemove') {
            if (this.dragging) {
                const currentPos = this.getEventCoordinates(e);
                if (!this.mouseMoved) {
                    const dx = currentPos.x - this.lastPos.x;
                    const dy = currentPos.y - this.lastPos.y;
                    if (Math.hypot(dx, dy) > 5) {
                        this.mouseMoved = true;
                    }
                }
                this.offset.x += currentPos.x - this.lastPos.x;
                this.offset.y += currentPos.y - this.lastPos.y;
                this.lastPos = currentPos;

                const currentTime = performance.now();
                this.panEventHistory.push({ x: currentPos.x, y: currentPos.y, time: currentTime });
                if (this.panEventHistory.length > 10) this.panEventHistory.shift();
                this.lastPanEventTime = currentTime;

                this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') {
                            entry.cachedPoints = [];
                        }
                    }
                });
                this.requestDraw();
            } else {
                this.updateSidebarCursor(e.clientX, e.clientY);
            }
        }
    }

 

handleInteractionEnd(e) {
    if (this.is3DMode) {
        this.isDragging3D = false;
        this.dragMode3D = 'none';
        return;
    }

    if (this.currentUIMode === 'annotation') {
        this.handleAnnotationInteractionEnd(e);
        return;
    }

    if (this.annotationInteraction.type) {
        this.annotationInteraction.type = null;
        return;
    }
    if (this.variableCardInteraction.active) {
    if (this.variableCardInteraction.type === 'slider') {
         this.recalculateAll();
    }
    this.variableCardInteraction = { active: false, entryIndex: -1, type: null, offset: { x: 0, y: 0 } };
    return;
}
    if (e.type === 'touchend' && this.geometryInteractionState.active && !this.touchMoved) {
        this.handleGeometryClick(e);
    }

    if (this.draggingPoint) {
        if (e.type === 'mouseup' || (e.type === 'touchend' && this.touchMoved)) {
            const pointEntry = this.entries[this.selectedPointIndex];
            if (pointEntry) {
                pointEntry.isSelected = false;
            }
            this.draggingPoint = false;
            this.selectedPointIndex = -1;
            this.canvas.style.cursor = 'grab';
            this.hideInfoMessage();
            this.snapTargetObject = null;
            this.recalculateAll();
        }
        this.dragging = false;
        this.isPanning = false;
        this.touchState.panning = false;
        this.touchMoved = false;
        this.interactionWasPinch = false;
        return;
    }

    const eventType = e.type;
    let wasPanning = this.isPanning;
    let wasPinching = this.touchState.pinching;

    if (eventType === 'touchend' || eventType === 'touchcancel') {
        const endedPinch = this.touchState.pinching && e.touches.length < 2;

if (endedPinch) {
            clearTimeout(this.zoomEndTimeout);
            if (this.smoothPanningEnabled && this.performanceModeEnabled && this.globalPlayState === 0) {
                const history = this.zoomEventHistory;
                if (history.length >= 2) {
                    const last = history[history.length - 1];
                    let prev = history[history.length - 2];

                    const MAX_FLICK_DURATION_MS = 100;
                    for (let i = history.length - 2; i >= 0; i--) {
                        if (last.time - history[i].time > MAX_FLICK_DURATION_MS) break;
                        prev = history[i];
                    }

                    const dt = (last.time - prev.time) / 1000.0;
                    if (dt > 0.001) {
                        const dFactor = last.factor / prev.factor;
                        let velocityFactor = 1.0 + (dFactor - 1.0) * (16.67 / (last.time - prev.time));
                        velocityFactor = Math.max(0.7, Math.min(1.3, velocityFactor));

                        if (Math.abs(velocityFactor - 1) > 0.005) {
                            const lastCenter = e.touches.length > 0 ? this.getPinchCenter(e.touches) : this.touchState.initialPinch.center;
                            this.startSmoothZooming(velocityFactor, lastCenter, 'touch');
                        } else {
                            this.handleZoomEnd();
                        }
                    } else {
                         this.handleZoomEnd();
                    }
                } else {
                    this.handleZoomEnd();
                }
                 this.zoomEventHistory = [];
            } else {
                this.handleZoomEnd();
            }
        }

        if (e.touches.length === 0) {
            const wasActuallyPanning = this.touchState.panning;
            const isTouchTap = !this.touchMoved;

            if (isTouchTap && !this.draggingPoint && !this.geometryInteractionState.active) {
                const coords = this.getEventCoordinates(e);
                const clickedObject = this.findObjectNearClick(coords);
                if (this.geometrySnapEnabled && clickedObject) {
                    clearTimeout(this.highlightTimeout);
                    if (this.highlightedObject !== clickedObject) {
                        this.highlightedObject = clickedObject;
                        this.requestDraw();
                    }
                    this.highlightTimeout = setTimeout(() => {
                        if (this.highlightedObject === clickedObject) {
                            this.highlightedObject = null;
                            this.requestDraw();
                        }
                    }, 2000);
                }
                if (clickedObject) {
                    this.showInfoMessage(`点按：${clickedObject.name}`, 2000);
                }
            }

            this.isPanning = false;
            this.touchState.panning = false;
            this.touchState.pinching = false;

            const rect = this.canvas.getBoundingClientRect();
            const lastTouch = e.changedTouches[0];
            if (lastTouch && lastTouch.clientX >= rect.left && lastTouch.clientX <= rect.right &&
                lastTouch.clientY >= rect.top && lastTouch.clientY <= rect.bottom) {
                this.canvas.style.cursor = 'grab';
            } else {
                this.canvas.style.cursor = 'default';
            }
            this.stopSidebarResizeTouch();

            if (wasActuallyPanning) {
                if (this.smoothPanningEnabled && this.globalPlayState === 0 && !this.interactionWasPinch) {
                    this.startSmoothPanning();
                } else {
                    this.finalizePanInteraction();
                }
            } else if (wasPinching && !this.isZooming && !this.isSmoothZoomingActive) {
                this.clearPlotData();
                 this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    }
                });
                this.recalculateAll();
            } else if (!wasActuallyPanning && !wasPinching && isKeyboardOpen && lastTouch) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const isTapOnCanvas = lastTouch.clientX >= canvasRect.left && lastTouch.clientX <= canvasRect.right &&
                    lastTouch.clientY >= canvasRect.top && lastTouch.clientY <= canvasRect.bottom;
                const mainMenuElement = document.getElementById('main-menu');
                if (isTapOnCanvas && (!mainMenuElement || !mainMenuElement.classList.contains('open'))) {
                    closeKeyboard(false);
                }
            } else {
                 if (!this.isZooming && !this.isSmoothZoomingActive) this.requestDraw();
            }

            this.interactionWasPinch = false;

        } else if (e.touches.length === 1 && wasPinching) {
            this.isPanning = true;
            this.touchState.pinching = false;
            this.touchState.panning = true;
            this.touchState.lastPanPos = this.getEventCoordinates({
                touches: e.touches
            });
            this.panEventHistory = [];
            this.panEventHistory.push({
                x: this.touchState.lastPanPos.x,
                y: this.touchState.lastPanPos.y,
                time: performance.now()
            });
            this.lastPanEventTime = performance.now();
        }
    } else if (eventType === 'mouseup') {
        const isMouseTap = !this.mouseMoved;
        if (isMouseTap && !this.draggingPoint && !this.geometryInteractionState.active) {
            const coords = this.getEventCoordinates(e);
            const clickedObject = this.findObjectNearClick(coords);
            if (this.geometrySnapEnabled && clickedObject) {
                clearTimeout(this.highlightTimeout);
                if (this.highlightedObject !== clickedObject) {
                    this.highlightedObject = clickedObject;
                    this.requestDraw();
                }
                this.highlightTimeout = setTimeout(() => {
                    if (this.highlightedObject === clickedObject) {
                        this.highlightedObject = null;
                        this.requestDraw();
                    }
                }, 2000);
            }
            if (clickedObject) {
                this.showInfoMessage(`点按：${clickedObject.name}`, 2000);
            }
        }

        if (this.dragging) {
            this.isPanning = false;
            this.dragging = false;
            const rect = this.canvas.getBoundingClientRect();
            const isOverCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom;
            this.canvas.style.cursor = isOverCanvas ? 'grab' : 'default';

            if (this.isZooming) {
                clearTimeout(this.zoomEndTimeout);
                this.handleZoomEnd();
            } else if (this.smoothPanningEnabled && this.globalPlayState === 0) {
                this.startSmoothPanning();
            } else {
                this.finalizePanInteraction();
            }
        }
        this.interactionWasPinch = false;
        this.stopSidebarResize();
    }
}



  dragSelectedPoint(e) {
    if (this.selectedPointIndex === -1 || !this.draggingPoint) return;

    const entry = this.entries[this.selectedPointIndex];
    if (!entry || entry.type !== 'geometry' || entry.geometryType !== 'point') return;
    
    if (e.cancelable) e.preventDefault();
    
    const coords = this.getEventCoordinates(e);
    const mouseMathX = (coords.x - this.offset.x) / this.scale;
    const mouseMathY = (this.offset.y - coords.y) / this.scale;

const objectMap = new Map();
        this.entries.forEach(e => {
            if (e.name) objectMap.set(e.name.toLowerCase(), e);
        });

        if (entry.pointOnObject) {
            const onObject = objectMap.get(entry.onObjectName.toLowerCase());
            if (!onObject || !onObject.isMeaningful) return;

            let newParam = 0;
            const isLineLike = (t) => ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'].includes(t);

            if (isLineLike(onObject.geometryType)) {
                const { x_val: p1x, y_val: p1y } = onObject.p1;
            const dir_vec = onObject.dir_vec || onObject.dir;
            const {x: dx, y: dy} = dir_vec;
            const lenSq = dx * dx + dy * dy;
            if (lenSq > 1e-9) {
                newParam = ((mouseMathX - p1x) * dx + (mouseMathY - p1y) * dy) / lenSq;
            }
            
            if (onObject.geometryType === 'segment' || onObject.geometryType === 'vector') {
                newParam = Math.max(0, Math.min(1, newParam));
            } else if (onObject.geometryType === 'ray') {
                newParam = Math.max(0, newParam);
            }
        } else if (onObject.geometryType === 'circle') {
            const { x_val: cx, y_val: cy } = onObject.center;
            let angle = Math.atan2(mouseMathY - cy, mouseMathX - cx);
            if (angle < 0) angle += 2 * Math.PI;
            newParam = angle / (2 * Math.PI);
} else if (onObject.geometryType === 'ellipse' || onObject.geometryType === 'ellipse_ab') {
                 const { center, rotation, a, b } = onObject;
                 const relX = mouseMathX - center.x;
                 const relY = mouseMathY - center.y;
                 const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                 const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                 let angle = Math.atan2(localY / b, localX / a);
                 if (angle < 0) angle += 2 * Math.PI;
  newParam = angle / (2 * Math.PI);
        } else if (onObject.geometryType === 'hyperbola') {
            const { center, a, b, rotation, f1, f2 } = onObject;
            
            const d1 = Math.hypot(mouseMathX - f1.x_val, mouseMathY - f1.y_val);
            const d2 = Math.hypot(mouseMathX - f2.x_val, mouseMathY - f2.y_val);
            const branch_sign = Math.sign(d1 - d2) || 1;

            const relY = mouseMathY - center.y;
            const localY = (mouseMathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
            let t = Math.asinh(localY / b);
            
            const magic_offset = 100000;
            let param_to_store = t;
            if (branch_sign === -1) {
                param_to_store = t - magic_offset;
            }
            newParam = param_to_store;

        } else if (onObject.geometryType === 'parabola') {
            const { vertex, rotation } = onObject;
            const relX = mouseMathX - vertex.x;
            const relY = mouseMathY - vertex.y;
            const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
            const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
            newParam = localY;
        } else if (onObject.geometryType === 'circulararc') {
            if (!onObject.center || onObject.radius === undefined) return;
            const { center } = onObject;
            let angle = Math.atan2(mouseMathY - center.y_val, mouseMathX - center.x_val);
            let { startAngle, endAngle } = onObject;
            
            if (endAngle < startAngle) endAngle += 2 * Math.PI;
            

            let angleDiff = angle - startAngle;
            while (angleDiff < 0) angleDiff += 2 * Math.PI;
            while (angleDiff >= 2 * Math.PI) angleDiff -= 2 * Math.PI;
            
            const arcSpan = endAngle - startAngle;
            

            if (angleDiff <= arcSpan) {
                newParam = angleDiff / arcSpan;
            } else {

                const distToStart = angleDiff; 
                const distToEnd = (2 * Math.PI) - angleDiff + arcSpan;
                const distStart = Math.min(angleDiff, 2 * Math.PI - angleDiff);

                let diffToEnd = Math.abs(angleDiff - arcSpan);
                if (diffToEnd > Math.PI) diffToEnd = 2 * Math.PI - diffToEnd;
                
                newParam = (distStart < diffToEnd) ? 0 : 1;
            }
        }

        entry.parameter_expr = newParam.toPrecision(8);
        entry.expr = `point(${entry.name},${entry.onObjectName},${entry.parameter_expr})`;

          } else {
        let finalX = mouseMathX;
        let finalY = mouseMathY;
        
      if (this.geometrySnapEnabled) {
            this.snapTargetObject = null;
            const snapTolerancePixels = 12;
            let bestSnap = { dist: snapTolerancePixels, point: null };

            const gridStepInfo = this.calculateGridStep(this.canvas.clientWidth, this.canvas.clientHeight);
                if (gridStepInfo.unitStep > 0) {
                    const unitStep = gridStepInfo.unitStep;


                    const gridX = Math.round(mouseMathX / unitStep) * unitStep;
                    const distPixelX = Math.abs(mouseMathX - gridX) * this.scale;
                    
                    if (distPixelX < snapTolerancePixels) {
                        finalX = gridX;

                    }


                    const gridY = Math.round(mouseMathY / unitStep) * unitStep;
                    const distPixelY = Math.abs(mouseMathY - gridY) * this.scale;

                    if (distPixelY < snapTolerancePixels) {
                        finalY = gridY;
                    }

                    if (finalX !== mouseMathX || finalY !== mouseMathY) {
                         const distToSnap = Math.hypot((finalX - mouseMathX)*this.scale, (finalY - mouseMathY)*this.scale);
                         if (distToSnap < bestSnap.dist) {
                             bestSnap = { dist: distToSnap, point: { x: finalX, y: finalY }, object: { name: "网格" } };
                         }
                    }
                }
            
            // 批注吸附
            this.annotations.forEach(anno => {
                if (anno.type !== 'pen') return;
                const scaleX = anno.scaleX || 1;
                const scaleY = anno.scaleY || 1;
                
                for (let i = 0; i < anno.path.length - 1; i++) {
                    const p1Local = anno.path[i];
                    const p2Local = anno.path[i+1];
                    const p1 = { x: anno.x + p1Local.x * scaleX, y: anno.y + p1Local.y * scaleY };
                    const p2 = { x: anno.x + p2Local.x * scaleX, y: anno.y + p2Local.y * scaleY };
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const lenSq = dx*dx + dy*dy;
                    let t = 0;
                    if (lenSq > 1e-12) {
                        t = ((mouseMathX - p1.x) * dx + (mouseMathY - p1.y) * dy) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                    }
                    const closestX = p1.x + t * dx;
                    const closestY = p1.y + t * dy;
                    
                    const dist = Math.hypot(mouseMathX - closestX, mouseMathY - closestY) * this.scale;
                    if (dist < bestSnap.dist) {
                         bestSnap = { dist: dist, point: { x: closestX, y: closestY }, object: { name: "手绘笔迹" } };
                    }
                }
            });
            this.entries.forEach(entry => {
                if (entry.type !== 'point_list' || !entry.visible) return;
                
                for (const segment of entry.segments) {
                    for (let i = 0; i < segment.length - 1; i++) {
                        const idx1 = segment[i];
                        const idx2 = segment[i+1];
                        const p1Cache = entry.pointCache[idx1];
                        const p2Cache = entry.pointCache[idx2];
                        
                        if (Number.isFinite(p1Cache.valueX) && Number.isFinite(p1Cache.valueY) && 
                            Number.isFinite(p2Cache.valueX) && Number.isFinite(p2Cache.valueY)) {
                                
                            const p1 = { x: p1Cache.valueX, y: p1Cache.valueY };
                            const p2 = { x: p2Cache.valueX, y: p2Cache.valueY };
                            
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const lenSq = dx*dx + dy*dy;
                            let t = 0;
                            if (lenSq > 1e-12) {
                                t = ((mouseMathX - p1.x) * dx + (mouseMathY - p1.y) * dy) / lenSq;
                                t = Math.max(0, Math.min(1, t));
                            }
                            const closestX = p1.x + t * dx;
                            const closestY = p1.y + t * dy;
                            
                            const dist = Math.hypot(mouseMathX - closestX, mouseMathY - closestY) * this.scale;
                            if (dist < bestSnap.dist) {
                                bestSnap = { dist: dist, point: { x: closestX, y: closestY }, object: { name: entry.name || "点列" } };
                            }
                        }
                    }
                }
            });

this.entries.forEach(geo => {
                if (!geo.isMeaningful || !geo.visible || geo.type !== 'geometry' || geo === entry || (geo.dependencies && geo.dependencies.includes(entry.name.toLowerCase()))) return;
                let closestPointOnObject = null;
                const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                if (lineLike.includes(geo.geometryType) && geo.p1 && geo.dir) {
                    const { x_val: x1, y_val: y1 } = geo.p1;
                    const { x: dx, y: dy } = geo.dir;
                    let t = (mouseMathX - x1) * dx + (mouseMathY - y1) * dy;
                    if (geo.geometryType === 'segment' || geo.geometryType === 'vector') {
                        const len = Math.hypot(geo.p2.x_val - x1, geo.p2.y_val - y1);
                        t = Math.max(0, Math.min(len, t));
                    } else if (geo.geometryType === 'ray') {
                        t = Math.max(0, t);
                    }
                    closestPointOnObject = { x: x1 + t * dx, y: y1 + t * dy };
                } else if (geo.geometryType === 'circle' && geo.center && geo.radius) {
                    const distToCenter = Math.hypot(mouseMathX - geo.center.x_val, mouseMathY - geo.center.y_val);
                    if (distToCenter > 1e-9) {
                        const scaleFactor = geo.radius / distToCenter;
                        closestPointOnObject = { x: geo.center.x_val + (mouseMathX - geo.center.x_val) * scaleFactor, y: geo.center.y_val + (mouseMathY - geo.center.y_val) * scaleFactor };
                    }
                } else if (['ellipse', 'hyperbola', 'parabola'].includes(geo.geometryType)) {
                    const { center, a, b, rotation, vertex, p } = geo;
                    const c = center || vertex;
                    const r = rotation || 0;
                    if (c) {
                        const relX = mouseMathX - c.x;
                        const relY = mouseMathY - c.y;
                        const localX = relX * Math.cos(-r) - relY * Math.sin(-r);
                        const localY = relX * Math.sin(-r) + relY * Math.cos(-r);
                        let snapped_local_x, snapped_local_y;
                        if (geo.geometryType === 'ellipse' && a && b) {
                            let t = Math.atan2(localY / b, localX / a);
                            snapped_local_x = a * Math.cos(t);
                            snapped_local_y = b * Math.sin(t);
                        } else if (geo.geometryType === 'hyperbola' && a && b) {
                            let t = Math.asinh(localY / b);
                            snapped_local_x = (Math.sign(localX) || 1) * a * Math.cosh(t);
                            snapped_local_y = b * Math.sinh(t);
                        } else if (geo.geometryType === 'parabola' && p) {
                            snapped_local_x = localY * localY / (4 * p);
                            snapped_local_y = localY;
                        }
                        if (snapped_local_x !== undefined) {
                            closestPointOnObject = {
                                x: c.x + snapped_local_x * Math.cos(r) - snapped_local_y * Math.sin(r),
                                y: c.y + snapped_local_x * Math.sin(r) + snapped_local_y * Math.cos(r)
                            };
                        }
                    }
                }
                if (closestPointOnObject) {
                    const dist = Math.hypot(mouseMathX - closestPointOnObject.x, mouseMathY - closestPointOnObject.y) * this.scale;
                   if (dist < bestSnap.dist) {
bestSnap = { dist: dist, point: closestPointOnObject, object: geo };
}
                }
            });
            if (this.plottedFunctionPoints && this.plottedFunctionPoints.length > 0) {
                for (const p of this.plottedFunctionPoints) {
                    if (!p) continue;
                    const dist = Math.hypot(mouseMathX - p.x, mouseMathY - p.y) * this.scale;
                    if (dist < bestSnap.dist) {
bestSnap = { dist, point: { x: p.x, y: p.y }, object: null };
}
                }
            }
if (bestSnap.point) {
finalX = bestSnap.point.x;
finalY = bestSnap.point.y;
this.snapTargetObject = bestSnap.object;
}
if (this.snapTargetObject) {
this.showInfoMessage(`吸附：${this.snapTargetObject.name}`);
} else {
this.hideInfoMessage();
}
        } else {
            this.hideInfoMessage();
            this.snapTargetObject = null;
        }

        entry.x_val = finalX;
        entry.y_val = finalY;
        entry.x_expr = finalX.toPrecision(8);
        entry.y_expr = finalY.toPrecision(8);
        entry.expr = `point(${entry.name},${entry.x_expr},${entry.y_expr})`;
    }

    this.recalculateForGeometryDrag(entry);
}

    _isBreakPoint(y_next, y_curr, y_prev, y_prev2) {
        const scale = this.scale;
        let bpfactor = 0.25;
     
        const explicitPrecisionValue = this.explicitPrecisionSlider ? this.explicitPrecisionSlider.options.value : 2;
        const term1 = Math.abs(y_next - y_curr) > 500 / (scale * bpfactor * explicitPrecisionValue); 
        const term21 = Math.abs(y_next - y_curr) > 4 / (scale * bpfactor * explicitPrecisionValue);
        const term22 = Math.abs(y_curr - y_prev) < 0.005 / (scale * bpfactor * explicitPrecisionValue);
        const term2 = term21 && term22; 
        const term3 = Math.abs(y_curr - y_prev) > 500 / (scale * bpfactor * explicitPrecisionValue);
        
        return term1 || term2 || term3;
    }

          _isAdaptiveBreakPoint(points, i, dependentAxis = 'y') {
        if (i <= 1 || i >= points.length - 1) return false;

        const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
        const p_prev2 = points[i - 2];
        const p_prev = points[i - 1];
        const p_curr = points[i];
        const p_next = points[i + 1];

        if (!p_prev.valid || !p_curr.valid || !p_prev2.valid || !p_next || !p_next.valid) return false;

        const value_prev2 = p_prev2[dependentAxis];
        const value_prev = p_prev[dependentAxis];
        const value_curr = p_curr[dependentAxis];
        const value_next = p_next[dependentAxis];
        const tolerance = 1e-9;
        if (
            Math.abs(value_prev2 - value_prev) < tolerance &&
            Math.abs(value_prev - value_curr) > tolerance &&
            Math.abs(value_curr - value_next) < tolerance
        ) {
            return 'step';
        }
        
        const jumpThreshold = (dependentAxis === 'y' ? this.canvas.clientHeight : this.canvas.clientWidth) / this.scale * 0.5;
        if (p_curr[dependentAxis] * p_next[dependentAxis] < 0 && Math.abs(p_curr[dependentAxis] - p_next[dependentAxis]) > jumpThreshold) {
            return true;
        }

        const ZERO_DERIVATIVE_THRESHOLD = 1e-3;
        const slope1 = (p_prev[dependentAxis] - p_prev2[dependentAxis]) / (p_prev[independentAxis] - p_prev2[independentAxis]);
        const slope2 = (p_curr[dependentAxis] - p_prev[dependentAxis]) / (p_curr[independentAxis] - p_prev[independentAxis]);
        const slope3 = (p_next[dependentAxis] - p_curr[dependentAxis]) / (p_next[independentAxis] - p_curr[independentAxis]);

        if (
            isFinite(slope1) && isFinite(slope2) && isFinite(slope3) &&
            Math.abs(slope1) > ZERO_DERIVATIVE_THRESHOLD &&
            Math.sign(slope1) === Math.sign(slope3) &&
            Math.sign(slope1) !== Math.sign(slope2)
        ) {
            return true;
        }

        return false;
    }


    startSmoothPanning() {
        const history = this.panEventHistory;
        const historyLength = history.length;

        if (historyLength < 2) {
            this.finalizePanInteraction();
            return;
        }
        const lastRecordedEvent = history[historyLength - 1]; 
        let firstRelevantEventForFlick = null;
        const MAX_FLICK_DURATION_MS = 100; 
        const MAX_FLICK_SAMPLES_LOOKBACK = 5;  
        const MIN_FLICK_SAMPLES_FOR_VELOCITY = 1; 

        for (let i = historyLength - 2; i >= 0; i--) {
            const currentEventCandidate = history[i];
            const timeDiff = lastRecordedEvent.time - currentEventCandidate.time;
            const samplesBehind = (historyLength - 1) - i;

            if (timeDiff > MAX_FLICK_DURATION_MS && samplesBehind > MIN_FLICK_SAMPLES_FOR_VELOCITY) {
                break;
            }
            
            firstRelevantEventForFlick = currentEventCandidate; 

            if (samplesBehind >= MAX_FLICK_SAMPLES_LOOKBACK) {
                break;
            }
        }

        if (!firstRelevantEventForFlick) {
            if (historyLength >=2) {
                firstRelevantEventForFlick = history[historyLength - 2];
            } else {
                this.finalizePanInteraction();
                return;
            }
        }

        const dt = (lastRecordedEvent.time - firstRelevantEventForFlick.time) / 1000.0; 

        if (dt < 0.001) {
            this.finalizePanInteraction();
            return;
        }

        const dx = lastRecordedEvent.x - firstRelevantEventForFlick.x;
        const dy = lastRecordedEvent.y - firstRelevantEventForFlick.y;
        
        const MIN_FLICK_DISTANCE_THRESHOLD = 5; 
        if (Math.sqrt(dx*dx + dy*dy) < MIN_FLICK_DISTANCE_THRESHOLD && dt < 0.05 ) {
            this.finalizePanInteraction();
            return;
        }

        this.smoothPanVelocity.x = dx / dt;
        this.smoothPanVelocity.y = dy / dt;

        const velocityMagnitude = Math.sqrt(this.smoothPanVelocity.x**2 + this.smoothPanVelocity.y**2);

        if (velocityMagnitude < this.minFlickVelocityMagnitude) {
            this.finalizePanInteraction();
            return;
        }

        let calculatedAccsmooth = this.baseAccsmooth + velocityMagnitude * this.accsmoothVelocityFactor;
        this.accsmooth = Math.min(calculatedAccsmooth, this.maxAccsmooth);
        this.accsmooth = Math.max(this.accsmooth, this.baseAccsmooth);

        this.isSmoothPanningActive = true;
        this.lastSmoothPanTime = performance.now();
        this.requestDraw();
    }

    finalizePanInteraction() {
        this.isUsingPanOptimization = false;
        if (this.globalPlayState === 0) {
            const cssWidth = this.canvasContainer.clientWidth;
            const cssHeight = this.canvasContainer.clientHeight;
            this.processImplicitBlocksOnGrid(cssWidth, cssHeight);

            if (this.performanceModeEnabled) {
                this.cleanupUnusedCache(cssWidth, cssHeight);
            }
        }
        this.recalculateAll();
    }
startSmoothZooming(velocityFactor, target, source = 'mouse') {
    if (!this.smoothPanningEnabled || !this.performanceModeEnabled || this.globalPlayState !== 0) {
        this.handleZoomEnd();
        return;
    }
    clearTimeout(this.zoomEndTimeout);
    this.isSmoothPanningActive = false;
    this.isSmoothZoomingActive = true;
    
    const inertiaScale = (source === 'touch') ? this.touchZoomInertiaScale : this.mouseZoomInertiaScale;
    this.smoothZoomVelocity = 1.0 + (velocityFactor - 1.0) * inertiaScale;
    
    this.smoothZoomTarget = target;
    this.lastSmoothPanTime = performance.now();

    if (!this.isZooming && this.performanceModeEnabled) {
        this.captureCanvasStateForTransform();
        this.startPerformanceZoom();
    }
    this.requestDraw();
}

captureCanvasStateForTransform() {
    if (this.globalPlayState !== 0) return;
    this.isTransformingCache = true;
    this.transformInitialState = { offset: { ...this.offset }, scale: this.scale };

    const wasTransforming = this.isTransformingCache;
    this.isTransformingCache = false;
    this.draw();
    this.isTransformingCache = wasTransforming;

    this.offscreenCanvas.width = this.canvas.width;
    this.offscreenCanvas.height = this.canvas.height;
    const ctx = this.offscreenCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.drawImage(this.canvas, 0, 0);
    ctx.drawImage(this.axisCanvas, 0, 0);
}

onZoom(e) {
        e.preventDefault();
        
        if (this.is3DMode) {
            const zoomIntensity = -0.1;
            const delta = e.deltaY > 0 ? -1 : 1; 
            this.scale3D *= (1 + delta * zoomIntensity); 
            if (this.scale3D < 0.001) this.scale3D = 0.001;
            if (this.scale3D > 100.0) this.scale3D = 100.0;
            this.recalculate3D();
            this.requestDraw();
            return;
        }


        const zoomIntensity = 0.1;
        const delta = e.deltaY > 0 ? -1 : 1;
        const effectiveIntensity = e.ctrlKey ? zoomIntensity * 0.5 : zoomIntensity;
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (this.smoothPanningEnabled && this.performanceModeEnabled && this.globalPlayState === 0) {
            const velocityFactor = 1 + delta * effectiveIntensity * 3;
            this.startSmoothZooming(velocityFactor, { x: mouseX, y: mouseY }, 'mouse');
        } else {
            clearTimeout(this.zoomEndTimeout);
            if (!this.isZooming) {
                this.isZooming = true;
                if (this.performanceModeEnabled) {
                    this.captureCanvasStateForTransform();
                    this.startPerformanceZoom();
                } else if (this.lowPrecisionBufferEnabled) {
                    if (!this.isUsingLowPrecisionBuffer) {
                        this.originalExplicitPrecision = this.explicitPrecisionStep;
                        this.originalImplicitPrecision = this.implicitPrecisionStep;
                        this.isUsingLowPrecisionBuffer = true;
                    }
                    this.explicitPrecisionStep = 1;
                    this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
                    this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
                    this.implicitPrecisionSlider.setValue(this.implicitPrecisionStep);
                    this.updatePrecisionLabels();
                }
            }

            if (!this.performanceModeEnabled) {
                this.clearPlotData();
                this.entries.forEach(entry => {
                    if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    }
                });
            }
            
            const zoomFactor = 1 + delta * effectiveIntensity;
            const mouseXMath = (mouseX - this.offset.x) / this.scale;
            const mouseYMath = (this.offset.y - mouseY) / this.scale;
            let newScale = this.scale * zoomFactor;
            newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));
            this.offset.x = mouseX - mouseXMath * newScale;
            this.offset.y = mouseY + mouseYMath * newScale;
            this.scale = newScale;

            this.zoomEndTimeout = setTimeout(() => this.handleZoomEnd(), 300);
            this.requestDraw();
        }
    }

    startPanOptimization() {
        if (this.globalPlayState === 0) {
            this.isUsingPanOptimization = true;
            this.panStartOffset = { ...this.offset };

            const wasOptimizing = this.isUsingPanOptimization;
            this.isUsingPanOptimization = false;
            this.draw();
            this.isUsingPanOptimization = wasOptimizing;

            this.offscreenCanvas.width = this.canvas.width;
            this.offscreenCanvas.height = this.canvas.height;
            const ctx = this.offscreenCtx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.drawImage(this.canvas, 0, 0);
            ctx.drawImage(this.axisCanvas, 0, 0);
        } else {
            this.isUsingPanOptimization = false;
        }
    }

             startSidebarResize(e) {
        const infoModes = ['settings', 'file', 'about'];
        if (this.isPortraitMode && infoModes.includes(this.currentUIMode)) {
            return;
        }
        if (e.type !== 'mousedown' || e.button !== 0) return;
        const rect = this.sidebar.getBoundingClientRect();
        let onResizeHandle = false;

        if (this.isPortraitMode) {
             onResizeHandle = e.clientY <= rect.top + this.resizeHandleWidth && e.clientY >= rect.top - 3;
        } else {
             onResizeHandle = e.clientX >= rect.right - this.resizeHandleWidth && e.clientX <= rect.right + 3;
        }


        if (onResizeHandle) {
          document.body.classList.add('sidebar-resizing');
            this.isResizingSidebar = true;
            this.initialResizeX = e.clientX;
            this.initialResizeY = e.clientY;
            this.initialSidebarWidth = this.sidebar.offsetWidth;
            document.body.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
            this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
            e.preventDefault();
        }
    }

doSidebarResize(e) {
    if (!this.isResizingSidebar || e.type !== 'mousemove') return;

    const background = document.getElementById('sidebar-background');
    const computedStyle = window.getComputedStyle(this.sidebar);

    if (this.isPortraitMode) {
        const dy = e.clientY - this.initialResizeY;
        const currentRect = this.sidebar.getBoundingClientRect();
        let newTop = currentRect.top + dy;
        
        const bottomStyle = parseFloat(window.getComputedStyle(this.sidebar).bottom);
        const minH = parseInt(computedStyle.minHeight, 10) || 150;
        const maxH = Math.max(minH, window.innerHeight * 0.6);

        const minTop = window.innerHeight - bottomStyle - maxH;
        const maxTop = window.innerHeight - bottomStyle - minH;
        
        newTop = Math.max(minTop, Math.min(newTop, maxTop));
        
        this.sidebar.style.height = 'auto';
        this.sidebar.style.top = `${newTop}px`;
        if (background) {
            background.style.height = 'auto';
            background.style.top = `${newTop - 5}px`;
        }
        
        this.initialResizeY = e.clientY;
   } else {
            const dx = e.clientX - this.initialResizeX;
            let newWidth = this.initialSidebarWidth + dx;

            const minW = parseInt(computedStyle.minWidth, 10) || 250;
            const maxW = Math.max(minW, window.innerWidth * 0.8);

newWidth = Math.max(minW, Math.min(newWidth, maxW));

            this.sidebar.style.width = `${newWidth}px`;
            if (background) {
                background.style.width = `${newWidth}px`;
                this.lastValidSidebarRight = background.getBoundingClientRect().right;
            }
            

            this.updateTopBarLayout();
        }
    }

    stopSidebarResize() {
        if (this.isResizingSidebar) {
          document.body.classList.remove('sidebar-resizing'); 
            this.isResizingSidebar = false;
            this.sidebar.style.cursor = 'default';
            document.body.style.cursor = 'default';
            this.clearPlotData();
            this.entries.forEach(entry => {
                if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
            });

            setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
            }, 350);

            setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
            }, 1000);

             this.updateSidebarCursor(this.lastPos.x + this.canvas.getBoundingClientRect().left, this.lastPos.y + this.canvas.getBoundingClientRect().top);
        }
    }

         startSidebarResizeTouch(e) {
        const infoModes = ['settings', 'file', 'about'];
        if (this.isPortraitMode && infoModes.includes(this.currentUIMode)) {
            return;
        }
        if (e.touches.length !== 1 || this.touchState.panning || this.touchState.pinching) return;

         const rect = this.sidebar.getBoundingClientRect();
         const touchX = e.touches[0].clientX;
         const touchY = e.touches[0].clientY;
         let onResizeHandle = false;

         if (this.isPortraitMode) {
              onResizeHandle = touchY >= rect.top - this.touchResizePadding && touchY <= rect.top + this.touchResizePadding;
         } else {
              onResizeHandle = touchX >= rect.right - this.touchResizePadding && touchX <= rect.right + this.touchResizePadding;
         }


         if (onResizeHandle) {
          document.body.classList.add('sidebar-resizing');
             this.isResizingSidebarTouch = true;
             this.initialResizeTouchX = touchX;
             this.initialResizeTouchY = touchY;
             this.initialSidebarWidth = this.sidebar.offsetWidth;
             this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
             e.preventDefault(); 
             e.stopPropagation(); 
         }
     }

doSidebarResizeTouch(e) {
    if (!this.isResizingSidebarTouch || e.touches.length !== 1) return;
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    const computedStyle = window.getComputedStyle(this.sidebar);
    const background = document.getElementById('sidebar-background');

    if (this.isPortraitMode) {
        const dy = touchY - this.initialResizeTouchY;
        const currentRect = this.sidebar.getBoundingClientRect();
        let newTop = currentRect.top + dy;
        
        const bottomStyle = parseFloat(window.getComputedStyle(this.sidebar).bottom);
        const minH = parseInt(computedStyle.minHeight, 10) || 150;
        const maxH = Math.max(minH, window.innerHeight * 0.6);

        const minTop = window.innerHeight - bottomStyle - maxH;
        const maxTop = window.innerHeight - bottomStyle - minH;
        
        newTop = Math.max(minTop, Math.min(newTop, maxTop));
        
        this.sidebar.style.height = 'auto';
        this.sidebar.style.top = `${newTop}px`;
        if (background) {
            background.style.height = 'auto';
            background.style.top = `${newTop - 5}px`;
        }
        
        this.initialResizeTouchY = touchY;
    } else {
        const dx = touchX - this.initialResizeTouchX;
        let newWidth = this.initialSidebarWidth + dx;

        const minW = parseInt(computedStyle.minWidth, 10) || 250;
        const maxW = Math.max(minW, window.innerWidth * 0.8);

        newWidth = Math.max(minW, Math.min(newWidth, maxW));
        this.sidebar.style.width = `${newWidth}px`;
        if (background) background.style.width = `${newWidth}px`;
    }
    e.preventDefault();
    e.stopPropagation();
}

     stopSidebarResizeTouch() {
         if (this.isResizingSidebarTouch) {
          document.body.classList.remove('sidebar-resizing'); 
             this.isResizingSidebarTouch = false;
             this.sidebar.style.cursor = 'default';
             this.clearPlotData();
             this.entries.forEach(entry => {
                 if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
             });

             setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
             }, 350);
             
             setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
             }, 1000);
         }
     }


addEntry(rawInputFromUI) {
        const rawInputTrimmed = (typeof rawInputFromUI === 'string' && rawInputFromUI.trim() !== '')
            ? rawInputFromUI.trim()
            : prompt('请输入表达式 (例: y=x^2, f(x)=x^2, x^2+y^2=4, x=cos(t),y=sin(t), a=2):');

        if (rawInputTrimmed === null || rawInputTrimmed === "") return;

        const lowercaseInput = rawInputTrimmed.toLowerCase();
        try {
            const funcDefMatch = rawInputTrimmed.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
            let handledByParseInternal = false;

            if (funcDefMatch) {
                const funcName = funcDefMatch[1];
                const funcNameLower = funcName.toLowerCase();

                const isBuiltInMath = this.calcJSUtils.calc1.includes(funcNameLower);
                const isExistingSimpleCustom = this.calcJSUtils.customFunctions.hasOwnProperty(funcNameLower);
                const isExistingAdvancedCustom = this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(funcNameLower);
                const isExistingConstant = this.calcJSUtils.constants.hasOwnProperty(funcNameLower);
                const isPredefined = isBuiltInMath || isExistingSimpleCustom || isExistingAdvancedCustom || isExistingConstant;


                if (isPredefined && funcNameLower !== 'x' && funcNameLower !== 'y' && funcNameLower !== 't') {
                    const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                    if (entryData) {
                         const existingIndex = this.entries.findIndex(e => e.expr === entryData.expr && e.type === entryData.type);
                         if (existingIndex === -1) this.entries.push(entryData);
                         else this.entries[existingIndex] = entryData;
                    }
                    handledByParseInternal = true;
                } else if (funcNameLower === 'x' || funcNameLower === 'y' || funcNameLower === 't') {
                    const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                     if (entryData) {
                        if (entryData.type === 'variable') { 
                            const existingIndex = this.entries.findIndex(e => e.type === 'variable' && e.key === entryData.key);
                            if (existingIndex > -1) {
                                 if (this.entries[existingIndex].isEditableIndependent && entryData.isEditableIndependent) {
                                    entryData.sliderActive = this.entries[existingIndex].sliderActive;
                                    entryData.playState = this.entries[existingIndex].playState;
                                    entryData.playDirection = this.entries[existingIndex].playDirection;
                                    if (!Number.isFinite(entryData.value)) {
                                        if (Number.isFinite(this.entries[existingIndex].value)) {
                                            entryData.value = this.entries[existingIndex].value;
                                        } else {
                                            entryData.value = Number.isFinite(entryData.min) ? entryData.min : 0;
                                        }
                                    }
                                     if (! /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(entryData.expr.split('=')[1]?.trim() || '')) {
                                         entryData.min = this.entries[existingIndex].min;
                                         entryData.max = this.entries[existingIndex].max;
                                         entryData.step = this.entries[existingIndex].step;
                                     }
                                }
                                this.entries[existingIndex] = entryData;
                            } else {
                                this.entries.push(entryData);
                            }
                        } else { 
                            this.entries.push(entryData);
                        }
                    }
                    handledByParseInternal = true;
                } else {
                    const definedFuncData = this.defineCalcJSFunction(rawInputTrimmed, false); 

                    if (definedFuncData) {
                        let definitionEntry;
                        if (definedFuncData.type === 'custom_function_definition') {
                            definitionEntry = {
                                type: 'custom_function_definition',
                                name: definedFuncData.name,
                                params: definedFuncData.params,
                                body: definedFuncData.rawBodyString, 
                                expr: definedFuncData.originalExpression, 
                                dependencies: this._extractDependenciesFromTokensWithLargeOps(
                                    definedFuncData.bodyTokens, 
                                    definedFuncData.params,
                                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames
                                ),
                                compilationError: undefined
                            };

                 
                            if (this.is3DMode && definedFuncData.params.length === 2) {
                                const p1 = definedFuncData.params[0].toLowerCase();
                                const p2 = definedFuncData.params[1].toLowerCase();
                                const funcCall = `${definedFuncData.name}(${definedFuncData.params[0]},${definedFuncData.params[1]})`;
                                let autoAddedExpr = null;
                                if ((p1 === 'x' && p2 === 'y') || (p1 === 'y' && p2 === 'x')) autoAddedExpr = `z=${funcCall}`;
                                else if ((p1 === 'y' && p2 === 'z') || (p1 === 'z' && p2 === 'y')) autoAddedExpr = `x=${funcCall}`;
                                else if ((p1 === 'x' && p2 === 'z') || (p1 === 'z' && p2 === 'x')) autoAddedExpr = `y=${funcCall}`;

                                if (autoAddedExpr) {
                                    const normalizedAutoExpr = autoAddedExpr.replace(/\s+/g, '').toLowerCase();
                                    const exists = this.entries.some(e => 
                                        e.type === 'function' && 
                                        e.expr.replace(/\s+/g, '').toLowerCase() === normalizedAutoExpr
                                    );
                                    
                                    if (!exists) {
                                        const parsedAutoEntry = this.parseInputInternal(autoAddedExpr.toLowerCase(), autoAddedExpr);
                                        if (parsedAutoEntry && parsedAutoEntry.type === 'function') {
                                            this.entries.push(parsedAutoEntry);
                                        }
                                    }
                                }
                            } else if (definedFuncData.params.length === 1) {
                                const paramNameLower = definedFuncData.params[0].toLowerCase();
                                const funcCall = `${definedFuncData.name}(${definedFuncData.params[0]})`;
                                let autoAddedExpr = null;
                                if (paramNameLower === 'x') autoAddedExpr = `y=${funcCall}`;
                                else if (paramNameLower === 'y') autoAddedExpr = `x=${funcCall}`;

                                if (autoAddedExpr) {
                                    const normalizedAutoExpr = autoAddedExpr.replace(/\s+/g, '').toLowerCase();
                                    const exists = this.entries.some(e => 
                                        e.type === 'function' && 
                                        e.expr.replace(/\s+/g, '').toLowerCase() === normalizedAutoExpr
                                    );
                                    
                                    if (!exists) {
                                        const parsedAutoEntry = this.parseInputInternal(autoAddedExpr.toLowerCase(), autoAddedExpr);
                                        if (parsedAutoEntry && parsedAutoEntry.type === 'function') {
                                            this.entries.push(parsedAutoEntry);
                                        }
                                    }
                                }
                            }
                        } else if (definedFuncData.type === 'advanced_custom_function_definition') {
                            definitionEntry = {
                                type: 'advanced_custom_function_definition',
                                name: definedFuncData.name,
                                params: definedFuncData.params,
                                bodyJs: definedFuncData.bodyJs,
                                expr: `${definedFuncData.name}(${definedFuncData.params.join(',')}) { /* JS body */ }`,
                                dependencies: [], 
                                compilationError: undefined
                            };
                        }

                        if (definitionEntry) {
                             const existingDefIndex = this.entries.findIndex(e => e.type === definitionEntry.type && e.name === definitionEntry.name);
                             if (existingDefIndex > -1) {
                                this.entries[existingDefIndex] = definitionEntry; 
                             } else {
                                this.entries.push(definitionEntry);
                             }
                        }
                    }
                    handledByParseInternal = true;
                }
            }

            if (!handledByParseInternal) {
                const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                if (entryData) {
                    if (entryData.type === 'variable') {
                        const existingIndex = this.entries.findIndex(e => e.type === 'variable' && e.key === entryData.key);
                        if (existingIndex > -1) {
                             if (this.entries[existingIndex].isEditableIndependent && entryData.isEditableIndependent) {
                                entryData.sliderActive = this.entries[existingIndex].sliderActive;
                                entryData.playState = this.entries[existingIndex].playState;
                                entryData.playDirection = this.entries[existingIndex].playDirection;
                                if (!Number.isFinite(entryData.value)) { 
                                    if (Number.isFinite(this.entries[existingIndex].value)) {
                                        entryData.value = this.entries[existingIndex].value; 
                                    } else { 
                                        entryData.value = Number.isFinite(entryData.min) ? entryData.min : 0; 
                                    }
                                }
                                 if (! /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(entryData.expr.split('=')[1]?.trim() || '')) {
                                     entryData.min = this.entries[existingIndex].min;
                                     entryData.max = this.entries[existingIndex].max;
                                     entryData.step = this.entries[existingIndex].step;
                                 }
                            }
                            this.entries[existingIndex] = entryData;
                        } else {
                            this.entries.push(entryData);
                        }
                    } else if (entryData.type === 'constant') {
                        const existingIndex = this.entries.findIndex(e => e.type === 'constant' && e.name === entryData.name);
                        if (existingIndex > -1) {
                            this.entries[existingIndex] = entryData;
                        } else {
                            this.entries.push(entryData);
                        }
                    }
                    else { 
                        const existingFuncIndex = this.entries.findIndex(e => e.type === 'function' && e.expr.toLowerCase() === entryData.expr.toLowerCase());
                        if (existingFuncIndex === -1) {
                            this.entries.push(entryData);
                        } else {
                            this.entries[existingFuncIndex] = entryData;
                        }
                    }
                }
            }
            this.recalculateAll();
            this.updateGlobalPlayState();

        } catch (e) {
            alert(`解析表达式出错: ${e.message}`);
        }
    }

async handleEntryListClick(e) {
        // 点击列表时，如果有选中的批注，立即取消选中并刷新UI
        if (this.selectedAnnotationIndex !== -1) {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        }

        const item = e.target.closest('.entry-item');
        if (!item) return;

        const framePlayBtn = e.target.closest('.frame-play-toggle-btn');
        const frameCurrentVal = e.target.closest('.frame-current-value');
        const frameTotalVal = e.target.closest('.frame-total-value');
        const frameFpsVal = e.target.closest('.frame-fps-value');

        if (item.classList.contains('playback-control-card')) {
            if (framePlayBtn) {
                this.isFramePlaying = !this.isFramePlaying;
                this.frameAccumulator = 0; 
                this.lastAnimationTime = performance.now();
                this.updateGlobalPlayState();
                this.updateEntryList();
                return;
            }

            if (frameCurrentVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.currentFrame, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal >= 0 && newVal <= this.totalFrames) {
                            this.currentFrame = newVal;
                            this.updateEntryList();
                            this.requestDraw();
                        }
                    });
                }
                return;
            }
            if (frameTotalVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.totalFrames, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal > 0) {
                            this.totalFrames = newVal;
                            if (this.currentFrame > this.totalFrames) this.currentFrame = this.totalFrames;
                            this.updateEntryList();
                            this.requestDraw();
                        }
                    });
                }
                return;
            }
            if (frameFpsVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.playbackFPS, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal > 0) {
                            this.playbackFPS = newVal;
                            this.updateEntryList();
                        }
                    });
                }
                return;
            }
            return;
        }

        const index = parseInt(item.dataset.index, 10);
        if (isNaN(index) || index < 0 || index >= this.entries.length) return;
        const entry = this.entries[index];

        const colorToggleBtn = e.target.closest('.color-toggle-btn');
        const settingsToggleBtn = e.target.closest('.settings-toggle-btn');
        const visibilityToggleBtn = e.target.closest('.visibility-toggle-btn');
        const playToggleBtn = e.target.closest('.play-toggle-btn');
        const editBtn = e.target.closest('.edit-btn');
        const deleteBtn = e.target.closest('.delete-btn');
        const textArea = e.target.closest('.entry-text-area');
        const sliderPropsSpan = e.target.closest('.slider-props span');
        const displayFrameVal = e.target.closest('.display-frame-value');
        const extend3DToggle = e.target.closest('.extend-3d-toggle');
        const sliceAxisVal = e.target.closest('.slice-axis-value');
        const sliceValVal = e.target.closest('.slice-val-value');
        const playModeVal = e.target.closest('.play-mode-value');
        const togglePlotCardBtn = e.target.closest('.toggle-plot-card-btn');

        if (displayFrameVal) {
            if (window.globalOpenKeyboardForValue) {
                window.globalOpenKeyboardForValue(entry.displayFrame, (newValStr) => {
                    const newVal = parseInt(newValStr, 10);
                    if (!isNaN(newVal) && newVal >= 0) {
                        entry.displayFrame = newVal;
                        this.updateEntryList();
                        this.requestDraw();
                    }
                });
            }
            return;
        }

        if (extend3DToggle) {
            entry.extendTo3D = extend3DToggle.checked;
            this.recalculate3D();
            this.requestDraw();
            return;
        }

        if (sliceAxisVal) {
            const axes = ['none', 'x', 'y', 'z'];
            let currentIdx = axes.indexOf(entry.sliceAxis);
            if (currentIdx === -1) currentIdx = 0;
            entry.sliceAxis = axes[(currentIdx + 1) % axes.length];
            this.updateEntryList();
            this.recalculate3D();
            this.requestDraw();
            return;
        }

        if (sliceValVal) {
            if (window.globalOpenKeyboardForValue) {
                window.globalOpenKeyboardForValue(entry.sliceVal, (newValStr) => {
                    const newVal = parseFloat(newValStr);
                    if (!isNaN(newVal)) {
                        entry.sliceVal = newVal;
                        this.updateEntryList();
                        this.recalculate3D();
                        this.requestDraw();
                    }
                });
            }
            return;
        }

        if (playModeVal && entry.type === 'variable' && entry.isEditableIndependent) {
            entry.playMode = ((entry.playMode || 0) + 1) % 5;
            this.updateEntryList();
            return;
        }
if (togglePlotCardBtn && entry.type === 'variable' && entry.isEditableIndependent) {
            entry.showOnPlot = togglePlotCardBtn.checked;
            if (entry.showOnPlot) {
                const cssWidth = this.canvas.clientWidth;
                const cssHeight = this.canvas.clientHeight;
                const centerX = (cssWidth / 2 - this.offset.x) / this.scale;
                const centerY = (this.offset.y - cssHeight / 2) / this.scale;

                if (entry.cardX === undefined) entry.cardX = centerX;
                if (entry.cardY === undefined) entry.cardY = centerY;
                if (entry.cardW === undefined) entry.cardW = 220;
                if (entry.cardH === undefined) entry.cardH = 75;
            }
            
            setTimeout(() => {
                this.updateEntryList();
                this.requestDraw();
            }, 0);
            return;
        }
        const toggleExpansion = () => {
            const shouldBeExpanded = !entry.expanded;
            entry.expanded = shouldBeExpanded;
            item.classList.toggle('expanded', shouldBeExpanded);

            if (shouldBeExpanded) {
                this.entries.forEach((otherEntry, otherIndex) => {
                    if (index !== otherIndex && otherEntry.expanded) {
                        otherEntry.expanded = false;
                        const otherItem = this.entryList.querySelector(`.entry-item[data-index="${otherIndex}"]`);
                        if (otherItem) otherItem.classList.remove('expanded');
                    }
                });
            }

            if (entry.expanded) {
                setTimeout(() => {
                    if (entry.expanded) {
                        this.updateEntryList();
                    }
                }, 250);
            }
        };

        if (editBtn) {
            this.startEditEntry(index);
            return;
        }
        if (deleteBtn) {
            this._handleCascadingDelete(index);
            return;
        }
        if (visibilityToggleBtn) {
            entry.visible = !entry.visible;
            this.recalculateAll();
            return;
        }
        if (playToggleBtn) {
            if (entry.type === 'variable' && entry.isEditableIndependent) {
                entry.playState = entry.playState === 1 ? 0 : 1;

                if (entry.playState === 1) {
                    this.recalculateAll(); 
                }
                this.updateGlobalPlayState();
                this.updateEntryList();
            }
            return;
        }
        if (sliderPropsSpan && entry.type === 'variable' && entry.isEditableIndependent) {
            if (sliderPropsSpan.classList.contains('slider-min-value')) this.promptEditSliderProperty(index, 'min', entry.min);
            else if (sliderPropsSpan.classList.contains('slider-max-value')) this.promptEditSliderProperty(index, 'max', entry.max);
            else if (sliderPropsSpan.classList.contains('slider-step-value')) this.promptEditSliderProperty(index, 'step', entry.step);
            return;
        }

        if (colorToggleBtn || settingsToggleBtn) {
            toggleExpansion();
            return;
        }
        
        const isTouch = document.body.classList.contains('is-touch-device');
        const isSliderArea = e.target.closest('.entry-expandable-content') || e.target.closest('.variable-slider-wrapper');

        if (textArea || (isTouch && !isSliderArea)) {
            toggleExpansion();
            return;
        }
    }
  promptEditVariableValue(index) {
         const entry = this.entries[index];
         if (!entry || entry.type !== 'variable' || !entry.isEditableIndependent) return;

         const newValueString = prompt(`请输入变量 "${entry.name.toUpperCase()}" 的新值:`, String(entry.value));
         if (newValueString === null) return;

         const parsedValue = this._parseOrEvaluateInput(newValueString);
         if (parsedValue === null) {
              alert('输入的值无效。');
              return;
         }

         let tempNewValue = parsedValue;

         const editProps = prompt(`是否更改变量 "${entry.name.toUpperCase()}" 的滑杆参数 (最小值, 最大值, 步长)?\n输入 空/no/不/否/0 跳过, 输入其他继续:`, '');

         if (editProps !== null && editProps.trim().toLowerCase() !== '' && editProps.trim().toLowerCase() !== 'no' && editProps.trim() !== '不' && editProps.trim() !== '否' && editProps.trim() !== '0') {

              const newMinString = prompt(`请输入新的最小值 (当前: ${Number.isFinite(entry.min) ? entry.min : 'NaN'}):`, String(entry.min));
              const newMin = this._parseOrEvaluateInput(newMinString);
              if (newMin !== null) {
                  if (Number.isFinite(entry.max) && newMin >= entry.max) {
                      alert('最小值必须小于当前或新设定的最大值。 跳过更新最小值。');
                  } else {
                       entry.min = newMin;
                  }
              }

              const newMaxString = prompt(`请输入新的最大值 (当前: ${Number.isFinite(entry.max) ? entry.max : 'NaN'}):`, String(entry.max));
              const newMax = this._parseOrEvaluateInput(newMaxString);
              if (newMax !== null) {
                   if (Number.isFinite(entry.min) && newMax <= entry.min) {
                        alert('最大值必须大于当前或新设定的最小值。 跳过更新最大值。');
                   } else {
                        entry.max = newMax;
                   }
              }

              const newStepString = prompt(`请输入新的步长 (必须大于0, 当前: ${Number.isFinite(entry.step) ? entry.step : 'NaN'}):`, String(entry.step));
              const newStep = this._parseOrEvaluateInput(newStepString);
              if (newStep !== null) {
                  if (newStep > 0) {
                      entry.step = newStep;
                  } else {
                       alert('步长必须大于零。 跳过更新步长。');
                  }
              }
         }

         if (Number.isFinite(entry.min) && tempNewValue < entry.min) {
             tempNewValue = entry.min;
         }
         if (Number.isFinite(entry.max) && tempNewValue > entry.max) {
             tempNewValue = entry.max;
         }

         if (entry.value !== tempNewValue) {
            entry.value = tempNewValue;
            entry.playDirection = 1;
         }

         this.recalculateAll();
    }

 promptEditSliderProperty(index, property, currentValue) {
         const entry = this.entries[index];
         if (!entry || entry.type !== 'variable' || !entry.isEditableIndependent) return;

         if (window.globalOpenKeyboardForValue) {
             window.globalOpenKeyboardForValue(currentValue, (newValueString) => {
                 const newValue = this._parseOrEvaluateInput(newValueString);
                 if (newValue !== null) {
                     if (property === 'step' && newValue <= 0) {
                          alert('步长必须大于 0。');
                          return;
                     }
                     if (property === 'min' && Number.isFinite(entry.max) && newValue >= entry.max) {
                         alert('最小值必须小于最大值。');
                         return;
                     }
                     if (property === 'max' && Number.isFinite(entry.min) && newValue <= entry.min) {
                          alert('最大值必须大于最小值。');
                         return;
                     }

                    entry[property] = newValue;

                    if (Number.isFinite(entry.min) && Number.isFinite(entry.value) && entry.value < entry.min) entry.value = entry.min;
                    if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;

                    this.recalculateAll();
                }
             });
         }
    }


promptEditParametricRange(param) {
    const currentValue = param === 'tmin' ? this.tmin : this.tmax;
    

    if (window.globalOpenKeyboardForValue) {
        window.globalOpenKeyboardForValue(currentValue, (newValueString) => {
            const parsedValue = this._parseOrEvaluateInput(newValueString);
            if (parsedValue === null) return;

            if (param === 'tmin') {
               if (parsedValue >= this.tmax) {
                   alert('tmin 必须小于 tmax。');
                   return;
               }
               this.tmin = parsedValue;
            } else {
               if (parsedValue <= this.tmin) {
                   alert('tmax 必须大于 tmin。');
                   return;
               }
               this.tmax = parsedValue;
            }

            this.updateParametricRangeLabels();
            this.entries.forEach(entry => {
               if (entry.plotType === 'parametric') {
                   entry.cachedPoints = [];
                   entry.webglVertices = null;
               }
            });
            this.requestDraw();
        });
    }
}


handleVariableSliderChange(e) {
}

handleColorSliderChange(e) {
}

hsbToRgba(h_100, s_100, b_100, a_100) {
let h = h_100 * 3.6;
let s = s_100 / 100;
let v = b_100 / 100;
let alpha = 1.0 - (a_100 / 100);

let i = Math.floor(h / 60);
let f = (h / 60) - i;
let p = v * (1 - s);
let q = v * (1 - f * s);
let t = v * (1 - (1 - f) * s);

let r, g, b;
switch (i % 6) {
   case 0: r = v; g = t; b = p; break;
   case 1: r = q; g = v; b = p; break;
   case 2: r = p; g = v; b = t; break;
   case 3: r = p; g = q; b = v; break;
   case 4: r = t; g = p; b = v; break;
   case 5: r = v; g = p; b = q; break;
   default: r = 0; g = 0; b = 0; break;
}
return `rgba(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)}, ${alpha})`;
}

hsbToRgbaArray(h_100, s_100, b_100, a_100) {
    const alpha = 1.0 - (a_100 / 100);
    if (this.isDarkModeActive && b_100 === 0) {
        return [1.0, 1.0, 1.0, alpha];
    }

    let temp_h_100 = h_100;
    let temp_s_100 = s_100;
    let temp_b_100 = b_100;

    if (this.isDarkModeActive) {
        if (temp_b_100 < 35) temp_b_100 = 35;
    } else {
        if (temp_s_100 < 15 && temp_b_100 > 85) temp_b_100 = 85;
    }
    
    let h = temp_h_100 * 3.6;
    let s = temp_s_100 / 100;
    let v = temp_b_100 / 100;

    let i = Math.floor(h / 60);
    let f = (h / 60) - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);

    let r, g, b_val;
    switch (i % 6) {
       case 0: r = v; g = t; b_val = p; break;
       case 1: r = q; g = v; b_val = p; break;
       case 2: r = p; g = v; b_val = t; break;
       case 3: r = p; g = q; b_val = v; break;
       case 4: r = t; g = p; b_val = v; break;
       case 5: r = v; g = p; b_val = q; break;
       default: r = 0; g = 0; b_val = 0; break;
    }

    if (this.colorInversionEnabled && this.isDarkModeActive) {
        r = 1.0 - r;
        g = 1.0 - g;
        b_val = 1.0 - b_val;
    }

    return [r, g, b_val, alpha];
}


hsbToHex(h_100, s_100, b_100) {
const rgba = this.hsbToRgba(h_100, s_100, b_100, 0);
const parts = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
if (!parts) return '#000000';

const toHex = (c) => {
    const hex = parseInt(c, 10).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
};

return `#${toHex(parts[1])}${toHex(parts[2])}${toHex(parts[3])}`;
}
parseInputInternal(lowercaseInput, originalInput, ignoreIndex = -1, existingUserSymbolNames = new Set()) {
        if (originalInput.trim().startsWith('//')) {
            return { type: 'text', name: this.autonameText(), content: originalInput.trim().substring(2).trim(), expr: originalInput.trim(), color: { h: 0, s: 0, b: 60, a: 0 }, expanded: false };
        }
        originalInput = originalInput.replace(/\s+/g, '');
        lowercaseInput = originalInput.toLowerCase();

        if (originalInput.startsWith('/-/')) return this.parsePointList(originalInput, ignoreIndex);

        const keywordMatch = originalInput.match(/^([a-zA-Z_][\w]*)\(/);
        if (keywordMatch && this.geometryKeywords.has(keywordMatch[1].toLowerCase())) {
            return this.parseGeometryDefinition(originalInput, ignoreIndex);
        }

        const currentExistingSymbols = new Set([
            ...this.calcJSUtils.calc1, ...this.calcJSUtils.calc3, ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex).map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean),
            ...existingUserSymbolNames
        ]);
        
        let entryData = { 
            type: null, expr: originalInput, dependencies: [], hasLargeOps: false, 
            webglVertices: null, compilationError: undefined, extendTo3D: false, sliceAxis: 'none', sliceVal: 0
        };
        let rawExprForParsing = "";
        let potentialNewVariables = [];
        let excludeParamsForDepExtraction = [];

        const logicMatch = originalInput.match(/^(.*?)(>=|<=|>|<|=)(.*)$/s);

        if (logicMatch) {
            const lhsRaw = logicMatch[1].trim();
            const operator = logicMatch[2].trim();
            const rhsRaw = logicMatch[3].trim();
            const param3DMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+?)\s*,\s*z\s*=\s*(.+)\s*$/i);
            const parametricMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+)\s*$/i);

            if (param3DMatch && operator === '=') {
                entryData.type = 'function'; entryData.plotType = 'parametric3d'; excludeParamsForDepExtraction = ['t'];
            } else if (parametricMatch && operator === '=') {
                entryData.type = 'function'; entryData.plotType = 'parametric'; excludeParamsForDepExtraction = ['t'];
            } else {
                const isVariableNaming = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(lhsRaw) && operator === '=';
                const isReservedPlotVar = ['x', 'y', 'z', 't'].includes(lhsRaw.toLowerCase());
                const isKnownFunction = this.calcJSUtils.calc1.includes(lhsRaw.toLowerCase()) || this.calcJSUtils.constants.hasOwnProperty(lhsRaw.toLowerCase()) || this.disallowedVariableKeys.has(lhsRaw.toLowerCase());

                if (isVariableNaming && !isReservedPlotVar && !isKnownFunction) {
                    entryData.type = 'variable'; entryData.name = lhsRaw; entryData.key = lhsRaw.toLowerCase();
                    rawExprForParsing = rhsRaw; excludeParamsForDepExtraction = [];
                    entryData.isEditableIndependent = /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(rhsRaw);
                    if (entryData.isEditableIndependent) {
                        const initialValue = parseFloat(rhsRaw);
                        entryData.value = Number.isFinite(initialValue) ? initialValue : 0;
                        const absValue = Math.abs(entryData.value);
                        let defaultMin, defaultMax;
                        if (entryData.value === 0) { defaultMin = -10; defaultMax = 10;} 
                        else { defaultMin = -2 * absValue; defaultMax = 2 * absValue; }
                        if (defaultMin >= defaultMax) { defaultMin = defaultMax - 100; if (defaultMin >= defaultMax) defaultMax = defaultMin + 200; }
                        entryData.min = defaultMin; entryData.max = defaultMax; entryData.step = 0.02;
                        entryData.playState = 0; entryData.playDirection = 1; entryData.playMode = 0;
                    }
                } else if (lhsRaw.endsWith(')') && operator === '=') {
                    const funcDefMatch = originalInput.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
                    if (funcDefMatch) {
                        const definedFuncData = this.defineCalcJSFunction(originalInput, true);
                        if (definedFuncData) {
                            if (definedFuncData.type === 'custom_function_definition') {
                                entryData = {
                                    type: 'custom_function_definition', name: definedFuncData.name, params: definedFuncData.params,
                                    body: definedFuncData.rawBodyString, expr: definedFuncData.originalExpression, compilationError: undefined,
                                    hasLargeOps: definedFuncData.bodyTokens.some(t => ['sum', 'prod', 'int'].includes(t))
                                };
                                entryData.dependencies = this._extractDependenciesFromTokensWithLargeOps(
                                    definedFuncData.bodyTokens, definedFuncData.params,
                                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames, currentExistingSymbols
                                );
                                return entryData;
                            } else {
                                return { type: 'advanced_custom_function_definition', name: definedFuncData.name, params: definedFuncData.params, bodyJs: definedFuncData.bodyJs, expr: `${definedFuncData.name}(${definedFuncData.params.join(',')}) { /* JS body */ }`, dependencies: [], compilationError: undefined };
                            }
                        }
                    }
                }
                
                if (!entryData.type) {
                    const rhsTokens = this.improvedTokenize(rhsRaw, currentExistingSymbols);
                    if (lhsRaw.toLowerCase() === 'y' && operator === '=') {
                        // 修复 Bug 3：检测右侧是否包含 y，如果是，强制转为隐函数
                        if (rhsTokens.includes('y')) { 
                            entryData.type = 'function'; entryData.plotType = 'implicit'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y']; 
                        } else { 
                            entryData.type = 'function'; 
                            if (rhsRaw.includes('z')) { entryData.plotType = 'y3d'; excludeParamsForDepExtraction = ['x', 'z']; } 
                            else { entryData.plotType = 'y'; excludeParamsForDepExtraction = ['x']; } 
                            rawExprForParsing = rhsRaw; 
                        }
                    } else if (lhsRaw.toLowerCase() === 'x' && operator === '=') {
                        if (rhsTokens.includes('x')) { 
                            entryData.type = 'function'; entryData.plotType = 'implicit'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y']; 
                        } else { 
                            entryData.type = 'function'; 
                            if (rhsRaw.includes('z')) { entryData.plotType = 'x3d'; excludeParamsForDepExtraction = ['y', 'z']; } 
                            else { entryData.plotType = 'x'; excludeParamsForDepExtraction = ['y']; } 
                            rawExprForParsing = rhsRaw; 
                        }
                    } else if (lhsRaw.toLowerCase() === 'z' && operator === '=') {
                        // 修复 Bug 3：检测右侧是否包含 z，如果是，强制转为隐函数
                        if (rhsTokens.includes('z')) {
                            entryData.type = 'function'; entryData.plotType = 'implicit3d'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y', 'z']; 
                        } else {
                            entryData.type = 'function'; entryData.plotType = 'z'; excludeParamsForDepExtraction = ['x', 'y']; rawExprForParsing = rhsRaw;
                        }
                    } else {
                        entryData.type = 'function';
                        const tempTokens = this.improvedTokenize(originalInput, currentExistingSymbols);
                        const hasZ = tempTokens.includes('z');
                        if (hasZ) { entryData.plotType = 'implicit3d'; excludeParamsForDepExtraction = ['x', 'y', 'z']; } 
                        else { entryData.plotType = 'implicit'; excludeParamsForDepExtraction = ['x', 'y']; }
                        entryData.sign = operator; rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`;
                    }
                }
            }
        } else {
            // 没有等号的情况
            const tempTokens = this.improvedTokenize(originalInput, currentExistingSymbols);
            const hasX = tempTokens.includes('x'), hasY = tempTokens.includes('y'), hasZ = tempTokens.includes('z');

            if (hasX && hasY && hasZ) {
                entryData.type = 'function'; entryData.plotType = 'implicit3d'; entryData.sign = '='; rawExprForParsing = `(${originalInput})-(0)`; excludeParamsForDepExtraction = ['x', 'y', 'z']; entryData.expr = `${originalInput}=0`;
            } else if (hasX && hasY) {
                entryData.type = 'function';
                if (this.is3DMode) { entryData.plotType = 'z'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `z=${originalInput}`; } 
                else { entryData.plotType = 'implicit'; entryData.sign = '='; rawExprForParsing = `(${originalInput})-(0)`; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `${originalInput}=0`; }
            } else if (hasX && hasZ) { entryData.type = 'function'; entryData.plotType = 'y3d'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'z']; entryData.expr = `y=${originalInput}`;
            } else if (hasY && hasZ) { entryData.type = 'function'; entryData.plotType = 'x3d'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['y', 'z']; entryData.expr = `x=${originalInput}`;
            } else if (hasZ) { entryData.type = 'function'; entryData.plotType = 'z'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `z=${originalInput}`;
            } else if (hasX) { entryData.type = 'function'; entryData.plotType = 'y'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x']; entryData.expr = `y=${originalInput}`;
            } else if (hasY) { entryData.type = 'function'; entryData.plotType = 'x'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['y']; entryData.expr = `x=${originalInput}`;
            } else {
                entryData.type = 'variable'; entryData.name = this.autonameConstant(); entryData.key = entryData.name.toLowerCase();
                entryData.expr = `${entryData.name}=${originalInput}`; rawExprForParsing = originalInput; excludeParamsForDepExtraction = []; entryData.isEditableIndependent = false;
            }
        }

        if (entryData.plotType === 'parametric' || entryData.plotType === 'parametric3d') {
            const processComponent = (rawExpr, componentSuffix) => {
                let tokens = this.improvedTokenize(rawExpr, currentExistingSymbols);
                
                let expanded = this.calcJSUtils.expandCustomFunctions.call(this.calcJSUtils, tokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
                let fullyExpanded = this.calcJSUtils.expandDiffOperations.call(this.calcJSUtils, expanded, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
                
                let hasLargeOps = fullyExpanded.some(t => ['sum', 'prod', 'int'].includes(t));

                const deps = this._extractDependenciesFromTokensWithLargeOps(fullyExpanded, excludeParamsForDepExtraction, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames, currentExistingSymbols);
                deps.forEach(dep => potentialNewVariables.push(dep));
                
                // 修复 Bug 1：强制保存 token 列表，无论是否有 large ops
                entryData[`largeOpTokens${componentSuffix}`] = fullyExpanded;
                if (!hasLargeOps) {
                    entryData[`processedExpr${componentSuffix}`] = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, fullyExpanded).join('');
                }
                entryData[`expr${componentSuffix}_raw`] = rawExpr;
                return hasLargeOps;
            };

            const param3DMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+?)\s*,\s*z\s*=\s*(.+)\s*$/i);
            const parametricMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+)\s*$/i);

            if (param3DMatch) {
                const hasX = processComponent(param3DMatch[1].trim(), 'X');
                const hasY = processComponent(param3DMatch[2].trim(), 'Y');
                const hasZ = processComponent(param3DMatch[3].trim(), 'Z');
                entryData.hasLargeOps = hasX || hasY || hasZ;
            } else if (parametricMatch) {
                const hasX = processComponent(parametricMatch[1].trim(), 'X');
                const hasY = processComponent(parametricMatch[2].trim(), 'Y');
                entryData.hasLargeOps = hasX || hasY;
            }
            entryData.dependencies = Array.from(new Set(potentialNewVariables));
        } else if (rawExprForParsing) {
            let tokens = this.improvedTokenize(rawExprForParsing, currentExistingSymbols);
            let expandedCustomFuncTokens = this.calcJSUtils.expandCustomFunctions.call(this.calcJSUtils, tokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
            let fullyExpandedTokens = this.calcJSUtils.expandDiffOperations.call(this.calcJSUtils, expandedCustomFuncTokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
            
            potentialNewVariables.push(...this._extractDependenciesFromTokensWithLargeOps(
                fullyExpandedTokens, excludeParamsForDepExtraction,
                this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, 
                this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                currentExistingSymbols
            ));
            
            entryData.hasLargeOps = fullyExpandedTokens.some(t => ['sum', 'prod', 'int'].includes(t));
            if (entryData.hasLargeOps) { 
                entryData.largeOpTokens = fullyExpandedTokens;
            } else {
                entryData.processedExpr = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, fullyExpandedTokens).join('');
            }
            entryData.dependencies = Array.from(new Set(potentialNewVariables));
        }

        const blockingSymbols = new Set([
            ...this.calcJSUtils.calc1, ...this.calcJSUtils.calc3, ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex && (e.type === 'variable' || e.type === 'constant' || e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition')).map(e => e.key || e.name).filter(Boolean).map(k => k.toLowerCase())
        ]);

        entryData.dependencies.forEach(depKey => {
            if (depKey.length === 1 && this.allowedVariableKeys.has(depKey) && !blockingSymbols.has(depKey)) {
                const initialValueForNewVar = 1;
                this.entries.push({
                   type: 'variable', name: depKey, key: depKey,
                   expr: `${depKey}=${initialValueForNewVar}`,
                   processedExpr: String(initialValueForNewVar), 
                   hasLargeOps: false, largeOpTokens: null,
                   dependencies: [], isEditableIndependent: true,
                   value: initialValueForNewVar, min: -2, max: 2, step: 0.05,
                   sliderActive: false, playState: 0, playDirection: 1, playMode: 0,
                   compilationError: undefined
               });
               blockingSymbols.add(depKey);
            }
        });

        if (entryData.type !== 'variable' && entryData.type !== 'text' && entryData.type !== 'point_list') {
           entryData.color = { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
           entryData.thickness = 3; entryData.displayFrame = 0; entryData.expanded = false; entryData.visible = true;
        }

        return entryData;
    }

            improvedTokenize(expression, knownSymbolsSet) {
        if (!expression) return [];
        let expr = expression.toLowerCase().replace(/\s+/g, '');

                const staticTokens = ['sum', 'prod', 'int', 'diff', 'diffat', 'x', 'y', 'z', 't'];
        const allSymbols = Array.from(new Set([...knownSymbolsSet, ...staticTokens]));
        
        allSymbols.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length;
            return a.localeCompare(b);
        });

        
        let segments = [expr];

        for (const sym of allSymbols) {
            const newSegments = [];
            for (const seg of segments) {
                if (typeof seg !== 'string') {
                    newSegments.push(seg);                    continue;
                }
                
                let remaining = seg;
                                while (true) {
                    const idx = remaining.indexOf(sym);
                    if (idx === -1) {
                        if (remaining.length > 0) newSegments.push(remaining);
                        break;
                    }
                    
                                        if (idx > 0) {
                        newSegments.push(remaining.substring(0, idx));
                    }
                                    newSegments.push({ type: 'token', value: sym });
                    
                                        remaining = remaining.substring(idx + sym.length);
                }
            }
            segments = newSegments;
        }

        
        const finalTokens = [];
        
        for (const seg of segments) {
            if (typeof seg !== 'string') {
                            finalTokens.push(seg.value);
                continue;
            }

                        let i = 0;
            const len = seg.length;
            while (i < len) {
                const char = seg[i];

                if (/[0-9.]/.test(char)) {
                    let numStr = char;
                    let j = i + 1;
                    while (j < len && /[0-9.]/.test(seg[j])) {
                        numStr += seg[j];
                        j++;
                    }
                                        if ((numStr.match(/\./g) || []).length > 1) {
                         finalTokens.push(char);
                         i++;
                         continue;
                    }
                    finalTokens.push(numStr);
                    i = j;
                } 
else if (['+', '-', '*', '/', '^', ',', '(', ')', '=', '<', '>'].includes(char)) {
                    finalTokens.push(char);
                    i++;
                } 
                else if (/[a-z_]/.test(char)) {
                    let id = char;
                    let j = i + 1;
                    while (j < len && /[a-z0-9_]/.test(seg[j])) {
                        id += seg[j];
                        j++;
                    }
                    finalTokens.push(id);
                    i = j;
                }
                else {
                    
                    finalTokens.push(char);
                    i++;
                }
            }
        }

        return finalTokens;
    }


    parseGeometryDefinition(originalInput, ignoreIndex = -1) {
        const firstParen = originalInput.indexOf('(');
        const lastParen = originalInput.lastIndexOf(')');
        if (firstParen === -1 || lastParen === -1 || lastParen < firstParen) {
            throw new Error("几何对象定义格式错误: 括号不匹配。");
        }
        
        const keyword = originalInput.substring(0, firstParen).trim().toLowerCase();
        const paramString = originalInput.substring(firstParen + 1, lastParen).trim();
        
        const params = [];
        let parenLevel = 0;
        let lastSplit = 0;
        for (let i = 0; i < paramString.length; i++) {
            if (paramString[i] === '(') parenLevel++;
            else if (paramString[i] === ')') parenLevel--;
            else if (paramString[i] === ',' && parenLevel === 0) {
                params.push(paramString.substring(lastSplit, i).trim());
                lastSplit = i + 1;
            }
        }
        params.push(paramString.substring(lastSplit).trim());
        
        if (params.length === 1 && params[0] === "") {
            params.length = 0;
        }

        const name = params.length > 0 ? params[0] : this.autonameText();
        const isNameTaken = this.entries.some((e, i) => 
            i !== ignoreIndex && e.name && e.name.toLowerCase() === name.toLowerCase() && e.type !== 'variable' && e.type !== 'constant'
        );
        if (isNameTaken) {
            throw new Error(`创建或编辑失败：几何或函数名称 "${name}" 已被占用。`);
        }

const entry = {
            type: 'geometry',
            geometryType: keyword,
            expr: originalInput,
            name: name,
            dependencies: [],
            variableDependencies: [],
            objectDependencies: [],
            isMeaningful: false,
            visible: true,
            color: this.isDarkModeActive ? { h: 0, s: 0, b: 100, a: 0 } : { h: 0, s: 0, b: 0, a: 0 },
            thickness: 3,
            displayFrame: 0,
            webglVertices: null,
            webglFillVertices: null,
            compilationError: undefined
        };
        
        const allVarDeps = new Set();
        const allObjDeps = new Set();
        const existingSymbolNames = new Set(
            this.entries
                .filter((e, i) => i !== ignoreIndex)
                .map(e => (e.key || e.name)?.toLowerCase())
                .filter(Boolean)
        );
        
        const geometryObjectMapForParsing = new Map();
        this.entries.forEach((e, i) => {
            if (i !== ignoreIndex && e.type === 'geometry' && e.name) {
                geometryObjectMapForParsing.set(e.name.toLowerCase(), e);
            }
        });

        const parseAndAddExpressionDeps = (exprStr) => {
            if (!exprStr || typeof exprStr !== 'string') return;
            try {
                const tokens = this.calcJSUtils.tokenize(exprStr);
                const exprDeps = this._extractDependenciesFromTokensWithLargeOps(
                    tokens, [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingSymbolNames
                );
                exprDeps.forEach(dep => allVarDeps.add(dep));
            } catch (e) {}
        };

        const addObjectNameDep = (nameStr) => {
            if (nameStr && typeof nameStr === 'string') {
                allObjDeps.add(nameStr.toLowerCase());
            }
        };

        switch(keyword) {
            case 'point': {
                if (params.length !== 3) throw new Error("point 定义需要3个参数: point(名称, x/对象, y/参数)");
                const potentialObjectName = params[1].toLowerCase();
                const potentialObject = geometryObjectMapForParsing.get(potentialObjectName);
                if (potentialObject && !['point', 'midpoint', 'intercept'].includes(potentialObject.geometryType)) {
                    entry.pointOnObject = true;
                    entry.onObjectName = params[1];
                    entry.parameter_expr = params[2];
                    addObjectNameDep(entry.onObjectName);
                    parseAndAddExpressionDeps(entry.parameter_expr);
                } else {
                    entry.pointOnObject = false;
                    entry.x_expr = params[1];
                    entry.y_expr = params[2];
                    parseAndAddExpressionDeps(entry.x_expr);
                    parseAndAddExpressionDeps(entry.y_expr);
                }
                break;
            }
            case 'midpoint':
                if (params.length !== 3) throw new Error("midpoint 定义需要3个参数: midpoint(名称, 点1名称, 点2名称)");
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'intercept':
                if (params.length < 3 || params.length > 4) throw new Error("intercept 定义需要3或4个参数: intercept(名称, 对象1, 对象2, [符号])");
                entry.obj1Name = params[1];
                entry.obj2Name = params[2];
                entry.sign = params.length === 4 ? parseFloat(params[3]) : 1;
                if (isNaN(entry.sign) || (entry.sign !== 1 && entry.sign !== -1)) throw new Error("intercept 的第四个参数 (符号) 必须是 1 或 -1");
                addObjectNameDep(entry.obj1Name);
                addObjectNameDep(entry.obj2Name);
                break;
            case 'segment': case 'ray': case 'line': case 'vector':
                if (params.length !== 3) throw new Error(`${keyword} 定义需要3个参数: ${keyword}(名称, 起始点, 结束点)`);
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'perpendicularline':
                if (params.length !== 3) throw new Error("perpendicularline 定义需要3个参数: perpendicularline(名称, 线, 点)");
                entry.lineName = params[1];
                entry.pointName = params[2];
                addObjectNameDep(entry.lineName);
                addObjectNameDep(entry.pointName);
                break;
            case 'parallelline':
                if (params.length !== 3) throw new Error("parallelline 定义需要3个参数: parallelline(名称, 线, 点)");
                entry.lineName = params[1];
                entry.pointName = params[2];
                addObjectNameDep(entry.lineName);
                addObjectNameDep(entry.pointName);
                break;
            case 'anglebisector':
                if (params.length !== 4) throw new Error("anglebisector 定义需要4个参数: anglebisector(名称, 点1, 顶点, 点3)");
                entry.p1Name = params[1];
                entry.vertexName = params[2];
                entry.p3Name = params[3];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.vertexName);
                addObjectNameDep(entry.p3Name);
                break;
            case 'circle':
                if (params.length !== 3) throw new Error("circle 定义需要3个参数: circle(名称, 圆心, 半径或点)");
                entry.centerName = params[1];
                addObjectNameDep(entry.centerName);
                const radiusOrPoint = params[2];
                if (geometryObjectMapForParsing.has(radiusOrPoint.toLowerCase())) {
                    entry.pointOnCircleName = radiusOrPoint;
                    addObjectNameDep(entry.pointOnCircleName);
                } else {
                    entry.radius_expr = radiusOrPoint;
                    parseAndAddExpressionDeps(entry.radius_expr);
                }
                break;
case 'ellipse':
            if (params.length === 4) {
                entry.f1Name = params[1];
                entry.f2Name = params[2];
                entry.pName = params[3];
                addObjectNameDep(entry.f1Name);
                addObjectNameDep(entry.f2Name);
                addObjectNameDep(entry.pName);
            } else if (params.length === 3) {
                entry.geometryType = 'ellipse_ab';
                entry.a_expr = params[1];
                entry.b_expr = params[2];
                parseAndAddExpressionDeps(entry.a_expr);
                parseAndAddExpressionDeps(entry.b_expr);
            } else {
                throw new Error("ellipse 定义需要3个参数 ellipse(名称, a, b) 或4个参数 ellipse(名称, 焦点1, 焦点2, 点)");
            }
            break;
        case 'hyperbola':
            if (params.length !== 4) throw new Error(`${keyword} 定义需要4个参数: ${keyword}(名称, 焦点1, 焦点2, 点)`);
            entry.f1Name = params[1];
            entry.f2Name = params[2];
            entry.pName = params[3];
            addObjectNameDep(entry.f1Name);
            addObjectNameDep(entry.f2Name);
            addObjectNameDep(entry.pName);
            break;
            case 'parabola':
                if (params.length !== 3) throw new Error("parabola 定义需要3个参数: parabola(名称, 焦点, 准线)");
                entry.focusName = params[1];
                entry.directrixName = params[2];
                addObjectNameDep(entry.focusName);
                addObjectNameDep(entry.directrixName);
                break;
            case 'polygon':
                if (params.length < 2) throw new Error("polygon 定义至少需要2个参数: polygon(名称, 顶点数, ...顶点名称)");
                const numVertices = parseInt(params[1], 10);
                if (isNaN(numVertices) || numVertices < 3) throw new Error("polygon 第2个参数必须是大于等于3的整数 (顶点数)");
                if (params.length !== numVertices + 2) throw new Error(`polygon 顶点数量与声明不符: 期望 ${numVertices}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
                case 'length':
                if (params.length !== 3) throw new Error("length 定义需要3个参数: length(名称, 点1, 点2)");
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'angle':
                if (params.length !== 4) throw new Error("angle 定义需要4个参数: angle(名称, 点1, 顶点, 点3)");
                entry.p1Name = params[1];
                entry.vertexName = params[2];
                entry.p3Name = params[3];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.vertexName);
                addObjectNameDep(entry.p3Name);
                break;
            case 'area':
                if (params.length < 2) throw new Error("area 定义至少需要2个参数: area(名称, 顶点数, ...顶点名称)");
                const numAreaVertices = parseInt(params[1], 10);
                if (isNaN(numAreaVertices) || numAreaVertices < 3) throw new Error("area 第2个参数必须是大于等于3的整数 (顶点数)");
                if (params.length !== numAreaVertices + 2) throw new Error(`area 顶点数量与声明不符: 期望 ${numAreaVertices}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
                            case 'isparallel':
                if (params.length === 2) {
                    entry.name = this.autonameByPrefix('isparallel');
                    entry.l1Name = params[0];
                    entry.l2Name = params[1];
                } else if (params.length === 3) {
                    entry.name = params[0];
                    entry.l1Name = params[1];
                    entry.l2Name = params[2];
                } else {
                    throw new Error("isparallel 定义需要2或3个参数: isparallel(线1, 线2) 或 isparallel(名称, 线1, 线2)");
                }
                addObjectNameDep(entry.l1Name);
                addObjectNameDep(entry.l2Name);
                break;
            case 'isperpendicular':
                if (params.length === 2) {
                    entry.name = this.autonameByPrefix('isperp');
                    entry.l1Name = params[0];
                    entry.l2Name = params[1];
                } else if (params.length === 3) {
                    entry.name = params[0];
                    entry.l1Name = params[1];
                    entry.l2Name = params[2];
                } else {
                    throw new Error("isperpendicular 定义需要2或3个参数: isperpendicular(线1, 线2) 或 isperpendicular(名称, 线1, 线2)");
                }
                addObjectNameDep(entry.l1Name);
                addObjectNameDep(entry.l2Name);
                break;
            case 'isconcyclic':
                if (params.length === 4) {
                    entry.name = this.autonameByPrefix('isconcyclic');
                    entry.p1Name = params[0]; entry.p2Name = params[1]; entry.p3Name = params[2]; entry.p4Name = params[3];
                } else if (params.length === 5) {
                    entry.name = params[0];
                    entry.p1Name = params[1]; entry.p2Name = params[2]; entry.p3Name = params[3]; entry.p4Name = params[4];
                } else {
                    throw new Error("isconcyclic 定义需要4或5个参数: isconcyclic(点1, 点2, 点3, 点4) 或 isconcyclic(名称, ...)");
                }
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                addObjectNameDep(entry.p3Name);
                addObjectNameDep(entry.p4Name);
                break;
                            case 'rotate':
                if (params.length !== 4) throw new Error("rotate 定义需要4个参数: rotate(新点名, 旋转中心, 旋转点, 角度)");
                entry.centerName = params[1];
                entry.rotatedPointName = params[2];
                entry.angle_expr = params[3];
                addObjectNameDep(entry.centerName);
                addObjectNameDep(entry.rotatedPointName);
                parseAndAddExpressionDeps(entry.angle_expr);
                break;
            case 'reflect':
                if (params.length !== 3) throw new Error("reflect 定义需要3个参数: reflect(新点名, 对称轴/点, 作用点)");
                entry.axisName = params[1];
                entry.reflectedPointName = params[2];
                addObjectNameDep(entry.axisName);
                addObjectNameDep(entry.reflectedPointName);
                break;
            case 'translate':
                if (params.length === 3) {
                    entry.vectorName = params[1];
                    entry.translatedPointName = params[2];
                    addObjectNameDep(entry.vectorName);
                    addObjectNameDep(entry.translatedPointName);
                } else if (params.length === 4) {
                    entry.translatedPointName = params[1];
                    entry.dx_expr = params[2];
                    entry.dy_expr = params[3];
                    addObjectNameDep(entry.translatedPointName);
                    parseAndAddExpressionDeps(entry.dx_expr);
                    parseAndAddExpressionDeps(entry.dy_expr);
                } else {
                    throw new Error("translate 定义需要3或4个参数: translate(新点名, 向量, 作用点) 或 translate(新点名, 作用点, dx, dy)");
                }
                break;
                case 'fitline':
                if (params.length < 2) throw new Error("fitline 定义至少需要2个参数: fitline(名称, 顶点数, ...顶点名称)");
                const numFitPoints = parseInt(params[1], 10);
                if (isNaN(numFitPoints) || numFitPoints < 2) throw new Error("fitline 第2个参数必须是大于等于2的整数 (点数)");
                if (params.length !== numFitPoints + 2) throw new Error(`fitline 点数量与声明不符: 期望 ${numFitPoints}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
 case 'circulararc':
                if (params.length !== 4) throw new Error("circulararc 定义需要4个参数: circulararc(名称, 圆心, 起始点, 终点)");
                entry.centerName = params[1];
                entry.startPointName = params[2];
                entry.endPointName = params[3];
                addObjectNameDep(entry.centerName);
                addObjectNameDep(entry.startPointName);
                addObjectNameDep(entry.endPointName);
                break;
            case 'tangent':
                if (params.length !== 4) throw new Error("tangent 定义需要4个参数: tangent(名称, 圆锥曲线, 点, 符号)");
                entry.conicName = params[1];
                entry.pointName = params[2];
                entry.sign = parseInt(params[3], 10);
                if (isNaN(entry.sign) || (entry.sign !== 1 && entry.sign !== -1)) throw new Error("tangent 的第四个参数 (符号) 必须是 1 或 -1");
                addObjectNameDep(entry.conicName);
                addObjectNameDep(entry.pointName);
                break;
            default:
                throw new Error(`未知的几何对象类型: ${keyword}`);
        }

entry.variableDependencies = Array.from(allVarDeps);
        entry.objectDependencies = Array.from(allObjDeps);
        entry.dependencies = Array.from(new Set([...allVarDeps, ...allObjDeps]));
        
        const blockingSymbols = new Set([
            ...this.calcJSUtils.calc1,
            ...this.calcJSUtils.calc3,
            ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex && (e.type === 'variable' || e.type === 'constant' || e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition')).map(e => e.key || e.name).filter(Boolean).map(k => k.toLowerCase())
        ]);

        entry.variableDependencies.forEach(depKey => { 
           if (depKey.length === 1 && this.allowedVariableKeys.has(depKey) && !blockingSymbols.has(depKey)) {
               const initialValueForNewVar = 1;
               const newVarEntry = {
                   type: 'variable', name: depKey, key: depKey,
                   expr: `${depKey}=${initialValueForNewVar}`,
                   processedExpr: String(initialValueForNewVar), 
                   hasLargeOps: false, largeOpTokens: null,
                   dependencies: [], isEditableIndependent: true,
                   value: initialValueForNewVar, min: -2, max: 2, step: 0.05,
                   sliderActive: false, playState: 0, playDirection: 1,
                   compilationError: undefined
               };
               this.entries.push(newVarEntry);
               blockingSymbols.add(depKey);
           }
        });

        return entry;
    }

    recalculateVariableValues() {
        const maxIterations = 20;
        let iteration = 0;
        let changedInTotal = true;

        const independentVariableEntries = this.entries.filter(e => e.type === 'variable' && e.isEditableIndependent);
        const dependentVariableEntries = this.entries.filter(e => e.type === 'variable' && !e.isEditableIndependent);

        this.variables.clear();
        independentVariableEntries.forEach(entry => {
            if (Number.isFinite(entry.value)) {
                this.variables.set(entry.key, entry.value);
                entry.expr = `${entry.name}=${entry.value}`;
            } else {
                this.variables.set(entry.key, NaN);
            }
        });

        while (changedInTotal && iteration < maxIterations) {
           changedInTotal = false;

           for (const entry of dependentVariableEntries) {
               const allDependenciesDefined = entry.dependencies && Array.isArray(entry.dependencies) && entry.dependencies.every(depKey => this.variables.has(depKey) && Number.isFinite(this.variables.get(depKey)));

               let newValue = NaN;
               delete entry.compilationError;
               if (allDependenciesDefined || (entry.dependencies && entry.dependencies.length === 0)) {
                   try {
                        let exprToEval;
                        let tokensToUse;
                        if (entry.hasLargeOps) {
                             tokensToUse = entry.largeOpTokens;
                             exprToEval = null;
                        } else {
                             tokensToUse = null;
                             exprToEval = entry.processedExpr;
                        }

                        if (tokensToUse) {
                            newValue = this.evaluateExpressionWithCalcJS(tokensToUse, Object.fromEntries(this.variables));
                        } else if (exprToEval) {
                           const funcArgs = ['variables', 'Math', '__advanced__'];
                           const varDeclarations = Array.from(this.variables.keys()).map(depKey =>
                               `const ${depKey} = variables.has('${depKey}') ? variables.get('${depKey}') : NaN;`
                           ).join(' ');
                           const funcBody = `try { const variables = arguments[0]; const Math = arguments[1]; const __advanced__ = arguments[2]; ${varDeclarations} return (${exprToEval}); } catch(e) { return NaN; }`;
                           const expressionFunc = new Function(...funcArgs, funcBody);
                           newValue = expressionFunc(this.variables, Math, this.calcJSUtils.getAdvancedFuncsMap());
                        } else {
                            newValue = NaN;
                            entry.compilationError = "无有效表达式可求值";
                        }

                   } catch (e) {
                        newValue = NaN;
                        entry.compilationError = e.message;
                   }
               } else {
                    newValue = NaN;
                    if (entry.dependencies && entry.dependencies.length > 0) {
                        const missingDeps = entry.dependencies.filter(depKey => !this.variables.has(depKey) || !Number.isFinite(this.variables.get(depKey)));
                        if (missingDeps.length > 0) {
                             entry.compilationError = `依赖未定义: ${missingDeps.join(', ')}`;
                        }
                    }
               }

               const currentKeyForMap = entry.key;
               const oldValueInMap = this.variables.has(currentKeyForMap) ? this.variables.get(currentKeyForMap) : undefined;
               const valuesAreEqual = (v1, v2) => (Number.isNaN(v1) && Number.isNaN(v2)) || Math.abs(v1 - v2) < 1e-9;
                if (!valuesAreEqual(newValue, oldValueInMap)) {
                    this.variables.set(currentKeyForMap, newValue);
                    entry.value = newValue;
                    changedInTotal = true;
                } else {
                     entry.value = oldValueInMap;
                }
           }
           iteration++;
        }
        if (iteration === maxIterations && changedInTotal) {
           dependentVariableEntries.forEach(entry => {
                if(!entry.compilationError) entry.compilationError = "可能存在循环依赖";
           });
        }
    }

    recalculateGeometryObjects() {
    const geometryEntries = this.entries.filter(e => e.type === 'geometry');
    if (geometryEntries.length === 0) return;

    const objectMap = new Map();
    this.entries.forEach(e => {
        if (e.type === 'geometry' && e.name) {
            objectMap.set(e.name.toLowerCase(), e);
        }
    });

    const maxIterations = 20;
    let iteration = 0;
    let changedInIteration = true;

    while(changedInIteration && iteration < maxIterations) {
        changedInIteration = false;
        iteration++;

        for (const entry of geometryEntries) {
            const oldMeaningful = entry.isMeaningful;
            const oldValues = {x: entry.x_val, y: entry.y_val, r: entry.radius};

            let depsMeaningful = true;
            if (entry.variableDependencies) {
                for (const depName of entry.variableDependencies) {
                    if (!this.variables.has(depName) || !Number.isFinite(this.variables.get(depName))) {
                        depsMeaningful = false; 
                        break;
                    }
                }
            }
            if (depsMeaningful && entry.objectDependencies) {
                for (const depName of entry.objectDependencies) {
                    const depObj = objectMap.get(depName);
                    if (!depObj || !depObj.isMeaningful) {
                        depsMeaningful = false; 
                        break;
                    }
                }
            }

            if (!depsMeaningful) {
                entry.isMeaningful = false;
                if(oldMeaningful) changedInIteration = true;
                continue;
            }

            let newMeaningful = true;
            entry.compilationError = undefined;
            
            try {
                switch(entry.geometryType) {
                    case 'point': {
                        if (entry.pointOnObject) {
                            const onObject = objectMap.get(entry.onObjectName.toLowerCase());
                            if (!onObject || !onObject.isMeaningful) { newMeaningful = false; break; }
                            
                            const param = this.evaluateExpressionWithCalcJS(entry.parameter_expr, Object.fromEntries(this.variables));
                            if (!Number.isFinite(param)) { newMeaningful = false; break; }

                            const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);

                            if (isLineLike(onObject.geometryType)) {
                                if (['segment', 'vector'].includes(onObject.geometryType) && (param < 0 || param > 1)) {
                                    newMeaningful = false;
                                } else if (onObject.geometryType === 'ray' && param < 0) {
                                    newMeaningful = false;
                                }
                                
                                if (newMeaningful) {
                                    let p1_base, dir_to_use;
                                    if (onObject.p1 && (onObject.dir_vec || onObject.dir)) {
                                        p1_base = onObject.p1;
                                        dir_to_use = onObject.dir_vec || onObject.dir; 
                                        entry.x_val = p1_base.x_val + param * dir_to_use.x;
                                        entry.y_val = p1_base.y_val + param * dir_to_use.y;
                                    } else {
                                        newMeaningful = false;
                                    }
                                }

                            } else if (onObject.geometryType === 'circle') {
                                const angle = param * 2 * Math.PI;
                                entry.x_val = onObject.center.x_val + onObject.radius * Math.cos(angle);
                                entry.y_val = onObject.center.y_val + onObject.radius * Math.sin(angle);

                           } else if (onObject.geometryType === 'ellipse' || onObject.geometryType === 'ellipse_ab') {
                                if (!onObject.center || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const t = param * 2 * Math.PI;
                                const localX = onObject.a * Math.cos(t);
                                const localY = onObject.b * Math.sin(t);
                                entry.x_val = onObject.center.x + localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                entry.y_val = onObject.center.y + localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);

                            } else if (onObject.geometryType === 'hyperbola') {
                                if (!onObject.center || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const magic_offset = 100000;
                                let branch_sign = 1;
                                let t = param;

                                if (param < -magic_offset / 2) {
                                    branch_sign = -1;
                                    t = param + magic_offset;
                                }
                                
                                const localX = branch_sign * onObject.a * Math.cosh(t);
                                const localY = onObject.b * Math.sinh(t);
                                entry.x_val = onObject.center.x + localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                entry.y_val = onObject.center.y + localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);

                            } else if (onObject.geometryType === 'parabola') {
                                if (!onObject.vertex || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const t = param;
                                const localX = (t * t) / (4 * onObject.p);
                                const localY = t;
                                const rotatedLocalX = localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                const rotatedLocalY = localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);
                                entry.x_val = onObject.vertex.x + rotatedLocalX;
                                entry.y_val = onObject.vertex.y + rotatedLocalY;
                            } else if (onObject.geometryType === 'circulararc') {
                                if (!onObject.center || onObject.radius === undefined) { newMeaningful = false; break; }
                                let { startAngle, endAngle } = onObject;
                                if (endAngle < startAngle) endAngle += 2 * Math.PI;
                                
                                const angle = startAngle + param * (endAngle - startAngle);
                                entry.x_val = onObject.center.x_val + onObject.radius * Math.cos(angle);
                                entry.y_val = onObject.center.y_val + onObject.radius * Math.sin(angle);
                            }

                        } else {
                            const x = this.evaluateExpressionWithCalcJS(entry.x_expr, Object.fromEntries(this.variables));
                            const y = this.evaluateExpressionWithCalcJS(entry.y_expr, Object.fromEntries(this.variables));
                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                entry.x_val = x; entry.y_val = y;
                            } else newMeaningful = false;
                        }
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'midpoint': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        if (!p1 || !p2) { newMeaningful = false; break; }
                        entry.x_val = (p1.x_val + p2.x_val) / 2;
                        entry.y_val = (p1.y_val + p2.y_val) / 2;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                                        case 'rotate': {
                        const center = objectMap.get(entry.centerName.toLowerCase());
                        const p = objectMap.get(entry.rotatedPointName.toLowerCase());
                        if (!center || !p) { newMeaningful = false; break; }
                        const angle_deg = this.evaluateExpressionWithCalcJS(entry.angle_expr, Object.fromEntries(this.variables));
                        if (!Number.isFinite(angle_deg)) { newMeaningful = false; break; }
                        const angle_rad = angle_deg * (Math.PI / 180);
                        const cos_a = Math.cos(angle_rad);
                        const sin_a = Math.sin(angle_rad);
                        const rel_x = p.x_val - center.x_val;
                        const rel_y = p.y_val - center.y_val;
                        entry.x_val = center.x_val + rel_x * cos_a - rel_y * sin_a;
                        entry.y_val = center.y_val + rel_x * sin_a + rel_y * cos_a;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'reflect': {
                        const axis = objectMap.get(entry.axisName.toLowerCase());
                        const p = objectMap.get(entry.reflectedPointName.toLowerCase());
                        if (!axis || !p) { newMeaningful = false; break; }
                        
                        if (['point', 'midpoint', 'intercept'].includes(axis.geometryType)) {
                            entry.x_val = 2 * axis.x_val - p.x_val;
                            entry.y_val = 2 * axis.y_val - p.y_val;
                        } else {
                            const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                            if (!lineLike.includes(axis.geometryType) || !axis.p1 || !axis.dir) { newMeaningful = false; break; }
                            const {x_val: p1x, y_val: p1y} = axis.p1;
                            const {x: dirx, y: diry} = axis.dir;
                            const vec_ap = { x: p.x_val - p1x, y: p.y_val - p1y };
                            const t = vec_ap.x * dirx + vec_ap.y * diry;
                            const proj_x = p1x + t * dirx;
                            const proj_y = p1y + t * diry;
                            entry.x_val = 2 * proj_x - p.x_val;
                            entry.y_val = 2 * proj_y - p.y_val;
                        }
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'translate': {
                        const p = objectMap.get(entry.translatedPointName.toLowerCase());
                        if (!p) { newMeaningful = false; break; }
                        let dx = 0, dy = 0;
                        if (entry.vectorName) {
                            const v = objectMap.get(entry.vectorName.toLowerCase());
                            if (!v || !v.p1 || !v.p2) { newMeaningful = false; break; }
                            dx = v.p2.x_val - v.p1.x_val;
                            dy = v.p2.y_val - v.p1.y_val;
                        } else {
                            dx = this.evaluateExpressionWithCalcJS(entry.dx_expr, Object.fromEntries(this.variables));
                            dy = this.evaluateExpressionWithCalcJS(entry.dy_expr, Object.fromEntries(this.variables));
                            if (!Number.isFinite(dx) || !Number.isFinite(dy)) { newMeaningful = false; break; }
                        }
                        entry.x_val = p.x_val + dx;
                        entry.y_val = p.y_val + dy;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                 case 'intercept': {
                        const obj1 = objectMap.get(entry.obj1Name.toLowerCase());
                        const obj2 = objectMap.get(entry.obj2Name.toLowerCase());
                        if (!obj1 || !obj2 || !obj1.isMeaningful || !obj2.isMeaningful) { newMeaningful = false; break; }
                        
                        const type1 = obj1.geometryType;
                        const type2 = obj2.geometryType;
                        const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);
                        const isCircle = (t) => ['circle', 'circulararc'].includes(t);
                        const isConic = (t) => ['ellipse', 'hyperbola', 'parabola', 'ellipse_ab'].includes(t);
                        let intersectResult = null;

                        if (isLineLike(type1) && isLineLike(type2)) {
                            const {x_val: x1, y_val: y1} = obj1.p1;
                            const {x:dx1, y:dy1} = obj1.dir;
                            const {x_val: x2, y_val: y2} = obj2.p1;
                            const {x:dx2, y:dy2} = obj2.dir;
                            const det = dx1 * dy2 - dx2 * dy1;
                            if (Math.abs(det) < 1e-9) { newMeaningful = false; break; }
                            const t = ((x2 - x1) * dy2 - (y2 - y1) * dx2) / det;
                            intersectResult = { x: x1 + t * dx1, y: y1 + t * dy1 };
                        } else if ((isLineLike(type1) && isCircle(type2)) || (isCircle(type1) && isLineLike(type2))) {
                            const line = isLineLike(type1) ? obj1 : obj2;
                            const circle = isCircle(type1) ? obj1 : obj2;
                            const {x_val: lx, y_val: ly} = line.p1;
                            const {x:dx, y:dy} = line.dir;
                            const {x_val: cx, y_val: cy} = circle.center;
                            const r = circle.radius;
                            const A = dx*dx + dy*dy;
                            const B = 2 * (dx * (lx - cx) + dy * (ly - cy));
                            const C = (lx - cx)**2 + (ly - cy)**2 - r*r;
                            const discriminant = B*B - 4*A*C;
                            if (discriminant < -1e-9) { newMeaningful = false; break; }
                            const t = (-B + entry.sign * Math.sqrt(Math.max(0, discriminant))) / (2*A);
                            intersectResult = { x: lx + t * dx, y: ly + t * dy };
                        } else if (isCircle(type1) && isCircle(type2)) {
                            const {x_val: cx1, y_val: cy1} = obj1.center; const r1 = obj1.radius;
                            const {x_val: cx2, y_val: cy2} = obj2.center; const r2 = obj2.radius;
                            const d_sq = (cx1 - cx2)**2 + (cy1 - cy2)**2;
                            const d = Math.sqrt(d_sq);
                            if (d > r1 + r2 + 1e-9 || d < Math.abs(r1 - r2) - 1e-9 || d < 1e-9) { newMeaningful = false; break; }
                            const a = (r1*r1 - r2*r2 + d_sq) / (2*d);
                            const h = Math.sqrt(Math.max(0, r1*r1 - a*a));
                            const x_mid = cx1 + a * (cx2 - cx1) / d;
                            const y_mid = cy1 + a * (cy2 - cy1) / d;
                            intersectResult = { x: x_mid + entry.sign * h * (cy2 - cy1) / d, y: y_mid - entry.sign * h * (cx2 - cx1) / d };
                        } else if ((isLineLike(type1) && isConic(type2)) || (isConic(type1) && isLineLike(type2))) {
                            const line = isLineLike(type1) ? obj1 : obj2;
                            const conic = isConic(type1) ? obj1 : obj2;
                            const {x_val: x1, y_val: y1} = line.p1;
                            const {x:dx, y:dy} = line.dir;
                            let A=0, B=0, C=0;

                            if (conic.geometryType === 'ellipse' || conic.geometryType === 'hyperbola' || conic.geometryType === 'ellipse_ab') {
                                const {x: h, y: k} = conic.center;
                                const {a, b, rotation: r} = conic;
                                const cos_r = Math.cos(r), sin_r = Math.sin(r);
                                const x1_h = x1 - h, y1_k = y1 - k;
                                const T1 = cos_r * dx + sin_r * dy;
                                const T2 = -sin_r * dx + cos_r * dy;
                                const C1 = cos_r * x1_h + sin_r * y1_k;
                                const C2 = -sin_r * x1_h + cos_r * y1_k;
                                const sign = (conic.geometryType === 'ellipse' || conic.geometryType === 'ellipse_ab') ? 1 : -1;
                                A = T1*T1/(a*a) + sign*T2*T2/(b*b);
                                B = 2*C1*T1/(a*a) + 2*sign*C2*T2/(b*b);
                                C = C1*C1/(a*a) + sign*C2*C2/(b*b) - 1;
                            } else if (conic.geometryType === 'parabola') {
                                const {x_val: fx, y_val: fy} = conic.focus;
                                const {x_val: dpx, y_val: dpy} = conic.directrix.p1;
                                const {x: ddx, y: ddy} = conic.directrix.dir;
                                const A_par = 1, B_par = 0, C_par = -2*fx, D_par = -2*fy, E_par = fx*fx+fy*fy;
                                const A_dir = -ddy, B_dir = ddx, C_dir = ddy*dpx - ddx*dpy;
                                const F_dir = A_dir*A_dir + B_dir*B_dir;
                                const t_sq_coeff = A_par*dx*dx + B_par*dx*dy + ddx*ddx*dy*dy - 2*ddx*ddy*dx*dy + ddy*ddy*dx*dx;
                                const t_coeff = C_par*dx + D_par*dy + 2*A_par*x1*dx + B_par*(x1*dy+y1*dx) - 2*(A_dir*(x1*dx+A_dir) + B_dir*(y1*dy+B_dir) + C_dir*(A_dir*dx+B_dir*dy));
                                const const_coeff = A_par*x1*x1 + B_par*x1*y1 + C_par*x1 + D_par*y1 + E_par - (A_dir*x1+B_dir*y1+C_dir)**2;
                                A = t_sq_coeff/F_dir - 1;
                                B = t_coeff/F_dir;
                                C = const_coeff/F_dir;
                            }
                            
                            const discriminant = B*B - 4*A*C;
                            if (discriminant < -1e-9) { newMeaningful = false; break; }
                            const t = (-B + entry.sign * Math.sqrt(Math.max(0, discriminant))) / (2*A);
                            intersectResult = {x: x1 + t*dx, y: y1 + t*dy};

                        } else if ((isCircle(type1) && isConic(type2)) || (isConic(type1) && isCircle(type2)) || (isConic(type1) && isConic(type2))) {
                             entry.compilationError = "交点求解复杂"; newMeaningful = false; break;
                        }

                        if (intersectResult && Number.isFinite(intersectResult.x) && Number.isFinite(intersectResult.y)) {
                            const inBounds = (obj, pt) => {
                                if (['line', 'perpendicularline', 'parallelline', 'anglebisector', 'circle', 'ellipse', 'hyperbola', 'parabola', 'fitline', 'tangent', 'ellipse_ab'].includes(obj.geometryType)) return true;
                                if (obj.geometryType === 'circulararc') {
                                    const {x:px, y:py} = pt;
                                    const {x_val: cx, y_val: cy} = obj.center;
                                    let angle = Math.atan2(py - cy, px - cx);
                                    let sA = obj.startAngle;
                                    let eA = obj.endAngle;
                                    if (eA < sA) eA += 2 * Math.PI;
                                    
                                    let checkAngle = angle;
                                    while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
                                    while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;

                                    return checkAngle <= eA + 1e-9;
                                }
                                if (!obj.p1 || !obj.p2) return false;
                                const {x:px, y:py} = pt;
                                const {x_val: x1, y_val: y1} = obj.p1;
                                const {x_val: x2, y_val: y2} = obj.p2;
                                const dot = (px - x1) * (x2 - x1) + (py - y1) * (y2 - y1);
                                if (['ray', 'vector'].includes(obj.geometryType)) return dot >= -1e-9;
                                if (obj.geometryType === 'segment') {
                                    const len_sq = (x2-x1)**2 + (y2-y1)**2;
                                    return dot >= -1e-9 && dot <= len_sq + 1e-9;
                                }
                                return true;
                            };
                            if (!inBounds(obj1, intersectResult) || !inBounds(obj2, intersectResult)) {
                                newMeaningful = false;
                            } else {
                                entry.x_val = intersectResult.x;
                                entry.y_val = intersectResult.y;
                                entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                            }
                        } else {
                             newMeaningful = false;
                        }
                        break;
                    }
                    case 'segment': case 'ray': case 'line': case 'vector':
                    case 'perpendicularline': case 'parallelline': case 'anglebisector': {
                        let p1, p2, dir;
                        let isPointToPointLine = false;

                        if (['segment','ray','line','vector'].includes(entry.geometryType)) {
                            p1 = objectMap.get(entry.p1Name.toLowerCase());
                            p2 = objectMap.get(entry.p2Name.toLowerCase());
                            if (!p1 || !p2) { newMeaningful = false; break; }
                            dir = { x: p2.x_val - p1.x_val, y: p2.y_val - p1.y_val };
                            isPointToPointLine = true;
                        } else if (entry.geometryType === 'perpendicularline') {
                            const line = objectMap.get(entry.lineName.toLowerCase());
                            p1 = objectMap.get(entry.pointName.toLowerCase());
                            if (!line || !p1 || !line.dir) { newMeaningful = false; break; }
                            dir = { x: -line.dir.y, y: line.dir.x };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        } else if (entry.geometryType === 'parallelline') {
                            const line = objectMap.get(entry.lineName.toLowerCase());
                            p1 = objectMap.get(entry.pointName.toLowerCase());
                            if (!line || !p1 || !line.dir) { newMeaningful = false; break; }
                            dir = { ...line.dir };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        } else if (entry.geometryType === 'anglebisector') {
                            const pa = objectMap.get(entry.p1Name.toLowerCase());
                            p1 = objectMap.get(entry.vertexName.toLowerCase());
                            const pc = objectMap.get(entry.p3Name.toLowerCase());
                            if (!pa || !p1 || !pc) { newMeaningful = false; break; }
                            const ba = { x: pa.x_val - p1.x_val, y: pa.y_val - p1.y_val };
                            const bc = { x: pc.x_val - p1.x_val, y: pc.y_val - p1.y_val };
                            const len_ba = Math.sqrt(ba.x*ba.x + ba.y*ba.y);
                            const len_bc = Math.sqrt(bc.x*bc.x + bc.y*bc.y);
                            if(len_ba < 1e-9 || len_bc < 1e-9) { newMeaningful = false; break; }
                            dir = { x: ba.x/len_ba + bc.x/len_bc, y: ba.y/len_ba + bc.y/len_bc };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        }

                        entry.p1 = p1; 
                        entry.p2 = p2;
                        if (isPointToPointLine) {
                            entry.dir_vec = dir;
                        }

                        const dirLen = Math.sqrt(dir.x*dir.x + dir.y*dir.y);
                        if (dirLen < 1e-9) { newMeaningful = false; break; }
                        entry.dir = { x: dir.x / dirLen, y: dir.y / dirLen };
                        
                        if (newMeaningful) {
                            const p1_val = entry.p1;
                            const dir_val = entry.dir;
                            if (Math.abs(dir_val.x) < 1e-9) {
                                entry.detailsString = `x = ${p1_val.x_val.toPrecision(4)}`;
                            } else {
                                const m = dir_val.y / dir_val.x;
                                const b = p1_val.y_val - m * p1_val.x_val;
                                entry.detailsString = `y = ${m.toPrecision(3)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toPrecision(3)}`;
                            }
                        }
                        break;
                    }
                    case 'circle': {
                        entry.center = objectMap.get(entry.centerName.toLowerCase());
                        if (!entry.center) { newMeaningful = false; break; }
                        if (entry.pointOnCircleName) {
                            const pOn = objectMap.get(entry.pointOnCircleName.toLowerCase());
                            if (!pOn) { newMeaningful = false; break; }
                            entry.radius = Math.sqrt((pOn.x_val - entry.center.x_val)**2 + (pOn.y_val - entry.center.y_val)**2);
                        } else {
                            entry.radius = this.evaluateExpressionWithCalcJS(entry.radius_expr, Object.fromEntries(this.variables));
                        }
                        if (!Number.isFinite(entry.radius) || entry.radius <= 1e-9) newMeaningful = false;
                        if (newMeaningful) {
                            const h = entry.center.x_val;
                            const k = entry.center.y_val;
                            const r2 = entry.radius * entry.radius;
                            const x_part = `(x ${h > 0 ? '-' : '+'} ${Math.abs(h).toPrecision(3)})²`;
                            const y_part = `(y ${k > 0 ? '-' : '+'} ${Math.abs(k).toPrecision(3)})²`;
                            entry.detailsString = `${x_part} + ${y_part} = ${r2.toPrecision(3)}`;
                        }
                        break;
                    }
                    case 'ellipse_ab': {
                        const a = this.evaluateExpressionWithCalcJS(entry.a_expr, Object.fromEntries(this.variables));
                        const b = this.evaluateExpressionWithCalcJS(entry.b_expr, Object.fromEntries(this.variables));

                        if (!Number.isFinite(a) || !Number.isFinite(b) || a <= 0 || b <= 0) {
                            newMeaningful = false;
                            break;
                        }

                        entry.a = a;
                        entry.b = b;
                        entry.center = { x: 0, y: 0 };
                        entry.rotation = 0;

                        const c = Math.sqrt(Math.abs(a * a - b * b));
                        if (a > b) {
                            entry.f1 = { x_val: -c, y_val: 0 };
                            entry.f2 = { x_val: c, y_val: 0 };
                        } else {
                            entry.f1 = { x_val: 0, y_val: -c };
                            entry.f2 = { x_val: 0, y_val: c };
                        }

                        if (newMeaningful) {
                            const a2 = (a * a).toPrecision(3);
                            const b2 = (b * b).toPrecision(3);
                            entry.detailsString = `x²/${a2} + y²/${b2} = 1`;
                        }
                        break;
                    }
                    case 'ellipse': {
                        entry.f1 = objectMap.get(entry.f1Name.toLowerCase());
                        entry.f2 = objectMap.get(entry.f2Name.toLowerCase());
                        entry.p = objectMap.get(entry.pName.toLowerCase());
                        if (!entry.f1 || !entry.f2 || !entry.p) { newMeaningful = false; break; }
                        entry.dist_sum = Math.sqrt((entry.p.x_val-entry.f1.x_val)**2 + (entry.p.y_val-entry.f1.y_val)**2) + Math.sqrt((entry.p.x_val-entry.f2.x_val)**2 + (entry.p.y_val-entry.f2.y_val)**2);
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2)/2;
                        if (entry.dist_sum <= 2*c + 1e-9) { newMeaningful = false; break; }
                        entry.center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        entry.a = entry.dist_sum / 2;
                        entry.b = Math.sqrt(entry.a*entry.a - c*c);
                        entry.rotation = Math.atan2(f2y-f1y, f2x-f1x);
                        if (newMeaningful) {
                            const {a, b, rotation: r, center} = entry;
                            const cos_r = Math.cos(r), sin_r = Math.sin(r);
                            const h = center.x, k = center.y;
                            const a2 = a*a, b2 = b*b;
                            
                            const term1_A = cos_r*cos_r/a2 + sin_r*sin_r/b2;
                            const term1_B = 2*cos_r*sin_r/a2 - 2*cos_r*sin_r/b2;
                            const term1_C = sin_r*sin_r/a2 + cos_r*cos_r/b2;

                            const term2_D = -2*h*term1_A - k*term1_B;
                            const term2_E = -2*k*term1_C - h*term1_B;
                            
                            const term3_F = h*h*term1_A + k*k*term1_C + h*k*term1_B - 1;
                            
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'hyperbola': {
                        entry.f1 = objectMap.get(entry.f1Name.toLowerCase());
                        entry.f2 = objectMap.get(entry.f2Name.toLowerCase());
                        entry.p = objectMap.get(entry.pName.toLowerCase());
                        if (!entry.f1 || !entry.f2 || !entry.p) { newMeaningful = false; break; }
                        entry.dist_diff = Math.abs(Math.sqrt((entry.p.x_val-entry.f1.x_val)**2 + (entry.p.y_val-entry.f1.y_val)**2) - Math.sqrt((entry.p.x_val-entry.f2.x_val)**2 + (entry.p.y_val-entry.f2.y_val)**2));
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2) / 2;
                        if (entry.dist_diff >= 2*c - 1e-9 || entry.dist_diff < 1e-9) { newMeaningful = false; break; }
                        entry.center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        entry.a = entry.dist_diff / 2;
                        entry.b = Math.sqrt(c*c - entry.a*entry.a);
                        entry.rotation = Math.atan2(f2y-f1y, f2x-f1x);
                        if (newMeaningful) {
                            const {a, b, rotation: r, center} = entry;
                            const cos_r = Math.cos(r), sin_r = Math.sin(r);
                            const h = center.x, k = center.y;
                            const a2 = a*a, b2 = b*b;

                            const term1_A = cos_r*cos_r/a2 - sin_r*sin_r/b2;
                            const term1_B = 2*cos_r*sin_r/a2 + 2*cos_r*sin_r/b2;
                            const term1_C = sin_r*sin_r/a2 - cos_r*cos_r/b2;

                            const term2_D = -2*h*term1_A - k*term1_B;
                            const term2_E = -2*k*term1_C - h*term1_B;
                            
                            const term3_F = h*h*term1_A + k*k*term1_C + h*k*term1_B - 1;
                           
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'parabola': {
                        entry.focus = objectMap.get(entry.focusName.toLowerCase());
                        entry.directrix = objectMap.get(entry.directrixName.toLowerCase());
                        if (!entry.focus || !entry.directrix || !entry.directrix.dir) { newMeaningful = false; break; }
                        const {x_val: fx, y_val: fy} = entry.focus;
                        const {x_val: p1x, y_val: p1y} = entry.directrix.p1;
                        const {x: dirx, y: diry} = entry.directrix.dir;
                        const p2x = p1x + dirx, p2y = p1y + diry;
                        const k = ((p2y-p1y)*(fx-p1x) - (p2x-p1x)*(fy-p1y)) / ((p2y-p1y)**2 + (p2x-p1x)**2);
                        const proj_x = fx - k*(p2y-p1y), proj_y = fy + k*(p2x-p1x);
                        entry.vertex = {x: (fx+proj_x)/2, y: (fy+proj_y)/2};
                        entry.p = Math.sqrt((fx-entry.vertex.x)**2 + (fy-entry.vertex.y)**2);
                        entry.rotation = Math.atan2(fy-proj_y, fx-proj_x);
                        if (newMeaningful) {
                            const {x: h, y: v_k} = entry.vertex;
                            const {p, rotation: r} = entry;
                            const c = Math.cos(r), s = Math.sin(r);
                            const term1_A = s*s;
                            const term1_B = -2*c*s;
                            const term1_C = c*c;
                            const term2_D = -4*p*c - 2*h*s*s + 2*v_k*c*s;
                            const term2_E = -4*p*s + 2*h*c*s - 2*v_k*c*c;
                            const term3_F = h*h*s*s + v_k*v_k*c*c - 2*h*v_k*c*s + 4*p*h*c + 4*p*v_k*s;
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'polygon': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) newMeaningful = false;
                        entry.detailsString = "";
                        break;
                    }
                    case 'length': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        if (!p1 || !p2) { newMeaningful = false; break; }
                        entry.value = Math.hypot(p2.x_val - p1.x_val, p2.y_val - p1.y_val);
                        entry.detailsString = `l(${entry.p1Name}, ${entry.p2Name}) = ${entry.value.toPrecision(4)}`;
                        break;
                    }
                    case 'angle': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const vertex = objectMap.get(entry.vertexName.toLowerCase());
                        const p3 = objectMap.get(entry.p3Name.toLowerCase());
                        if (!p1 || !vertex || !p3) { newMeaningful = false; break; }

                        const v_BA = { x: p1.x_val - vertex.x_val, y: p1.y_val - vertex.y_val };
                        const v_BC = { x: p3.x_val - vertex.x_val, y: p3.y_val - vertex.y_val };
                        const len_BA = Math.hypot(v_BA.x, v_BA.y);
                        const len_BC = Math.hypot(v_BC.x, v_BC.y);

                        if (len_BA < 1e-9 || len_BC < 1e-9) { newMeaningful = false; break; }
                        
                        const dot = v_BA.x * v_BC.x + v_BA.y * v_BC.y;
                        const cos_theta = dot / (len_BA * len_BC);
                        entry.value = Math.acos(Math.max(-1, Math.min(1, cos_theta))) * (180 / Math.PI);
                        entry.detailsString = `∠(${entry.p1Name}, ${entry.vertexName}, ${entry.p3Name}) = ${entry.value.toPrecision(3)}°`;
                        break;
                    }
                    case 'area': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) { newMeaningful = false; break; }
                        let area_val = 0;
                        const n = entry.points.length;
                        for (let i = 0; i < n; i++) {
                            const p1 = entry.points[i];
                            const p2 = entry.points[(i + 1) % n];
                            area_val += (p1.x_val * p2.y_val - p2.x_val * p1.y_val);
                        }
                        entry.value = Math.abs(area_val) / 2.0;
                        entry.detailsString = `S(${entry.pointNames.join(', ')}) = ${entry.value.toPrecision(4)}`;
                        break;
                    }
                                        case 'isparallel': {
                        const l1 = objectMap.get(entry.l1Name.toLowerCase());
                        const l2 = objectMap.get(entry.l2Name.toLowerCase());
                        if (!l1 || !l2 || !l1.dir || !l2.dir) { newMeaningful = false; break; }
                        const cross_product_z = l1.dir.x * l2.dir.y - l1.dir.y * l2.dir.x;
                        entry.value = Math.abs(cross_product_z) < 1e-9 ? 1 : 0;
                        entry.detailsString = `${entry.name}(${entry.l1Name}, ${entry.l2Name}) = ${entry.value}`;
                        break;
                    }
                    case 'isperpendicular': {
                        const l1 = objectMap.get(entry.l1Name.toLowerCase());
                        const l2 = objectMap.get(entry.l2Name.toLowerCase());
                        if (!l1 || !l2 || !l1.dir || !l2.dir) { newMeaningful = false; break; }
                        const dot_product = l1.dir.x * l2.dir.x + l1.dir.y * l2.dir.y;
                        entry.value = Math.abs(dot_product) < 1e-9 ? 1 : 0;
                        entry.detailsString = `${entry.name}(${entry.l1Name}, ${entry.l2Name}) = ${entry.value}`;
                        break;
                    }
                    case 'isconcyclic': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        const p3 = objectMap.get(entry.p3Name.toLowerCase());
                        const p4 = objectMap.get(entry.p4Name.toLowerCase());
                        if (!p1 || !p2 || !p3 || !p4) { newMeaningful = false; break; }
                        
                        const {x_val: x1, y_val: y1} = p1;
                        const {x_val: x2, y_val: y2} = p2;
                        const {x_val: x3, y_val: y3} = p3;
                        const {x_val: x4, y_val: y4} = p4;

                        const ax = x2 - x1, ay = y2 - y1;
                        const bx = x3 - x1, by = y3 - y1;
                        const D = 2 * (ax * by - ay * bx);

                        if (Math.abs(D) < 1e-9) {
                            const a = {x: x2-x1, y: y2-y1};
                            const b = {x: x3-x1, y: y3-y1};
                            const c = {x: x4-x1, y: y4-y1};
                            const cross_ab = a.x * b.y - a.y * b.x;
                            const cross_ac = a.x * c.y - a.y * c.x;
                            entry.value = Math.abs(cross_ab) < 1e-9 && Math.abs(cross_ac) < 1e-9 ? 1 : 0;
                        } else {
                            const sqA = ax*ax + ay*ay;
                            const sqB = bx*bx + by*by;
                            const center_x = x1 + (sqA * by - sqB * ay) / D;
                            const center_y = y1 + (sqB * ax - sqA * bx) / D;
                            const radius_sq = (x1 - center_x)**2 + (y1 - center_y)**2;
                            const dist_p4_sq = (x4 - center_x)**2 + (y4 - center_y)**2;
                            
                            entry.value = Math.abs(dist_p4_sq - radius_sq) < 1e-7 ? 1 : 0;
                        }
                        entry.detailsString = `${entry.name}(${entry.p1Name}, ${entry.p2Name}, ${entry.p3Name}, ${entry.p4Name}) = ${entry.value}`;
                        break;
                    }                    case 'fitline': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) { newMeaningful = false; break; }
                        const n = entry.points.length;
                        if (n < 2) { newMeaningful = false; break; }

                        let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
                        for (const p of entry.points) {
                            sum_x += p.x_val;
                            sum_y += p.y_val;
                            sum_xy += p.x_val * p.y_val;
                            sum_x2 += p.x_val * p.x_val;
                        }

                        const denominator = n * sum_x2 - sum_x * sum_x;
                        if (Math.abs(denominator) < 1e-9) {
                            const avg_x = sum_x / n;
                            entry.p1 = { x_val: avg_x, y_val: 0 };
                            entry.p2 = { x_val: avg_x, y_val: 1 };
                            entry.dir = { x: 0, y: 1 };
                            entry.detailsString = `x = ${avg_x.toPrecision(4)}`;
                        } else {
                            const m = (n * sum_xy - sum_x * sum_y) / denominator;
                            const b = (sum_y - m * sum_x) / n;
                            entry.p1 = { x_val: 0, y_val: b };
                            entry.p2 = { x_val: 1, y_val: m + b };
                            const dir = { x: 1, y: m };
                            const dirLen = Math.hypot(dir.x, dir.y);
                            entry.dir = { x: dir.x / dirLen, y: dir.y / dirLen };
                            entry.detailsString = `y = ${m.toPrecision(3)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toPrecision(3)}`;
                        }
                        break;
                        
                    }
case 'circulararc': {
                        if (!entry.centerName || !entry.startPointName || !entry.endPointName) { newMeaningful = false; break; }
                        const center = objectMap.get(entry.centerName.toLowerCase());
                        const startPoint = objectMap.get(entry.startPointName.toLowerCase());
                        const endPoint = objectMap.get(entry.endPointName.toLowerCase());
                        if (!center || !startPoint || !endPoint) { newMeaningful = false; break; }
                        
                        entry.center = center;
                        entry.radius = Math.hypot(startPoint.x_val - center.x_val, startPoint.y_val - center.y_val);
                        if (entry.radius < 1e-9) { newMeaningful = false; break; }
                        
                        entry.startAngle = Math.atan2(startPoint.y_val - center.y_val, startPoint.x_val - center.x_val);
                        
                        const dir_vec_x = endPoint.x_val - center.x_val;
                        const dir_vec_y = endPoint.y_val - center.y_val;
                        const len = Math.hypot(dir_vec_x, dir_vec_y);
                        if (len < 1e-9) { newMeaningful = false; break; }

                        entry.endAngle = Math.atan2(dir_vec_y, dir_vec_x);
                        if (newMeaningful) {
                             entry.detailsString = `圆心: ${entry.centerName}, 半径: ${entry.radius.toPrecision(4)}`;
                        }
                        break;
                    }
                  case 'tangent': {
    if (!entry.conicName || !entry.pointName) { newMeaningful = false; break; }
    const conic = objectMap.get(entry.conicName.toLowerCase());
    const point = objectMap.get(entry.pointName.toLowerCase());
    if (!conic || !point || !conic.isMeaningful || !point.isMeaningful) { newMeaningful = false; break; }

    const { x_val: x0, y_val: y0 } = point;
    let A = 0, B = 0, C = 0, D = 0, E = 0, F = 0;
    let isValidConic = false;

    if (conic.geometryType === 'circle' || conic.geometryType === 'circulararc') {
        const { x_val: cx, y_val: cy } = conic.center;
        const r = conic.radius;
        A = 1;
        B = 1;
        C = 0;
        D = -2 * cx;
        E = -2 * cy;
        F = cx * cx + cy * cy - r * r;
        isValidConic = true;
    }else if (conic.geometryType === 'ellipse' || conic.geometryType === 'hyperbola' || conic.geometryType === 'ellipse_ab') { const { x: h, y: k } = conic.center; const { a, b, rotation: rot } = conic; const cos_r = Math.cos(rot), sin_r = Math.sin(rot); const sign = (conic.geometryType === 'ellipse' || conic.geometryType === 'ellipse_ab') ? 1 : -1;
        
        const Qu = 1/(a*a);
        const Qv = sign/(b*b);
        
        A = Qu * cos_r * cos_r + Qv * sin_r * sin_r;
        B = Qu * sin_r * sin_r + Qv * cos_r * cos_r;
        C = 2 * (Qu - Qv) * sin_r * cos_r;
        
        const U0 = -h * cos_r - k * sin_r;
        const V0 = h * sin_r - k * cos_r;
        
        D = 2 * Qu * cos_r * U0 - 2 * Qv * sin_r * V0;
        E = 2 * Qu * sin_r * U0 + 2 * Qv * cos_r * V0;
        F = Qu * U0 * U0 + Qv * V0 * V0 - 1;
        isValidConic = true;
    } else if (conic.geometryType === 'parabola') {
        const { x: h, y: k } = conic.vertex;
        const { p, rotation: rot } = conic;
        const c = Math.cos(rot);
        const s = Math.sin(rot);

        const V0 = h * s - k * c;
        const U0 = -h * c - k * s;
        
        A = s * s;
        B = c * c;
        C = -2 * s * c;
        D = -2 * s * V0 - 4 * p * c;
        E = 2 * c * V0 - 4 * p * s;
        F = V0 * V0 - 4 * p * U0;
        isValidConic = true;
    }

    if (!isValidConic) { newMeaningful = false; break; }

    const m11 = A, m12 = C/2, m13 = D/2;
    const m21 = C/2, m22 = B, m23 = E/2;
    const m31 = D/2, m32 = E/2, m33 = F;

    const S11 = m22 * m33 - m23 * m32;
    const S22 = m11 * m33 - m13 * m31;
    const S33 = m11 * m22 - m12 * m21;
    const S12 = -(m21 * m33 - m23 * m31); 
    const S13 = m21 * m32 - m22 * m31;    
    const S23 = -(m11 * m32 - m12 * m31); 
    
    const aq = S11 + S33 * x0 * x0 - 2 * S13 * x0;
    const bq = -2 * S12 + 2 * S13 * y0 + 2 * S23 * x0 - 2 * S33 * x0 * y0;
    const cq = S22 + S33 * y0 * y0 - 2 * S23 * y0;

    const epsilon = 1e-9;
    let solutions = [];


    if (Math.abs(aq) < epsilon) {
        const disc_vert = (C * x0 + E) * (C * x0 + E) - 4 * B * (A * x0 * x0 + D * x0 + F);
        if (Math.abs(disc_vert) < 1e-7) {
             solutions.push({ isVertical: true });
        }

        if (Math.abs(bq) > epsilon) {
            solutions.push({ isVertical: false, k: -cq / bq });
        }
    } else {
        const delta = bq * bq - 4 * aq * cq;
        if (delta >= -epsilon) {
            const sqrtDelta = Math.sqrt(Math.max(0, delta));
            const k1 = (-bq + sqrtDelta) / (2 * aq);
            solutions.push({ isVertical: false, k: k1 });
            
            if (delta > epsilon) {
                const k2 = (-bq - sqrtDelta) / (2 * aq);
                solutions.push({ isVertical: false, k: k2 });
            }
        }
    }

    if (solutions.length === 0) {
        newMeaningful = false;
    } else {
        let selectedSol;
        if (solutions.length === 1) {
            selectedSol = solutions[0];
        } else {
            if (entry.sign === 1) selectedSol = solutions[0];
            else selectedSol = solutions[1];
        }
        
        if (conic.geometryType === 'circulararc') {
             let touchX, touchY;
             const { x_val: cx, y_val: cy } = conic.center;
             
             if (selectedSol.isVertical) {
                 touchX = x0;
                 touchY = cy; 
             } else {
                 const k_sol = selectedSol.k;
                 const m = k_sol;
                 const b_line = y0 - m * x0;
                 
                 touchX = (cx + m * (cy - b_line)) / (1 + m * m);
                 touchY = m * touchX + b_line;
             }
             
             let angle = Math.atan2(touchY - cy, touchX - cx);
             let sA = conic.startAngle;
             let eA = conic.endAngle;
             if (eA < sA) eA += 2 * Math.PI;
             
             let checkAngle = angle;
             while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
             while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;
             
             if (!(checkAngle <= eA + 1e-9)) {
                 newMeaningful = false;
                 entry.compilationError = "切点不在圆弧范围内";
             }
        }

        if (newMeaningful) {
            if (selectedSol.isVertical) {
                entry.p1 = { x_val: x0, y_val: y0 };
                entry.p2 = { x_val: x0, y_val: y0 + 1 };
                entry.dir = { x: 0, y: 1 };
                entry.detailsString = `x = ${x0.toPrecision(4)}`;
            } else {
                const k_val = selectedSol.k;
                entry.p1 = { x_val: x0, y_val: y0 };
                entry.p2 = { x_val: x0 + 1, y_val: y0 + k_val };
                const len = Math.sqrt(1 + k_val * k_val);
                entry.dir = { x: 1 / len, y: k_val / len };
                const b_val = y0 - k_val * x0;
                entry.detailsString = `y = ${k_val.toPrecision(3)}x ${b_val >= 0 ? '+' : '-'} ${Math.abs(b_val).toPrecision(3)}`;
            }
        }
    }
    break;
}


                }
                entry.isMeaningful = newMeaningful;
            } catch (e) {
                entry.isMeaningful = false;
                entry.compilationError = e.message;
            }
            if (entry.isMeaningful !== oldMeaningful) changedInIteration = true;
            else if(entry.isMeaningful) {
                if ((entry.geometryType === 'point' || entry.geometryType === 'midpoint' || entry.geometryType === 'intercept') && (Math.abs(entry.x_val - oldValues.x) > 1e-9 || Math.abs(entry.y_val - oldValues.y) > 1e-9)) {
                    changedInIteration = true;
                } else if(entry.geometryType === 'circle' && Math.abs(entry.radius - oldValues.r) > 1e-9) {
                    changedInIteration = true;
                }
            }
        }
    }
}

    formatConicEquation(A,B,C,D,E,F) {
        const formatTerm = (val, termStr, isFirst = false) => {
            if (Math.abs(val) < 1e-7) return "";
            const sign = val > 0 ? (isFirst ? "" : "+ ") : "- ";
            const absVal = Math.abs(val);
            const numStr = Math.abs(absVal - 1) < 1e-7 ? "" : absVal.toPrecision(3);
            return `${sign}${numStr}${termStr} `;
        };

        let equation = formatTerm(A, "x²", true) +
                       formatTerm(B, "xy") +
                       formatTerm(C, "y²") +
                       formatTerm(D, "x") +
                       formatTerm(E, "y") +
                       formatTerm(F, "");
        
        return equation.trim() + " = 0";
    }
// --- 新增：将数学 Token 转译为原生 JS 代码字符串 (核心优化) ---
    _transpileTokensToJs(tokens) {
        let result = '';
        let i = 0;

        while (i < tokens.length) {
            const token = tokens[i];

            if (['sum', 'prod', 'int'].includes(token)) {
                // 1. 检查语法结构 sum(...)
                if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                    result += token; i++; continue;
                }
                const openParenIdx = i + 1;
                // 使用现有的工具查找匹配括号
                const closeParenIdx = this.calcJSUtils.findMatchingParen(tokens, openParenIdx);
                
                if (closeParenIdx === -1) {
                    result += token; i++; continue;
                }

                // 2. 提取4个参数：表达式、变量名、起始值、终止值
                // 注意：extractArguments 返回的是 token 数组的数组
                const args = this.calcJSUtils.extractArguments(tokens, openParenIdx, closeParenIdx, 4);
                
                // 3. 递归转译参数（支持嵌套，如 sum 里套 sum）
                const bodyJs = this._transpileTokensToJs(args[0]);
                const varName = args[1][0]; // 变量名通常是单个字符
                const startJs = this._transpileTokensToJs(args[2]);
                const endJs = this._transpileTokensToJs(args[3]);

                // 4. 生成 IIFE (立即执行函数) 形式的循环代码
                if (token === 'sum') {
                    result += `((() => { 
                        let __res = 0; 
                        let __s = Math.round(${startJs}); 
                        let __e = Math.round(${endJs});
                        // 防止死循环，限制最大迭代次数(可选)
                        if(Math.abs(__e - __s) > 100000) return NaN;
                        for(let ${varName} = __s; ${varName} <= __e; ${varName}++) {
                            __res += (${bodyJs});
                        }
                        return __res; 
                    })())`;
                } else if (token === 'prod') {
                    result += `((() => { 
                        let __res = 1; 
                        let __s = Math.round(${startJs}); 
                        let __e = Math.round(${endJs});
                        if(Math.abs(__e - __s) > 100000) return NaN;
                        for(let ${varName} = __s; ${varName} <= __e; ${varName}++) {
                            __res *= (${bodyJs});
                        }
                        return __res; 
                    })())`;
                } else if (token === 'int') {
                    // 积分：使用梯形法则
                    const steps = this.integralNumSteps || 100;
                    result += `((() => { 
                        let __sum = 0; 
                        let __a = (${startJs}); 
                        let __b = (${endJs});
                        let __n = ${steps};
                        let __h = (__b - __a) / __n;
                        if (Math.abs(__h) < 1e-15) return 0;
                        
                        // 首项 f(a) * 0.5
                        let ${varName} = __a;
                        let __val = (${bodyJs});
                        if (!Number.isFinite(__val)) __val = 0;
                        __sum += 0.5 * __val;

                        // 中间项
                        for(let __i = 1; __i < __n; __i++) {
                            ${varName} = __a + __i * __h;
                            __val = (${bodyJs});
                            if (!Number.isFinite(__val)) __val = 0;
                            __sum += __val;
                        }

                        // 尾项 f(b) * 0.5
                        ${varName} = __b;
                        __val = (${bodyJs});
                        if (!Number.isFinite(__val)) __val = 0;
                        __sum += 0.5 * __val;

                        return __sum * __h; 
                    })())`;
                }

                // 跳过已处理的 token 部分
                i = closeParenIdx + 1; 
            } else {
                // 普通 Token 直接拼接
                result += token;
                i++;
            }
        }
        return result;
    }

recompileFunctions() {
        const functionEntries = this.entries.filter(e => e.type === 'function');
        const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();

        const compileTokensToJs = (tokens) => {
            if (!tokens || !Array.isArray(tokens)) return "NaN";
            
            const placeholders = new Map();
            let placeholderCounter = 0;

            const transpileRecursive = (inputTokens) => {
                let outputTokens = [];
                let i = 0;
                while (i < inputTokens.length) {
                    const token = inputTokens[i];
                    if (['sum', 'prod', 'int'].includes(token)) {
                        if (i + 1 >= inputTokens.length || inputTokens[i+1] !== '(') { outputTokens.push(token); i++; continue; }
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.calcJSUtils.findMatchingParen(inputTokens, openParenIdx);
                        if (closeParenIdx === -1) { outputTokens.push(token); i++; continue; }
                        const args = this.calcJSUtils.extractArguments(inputTokens, openParenIdx, closeParenIdx, 4);
                        if (args.length !== 4) { outputTokens.push("NaN"); i = closeParenIdx + 1; continue; }

                        const bodyJs = compileInternal(args[0]);
                        const varName = args[1][0];
                        const startJs = compileInternal(args[2]);
                        const endJs = compileInternal(args[3]);

                        let loopCode = "";
                        if (token === 'sum') {
                            loopCode = `((() => { let __res = 0; let __s = Math.round(${startJs}); let __e = Math.round(${endJs}); if(Math.abs(__e - __s) > 50000) return 0; for(let ${varName} = __s; ${varName} <= __e; ${varName}++) { __res += (${bodyJs}); } return __res; })())`;
                        } else if (token === 'prod') {
                            loopCode = `((() => { let __res = 1; let __s = Math.round(${startJs}); let __e = Math.round(${endJs}); if(Math.abs(__e - __s) > 50000) return 0; for(let ${varName} = __s; ${varName} <= __e; ${varName}++) { __res *= (${bodyJs}); } return __res; })())`;
                        } else if (token === 'int') {
                            const steps = this.integralNumSteps || 100;
                            loopCode = `((() => { let __sum = 0; let __a = (${startJs}); let __b = (${endJs}); let __n = ${steps}; let __h = (__b - __a) / __n; if (Math.abs(__h) < 1e-15) return 0; let ${varName} = __a; let __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += 0.5 * __val; for(let __i = 1; __i < __n; __i++) { ${varName} = __a + __i * __h; __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += __val; } ${varName} = __b; __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += 0.5 * __val; return __sum * __h; })())`;
                        }
                        const key = `__ARCH_MACRO_${placeholderCounter++}__`;
                        placeholders.set(key, loopCode);
                        outputTokens.push(key);
                        i = closeParenIdx + 1;
                    } else { outputTokens.push(token); i++; }
                }
                return outputTokens;
            };

            const compileInternal = (ts) => {
                const tokensWithPlaceholders = transpileRecursive(ts);
                const processed = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, tokensWithPlaceholders);
                let str = processed.join('');
                if (placeholders.size > 0) { placeholders.forEach((val, key) => { str = str.split(key).join(val); }); }
                return str;
            };

            return compileInternal(tokens);
        };

        for (const entry of functionEntries) {
            delete entry.func; delete entry.funcX; delete entry.funcY; delete entry.funcZ; delete entry.compilationError;
            entry.webglVertices = null;

            // 检查依赖有效性（不阻断编译，因为有可能是内部变量）
            const allValid = !entry.dependencies || entry.dependencies.every(k => this.variables.has(k) && Number.isFinite(this.variables.get(k)));
            if (!allValid && !entry.dependencies.some(d => ['x','y','z','t'].includes(d))) {
                // 仅当确实缺少全局变量时标记，但我们继续尝试编译，因为可能是参数
            }

            const makeFunc = (args, bodyStr) => {
                if (!bodyStr) return () => NaN;
                
                // 核心修复：过滤掉已经是函数参数(args)的变量名，防止重复声明错误
                // 这确保了如果 args=['a'] 且 dependencies=['a', 'b']，只有 'b' 会被从全局变量中获取
                const validDependencies = (entry.dependencies || []).filter(k => !args.includes(k));
                
                const varDecls = validDependencies.map(k => `const ${k} = variables.has('${k}') ? variables.get('${k}') : NaN;`).join(' ');

                // 生成源码。注意这里不需要再手动从 arguments 映射 args，因为 new Function 的签名已经包含了它们
                const src = `try { 
                    ${varDecls} 
                    return (${bodyStr}); 
                } catch(e) { return NaN; }`;

                return new Function(...args, 'variables', 'Math', '__advanced__', src);
            };

            try {
                if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                    entry.funcX = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensX));
                    entry.funcY = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensY));
                    if (entry.plotType === 'parametric3d') {
                        entry.funcZ = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensZ));
                    }
                } else {
                    let args = [];
                    if (['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType)) args = ['x', 'y', 'z'];
                    else if (entry.plotType === 'y') args = ['x'];
                    else if (entry.plotType === 'x') args = ['y'];
                    else args = ['x', 'y'];

                    if (entry.hasLargeOps) {
                        entry.func = makeFunc(args, compileTokensToJs(entry.largeOpTokens));
                    } else {
                        entry.func = makeFunc(args, entry.processedExpr);
                    }
                    
                    // 简单的测试运行以捕获运行时错误（可选）
                    if (entry.plotType !== 'parametric' && entry.plotType !== 'parametric3d') {
                         // entry.func(...args.map(_=>0), this.variables, Math, advancedFuncsMap);
                    }
                }
            } catch (e) {
                console.warn("Recompile error:", e);
                entry.compilationError = "编译错误: " + e.message;
                entry.func = () => NaN;
            }
        }
    }

recalculateForGeometryDrag(draggedEntry) {
    this.recalculateGeometryObjects();


    this.recompileFunctions();


    this.clearPlotData();


    this.updateEntryVariableValuesDisplay();
    this.updateGeometryMeasurementDisplay();


    this.requestDraw();
}

     recalculateAll() {
        
        this.restoreOriginalPrecisions();
        this.isAnimatingWithPerformanceMode = false;
        this.isZooming = false;
        this.isSmoothPanningActive = false;

        this.recalculateVariableValues();
        this.recalculatePointLists();
        this.recalculateGeometryObjects();
        this.recompileFunctions();
        if (this.is3DMode) {
            this.recalculate3D();
        }

        this.entries.forEach(entry => {
            if (entry.type === 'function' && (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y')) {
                entry.webglVertices = null;
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            }
            if (entry.type === 'geometry') {
                entry.webglVertices = null;
            }
        });

if (this.traceState.active && this.traceState.targetName) {
            const targetEntry = this.entries.find(e => e.name === this.traceState.targetName);
            if (targetEntry && targetEntry.isMeaningful) {
                const newPoint = {x: targetEntry.x_val, y: targetEntry.y_val};
                const lastPoint = this.traceState.path[this.traceState.path.length - 1];
                if (!lastPoint || Math.hypot(newPoint.x - lastPoint.x, newPoint.y - lastPoint.y) > 1e-9) {
                    this.traceState.path.push(newPoint);
                }
            }
        }

        this.updateEntryList();
        this.clearPlotData();
        this.requestDraw();
    }

recalculateForAnimation() {
        if (this.lowPrecisionBufferEnabled && this.globalPlayState === 1 && !this.isZooming && !this.isPanning && !this.isSmoothPanningActive) {
            if (!this.isUsingLowPrecisionBuffer) {
                this.originalExplicitPrecision = this.explicitPrecisionStep;
                this.originalImplicitPrecision = this.implicitPrecisionStep;
                this.isUsingLowPrecisionBuffer = true;
            }
            this.explicitPrecisionStep = 1;
            this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
        } else if (this.isUsingLowPrecisionBuffer && this.globalPlayState === 0) {
            this.restoreOriginalPrecisions();
            this.isUsingLowPrecisionBuffer = false;
        } else if (this.isAnimatingWithPerformanceMode && this.globalPlayState === 0) {
            this.restoreOriginalPrecisions();
            this.isAnimatingWithPerformanceMode = false;
        }

        this.recalculateVariableValues();
         this.recalculatePointLists();
        this.recalculateGeometryObjects();
        this.recompileFunctions();

        if (this.is3DMode) {
            this.recalculate3D();
        }

        this.entries.forEach(entry => {
            if (entry.type === 'function' && (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y')) {
                entry.webglVertices = null;
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            }
            if (entry.type === 'geometry') {
                entry.webglVertices = null;
                entry.webglFillVertices = null;
            }
        });
        this.updateEntryVariableValuesDisplay();
        this.clearPlotData();
        this.requestDraw();
    }

recalculate3D() {
        if (!this.is3DMode) return;
        
        this.cache3D.meshes.clear();
        this.cache3D.lines.clear();
        
        const baseMap = this.calcJSUtils.getAdvancedFuncsMap();
        const advancedFuncsMap = { ...baseMap };
        const originalPow = advancedFuncsMap.pow;
        advancedFuncsMap.pow = (a, b) => {
            if (a < 0 && Math.abs(b - Math.round(b)) > 1e-10) return NaN;
            return originalPow(a, b);
        };

        const range = this.bounds3D; 
    
    this.entries.forEach((entry, index) => {
        const isVisible = this.getEffectiveVisibility(entry); if ((!isVisible && !this.showHiddenMath && !this.showHiddenGeo) || entry.compilationError) return; 
        if (this.showPlaybackControls && this.currentFrame !== 0 && entry.displayFrame !== 0 && entry.displayFrame !== this.currentFrame) return;
        if (entry.type !== 'function') return;

        const is2D = ['y', 'x', 'parametric', 'implicit'].includes(entry.plotType);
        const is3D = ['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType);
        
        if (is2D && !this.overlayDrawingEnabled && !entry.extendTo3D) return;

        if (is3D && entry.sliceAxis !== 'none') {

            const axis = entry.sliceAxis;
            const k = entry.sliceVal;
            const vertices = [];
            
            const mcRes = Math.max(10, Math.min(200, Math.floor(250 / this.implicitPrecisionStep)));
            const step = (range * 2) / mcRes;
            const values = new Float32Array((mcRes + 1) * (mcRes + 1));
            let vIdx = 0;

            
            for (let v = 0; v <= mcRes; v++) {
                const fv_screen = -range + v * step;
                const fv_math = fv_screen * this.scale3D; 
                for (let u = 0; u <= mcRes; u++) {
                    const fu_screen = -range + u * step;
                    const fu_math = fu_screen * this.scale3D;
                    
                    let x_math, y_math, z_math;
                    if (axis === 'x') { x_math = k; y_math = fu_math + this.offset3D.y*this.scale3D; z_math = fv_math; } 
                    else if (axis === 'y') { x_math = fu_math + this.offset3D.x*this.scale3D; y_math = k; z_math = fv_math; } 
                    else { x_math = fu_math + this.offset3D.x*this.scale3D; y_math = fv_math + this.offset3D.y*this.scale3D; z_math = k; } 

                    let val = NaN;
                    try {
                        if (entry.plotType === 'z') {
                            val = entry.func(x_math, y_math, 0, this.variables, Math, advancedFuncsMap) - z_math;
                        } else if (entry.plotType === 'x3d') {
                            val = entry.func(0, y_math, z_math, this.variables, Math, advancedFuncsMap) - x_math;
                        } else if (entry.plotType === 'y3d') {
                            val = entry.func(x_math, 0, z_math, this.variables, Math, advancedFuncsMap) - y_math;
                        } else {
                            val = entry.func(x_math, y_math, z_math, this.variables, Math, advancedFuncsMap);
                        }
                    } catch (e) {}
                    values[vIdx++] = Number.isFinite(val) ? val : NaN;
                }
            }

            const getOffset2D = (v1, v2) => {
                 const delta = v2 - v1;
                 if (Math.abs(delta) < 1e-9) return 0.5;
                 return Math.max(0, Math.min(1, (0 - v1) / delta));
            };
            
            const N = mcRes + 1;
            const lineVerts = [];
            
            const pushSliceSegment = (u1, v1, u2, v2) => {
            
                let x1, y1, z1, x2, y2, z2;
              
                const k_screen = k / this.scale3D;
          
                
                let s1_x, s1_y, s1_z, s2_x, s2_y, s2_z;
                
                if (axis === 'x') {
                    s1_x = k_screen - this.offset3D.x; s1_y = u1; s1_z = v1;
                    s2_x = k_screen - this.offset3D.x; s2_y = u2; s2_z = v2;
                } else if (axis === 'y') {
                    s1_x = u1; s1_y = k_screen - this.offset3D.y; s1_z = v1;
                    s2_x = u2; s2_y = k_screen - this.offset3D.y; s2_z = v2;
                } else {
                    s1_x = u1; s1_y = v1; s1_z = k_screen;
                    s2_x = u2; s2_y = v2; s2_z = k_screen;
                }
                

                const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useThickLines = entryThickness > 1.5;
                
                if (!useThickLines) {
                    lineVerts.push(s1_x, s1_y, s1_z, s2_x, s2_y, s2_z);
                } else {
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z,  1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z,  1.0);
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z, -1.0);
                    
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z, -1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z,  1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z, -1.0);
                }
            };

            for (let v = 0; v < mcRes; v++) {
                for (let u = 0; u < mcRes; u++) {
                    const idx = u + v * N;
                    const v0 = values[idx], v1 = values[idx + 1], v2 = values[idx + 1 + N], v3 = values[idx + N];
                    if (Number.isNaN(v0) || Number.isNaN(v1) || Number.isNaN(v2) || Number.isNaN(v3)) continue;
                    
                    let sqIdx = 0;
                    if (v0 < 0) sqIdx |= 8; if (v1 < 0) sqIdx |= 4; if (v2 < 0) sqIdx |= 2; if (v3 < 0) sqIdx |= 1;
                    if (sqIdx === 0 || sqIdx === 15) continue;
                    
                    const fu = -range + u * step, fv = -range + v * step;
                    const pT = {u: fu + step * getOffset2D(v0, v1), v: fv};
                    const pR = {u: fu + step, v: fv + step * getOffset2D(v1, v2)};
                    const pB = {u: fu + step * getOffset2D(v3, v2), v: fv + step};
                    const pL = {u: fu, v: fv + step * getOffset2D(v0, v3)};

                    switch(sqIdx) {
                        case 1: case 14: pushSliceSegment(pL.u, pL.v, pB.u, pB.v); break;
                        case 2: case 13: pushSliceSegment(pB.u, pB.v, pR.u, pR.v); break;
                        case 3: case 12: pushSliceSegment(pL.u, pL.v, pR.u, pR.v); break;
                        case 4: case 11: pushSliceSegment(pT.u, pT.v, pR.u, pR.v); break;
                        case 5: pushSliceSegment(pT.u, pT.v, pL.u, pL.v); pushSliceSegment(pB.u, pB.v, pR.u, pR.v); break;
                        case 6: case 9: pushSliceSegment(pT.u, pT.v, pB.u, pB.v); break;
                        case 7: case 8: pushSliceSegment(pT.u, pT.v, pL.u, pL.v); break;
                        case 10: pushSliceSegment(pT.u, pT.v, pR.u, pR.v); pushSliceSegment(pB.u, pB.v, pL.u, pL.v); break;
                    }
                }
            }
            
            const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
            const useThickLines = entryThickness > 1.5;
            const count = lineVerts.length / (useThickLines ? 7 : 3);
            
            if (count > 0) {
                this.cache3D.lines.set(index, { 
                    vbo: this.createBuffer(lineVerts), 
                    count: count,
                    color: entry.color,
                    mode: useThickLines ? this.gl.TRIANGLES : this.gl.LINES,
                    thickness: entryThickness,
                    isThick: useThickLines
                });
            }

        } else if (is2D && entry.extendTo3D) {

            const isImplicitExtrusion = (entry.plotType === 'implicit');
            const isExplicitExtrusionX = (entry.plotType === 'x');
            const isExplicitExtrusionY = (entry.plotType === 'y');

            if (isExplicitExtrusionX || isExplicitExtrusionY) {

                const vertices = [];
                const normals = [];
                const resolution = Math.max(10, Math.floor(15 * this.explicitPrecisionStep));
                const step = (range * 2) / resolution;
                const grid = [];
                

                for(let i=0; i<=resolution; i++) {
                    for(let j=0; j<=resolution; j++) {
                        let u_screen = -range + i * step;
                        let v_screen = -range + j * step; 
                        let x_screen, y_screen, z_screen;
                        

                        
                        try {
                            if (isExplicitExtrusionY) {

                                x_screen = u_screen;
                                const x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                const y_math = entry.func(x_math, this.variables, Math, advancedFuncsMap);
                                y_screen = y_math / this.scale3D - this.offset3D.y;
                                z_screen = v_screen;
                            } else {

                                y_screen = u_screen;
                                const y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                const x_math = entry.func(y_math, this.variables, Math, advancedFuncsMap);
                                x_screen = x_math / this.scale3D - this.offset3D.x;
                                z_screen = v_screen;
                            }
                        } catch(e) { x_screen = NaN; }

                        if (Number.isFinite(x_screen) && Number.isFinite(y_screen) && Number.isFinite(z_screen)) {
                            grid.push({x: x_screen, y: y_screen, z: z_screen});
                        } else {
                            grid.push(null);
                        }
                    }
                }
                
                const N = resolution + 1;
                for(let i=0; i<resolution; i++) {
                    for(let j=0; j<resolution; j++) {
                        const idx = i * N + j;
                        const p1 = grid[idx]; const p2 = grid[idx+1]; const p3 = grid[idx+N]; const p4 = grid[idx+N+1];
                        if (p1 && p2 && p3) vertices.push(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z, p2.x, p2.y, p2.z);
                        if (p2 && p3 && p4) vertices.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z, p4.x, p4.y, p4.z);
                    }
                }
                
          
                 for(let k=0; k<vertices.length; k+=9) {
                     const ux = vertices[k+3] - vertices[k], uy = vertices[k+4] - vertices[k+1], uz = vertices[k+5] - vertices[k+2];
                     const vx = vertices[k+6] - vertices[k], vy = vertices[k+7] - vertices[k+1], vz = vertices[k+8] - vertices[k+2];
                     let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                     const len = Math.sqrt(nx*nx+ny*ny+nz*nz);
                     if (len > 0) { nx/=len; ny/=len; nz/=len; } else { nx=0; ny=0; nz=1; }
                     normals.push(nx,ny,nz, nx,ny,nz, nx,ny,nz); 
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else if (isImplicitExtrusion) {

                const vertices = [];
                const normals = [];
                const mcRes = Math.max(10, Math.min(160, Math.floor(200 / this.implicitPrecisionStep)));
                const step = (range * 2) / mcRes;
                const values = new Float32Array((mcRes + 1) * (mcRes + 1) * (mcRes + 1));
                
                let vIdx = 0;

                const layerValues = new Float32Array((mcRes + 1) * (mcRes + 1));
                
                for (let y = 0; y <= mcRes; y++) {
                    const fy_screen = -range + y * step;
                    const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                    for (let x = 0; x <= mcRes; x++) {
                        const fx_screen = -range + x * step;
                        const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                        let val = NaN;
                        try {
        
                            val = entry.func(fx_math, fy_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) {}
                         layerValues[y * (mcRes + 1) + x] = Number.isFinite(val) ? Math.max(-1e6, Math.min(1e6, val)) : NaN;
                    }
                }

                for (let z = 0; z <= mcRes; z++) {
                    values.set(layerValues, vIdx);
                    vIdx += layerValues.length;
                }

                const getOffset = (v1, v2) => {
                    const delta = v2 - v1;
                    if (Math.abs(delta) < 1e-9) return 0.5;
                    return Math.max(0, Math.min(1, (0 - v1) / delta));
                };

                 const getGradient = (x, y) => {
                    const h = 0.001 * this.scale3D;
                    let valMinusX, valPlusX, valMinusY, valPlusY;
                    try {
                        valMinusX = entry.func(x - h, y, this.variables, Math, advancedFuncsMap);
                        valPlusX = entry.func(x + h, y, this.variables, Math, advancedFuncsMap);
                        valMinusY = entry.func(x, y - h, this.variables, Math, advancedFuncsMap);
                        valPlusY = entry.func(x, y + h, this.variables, Math, advancedFuncsMap);
                    } catch(e) { return [0,1,0]; }

                    const dx = valPlusX - valMinusX;
                    const dy = valPlusY - valMinusY;
                    const dz = 0;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len > 1e-9) return [-dx/len, -dy/len, 0];
                    return [0, 1, 0];
                };

                const N = mcRes + 1;
                const NN = N * N;

                for (let z = 0; z < mcRes; z++) {
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N + z * NN;
                            if (Number.isNaN(values[idx])) continue; 
                            let cubeIndex = 0;
                            if (values[idx] < 0) cubeIndex |= 1;
                            if (values[idx + 1] < 0) cubeIndex |= 2;
                            if (values[idx + 1 + N] < 0) cubeIndex |= 4;
                            if (values[idx + N] < 0) cubeIndex |= 8;
                            if (values[idx + NN] < 0) cubeIndex |= 16;
                            if (values[idx + 1 + NN] < 0) cubeIndex |= 32;
                            if (values[idx + 1 + N + NN] < 0) cubeIndex |= 64;
                            if (values[idx + N + NN] < 0) cubeIndex |= 128;
                            if (edgeTable[cubeIndex] === 0) continue;

                            const fx = -range + x * step;
                            const fy = -range + y * step;
                            const fz = -range + z * step;
                            const vertList = new Array(12);

                            const v0=values[idx], v1=values[idx+1], v2=values[idx+1+N], v3=values[idx+N];
                            const v4=values[idx+NN], v5=values[idx+1+NN], v6=values[idx+1+N+NN], v7=values[idx+N+NN];
                            
                            if (edgeTable[cubeIndex] & 1) vertList[0] = [fx + step * getOffset(v0, v1), fy, fz];
                            if (edgeTable[cubeIndex] & 2) vertList[1] = [fx + step, fy + step * getOffset(v1, v2), fz];
                            if (edgeTable[cubeIndex] & 4) vertList[2] = [fx + step * (1 - getOffset(v2, v3)), fy + step, fz];
                            if (edgeTable[cubeIndex] & 8) vertList[3] = [fx, fy + step * (1 - getOffset(v3, v0)), fz];
                            if (edgeTable[cubeIndex] & 16) vertList[4] = [fx + step * getOffset(v4, v5), fy, fz + step];
                            if (edgeTable[cubeIndex] & 32) vertList[5] = [fx + step, fy + step * getOffset(v5, v6), fz + step];
                            if (edgeTable[cubeIndex] & 64) vertList[6] = [fx + step * (1 - getOffset(v6, v7)), fy + step, fz + step];
                            if (edgeTable[cubeIndex] & 128) vertList[7] = [fx, fy + step * (1 - getOffset(v7, v4)), fz + step];
                            if (edgeTable[cubeIndex] & 256) vertList[8] = [fx, fy, fz + step * getOffset(v0, v4)];
                            if (edgeTable[cubeIndex] & 512) vertList[9] = [fx + step, fy, fz + step * getOffset(v1, v5)];
                            if (edgeTable[cubeIndex] & 1024) vertList[10] = [fx + step, fy + step, fz + step * getOffset(v2, v6)];
                            if (edgeTable[cubeIndex] & 2048) vertList[11] = [fx, fy + step, fz + step * getOffset(v3, v7)];

                            for (let k = 0; triTable[cubeIndex][k] !== -1; k += 3) {
                                const p1 = vertList[triTable[cubeIndex][k]];
                                const p2 = vertList[triTable[cubeIndex][k + 1]];
                                const p3 = vertList[triTable[cubeIndex][k + 2]];
                                if (p1 && p2 && p3) {
                                    const n1 = getGradient((p1[0] + this.offset3D.x) * this.scale3D, (p1[1] + this.offset3D.y) * this.scale3D);
                                    const n2 = getGradient((p2[0] + this.offset3D.x) * this.scale3D, (p2[1] + this.offset3D.y) * this.scale3D);
                                    const n3 = getGradient((p3[0] + this.offset3D.x) * this.scale3D, (p3[1] + this.offset3D.y) * this.scale3D);
                                    vertices.push(...p1, ...p2, ...p3);
                                    normals.push(...n1, ...n2, ...n3);
                                }
                            }
                        }
                    }
                }
                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }
            }

        } else {

            if (entry.plotType === 'z' || entry.plotType === 'x3d' || entry.plotType === 'y3d') {
                const vertices = [];
                const normals = [];
                const resolution = Math.max(10, Math.floor(15 * this.explicitPrecisionStep));
                const step = (range * 2) / resolution;
                const grid = [];
                
                for(let i=0; i<=resolution; i++) {
                    for(let j=0; j<=resolution; j++) {
                        let u_screen = -range + i * step;
                        let v_screen = -range + j * step;
                        let x_math, y_math, z_math;
                        let x_screen, y_screen, z_screen;
                        
                        try {
                            if (entry.plotType === 'z') {
                                x_screen = u_screen; y_screen = v_screen;
                                x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                z_math = entry.func(x_math, y_math, 0, this.variables, Math, advancedFuncsMap);
                                z_screen = z_math / this.scale3D;
                            } else if (entry.plotType === 'x3d') {
                                y_screen = u_screen; z_screen = v_screen;
                                y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                z_math = z_screen * this.scale3D; 
                                x_math = entry.func(0, y_math, z_math, this.variables, Math, advancedFuncsMap);
                                x_screen = x_math / this.scale3D - this.offset3D.x;
                            } else { 
                                x_screen = u_screen; z_screen = v_screen;
                                x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                z_math = z_screen * this.scale3D;
                                y_math = entry.func(x_math, 0, z_math, this.variables, Math, advancedFuncsMap);
                                y_screen = y_math / this.scale3D - this.offset3D.y;
                            }
                        } catch(e) { z_math = NaN; }

                        if (Number.isFinite(x_screen) && Number.isFinite(y_screen) && Number.isFinite(z_screen)) {
                            grid.push({x: x_screen, y: y_screen, z: z_screen});
                        } else {
                            grid.push(null);
                        }
                    }
                }
                
                const N = resolution + 1;
                for(let i=0; i<resolution; i++) {
                    for(let j=0; j<resolution; j++) {
                        const idx = i * N + j;
                        const p1 = grid[idx];
                        const p2 = grid[idx+1]; 
                        const p3 = grid[idx+N]; 
                        const p4 = grid[idx+N+1];
                        
                        if (p1 && p2 && p3) vertices.push(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z, p2.x, p2.y, p2.z);
                        if (p2 && p3 && p4) vertices.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z, p4.x, p4.y, p4.z);
                    }
                }
                
                for(let k=0; k<vertices.length; k+=9) {
                     const ux = vertices[k+3] - vertices[k], uy = vertices[k+4] - vertices[k+1], uz = vertices[k+5] - vertices[k+2];
                     const vx = vertices[k+6] - vertices[k], vy = vertices[k+7] - vertices[k+1], vz = vertices[k+8] - vertices[k+2];
                     let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                     const len = Math.sqrt(nx*nx+ny*ny+nz*nz);
                     if (len > 0) { nx/=len; ny/=len; nz/=len; } else { nx=0; ny=0; nz=1; }
                     normals.push(nx,ny,nz, nx,ny,nz, nx,ny,nz); 
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else if (entry.plotType === 'implicit3d') {

                const vertices = [];
                const normals = [];
                const mcRes = Math.max(10, Math.min(160, Math.floor(200 / this.implicitPrecisionStep)));
                const step = (range * 2) / mcRes;
                const values = new Float32Array((mcRes + 1) * (mcRes + 1) * (mcRes + 1));
                
                let vIdx = 0;
                for (let z = 0; z <= mcRes; z++) {
                    const fz_screen = -range + z * step;
                    const fz_math = fz_screen * this.scale3D;
                    for (let y = 0; y <= mcRes; y++) {
                        const fy_screen = -range + y * step;
                        const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                        for (let x = 0; x <= mcRes; x++) {
                            const fx_screen = -range + x * step;
                            const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                            let val = NaN;
                            try {
                                val = entry.func(fx_math, fy_math, fz_math, this.variables, Math, advancedFuncsMap);
                            } catch (e) {}
                            values[vIdx++] = Number.isFinite(val) ? Math.max(-1e6, Math.min(1e6, val)) : NaN;
                        }
                    }
                }
                
                const getOffset = (v1, v2) => {
                    const delta = v2 - v1;
                    if (Math.abs(delta) < 1e-9) return 0.5;
                    return Math.max(0, Math.min(1, (0 - v1) / delta));
                };

                const getGradient = (x, y, z) => {
                    const h = 0.001 * this.scale3D;
                    let valMinusX, valPlusX, valMinusY, valPlusY, valMinusZ, valPlusZ;
                    try {
                        valMinusX = entry.func(x - h, y, z, this.variables, Math, advancedFuncsMap);
                        valPlusX = entry.func(x + h, y, z, this.variables, Math, advancedFuncsMap);
                        valMinusY = entry.func(x, y - h, z, this.variables, Math, advancedFuncsMap);
                        valPlusY = entry.func(x, y + h, z, this.variables, Math, advancedFuncsMap);
                        valMinusZ = entry.func(x, y, z - h, this.variables, Math, advancedFuncsMap);
                        valPlusZ = entry.func(x, y, z + h, this.variables, Math, advancedFuncsMap);
                    } catch(e) { return [0,1,0]; }

                    const dx = valPlusX - valMinusX;
                    const dy = valPlusY - valMinusY;
                    const dz = valPlusZ - valMinusZ;
                    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (len > 1e-9) return [-dx/len, -dy/len, -dz/len];
                    return [0, 1, 0];
                };

                const N = mcRes + 1;
                const NN = N * N;

                for (let z = 0; z < mcRes; z++) {
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N + z * NN;
                            const val0 = values[idx];
                            if (Number.isNaN(val0)) continue; 

                            let cubeIndex = 0;
                            if (values[idx] < 0) cubeIndex |= 1;
                            if (values[idx + 1] < 0) cubeIndex |= 2;
                            if (values[idx + 1 + N] < 0) cubeIndex |= 4;
                            if (values[idx + N] < 0) cubeIndex |= 8;
                            if (values[idx + NN] < 0) cubeIndex |= 16;
                            if (values[idx + 1 + NN] < 0) cubeIndex |= 32;
                            if (values[idx + 1 + N + NN] < 0) cubeIndex |= 64;
                            if (values[idx + N + NN] < 0) cubeIndex |= 128;
                            
                            if (edgeTable[cubeIndex] === 0) continue;
                            
                            const fx = -range + x * step;
                            const fy = -range + y * step;
                            const fz = -range + z * step;
                            
                            const vertList = new Array(12);
                            const v0=values[idx], v1=values[idx+1], v2=values[idx+1+N], v3=values[idx+N];
                            const v4=values[idx+NN], v5=values[idx+1+NN], v6=values[idx+1+N+NN], v7=values[idx+N+NN];
                            
                            if (edgeTable[cubeIndex] & 1) vertList[0] = [fx + step * getOffset(v0, v1), fy, fz];
                            if (edgeTable[cubeIndex] & 2) vertList[1] = [fx + step, fy + step * getOffset(v1, v2), fz];
                            if (edgeTable[cubeIndex] & 4) vertList[2] = [fx + step * (1 - getOffset(v2, v3)), fy + step, fz];
                            if (edgeTable[cubeIndex] & 8) vertList[3] = [fx, fy + step * (1 - getOffset(v3, v0)), fz];
                            if (edgeTable[cubeIndex] & 16) vertList[4] = [fx + step * getOffset(v4, v5), fy, fz + step];
                            if (edgeTable[cubeIndex] & 32) vertList[5] = [fx + step, fy + step * getOffset(v5, v6), fz + step];
                            if (edgeTable[cubeIndex] & 64) vertList[6] = [fx + step * (1 - getOffset(v6, v7)), fy + step, fz + step];
                            if (edgeTable[cubeIndex] & 128) vertList[7] = [fx, fy + step * (1 - getOffset(v7, v4)), fz + step];
                            if (edgeTable[cubeIndex] & 256) vertList[8] = [fx, fy, fz + step * getOffset(v0, v4)];
                            if (edgeTable[cubeIndex] & 512) vertList[9] = [fx + step, fy, fz + step * getOffset(v1, v5)];
                            if (edgeTable[cubeIndex] & 1024) vertList[10] = [fx + step, fy + step, fz + step * getOffset(v2, v6)];
                            if (edgeTable[cubeIndex] & 2048) vertList[11] = [fx, fy + step, fz + step * getOffset(v3, v7)];
                            
                            for (let k = 0; triTable[cubeIndex][k] !== -1; k += 3) {
                                const p1 = vertList[triTable[cubeIndex][k]];
                                const p2 = vertList[triTable[cubeIndex][k + 1]];
                                const p3 = vertList[triTable[cubeIndex][k + 2]];
                                
                                if (p1 && p2 && p3) {
                                    const n1 = getGradient((p1[0] + this.offset3D.x) * this.scale3D, (p1[1] + this.offset3D.y) * this.scale3D, p1[2] * this.scale3D);
                                    const n2 = getGradient((p2[0] + this.offset3D.x) * this.scale3D, (p2[1] + this.offset3D.y) * this.scale3D, p2[2] * this.scale3D);
                                    const n3 = getGradient((p3[0] + this.offset3D.x) * this.scale3D, (p3[1] + this.offset3D.y) * this.scale3D, p3[2] * this.scale3D);
                                    
                                    vertices.push(...p1, ...p2, ...p3);
                                    normals.push(...n1, ...n2, ...n3);
                                }
                            }
                        }
                    }
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else {

                const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useThickLines = entryThickness > 1.5;
                const lineVerts = [];

                const pushSegment = (x1, y1, z1, x2, y2, z2) => {
                    if (!useThickLines) {
                        lineVerts.push(x1, y1, z1, x2, y2, z2);
                    } else {

                        lineVerts.push(x1,y1,z1, x2,y2,z2,  1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1,  1.0);
                        lineVerts.push(x1,y1,z1, x2,y2,z2, -1.0);
                        
                        lineVerts.push(x1,y1,z1, x2,y2,z2, -1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1,  1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1, -1.0);
                    }
                };

                if (entry.plotType === 'parametric3d' || entry.plotType === 'parametric') {
                    const numSteps = Math.max(100, Math.floor(this.explicitPrecisionStep * 200));
                    const tStep = (this.tmax - this.tmin) / numSteps;
                    let lastP = null;
                    
                    for (let i = 0; i <= numSteps; i++) {
                       const t = this.tmin + i * tStep;
                       let x_math, y_math, z_math;
                       try {
                           x_math = entry.funcX(t, this.variables, Math, advancedFuncsMap);
                           y_math = entry.funcY(t, this.variables, Math, advancedFuncsMap);
                           if (entry.plotType === 'parametric3d') z_math = entry.funcZ(t, this.variables, Math, advancedFuncsMap);
                           else z_math = 0;
                       } catch(e) { x_math=NaN; }
                       
                       if (Number.isFinite(x_math) && Number.isFinite(y_math) && Number.isFinite(z_math)) {
                           const currentP = {
                               x: x_math / this.scale3D - this.offset3D.x,
                               y: y_math / this.scale3D - this.offset3D.y,
                               z: z_math / this.scale3D
                           };
                           if (Math.abs(currentP.x) <= range && Math.abs(currentP.y) <= range && Math.abs(currentP.z) <= range) {
                               if (lastP) pushSegment(lastP.x, lastP.y, lastP.z, currentP.x, currentP.y, currentP.z);
                               lastP = currentP;
                           } else {
                               lastP = null;
                           }
                       } else {
                           lastP = null;
                       }
                    }
                } else if (entry.plotType === 'y' || entry.plotType === 'x') {
                    const numSteps = Math.max(100, Math.floor(this.explicitPrecisionStep * 200));
                    const rangeX = this.bounds3D; 
                    const step = (rangeX * 2) / numSteps;
                    let lastP = null;
                    for (let i = 0; i <= numSteps; i++) {
                        const val1 = -rangeX + i * step;
                        let x_math, y_math;
                        try {
                            if (entry.plotType === 'y') {
                                x_math = (val1 + this.offset3D.x) * this.scale3D;
                                y_math = entry.func(x_math, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_math = (val1 + this.offset3D.y) * this.scale3D;
                                x_math = entry.func(y_math, this.variables, Math, advancedFuncsMap);
                            }
                        } catch(e) { x_math=NaN; y_math=NaN; }
                        if (Number.isFinite(x_math) && Number.isFinite(y_math)) {
                             const currentP = {
                               x: x_math / this.scale3D - this.offset3D.x,
                               y: y_math / this.scale3D - this.offset3D.y,
                               z: 0
                           };
                           if (Math.abs(currentP.x) <= range && Math.abs(currentP.y) <= range) {
                               if (lastP) pushSegment(lastP.x, lastP.y, lastP.z, currentP.x, currentP.y, currentP.z);
                               lastP = currentP;
                           } else { lastP = null; }
                        } else lastP = null;
                    }
                } else if (entry.plotType === 'implicit') {
                    const mcRes = Math.max(10, Math.min(200, Math.floor(250 / this.implicitPrecisionStep)));
                    const step = (range * 2) / mcRes;
                    const values = new Float32Array((mcRes + 1) * (mcRes + 1));
                    let vIdx = 0;
                    for (let y = 0; y <= mcRes; y++) {
                        const fy_screen = -range + y * step;
                        const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                        for (let x = 0; x <= mcRes; x++) {
                            const fx_screen = -range + x * step;
                            const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                            let val = NaN;
                            try { val = entry.func(fx_math, fy_math, this.variables, Math, advancedFuncsMap); } catch (e) {}
                            values[vIdx++] = Number.isFinite(val) ? val : NaN;
                        }
                    }
                    const getOffset2D = (v1, v2) => {
                         const delta = v2 - v1;
                         if (Math.abs(delta) < 1e-9) return 0.5;
                         return Math.max(0, Math.min(1, (0 - v1) / delta));
                    };
                    const N = mcRes + 1;
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N;
                            const v0 = values[idx], v1 = values[idx + 1], v2 = values[idx + 1 + N], v3 = values[idx + N];
                            if (Number.isNaN(v0) || Number.isNaN(v1) || Number.isNaN(v2) || Number.isNaN(v3)) continue;
                            let sqIdx = 0;
                            if (v0 < 0) sqIdx |= 8; if (v1 < 0) sqIdx |= 4; if (v2 < 0) sqIdx |= 2; if (v3 < 0) sqIdx |= 1;
                            if (sqIdx === 0 || sqIdx === 15) continue;
                            const fx = -range + x * step, fy = -range + y * step;
                            const pT = {x: fx + step * getOffset2D(v0, v1), y: fy, z: 0};
                            const pR = {x: fx + step, y: fy + step * getOffset2D(v1, v2), z: 0};
                            const pB = {x: fx + step * getOffset2D(v3, v2), y: fy + step, z: 0};
                            const pL = {x: fx, y: fy + step * getOffset2D(v0, v3), z: 0};
                            switch(sqIdx) {
                                case 1: case 14: pushSegment(pL.x, pL.y, 0, pB.x, pB.y, 0); break;
                                case 2: case 13: pushSegment(pB.x, pB.y, 0, pR.x, pR.y, 0); break;
                                case 3: case 12: pushSegment(pL.x, pL.y, 0, pR.x, pR.y, 0); break;
                                case 4: case 11: pushSegment(pT.x, pT.y, 0, pR.x, pR.y, 0); break;
                                case 5: pushSegment(pT.x, pT.y, 0, pL.x, pL.y, 0); pushSegment(pB.x, pB.y, 0, pR.x, pR.y, 0); break;
                                case 6: case 9: pushSegment(pT.x, pT.y, 0, pB.x, pB.y, 0); break;
                                case 7: case 8: pushSegment(pT.x, pT.y, 0, pL.x, pL.y, 0); break;
                                case 10: pushSegment(pT.x, pT.y, 0, pR.x, pR.y, 0); pushSegment(pB.x, pB.y, 0, pL.x, pL.y, 0); break;
                            }
                        }
                    }
                }
                
                const count = lineVerts.length / (useThickLines ? 7 : 3);
                
                this.cache3D.lines.set(index, { 
                    vbo: this.createBuffer(lineVerts), 
                    count: count,
                    color: entry.color,
                    mode: useThickLines ? this.gl.TRIANGLES : this.gl.LINES,
                    thickness: entryThickness,
                    isThick: useThickLines
                });
            }
        }
    });
    this.calculateAuxiliary3D();
}


    createBuffer(data) {
        const buf = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buf);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
        return buf;
    }

draw3D() {
        const gl = this.gl;
        const width = this.canvas.width; 
        const height = this.canvas.height; 
        const dpr = window.devicePixelRatio || 1;
        
        const sidebar = document.getElementById('sidebar-background');

        const isSidebarVisible = !document.body.classList.contains('sidebar-hidden') && sidebar && (this.isTransparencyEnabled || this.isPortraitMode);
        
        let viewX = 0;
        let viewY = 0;
        let viewW = width;
        let viewH = height;
        
        if (isSidebarVisible) {
            const rect = sidebar.getBoundingClientRect();
            if (this.isPortraitMode) {
                const sidebarHeightPhysical = rect.height * dpr;
                viewH = height - sidebarHeightPhysical;
                viewY = sidebarHeightPhysical; 
            } else {
                const sidebarWidthPhysical = rect.width * dpr;
                viewX = sidebarWidthPhysical;
                viewW = width - sidebarWidthPhysical;
            }
        }
        
        this.viewport3D = {
            x: viewX / dpr,
            y: viewY / dpr, 
            w: viewW / dpr,
            h: viewH / dpr
        };

        gl.viewport(viewX, viewY, viewW, viewH);
        
        const isDark = this.isDarkModeActive;
        
        if (isDark) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0); 
        } else {
            const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
            let r = 1.0, g = 1.0, b_val = 1.0;
            const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
            if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255; }
            gl.clearColor(r, g, b_val, 1.0);
        }

        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const aspect = viewW / viewH;
        const projection = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta),
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta),
            z: cam.rho * Math.cos(cam.phi)
        };
        
        const view = Mat4.lookAt(Mat4.create(), eye, {x:0, y:0, z:0}, {x:0, y:0, z:1});
        const mvp = Mat4.multiply(Mat4.create(), projection, view);
        
        const lightDir = [eye.x, eye.y, eye.z];

        gl.useProgram(this.shaderProgram3D);
        gl.uniformMatrix4fv(this.uniformLoc3D.mvp, false, mvp);
        gl.uniformMatrix4fv(this.uniformLoc3D.normalMat, false, Mat4.create()); 
        gl.uniform3fv(this.uniformLoc3D.lightDir, lightDir);
        gl.uniform1f(this.uniformLoc3D.bounds, this.bounds3D);

this.cache3D.meshes.forEach((mesh, idx) => {
            const entry = this.entries[idx];
            if (!entry || !entry.visible) return;
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.position);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.nbo);
            gl.vertexAttribPointer(this.attribLoc3D.normal, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.normal);
            
            const col = this.hsbToRgbaArray(mesh.color.h, mesh.color.s, mesh.color.b, mesh.color.a);
            gl.uniform4fv(this.uniformLoc3D.color, col);
            
            gl.drawArrays(gl.TRIANGLES, 0, mesh.count);
        });
        
        if (this.showAxes && this.cache3D.axes) {
             gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.axes.vbo);
             gl.vertexAttribPointer(this.attribLoc3D.position, 3, gl.FLOAT, false, 24, 0);
             gl.enableVertexAttribArray(this.attribLoc3D.position);
             gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.axes.vbo); 
             gl.vertexAttribPointer(this.attribLoc3D.normal, 3, gl.FLOAT, false, 24, 12); 
             gl.enableVertexAttribArray(this.attribLoc3D.normal);
             
             gl.uniform4f(this.uniformLoc3D.color, 0.8, 0.1, 0.1, 1.0); 
             gl.drawArrays(gl.TRIANGLES, 0, this.cache3D.axes.count / 3);
             gl.uniform4f(this.uniformLoc3D.color, 0.1, 0.1, 0.8, 1.0);
             gl.drawArrays(gl.TRIANGLES, this.cache3D.axes.count / 3, this.cache3D.axes.count / 3);
             gl.uniform4f(this.uniformLoc3D.color, 0.1, 0.8, 0.1, 1.0);
             gl.drawArrays(gl.TRIANGLES, 2 * this.cache3D.axes.count / 3, this.cache3D.axes.count / 3);
        }

        gl.useProgram(this.shaderProgram3DLine);
        gl.uniformMatrix4fv(this.uniformLoc3D.lineMvp, false, mvp);
        gl.uniform1f(this.uniformLoc3D.lineBounds, this.bounds3D);
        
        if (this.gridStyle !== 'hidden' && this.cache3D.grid) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.grid.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.linePos);
            const gridCol = isDark ? 0.3 : 0.7;
            gl.uniform4f(this.uniformLoc3D.lineColor, gridCol, gridCol, gridCol, 1.0);
            gl.drawArrays(gl.LINES, 0, this.cache3D.grid.count);
        }

        if (this.cache3D.box) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.box.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cache3D.box.ibo);
            const boxCol = isDark ? 0.6 : 0.5;
            gl.uniform4f(this.uniformLoc3D.lineColor, boxCol, boxCol, boxCol, 1.0);
            gl.drawElements(gl.LINES, this.cache3D.box.count, gl.UNSIGNED_SHORT, 0);
        }
        
        if (this.showAxes && this.cache3D.ticks) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.ticks.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            const tickCol = isDark ? 0.9 : 0.2;
            gl.uniform4f(this.uniformLoc3D.lineColor, tickCol, tickCol, tickCol, 1.0);
            gl.drawArrays(gl.LINES, 0, this.cache3D.ticks.count);
        }

this.cache3D.lines.forEach((line, idx) => {
            const entry = this.entries[idx];
            if (!entry || !entry.visible) return;
            
            if (line.isThick) {
                gl.useProgram(this.shaderProgram3DThick);
                gl.uniformMatrix4fv(this.uniformLoc3D.thickMvp, false, mvp);
                gl.uniform2f(this.uniformLoc3D.thickViewport, viewW, viewH);
                gl.uniform1f(this.uniformLoc3D.thickThickness, line.thickness);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
                
                const stride = 28; 
                gl.vertexAttribPointer(this.attribLoc3D.thickPos, 3, gl.FLOAT, false, stride, 0);
                gl.enableVertexAttribArray(this.attribLoc3D.thickPos);
                
                gl.vertexAttribPointer(this.attribLoc3D.thickOther, 3, gl.FLOAT, false, stride, 12);
                gl.enableVertexAttribArray(this.attribLoc3D.thickOther);
                
                gl.vertexAttribPointer(this.attribLoc3D.thickSide, 1, gl.FLOAT, false, stride, 24);
                gl.enableVertexAttribArray(this.attribLoc3D.thickSide);
                
                const col = this.hsbToRgbaArray(line.color.h, line.color.s, line.color.b, line.color.a);
                gl.uniform4fv(this.uniformLoc3D.thickColor, col);
                
                gl.drawArrays(gl.TRIANGLES, 0, line.count);
                
            } else {
                gl.useProgram(this.shaderProgram3DLine);
                gl.uniformMatrix4fv(this.uniformLoc3D.lineMvp, false, mvp);
                gl.uniform1f(this.uniformLoc3D.lineBounds, this.bounds3D);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
                gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.attribLoc3D.linePos);
                
                const col = this.hsbToRgbaArray(line.color.h, line.color.s, line.color.b, line.color.a);
                gl.uniform4fv(this.uniformLoc3D.lineColor, col);
                
                gl.drawArrays(gl.LINES, 0, line.count);
            }
        });
        

this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        if (this.showAxes && this.showAxisNumbers) {
            this.draw3DLabels(mvp, viewW, viewH, viewX, viewY);
        }
    }



 draw3DLabels(mvp, width, height, viewX, viewY) {
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        
        ctx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        
        if (!this.cache3D.labels) return;

        ctx.save();
        ctx.scale(dpr, dpr);
        
        ctx.beginPath();
        ctx.rect(viewX / dpr, (this.canvas.height - viewY - height) / dpr, width / dpr, height / dpr);
        ctx.clip();

        ctx.font = "16px 'HarmonyOS_SC', Arial";
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const cssViewWidth = width / dpr;
        const cssViewHeight = height / dpr;
        const cssViewX = viewX / dpr;

        const cssViewY = (this.canvas.height - viewY - height) / dpr;

        this.cache3D.labels.forEach(lbl => {
            const pos = [lbl.x, lbl.y, lbl.z];
            Mat4.transformVec3(pos, pos, mvp);
            
            if (pos[2] > 1.0 || pos[2] < -1.0) return;
            
            const x_rel = (pos[0] + 1) * 0.5 * cssViewWidth;
            const y_rel = (1 - pos[1]) * 0.5 * cssViewHeight;
            
            const x = cssViewX + x_rel;
            const y = cssViewY + y_rel;
            
            ctx.fillText(lbl.text, x, y);
        });
        
        ctx.restore();
    }


evaluateExpression(processedExprString) {
try {
    const funcArgs = ['variables', 'Math', '__advanced__'];
    const varDeclarations = Array.from(this.variables.keys()).map(depKey =>
       `const ${depKey} = variables.has('${depKey}') ? variables.get('${depKey}') : NaN;`
    ).join(' ');
     const mathDeclaration = 'const Math = arguments[1];';
     const advancedDeclaration = 'const __advanced__ = arguments[2];';
    const funcBody = `try { const variables = arguments[0]; ${mathDeclaration} ${advancedDeclaration} ${varDeclarations} return (${processedExprString}); } catch(e) { return NaN; }`;
    const expressionFunc = new Function(...funcArgs, funcBody);
    const result = expressionFunc(this.variables, Math, this.calcJSUtils.getAdvancedFuncsMap());
    return (typeof result === 'number' && !Number.isFinite(result) && !Number.isNaN(result)) ? NaN : result;
} catch (e) {
    throw new Error(`在 evaluateExpression 中求值错误: ${e.message} 表达式: ${processedExprString}`);
}
}

substituteVariablesForEvaluation(exprString) {
let result = exprString;
const sortedVariableKeys = Array.from(this.variables.keys()).sort((a, b) => b.length - a.length);
for (const varKey of sortedVariableKeys) {
   const value = this.variables.get(varKey);
   const valueString = Number.isFinite(value) ? String(value) : 'NaN';
   const regex = new RegExp(`\\b${varKey}\\b`, 'gi');
   result = result.replace(regex, `(${valueString})`);
}
return result;
}

substituteVariables(exprString) {
let substituted = exprString;
const sortedVariableEntries = this.entries.filter(e => e.type === 'variable').sort((a, b) => b.name.length - a.name.length);
for (const entry of sortedVariableEntries) {
    const varName = entry.name;
    const varKey = entry.key;
    const value = this.variables.get(varKey);
     const valueString = Number.isFinite(value) ? String(value) : 'NaN';
    const regex = new RegExp(`\\b${varName}\\b`, 'gi');
    substituted = substituted.replace(regex, `(${valueString})`);
}
return substituted;
}

      toggleGlobalScriptView() {
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        const scriptView = document.getElementById('global-script-view');
        const toggleBtn = document.getElementById('global-script-toggle-btn');
        
        if (scriptView.style.display === 'none') {

            listView.style.display = 'none';
            editorView.style.display = 'none';
            scriptView.style.display = 'flex';
            toggleBtn.textContent = '退出编辑';
            document.getElementById('main-content-title').textContent = "全局脚本";
        } else {

            scriptView.style.display = 'none';
            listView.style.display = 'flex';
            toggleBtn.textContent = '全局脚本';
            document.getElementById('main-content-title').textContent = "代码";
        }
    }

    stopGlobalScript() {
        if (this.globalScriptIntervalId) {
            clearInterval(this.globalScriptIntervalId);
            this.globalScriptIntervalId = null;
        }
        this.pen.segments = [];
        this.requestDraw();
    }





     deleteEntryByIdentifier(identifier, allowedTypes) {
        const lowerIdentifier = identifier.toLowerCase();

        const indexToDelete = this.entries.findIndex(e =>
            allowedTypes.includes(e.type) &&
            ((e.name && e.name.toLowerCase() === lowerIdentifier) ||
             (e.key && e.key === lowerIdentifier) ||
             (e.expr && e.expr.toLowerCase() === lowerIdentifier))
        );

        if (indexToDelete !== -1) {
            this._handleCascadingDelete(indexToDelete);
        }
    }



        _handleCascadingDelete(startIndex) {
        if (startIndex < 0 || startIndex >= this.entries.length) return;

        const initialEntry = this.entries[startIndex];
        const isInitialEntryGeometric = initialEntry.type === 'geometry';

        const itemsToDeleteIndices = new Set([startIndex]);
        const queue = [];
        const initialIdentifier = (initialEntry.name || initialEntry.key || '').toLowerCase();
        if (initialIdentifier) queue.push(initialIdentifier);

        const processedInQueue = new Set(queue);

        while (queue.length > 0) {
            const currentId = queue.shift();
            for (let i = 0; i < this.entries.length; i++) {
                if (itemsToDeleteIndices.has(i)) continue;
                const dependentEntry = this.entries[i];

                if (dependentEntry.dependencies && dependentEntry.dependencies.includes(currentId)) {
                    const isDependentEntryGeometric = dependentEntry.type === 'geometry';
                    

                    if (isInitialEntryGeometric === isDependentEntryGeometric) {
                        itemsToDeleteIndices.add(i);
                        const dependentId = (dependentEntry.name || dependentEntry.key || '').toLowerCase();
                        if (dependentId && !processedInQueue.has(dependentId)) {
                            queue.push(dependentId);
                            processedInQueue.add(dependentId);
                        }
                    }
                }
            }
        }

        const sortedIndices = Array.from(itemsToDeleteIndices).sort((a, b) => b - a);
        sortedIndices.forEach(idx => {
            const entryToDelete = this.entries[idx];
            if (entryToDelete) {
                if (entryToDelete.type === 'custom_function_definition') {
                    delete this.calcJSUtils.customFunctions[entryToDelete.name];
                    this.calcJSUtils.calc3 = this.calcJSUtils.calc3.filter(n => n !== entryToDelete.name);
                } else if (entryToDelete.type === 'advanced_custom_function_definition') {
                    delete this.calcJSUtils.advancedCustomFunctions[entryToDelete.name];
                    this.calcJSUtils.advancedCustomFunctionNames = this.calcJSUtils.advancedCustomFunctionNames.filter(n => n !== entryToDelete.name);
                }
                this.entries.splice(idx, 1);
            }
        });

        this.annotations.forEach(anno => {
            if (anno.type === 'checkbox' && anno.controlledNames) {

                anno.controlledNames = anno.controlledNames.filter(savedId => 
                    this.entries.some(entry => (entry.name || entry.expr) === savedId)
                );
            }
        });
 
        this.recalculateAll();
        this.updateGlobalPlayState();
    }

      deleteEntryByIndex(index) {
        const adjustedIndex = index - 1;
        if (adjustedIndex < 0 || adjustedIndex >= this.entries.length) {
            console.warn(`deleteindex: Invalid index ${index}.`);
            return;
        }
        this._handleCascadingDelete(adjustedIndex);
    }

    clearAllEntries() {
        this.entries = [];
        this.categoryFilterMode = 0;
        this.updateCategoryButtonIcon();
        this.variables.clear();
        this.calcJSUtils.customFunctions = {};
        this.calcJSUtils.calc3 = [];
        
const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        for (let i = ADVANCED_FUNCTION_DEFINITIONS.length - 1; i >= 0; i--) {
            if (!defaultAdvancedFunctionNames.has(ADVANCED_FUNCTION_DEFINITIONS[i].name)) {
                ADVANCED_FUNCTION_DEFINITIONS.splice(i, 1);
            }
        }
        
        this.initializeAdvancedCalcJSFunctions();
        this.initializeCalcJSBuiltinFunctions();
        this.pen.segments = [];
this.annotations = [];
        this.recalculateAll();
    }


       executeGlobalScript() {
        this.stopGlobalScript();
        this.globalScript = document.getElementById('global-script-input').value;

        this.performanceModeEnabled = false;
        this.smoothPanningEnabled = false;
        this.lowPrecisionBufferEnabled = false;
        if (this.performanceModeToggle) this.performanceModeToggle.checked = false;
        if (this.smoothPanningToggle) this.smoothPanningToggle.checked = false;
        if (this.lowPrecisionBufferToggle) this.lowPrecisionBufferToggle.checked = false;

        const archProxy = {
            create: (expr) => {
                setTimeout(() => this.addEntry(expr), 0);
            },
            createfunc: (expr, h, s, b, a, visible) => {
                setTimeout(() => {
                    const initialLength = this.entries.length;
                    this.addEntry(expr);
                    if (this.entries.length > initialLength) {
                        const newEntry = this.entries[this.entries.length - 1];
                        if (newEntry.type === 'function') {
                            newEntry.color = { h: h || 0, s: s || 100, b: b || 85, a: a || 0 };
                            newEntry.visible = (visible === 1);
                            this.recalculateAll();
                        }
                    }
                }, 0);
            },
            creategeo: (expr, h, s, b, a, visible) => {
                setTimeout(() => {
                    const initialLength = this.entries.length;
                    this.addEntry(expr);
                    if (this.entries.length > initialLength) {
                        const newEntry = this.entries[this.entries.length - 1];
                        if (newEntry.type === 'geometry') {
                            newEntry.color = { h: h || 0, s: s || 0, b: this.isDarkModeActive ? 100 : 0, a: a || 0 };
                            newEntry.visible = (visible === 1);
                            this.recalculateAll();
                        }
                    }
                }, 0);
            },
            deletegeo: (name) => {
                setTimeout(() => this.deleteEntryByIdentifier(name, ['geometry']), 0);
            },
            deletefunc: (identifier) => {
                setTimeout(() => this.deleteEntryByIdentifier(identifier, ['function', 'variable', 'constant', 'custom_function_definition', 'advanced_custom_function_definition']), 0);
            },
            deleteindex: (index) => {
                 setTimeout(() => this.deleteEntryByIndex(index), 0);
            },
            clearall: () => {
                setTimeout(() => this.clearAllEntries(), 0);
            },
            calc: (expr) => {
                return this.evaluateExpressionWithCalcJS(expr, {});
            },
            coordinate: (pointName, axis) => {
                if (pointName === 0) {
                    const cssWidth = this.canvas.clientWidth;
                    const cssHeight = this.canvas.clientHeight;
                    if (axis === 'x') {
                        return (cssWidth / 2 - this.offset.x) / this.scale;
                    } else if (axis === 'y') {
                        return (this.offset.y - cssHeight / 2) / this.scale;
                    }
                    return NaN;
                }
                const p = this.entries.find(e => e.name === pointName && e.type === 'geometry' && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(e.geometryType));
                if (!p || !p.isMeaningful) return NaN;
                return axis === 'x' ? p.x_val : (axis === 'y' ? p.y_val : NaN);
            },
            setcanvas: (x, y, zoom) => {
                if (typeof x === 'number' && typeof y === 'number' && typeof zoom === 'number' && zoom > 0) {
                    const cssWidth = this.canvas.clientWidth;
                    const cssHeight = this.canvas.clientHeight;
                    this.scale = Math.min(this.maxScale, Math.max(this.minScale, zoom));
                    this.offset.x = cssWidth / 2 - x * this.scale;
                    this.offset.y = cssHeight / 2 + y * this.scale;
                    this.recalculateAll();
                }
            },
            valuesetting: (varName, value, max, min, step) => {
                const entry = this.entries.find(e => e.type === 'variable' && e.isEditableIndependent && e.name === varName);
                if (entry) {
                    if (typeof value === 'number') entry.value = value;
                    if (typeof max === 'number') entry.max = max;
                    if (typeof min === 'number') entry.min = min;
                    if (typeof step === 'number' && step > 0) entry.step = step;

                    if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
                    if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
                    
                    this.recalculateAll();
                }
            },
            message: (text, time) => {
                this.showInfoMessage(String(text), (typeof time === 'number' && time > 0) ? time * 1000 : 3000);
            },
            pencolor: (h, s, b, a) => {
                this.pen.color = this.hsbToRgbaArray(h, s, b, a === undefined ? 0 : a);
            },
            penthickness: (t) => { this.pen.thickness = t; },
            pendown: () => { this.pen.isDown = true; },
            penup: () => { this.pen.isDown = false; },
            penposition: (x, y) => {
                if (this.pen.isDown && Number.isFinite(this.pen.x) && Number.isFinite(this.pen.y)) {
                    this.pen.segments.push({
                        p1: { x: this.pen.x, y: this.pen.y },
                        p2: { x, y },
                        color: [...this.pen.color],
                        thickness: this.pen.thickness
                    });
                    this.requestDraw();
                }
                this.pen.x = x;
                this.pen.y = y;
            }
        };

        try {
            const sandboxedFunc = new Function('arch', 'setInterval', 'clearInterval', `'use strict';\n${this.globalScript}`);
            
            sandboxedFunc(
                archProxy,
                (fn, delay) => { this.globalScriptIntervalId = setInterval(fn, delay); },
                (id) => clearInterval(id || this.globalScriptIntervalId)
            );
        } catch (e) {
            alert(`全局脚本错误: ${e.message}`);
            this.stopGlobalScript();
        }
    }
    
drawPenStrokesGL() {
        if (this.pen.segments.length === 0) return;
        const gl = this.gl;
        gl.useProgram(this.shaderProgramLines);

        this.pen.segments.forEach(seg => {

            const vertices = this.generateQuadVertices(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y, seg.thickness);
            if (vertices.length > 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
                gl.uniform4fv(this.uniformLocations.color, seg.color);
                gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
            }
        });
    }
generateHighlightedText(entry) {
        const text = entry.expr;
        if (!text) return '';

       
        const C_RED = '#ff0000';     
        const C_ORANGE = '#bf6f00';  
        const C_BLUE = '#0099ff';    
        const C_PURPLE = '#b300ff';   
        const C_GRAY = '#8c8c8c';    
        const C_GREEN = '#00bf39';    

        const isParametric = ['parametric', 'parametric3d'].includes(entry.plotType);
        const isImplicit = ['implicit', 'implicit3d'].includes(entry.plotType);
        
        const regex = /([a-zA-Z_][\w]*)|([0-9]+(?:\.[0-9]+)?)|([=<>]=?|!=)|([+\-*/^(),])|(\s+)|(.)/g;
        
        let html = '';
        let match;
        
        while ((match = regex.exec(text)) !== null) {
            const fullMatch = match[0];
            const identifier = match[1];
            const number = match[2];
            const relation = match[3];
            const punctuation = match[4];
            const whitespace = match[5];
            
            if (whitespace) {
                html += whitespace;
                continue;
            }
            
            let color = ''; 
            
            if (relation) {

                if (entry.type === 'function' && (isParametric || isImplicit)) {
                    color = C_RED;
                } else {
                    color = C_GRAY;
                }
            } else if (punctuation) {
                color = C_GRAY;
            } else if (identifier) {
                const lowerId = identifier.toLowerCase();
                

                const remaining = text.substring(match.index + fullMatch.length);
                const nextCharIsEquals = remaining.trim().startsWith('=');
                

                const isParametricHeader = isParametric && ['x', 'y', 'z'].includes(lowerId) && nextCharIsEquals;

                if (entry.type === 'geometry') {
                    if (lowerId === entry.geometryType.toLowerCase()) {
                         color = C_BLUE;
                    } else if (lowerId === entry.name?.toLowerCase()) {
                         color = C_GREEN;
                    } else if (entry.objectDependencies && entry.objectDependencies.map(d=>d.toLowerCase()).includes(lowerId)) {
                         color = C_GREEN;
                    } else if (this.calcJSUtils.calc1.includes(lowerId) || this.builtinFuncNames.includes(lowerId)) {
                        color = C_PURPLE;
                    } else {
                        color = C_ORANGE;
                    }
                } else {
                    if (isParametricHeader) {
                        color = C_RED;
                    } else if (this.calcJSUtils.calc1.includes(lowerId) || this.builtinFuncNames.includes(lowerId)) {
                        color = C_PURPLE;
                    } else if (
                        this.calcJSUtils.calc3.includes(lowerId) || 
                        this.calcJSUtils.advancedCustomFunctionNames.includes(lowerId) ||
                        (entry.type.includes('function_definition') && identifier === entry.name)
                    ) {
                        color = C_BLUE;
                    } else {
                        color = C_ORANGE;
                    }
                }
            } else if (number) {
                 color = '';
            } else {
                 color = '';
            }
            
            if (color) {
                html += `<span style="color:${color}">${fullMatch}</span>`;
            } else {
                html += fullMatch;
            }
        }
        return html;
    }


updateEntryList() {
        if (this.activeSliders) {
            this.activeSliders.forEach(slider => slider.disconnect());
        }
        this.activeSliders = [];

        let playbackCardHtml = '';
        if (this.showPlaybackControls) {
            const isPlaying = this.isFramePlaying;
            const playPauseIcon = isPlaying
  ? '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU4OTY5IiBoZWlnaHQ9IjkuNzc0MDIiIHZpZXdCb3g9IjAsMCw3LjU4OTY5LDkuNzc0MDIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMjA1MTYsLTE3NS4xMTI5OSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjQ1NTE2LDE3Ni4zNjI5OWwwLjAyMDM1LDcuMTY2MjgiLz48cGF0aCBkPSJNMjQyLjU0NDg0LDE4My42MzcwMWwtMC4wMjAzNiwtNy4xNjYyNiIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjc5NDg0NDk5OTk5OTk4MTo0Ljg4NzAxMDAwMDAwMDAwNC0tPg==" style="width:18px; height:18px;">'
                    : '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU2MDYzIiBoZWlnaHQ9IjEwLjAzNzIiIHZpZXdCb3g9IjAsMCw3LjU2MDYzLDEwLjAzNzIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMzAwNzEsLTE3NC45ODE0KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjgwMDczLDE4Mi45NDQxNHYtNi4xNzU1MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuOTQ0MzIsMTc2LjQ4MTRsNC40MTcwMiwzLjkyNjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS45NjU1OSwxODAuNjQ2MjZsLTQuMTY0ODgsMi44NzIzNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNjM4NjcsMTc5Ljg5NzE2YzAsLTEuMDQ0OTcgMC44NDcxMiwtMS44OTIxMSAxLjg5MjExLC0xLjg5MjExYzEuMDQ0OTcsMCAxLjg5MjExLDAuODQ3MTIgMS44OTIxMSwxLjg5MjExYzAsMS4wNDQ5NyAtMC44NDcxMiwxLjg5MjExIC0xLjg5MjExLDEuODkyMTFjLTEuMDQ0OTcsMCAtMS44OTIxMSwtMC44NDcxMiAtMS44OTIxMSwtMS44OTIxMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjY5OTI5NDk5OTk5OTk3ODo1LjAxODYwMDAwMDAwMDAyMS0tPg==" style="width:18px; height:18px;">';
            
playbackCardHtml = `
                <div class="entry-item playback-control-card" style="border: 1px solid var(--text-color-accent); background-color: var(--entry-item-bg-color);">
                    <div class="entry-main-row" style="justify-content: space-between; font-weight: bold; color: var(--text-color-accent);">
                        播控中心
                        <div class="entry-actions-new" style="opacity: 1; pointer-events: auto; display: flex; position: static;">
                             <span class="action-btn frame-play-toggle-btn" title="播放/暂停">${playPauseIcon}</span>
                        </div>
                    </div>
                    <div class="entry-expandable-content" style="max-height: none; opacity: 1; padding-top: 5px; display: block;">
                        <div class="variable-slider-wrapper">
                            <div id="frame-slider-container" class="custom-slider-container"></div>
                        </div>
                        <div class="slider-props" style="display: flex; justify-content: space-between; font-size: 0.9em; color: var(--text-color-subtle);">
                            <span>当前帧: <span class="frame-current-value" style="text-decoration: underline dotted; cursor: pointer;">${this.currentFrame}</span></span>
                            <span>总帧数: <span class="frame-total-value" style="text-decoration: underline dotted; cursor: pointer;">${this.totalFrames}</span></span>
                            <span>FPS: <span class="frame-fps-value" style="text-decoration: underline dotted; cursor: pointer;">${this.playbackFPS}</span></span>
                        </div>
                    </div>
                </div>`;
        }

this.entryList.innerHTML = playbackCardHtml + this.entries.map((entry, index) => {
                if (this.categoryFilterMode === 1) { 
                if (entry.type !== 'variable' && entry.type !== 'constant') return '';
            } else if (this.categoryFilterMode === 2) { 
                if (entry.type !== 'function') return '';
            } else if (this.categoryFilterMode === 3) { 
                if (entry.type !== 'geometry') return '';
            }
            let mainContentHtml = '';
            let actionsHtml = '';
            let expandableContentHtml = '';
            let alwaysVisibleContentHtml = '';
            
            let classes = ['entry-item'];
            let style = '';
            let title = entry.expr || '';

            if (entry.type === 'variable') {
                classes.push('variable-item');
                if (entry.isEditableIndependent) {
                    classes.push('independent-variable-item');
                    style = `--variable-indicator-color: ${entry.playState === 1 ? 'var(--variable-indicator-independent-playing-color)' : 'var(--variable-indicator-independent-paused-color)'};`;
                } else {
                    style = `--variable-indicator-color: var(--variable-indicator-dependent-color);`;
                }
            } else if (['function', 'geometry', 'text'].includes(entry.type)) {
                const color = this.hsbToHex(entry.color.h, entry.color.s, entry.color.b);
                const entryColorForBar = entry.visible ? color : 'rgba(128,128,128,0.4)';
                const entryVisibleOpacity = entry.visible ? 1 : 0.3;
                style = `--entry-color: ${entryColorForBar}; --entry-visible-opacity: ${entryVisibleOpacity};`;
                if (!entry.visible) classes.push('function-hidden');
            } else if (['custom_function_definition', 'advanced_custom_function_definition'].includes(entry.type)) {
                classes.push(entry.type.replace(/_/g, '-') + '-item');
                style = `--variable-indicator-color: var(--text-color-subtle);`;
            } else if (entry.type === 'constant') {
                classes.push('constant-item');
                style = `--variable-indicator-color: var(--variable-indicator-dependent-color);`;
            }
            
            if (entry.expanded) {
                classes.push('expanded');
            }
            

            let formattedExpr = this.generateHighlightedText(entry);

            if (entry.type === 'function' || entry.type === 'geometry' || entry.type === 'text' || entry.type === 'point_list') {

                let textDisplayHTML = formattedExpr;
                
                if (entry.type === 'text') {

                     textDisplayHTML = `<span style="color:var(--text-color-subtle)">// ${entry.content}</span>`;
                }
                
                if (entry.type === 'geometry' && entry.detailsString) {
                    textDisplayHTML += `<div style="font-style: italic; color: var(--text-color-subtle); font-size: 0.9em; word-break: normal; padding-top: 2px;">${entry.detailsString}</div>`;
                }

mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>${textDisplayHTML}</div>
                        ${entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : ''}
                    </div>`;
                
                actionsHtml = `
                    <div class="entry-actions-new">
                     <span class="action-btn color-toggle-btn" title="颜色设置"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC45OTQ1OSIgaGVpZ2h0PSIxMS4wMzEyMyIgdmlld0JveD0iMCwwLDEwLjk5NDU5LDExLjAzMTIzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjUwMjcsLTE3NC40ODQzOCkiPjxnIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjM3Ljk4NDMzLDE4MC45ODk1M2MtMC4xNTU3NiwwIC0wLjMwMjM1LDAuMDM2NjUgLTAuNDMwNjIsMC4xMDA3OGMtMC4xMjgyNywwLjA2NDEzIC0wLjI2NTcsMC4xMzc0MyAtMC4zOTM5NywwLjIxMDczYy0wLjEyODI3LDAuMDczMyAtMC4yNjU3LDAuMTQ2NTkgLTAuMzkzOTgsMC4yMTA3M2MtMC4xMjgyNywwLjA2NDEzIC0wLjI4NDAyLDAuMTAwNzggLTAuNDQ4OTQsMC4xMDA3OGMtMC4yMjkwNiwwIC0wLjQzOTc5LC0wLjA1NDk3IC0wLjYzMjE5LC0wLjE2NDkyYy0wLjE5MjQsLTAuMTA5OTQgLTAuMzc1NjQsLTAuMjI5MDYgLTAuNTQwNTcsLTAuMzY2NDljLTAuMjE5ODksLTAuMTkyNCAtMC4zODQ4MSwtMC40MDMxMyAtMC40NzY0MywtMC42NTA1MWMtMC4wOTE2MiwtMC4yNDczOCAtMC4xNjQ5MiwtMC41MTMwOCAtMC4xNjQ5MiwtMC43OTcxMWMwLC0wLjI4NDAzIDAuMDM2NjUsLTAuNTc3MjIgMC4xMTkxMSwtMC44NTIwOGMwLjA4MjQ2LC0wLjI3NDg3IDAuMTc0MDgsLTAuNTQ5NzMgMC4yOTMxOSwtMC44MTU0M2MwLjI1NjU0LC0wLjU2ODA1IDAuNTc3MjIsLTEuMDgxMTMgMC45NzExOSwtMS41NTc1NmMwLjE3NDA4LC0wLjIxMDczIDAuMzU3MzIsLTAuNDIxNDYgMC41NTg4OSwtMC42MTM4N2MwLjIwMTU3LC0wLjE5MjQgMC40MTIzLC0wLjM2NjQ4IDAuNjUwNTEsLTAuNTEzMDhjMC40MTIzLC0wLjI2NTcgMC44NDI5MiwtMC40NTgxMSAxLjI5MTg3LC0wLjU5NTU0YzAuNDQ4OTQsLTAuMTM3NDMgMC45MTYyMSwtMC4yMDE1NyAxLjQxMDk3LC0wLjIwMTU3YzAuNDU4MTEsMCAwLjkwNzA1LDAuMDY0MTQgMS4zMzc2OCwwLjE4MzI1YzAuNDMwNjIsMC4xMTkxMSAwLjg2MTI0LDAuMjg0MDMgMS4yNjQzOCwwLjUwMzkyYzAuNDk0NzYsMC4yNjU3IDAuOTM0NTQsMC41NzcyMiAxLjMxOTM0LDAuOTM0NTRjMC4zODQ4MSwwLjM1NzMyIDAuNzA1NDksMC43NTEzIDAuOTcxMTksMS4xOTEwOGMwLjI2NTcsMC40Mzk3OSAwLjQ2NzI3LDAuOTA3MDUgMC42MDQ3LDEuNDEwOTdjMC4xMzc0MywwLjUwMzkyIDAuMjAxNTcsMS4wMzUzMiAwLjIwMTU3LDEuNTk0MjFjMCwwLjQxMjMgLTAuMDM2NjUsMC44MjQ1OSAtMC4xMDk5NSwxLjI0NjA1Yy0wLjA3MzMsMC40MjE0NiAtMC4xOTI0LDAuODI0NTkgLTAuMzQ4MTYsMS4yMTg1N2MtMC4xNTU3NiwwLjM5Mzk4IC0wLjM0ODE2LDAuNzYwNDYgLTAuNTg2MzgsMS4xMTc3OGMtMC4yMzgyMSwwLjM1NzMyIC0wLjUyMjI1LDAuNjU5NjcgLTAuODQyOTIsMC45MTYyMWMtMC4yNjU3LDAuMjE5ODkgLTAuNTU4ODksMC4zOTM5OCAtMC44NzA0LDAuNTIyMjVjLTAuMzExNTEsMC4xMjgyNyAtMC42NDEzNCwwLjE5MjQgLTAuOTk4NjcsMC4xOTI0Yy0wLjMxMTUxLDAgLTAuNjMyMTksLTAuMDU0OTcgLTAuOTQzNywtMC4xNjQ5MmMtMC4zMTE1MSwtMC4xMDk5NCAtMC41NzcyMiwtMC4yNDczOCAtMC44MDYyNywtMC40MTIzYy0wLjIyOTA2LC0wLjE2NDkyIC0wLjQxMjMsLTAuMzU3MzIgLTAuNTY4MDUsLTAuNTc3MjJjLTAuMTU1NzYsLTAuMjE5ODkgLTAuMjY1NywtMC40NjcyNyAtMC4zNDgxNiwtMC43NDIxM2MtMC4wODI0NiwtMC4yNzQ4NyAtMC4xMjgyNiwtMC41NjgwNiAtMC4xNDY1OSwtMC44ODg3M2MtMC4wMDkxNiwtMC4xMDk5NCAtMC4wMDkxNiwtMC4yMTk4OSAtMC4wMTgzMiwtMC4zMjk4M2MtMC4wMDkxNiwtMC4xMDk5NCAtMC4wMDkxNiwtMC4yMTk4OSAtMC4wMTgzMiwtMC4zMjk4M2MwLC0wLjA2NDEzIC0wLjAwOTE2LC0wLjEyODI3IC0wLjAxODMyLC0wLjIxMDczYy0wLjAwOTE2LC0wLjA4MjQ2IC0wLjAxODMyLC0wLjE1NTc2IC0wLjAzNjY1LC0wLjIyOTA2Yy0wLjAxODMyLC0wLjA3MzMgLTAuMDM2NjUsLTAuMTU1NzUgLTAuMDY0MTMsLTAuMjE5ODljLTAuMDI3NDksLTAuMDY0MTMgLTAuMDU0OTcsLTAuMTI4MjcgLTAuMDkxNjIsLTAuMTgzMjVjLTAuMDM2NjUsLTAuMDQ1ODEgLTAuMDczMywtMC4wODI0NSAtMC4xMzc0MywtMC4xMDk5NGMtMC4wNjQxMywtMC4wMjc0OSAtMC4xMTkxMSwtMC4wNTQ5NyAtMC4xOTI0LC0wLjA3MzNjLTAuMDczMywtMC4wMTgzMiAtMC4xMzc0MywtMC4wMjc0OCAtMC4yMDE1NywtMC4wMzY2NWMtMC4wNjQxMywtMC4wMDkxNiAtMC4xMDk5NSwtMC4wMTgzMiAtMC4xNjQ5MiwtMC4wMTgzMnpNMjQwLjQzMDYxLDE3Ny4wNTg5NGMwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzMgLTAuMTkyNCwwLjEyODI3Yy0wLjA1NDk3LDAuMDU0OTcgLTAuMTAwNzgsMC4xMTkxMSAtMC4xMjgyNywwLjE5MjRjLTAuMDI3NDksMC4wNzMzIC0wLjA0NTgxLDAuMTU1NzYgLTAuMDQ1ODEsMC4yMjkwNmMwLDAuMDczMyAwLjAxODMyLDAuMTU1NzUgMC4wNDU4MSwwLjIyOTA1YzAuMDI3NDksMC4wNzMzIDAuMDczMywwLjEzNzQzIDAuMTI4MjcsMC4xOTI0YzAuMDU0OTcsMC4wNTQ5NyAwLjExOTExLDAuMTAwNzggMC4xOTI0LDAuMTI4MjdjMC4wNzMzLDAuMDI3NDkgMC4xNTU3NiwwLjA0NTgxIDAuMjI5MDYsMC4wNDU4MWMwLjA3MzMsMCAwLjE1NTc2LC0wLjAxODMyIDAuMjI5MDYsLTAuMDQ1ODFjMC4wNzMzLC0wLjAyNzQ5IDAuMTM3NDMsLTAuMDczMyAwLjE5MjQsLTAuMTI4MjdjMC4wNTQ5NywtMC4wNTQ5NyAwLjEwMDc4LC0wLjExOTExIDAuMTI4MjcsLTAuMTkyNGMwLjAyNzQ5LC0wLjA3MzMgMC4wNTQ5NywtMC4xMzc0MyAwLjA1NDk3LC0wLjIxOTg5ek0yNDIuMzE4MDUsMTgyLjczMDMyYzAsLTAuMTc0MDggLTAuMDU0OTcsLTAuMzExNTEgLTAuMTc0MDgsLTAuNDMwNjJjLTAuMTE5MTEsLTAuMTE5MTEgLTAuMjU2NTQsLTAuMTc0MDggLTAuNDMwNjIsLTAuMTc0MDhjLTAuMDgyNDYsMCAtMC4xNTU3NSwwLjAxODMyIC0wLjIyOTA1LDAuMDQ1ODFjLTAuMDczMywwLjAyNzQ5IC0wLjEzNzQzLDAuMDczMyAtMC4xOTI0LDAuMTI4MjdjLTAuMDU0OTcsMC4wNTQ5NyAtMC4xMDA3OCwwLjExOTExIC0wLjEyODI3LDAuMTkyNGMtMC4wMjc0OSwwLjA3MzMgLTAuMDQ1ODEsMC4xNTU3NiAtMC4wNDU4MSwwLjIyOTA2YzAsMC4wNzMzIDAuMDE4MzIsMC4xNTU3NSAwLjA0NTgxLDAuMjI5MDVjMC4wMjc0OSwwLjA3MzMgMC4wNzMzLDAuMTM3NDMgMC4xMjgyNywwLjE5MjRjMC4wNTQ5NywwLjA1NDk3IDAuMTE5MTEsMC4xMDA3OCAwLjE5MjQsMC4xMjgyN2MwLjA3MzMsMC4wMjc0OSAwLjE1NTc1LDAuMDQ1ODEgMC4yMjkwNSwwLjA0NTgxYzAuMDczMywwIDAuMTU1NzYsLTAuMDE4MzIgMC4yMjkwNiwtMC4wNDU4MWMwLjA3MzMsLTAuMDI3NDkgMC4xMzc0MywtMC4wNzMzIDAuMTkyNCwtMC4xMjgyN2MwLjA1NDk3LC0wLjA1NDk3IDAuMTAwNzgsLTAuMTE5MTEgMC4xMjgyNywtMC4xOTI0YzAuMDI3NDksLTAuMDczMyAwLjA1NDk3LC0wLjEzNzQzIDAuMDU0OTcsLTAuMjE5ODl6TTI0Mi40OTIxMiwxNzcuNzQ2MTZjMCwtMC4xNzQwOCAtMC4wNTQ5NywtMC4zMTE1MSAtMC4xNzQwOCwtMC40MzA2MmMtMC4xMTkxMSwtMC4xMTkxMSAtMC4yNTY1NCwtMC4xNzQwOCAtMC40MzA2MiwtMC4xNzQwOGMtMC4wODI0NiwwIC0wLjE1NTc2LDAuMDE4MzIgLTAuMjI5MDYsMC4wNDU4MWMtMC4wNzMzLDAuMDI3NDkgLTAuMTM3NDMsMC4wNzMzIC0wLjE5MjQsMC4xMjgyN2MtMC4wNTQ5NywwLjA1NDk3IC0wLjEwMDc4LDAuMTE5MTEgLTAuMTI4MjcsMC4xOTI0Yy0wLjAyNzQ5LDAuMDczMyAtMC4wNDU4MSwwLjE1NTc2IC0wLjA0NTgxLDAuMjI5MDZjMCwwLjA3MzMgMC4wMTgzMiwwLjE1NTc2IDAuMDQ1ODEsMC4yMjkwNmMwLjAyNzQ5LDAuMDczMyAwLjA3MzMsMC4xMzc0MyAwLjEyODI3LDAuMTkyNGMwLjA1NDk3LDAuMDU0OTcgMC4xMTkxMSwwLjEwMDc4IDAuMTkyNCwwLjEyODI3YzAuMDczMywwLjAyNzQ5IDAuMTU1NzYsMC4wNDU4MSAwLjIyOTA2LDAuMDQ1ODFjMC4wNzMzLDAgMC4xNTU3NiwtMC4wMTgzMiAwLjIyOTA2LC0wLjA0NTgxYzAuMDczMywtMC4wMjc0OSAwLjEzNzQzLC0wLjA3MzMgMC4xOTI0LC0wLjEyODI3YzAuMDU0OTcsLTAuMDU0OTcgMC4xMDA3OCwtMC4xMTkxMSAwLjEyODI3LC0wLjE5MjRjMC4wMjc0OSwtMC4wNzMzIDAuMDU0OTcsLTAuMTM3NDMgMC4wNTQ5NywtMC4yMTk4OXpNMjQzLjY5MjM0LDE3OS4yOTQ1MmMwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzI5IC0wLjE5MjQsMC4xMjgyNmMtMC4wNTQ5NywwLjA1NDk3IC0wLjEwMDc4LDAuMTE5MTEgLTAuMTI4MjcsMC4xOTI0Yy0wLjAyNzQ5LDAuMDczMyAtMC4wNDU4MSwwLjE1NTc2IC0wLjA0NTgxLDAuMjI5MDZjMCwwLjA3MzMgMC4wMTgzMiwwLjE1NTc2IDAuMDQ1ODEsMC4yMjkwNmMwLjAyNzQ5LDAuMDczMyAwLjA3MzMsMC4xMzc0MyAwLjEyODI3LDAuMTkyNGMwLjA1NDk3LDAuMDU0OTcgMC4xMTkxMSwwLjEwMDc4IDAuMTkyNCwwLjEyODI3YzAuMDczMywwLjAyNzQ5IDAuMTU1NzYsMC4wNDU4MSAwLjIyOTA2LDAuMDQ1ODFjMC4wNzMzLDAgMC4xNTU3NSwtMC4wMTgzMiAwLjIyOTA1LC0wLjA0NTgxYzAuMDczMywtMC4wMjc0OSAwLjEzNzQzLC0wLjA3MzMgMC4xOTI0LC0wLjEyODI3YzAuMDU0OTcsLTAuMDU0OTcgMC4xMDA3OCwtMC4xMTkxMSAwLjEyODI3LC0wLjE5MjRjMC4wMjc0OSwtMC4wNzMzIDAuMDU0OTcsLTAuMTM3NDMgMC4wNTQ5NywtMC4yMTk4OXpNMjQzLjY5MjM0LDE4MS4zNTYwM2MwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzMgLTAuMTkyNCwwLjEyODI3Yy0wLjA1NDk3LDAuMDU0OTcgLTAuMTAwNzgsMC4xMTkxMSAtMC4xMjgyNywwLjE5MjRjLTAuMDI3NDksMC4wNzMzIC0wLjA0NTgxLDAuMTU1NzYgLTAuMDQ1ODEsMC4yMjkwNmMwLDAuMDczMyAwLjAxODMyLDAuMTU1NzUgMC4wNDU4MSwwLjIyOTA1YzAuMDI3NDksMC4wNzMzIDAuMDczMywwLjEzNzQzIDAuMTI4MjcsMC4xOTI0YzAuMDU0OTcsMC4wNTQ5NyAwLjExOTExLDAuMTAwNzggMC4xOTI0LDAuMTI4MjdjMC4wNzMzLDAuMDI3NDkgMC4xNTU3NiwwLjA0NTgxIDAuMjI5MDYsMC4wNDU4MWMwLjA3MzMsMCAwLjE1NTc1LC0wLjAxODMyIDAuMjI5MDUsLTAuMDQ1ODFjMC4wNzMzLC0wLjAyNzQ5IDAuMTM3NDMsLTAuMDczMyAwLjE5MjQsLTAuMTI4MjdjMC4wNTQ5NywtMC4wNTQ5NyAwLjEwMDc4LC0wLjExOTExIDAuMTI4MjcsLTAuMTkyNGMwLjAyNzQ5LC0wLjA3MzMgMC4wNTQ5NywtMC4xMzc0MyAwLjA1NDk3LC0wLjIxOTg5eiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuNDk3Mjk1MDAwMDAwMDA4OjUuNTE1NjE0OTk5OTk5OTk3LS0+" style="width:18px; height:18px;"></span>
                        ${entry.type !== 'text' ? `<span class="action-btn visibility-toggle-btn" title="显示/隐藏"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC44MDg2OCIgaGVpZ2h0PSIxMC44MDg2OCIgdmlld0JveD0iMCwwLDEwLjgwODY4LDEwLjgwODY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1NjMsLTE3NC41OTU2NikiPjxnIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTIzNS40MDYzLDE4MGMwLC0yLjU3MDUyIDIuMDgzODIsLTQuNjU0MzQgNC42NTQzNCwtNC42NTQzNGMyLjU3MDUxLDAgNC42NTQzNCwyLjA4MzgyIDQuNjU0MzQsNC42NTQzNGMwLDIuNTcwNTIgLTIuMDgzODIsNC42NTQzNCAtNC42NTQzNCw0LjY1NDM0Yy0yLjU3MDUxLDAgLTQuNjU0MzQsLTIuMDgzODIgLTQuNjU0MzQsLTQuNjU0MzR6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzYuNDAyODQsMTgyLjUxMTMxbDcuMDc2NywtNS40NDkwNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNS41MTMzLDE3OS42MDk4OGMwLC0wLjEyNTY0IDAuMDMwOTcsLTAuMjQ0MDQgMC4wODU3LC0wLjM0Nzk5bDAuMzQyNTksLTAuNjg1MThjMS4xNjU5MiwtMi41NDQxMSAzLjM1NjE4LC0zLjI4NTQxIDUuODkyMTIsLTIuMzY1NDdjMC4xODgzNywtMC4wNTc0NCAwLjY2NjQsLTAuMTM5MjkgMC45MTE1LDAuMzk5OTVjMC4zMDk1NCwwLjY4MDk4IC0wLjM3MTQ0LDAuOTkwNTIgLTAuMzcxNDQsMC45OTA1MmMtMC40Mjc0LDAuMTkyMiAtMC44NTkzMSwwLjQyNDI3IC0xLjI5MDQ1LDAuNjg0NThjMC4xNTM3NSwwLjM4NTA1IC0wLjE0Mjg1LDAuNzQwOTYgLTAuMTQyODUsMC43NDA5NmwtMC4zNjU1MywwLjQzODMxYy0wLjg1MzM3LDAuOTc1MjcgLTEuNjAzNTcsMS43MDg4NyAtMi43NzYwNCwyLjI5OTQ5YzAsMCAtMC42MDM2MSwwLjMwMTggLTAuOTUwODQsLTAuMjQxMjVjLTAuMDc5NDksMC4wNjkyNiAtMC4xNTgwNywwLjEzNzk0IC0wLjIzNTY4LDAuMjA1OWwtMC4wMzQ0MSwwLjAzNjc1YzAsMCAtMC41Mjg5NCwwLjUyODk0IC0xLjA1Nzg3LDBjLTAuNTI4OTQsLTAuNTI4OTQgMCwtMS4wNTc4NyAwLC0xLjA1Nzg3bDAuMTA3MTIsLTAuMTA0NzhjMC4xMTQxNSwtMC4wOTk4IDAuMjMwMTUsLTAuMjAwNzggMC4zNDc4NiwtMC4zMDI2MmMtMC4yNzEwOSwtMC4xMTIzOCAtMC40NjE3NywtMC4zNzk1NyAtMC40NjE3NywtMC42OTEzeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4zNDM2OTc3Nzc3Nzc3Nzc6NS40MDQzNDAwMDAwMDAwMTktLT4=" style="width:18px; height:18px;"></span>` : ''}
                        <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                      </div>`;
                
const sliceAxisMap = {'none': '无', 'x': 'X轴', 'y': 'Y轴', 'z': 'Z轴'};
                const is3DModeAndFunc = this.is3DMode;
                const is2DType = ['x', 'y', 'implicit', 'parametric'].includes(entry.plotType);
                const is3DType = ['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType);

                let extra3DControls = '';
                if (is3DModeAndFunc) {
                    if (is2DType) {
                        extra3DControls = `
                        <div class="settings-item-row" style="margin-top: 5px; justify-content: space-between; font-size: 0.9em; color: var(--text-color-subtle);">
                            <label for="extend-3d-toggle-${index}">延伸到3D</label>
                            <label class="custom-switch-container">
                                <input type="checkbox" id="extend-3d-toggle-${index}" class="extend-3d-toggle" ${entry.extendTo3D ? 'checked' : ''}>
                                <span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span>
                            </label>
                        </div>`;
                    } else if (is3DType) {
                        extra3DControls = `
                        <div class="slider-group" style="margin-top: 5px; font-size: 0.9em; color: var(--text-color-subtle); display: flex; justify-content: space-between;">
                            <span>切片方向: <span class="slice-axis-value" style="text-decoration: underline dotted; cursor: pointer; font-weight: bold;">${sliceAxisMap[entry.sliceAxis] || '无'}</span></span>
                            ${entry.sliceAxis !== 'none' ? `<span>数值: <span class="slice-val-value" style="text-decoration: underline dotted; cursor: pointer;">${entry.sliceVal}</span></span>` : ''}
                        </div>`;
                    }
                }

expandableContentHtml = `
                    <div class="function-controls">
                       <div class="slider-group"><label>颜色:</label><div id="color-slider-h-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>饱和度:</label><div id="color-slider-s-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>亮度:</label><div id="color-slider-b-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>透明度:</label><div id="color-slider-a-${index}" class="custom-slider-container"></div></div>
                   
                     <div class="slider-group"><label>粗细:</label><div id="thickness-slider-${index}" class="custom-slider-container"></div></div>
                     <div class="slider-group" style="margin-top: 5px; font-size: 0.9em; color: var(--text-color-subtle);">
                        显示帧: <span class="display-frame-value" style="text-decoration: underline dotted; cursor: pointer;">${entry.displayFrame}</span>
                     </div>
                     ${extra3DControls}
                   </div>`;

            } else if (entry.type === 'variable' && entry.isEditableIndependent) {
const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : '...';
                
 
                const varNameHtml = `<span style="color:#ffaa00; font-weight:bold;">${entry.name.toUpperCase()}</span>`;
                const eqHtml = `<span style="color:#ff0000">=</span>`;
                
                mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>${varNameHtml} ${eqHtml} <span class="entry-value">${displayValue}</span></div>
                    </div>`;

                const playPauseIcon = entry.playState === 1
                     ? '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU4OTY5IiBoZWlnaHQ9IjkuNzc0MDIiIHZpZXdCb3g9IjAsMCw3LjU4OTY5LDkuNzc0MDIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMjA1MTYsLTE3NS4xMTI5OSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjQ1NTE2LDE3Ni4zNjI5OWwwLjAyMDM1LDcuMTY2MjgiLz48cGF0aCBkPSJNMjQyLjU0NDg0LDE4My42MzcwMWwtMC4wMjAzNiwtNy4xNjYyNiIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjc5NDg0NDk5OTk5OTk4MTo0Ljg4NzAxMDAwMDAwMDAwNC0tPg==" style="width:18px; height:18px;">'
                    : '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU2MDYzIiBoZWlnaHQ9IjEwLjAzNzIiIHZpZXdCb3g9IjAsMCw3LjU2MDYzLDEwLjAzNzIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMzAwNzEsLTE3NC45ODE0KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjgwMDczLDE4Mi45NDQxNHYtNi4xNzU1MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuOTQ0MzIsMTc2LjQ4MTRsNC40MTcwMiwzLjkyNjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS45NjU1OSwxODAuNjQ2MjZsLTQuMTY0ODgsMi44NzIzNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNjM4NjcsMTc5Ljg5NzE2YzAsLTEuMDQ0OTcgMC44NDcxMiwtMS44OTIxMSAxLjg5MjExLC0xLjg5MjExYzEuMDQ0OTcsMCAxLjg5MjExLDAuODQ3MTIgMS44OTIxMSwxLjg5MjExYzAsMS4wNDQ5NyAtMC44NDcxMiwxLjg5MjExIC0xLjg5MjExLDEuODkyMTFjLTEuMDQ0OTcsMCAtMS44OTIxMSwtMC44NDcxMiAtMS44OTIxMSwtMS44OTIxMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjY5OTI5NDk5OTk5OTk3ODo1LjAxODYwMDAwMDAwMDAyMS0tPg==" style="width:18px; height:18px;">';

                actionsHtml = `
                    <div class="entry-actions-new">
                         <span class="action-btn play-toggle-btn" title="播放/暂停">${playPauseIcon}</span>
                        <span class="action-btn settings-toggle-btn" title="滑块设置"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42MDcwOSIgaGVpZ2h0PSI5Ljk1NDg5IiB2aWV3Qm94PSIwLDAsMTAuNjA3MDksOS45NTQ4OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNC42OTY3OCwtMTc1LjAzMDMxKSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjM5LjcwNDUsMTgzLjY1OTRjLTAuMTAxNzcsMC4wNTkyMiAtMC4xODM1OSwwLjEzNjAyIC0wLjI1Njk1LDAuMjI3MzdjLTAuMDczMzcsMC4wOTEzNCAtMC4xNDI0OCwwLjE4OTk1IC0wLjIyMzExLDAuMjg1NTNjLTAuMDgwNjMsMC4wOTU1NiAtMC4xNDI0OCwwLjE4OTk1IC0wLjIyMzExLDAuMjg1NTNjLTAuMDgwNjMsMC4wOTU1NiAtMC4xNjI0NCwwLjE3MjM3IC0wLjI1Njk1LDAuMjI3MzdjLTAuMDg3MjQsMC4wNTA3NiAtMC4xNjgzOSwwLjA3ODUyIC0wLjI2MjI1LDAuMDg0NDdjLTAuMDkzODUsMC4wMDU5NiAtMC4xODg4OSwtMC4wMDY4NiAtMC4yNzc4NCwtMC4wNDI2OWMtMC4wNjE3MiwtMC4wMjI0NyAtMC4xMzkxOSwtMC4wNTUyNCAtMC4yMjgxNSwtMC4wOTEwNmMtMC4wODg5NiwtMC4wMzU4MiAtMC4xOTA2MSwtMC4wOTM0NSAtMC4yODgwMywtMC4xNDM4Yy0wLjA5NzQyLC0wLjA1MDM2IC0wLjIxMDU2LC0wLjExMTAyIC0wLjMxNjQ1LC0wLjE3NTkzYy0wLjEwNTg5LC0wLjA2NDkgLTAuMjExNzUsLTAuMTI5NzkgLTAuMzA2MTQsLTAuMTkxNjVjLTAuMDk0MzcsLTAuMDYxODYgLTAuMTc0MjIsLTAuMTMyMTcgLTAuMjQ5ODMsLTAuMTk1MjJjLTAuMDc1NjIsLTAuMDYzMDQgLTAuMTIwOTUsLTAuMTI0MjUgLTAuMTU0NzksLTAuMTgyNDFjLTAuMDU5MjIsLTAuMTAxNzcgLTAuMDg1MTIsLTAuMjEzMiAtMC4wODA3OCwtMC4zMjI3OWMwLjAwNDM2LC0wLjEwOTU4IDAuMDI3NDksLTAuMjIwMzUgMC4wNjIxMSwtMC4zMjgwOGMwLjAzNDYzLC0wLjEwNzczIDAuMDgzNzksLTAuMjIzOTIgMC4xMzcxOSwtMC4zMzI4M2MwLjA1MzM5LC0wLjEwODkyIDAuMTAyNTcsLTAuMjI1MSAwLjEzNzE5LC0wLjMzMjgzYzAuMDM0NjMsLTAuMTA3NzMgMC4wNTc3NiwtMC4yMTg1IDAuMDY2MzQsLTAuMzIwODFjMC4wMDg1OSwtMC4xMDIzMSAtMC4wMTMwOSwtMC4yMDY0NyAtMC4wNzIzMSwtMC4zMDgyNGMtMC4wNTUsLTAuMDk0NTEgLTAuMTM0ODQsLTAuMTY0ODMgLTAuMjMyMjUsLTAuMjE1MThjLTAuMDk3NDIsLTAuMDUwMzYgLTAuMjAwOTIsLTAuMDc3NzEgLTAuMzE1OTEsLTAuMTA4MTJjLTAuMTE1LC0wLjAzMDQgLTAuMjM2MDgsLTAuMDM3OCAtMC4zNjEzOCwtMC4wNTI0NmMtMC4xMjUzMSwtMC4wMTQ2NyAtMC4yNDMzNSwtMC4wMzM1NyAtMC4zNjEzOCwtMC4wNTI0NmMtMC4xMTgwNCwtMC4wMTg5IC0wLjIyMjczLC0wLjA2NTAyIC0wLjMyMDE0LC0wLjExNTM5Yy0wLjA5NzQyLC0wLjA1MDM2IC0wLjE3NzI2LC0wLjEyMDY3IC0wLjI0MDcxLC0wLjIyOTczYy0wLjAyOTYxLC0wLjA1MDg5IC0wLjA1MzE1LC0wLjEyNDc4IC0wLjA3MDYsLTAuMjIxNjZjLTAuMDE3NDUsLTAuMDk2ODkgLTAuMDM5MTMsLTAuMjAxMDUgLTAuMDQ2MjgsLTAuMzEzNjZjLTAuMDA3MTUsLTAuMTEyNjEgLTAuMDExMjQsLTAuMjM2NzUgLTAuMDE1MzUsLTAuMzYwODZjLTAuMDA0MSwtMC4xMjQxMyAtMC4wMDA5NCwtMC4yNTI0NiAwLjAwNjQ2LC0wLjM3MzU1YzAuMDA3NCwtMC4xMjEwOCAwLjAxMTc1LC0wLjIzMDY1IDAuMDIwMzQsLTAuMzMyOTZjMC4wMDg1OSwtMC4xMDIzMSAwLjAyMjYxLC0wLjE3ODU4IDAuMDMzNTcsLTAuMjQzMzVjMC4wMjAwOSwtMC4wOTkyNyAwLjA2MDEzLC0wLjE4MDk1IDAuMTExNjgsLTAuMjU5NjFjMC4wNTE1NSwtMC4wNzg2NSAwLjEyMzA1LC0wLjEzOTcyIDAuMjAzMDIsLTAuMTg2MjVjMC4xMDE3NywtMC4wNTkyMiAwLjIwODk3LC0wLjA5MjQgMC4zMjQ2NCwtMC4xMTEwNGMwLjExNTY2LC0wLjAxODY1IDAuMjM1NTQsLTAuMDMwMDEgMC4zNTU0MywtMC4wNDEzOWMwLjExOTg5LC0wLjAxMTM4IDAuMjM5NzcsLTAuMDIyNzQgMC4zNTU0MywtMC4wNDEzOWMwLjExNTY2LC0wLjAxODY1IDAuMjIyODUsLTAuMDUxODIgMC4zMjQ2NCwtMC4xMTEwNGMwLjEzMDg2LC0wLjA3NjE0IDAuMjE4NzYsLTAuMTc1OTQgMC4yNTk0NiwtMC4zMDY2N2MwLjA0MDcxLC0wLjEzMDczIDAuMDQ2OTEsLTAuMjcwNTggLTAuMDAzMTksLTAuNDA2ODVjLTAuMDUxMjksLTAuMTU1MDUgLTAuMTA5ODUsLTAuMzA1ODcgLTAuMTYxMTUsLTAuNDYwOTFjLTAuMDUxMjksLTAuMTU1MDUgLTAuMTA5ODUsLTAuMzA1ODcgLTAuMTYxMTUsLTAuNDYwOTFjLTAuMDQ1ODgsLTAuMTI5MDEgLTAuMDU0MiwtMC4yNjA0IC0wLjAxNjU0LC0wLjM3OTYzYzAuMDM3NjcsLTAuMTE5MjMgMC4xMDk4NCwtMC4yMjkzNCAwLjIwOTIzLC0wLjMyNjFjMC4xMDM2MywtMC4wODk0OSAwLjIwNDIyLC0wLjE2NzQ4IDAuMzE2MzEsLTAuMjQyNDNjMC4xMTIwOSwtMC4wNzQ5NSAwLjIyODQsLTAuMTQyNjMgMC4zMzc0NiwtMC4yMDYwOWMwLjExNjMyLC0wLjA2NzY4IDAuMjQ0MTMsLTAuMTMyMzIgMC4zNjQ2OCwtMC4xOTI3NGMwLjEyMDU1LC0wLjA2MDQxIDAuMjUyNTksLTAuMTE3NzkgMC4zODE2LC0wLjE2MzY2YzAuMTI5MDEsLTAuMDQ1ODggMC4yNjA0LC0wLjA1NDIgMC4zNzk2MywtMC4wMTY1NGMwLjExOTIzLDAuMDM3NjcgMC4yMjUxLDAuMTAyNTcgMC4zMjE4NywwLjIwMTk2YzAuMTA5NDYsMC4xMjEyIDAuMjExNjQsMC4yNDY2NCAwLjMxMzgxLDAuMzcyMDhjMC4xMDIxOCwwLjEyNTQ0IDAuMjA0MzYsMC4yNTA4OCAwLjMxMzgxLDAuMzcyMDhjMC4wOTM3MiwwLjExMDg5IDAuMjExMSwwLjE3ODgzIDAuMzUyMTQsMC4yMDM4MWMwLjE0MTA1LDAuMDI0OTcgMC4yNzEyNCwtMC4wMDIxMiAwLjM5NDgyLC0wLjA3NDAzYzAuMTAxNzcsLTAuMDU5MjIgMC4xODM1OSwtMC4xMzYwMiAwLjI1Njk1LC0wLjIyNzM3YzAuMDczMzcsLTAuMDkxMzQgMC4xNDI0OCwtMC4xODk5NSAwLjIyMzExLC0wLjI4NTUzYzAuMDgwNjMsLTAuMDk1NTYgMC4xNDI0OCwtMC4xODk5NSAwLjIyMzExLC0wLjI4NTUzYzAuMDgwNjMsLTAuMDk1NTYgMC4xNjI0NCwtMC4xNzIzNyAwLjI1Njk1LC0wLjIyNzM3YzAuMDg3MjQsLTAuMDUwNzYgMC4xNzU2NiwtMC4wODI3NSAwLjI2OTUyLC0wLjA4ODdjMC4wOTM4NSwtMC4wMDU5NiAwLjE4MTYyLDAuMDExMDkgMC4yNzc4NCwwLjA0MjY5YzAuMDYxNzIsMC4wMjI0NyAwLjEzOTE5LDAuMDU1MjQgMC4yMjgxNSwwLjA5MTA2YzAuMDg4OTYsMC4wMzU4MiAwLjE5MDYxLDAuMDkzNDUgMC4yODgwMywwLjE0MzhjMC4wOTc0MiwwLjA1MDM2IDAuMjEwNTYsMC4xMTEwMiAwLjMxNjQ1LDAuMTc1OTNjMC4xMDU4OSwwLjA2NDkgMC4yMTE3NSwwLjEyOTc5IDAuMzA2MTQsMC4xOTE2NWMwLjA5NDM3LDAuMDYxODYgMC4xNzQyMiwwLjEzMjE3IDAuMjQ5ODMsMC4xOTUyMmMwLjA3NTYyLDAuMDYzMDQgMC4xMjA5NSwwLjEyNDI1IDAuMTU0NzksMC4xODI0MWMwLjA1OTIyLDAuMTAxNzcgMC4wODUxMiwwLjIxMzIgMC4wODA3OCwwLjMyMjc5Yy0wLjAwNDM2LDAuMTA5NTggLTAuMDI3NDksMC4yMjAzNSAtMC4wNjIxMSwwLjMyODA4Yy0wLjAzNDYzLDAuMTA3NzMgLTAuMDgzNzksMC4yMjM5MiAtMC4xMzcxOSwwLjMzMjgzYy0wLjA1MzM5LDAuMTA4OTIgLTAuMTAyNTcsMC4yMjUxIC0wLjEzNzE5LDAuMzMyODNjLTAuMDM0NjMsMC4xMDc3MyAtMC4wNTc3NiwwLjIxODUgLTAuMDY2MzQsMC4zMjA4MWMtMC4wMDg1OSwwLjEwMjMxIDAuMDEzMDksMC4yMDY0NyAwLjA3MjMxLDAuMzA4MjRjMC4wNTUsMC4wOTQ1MSAwLjEzNDg0LDAuMTY0ODMgMC4yMzIyNSwwLjIxNTE4YzAuMDk3NDIsMC4wNTAzNiAwLjIwMDkyLDAuMDc3NzEgMC4zMTU5MSwwLjEwODEyYzAuMTE1LDAuMDMwNCAwLjIzNjA4LDAuMDM3OCAwLjM2MTM4LDAuMDUyNDZjMC4xMjUzMSwwLjAxNDY3IDAuMjQzMzUsMC4wMzM1NyAwLjM2MTM4LDAuMDUyNDZjMC4xMTgwNCwwLjAxODkgMC4yMjI3MywwLjA2NTAyIDAuMzIwMTQsMC4xMTUzOWMwLjA5NzQyLDAuMDUwMzYgMC4xNzcyNiwwLjEyMDY3IDAuMjQwNzEsMC4yMjk3M2MwLjAzMzg0LDAuMDU4MTYgMC4wNTczNywwLjEzMjA0IDAuMDc0ODMsMC4yMjg5NGMwLjAxNzQ1LDAuMDk2ODkgMC4wMzQ5LDAuMTkzNzggMC4wNDYyOCwwLjMxMzY2YzAuMDExMzgsMC4xMTk4OSAwLjAxMTI0LDAuMjM2NzUgMC4wMTUzNSwwLjM2MDg2YzAuMDA0MSwwLjEyNDEzIC0wLjAwMzI5LDAuMjQ1MiAtMC4wMTA2OSwwLjM2NjI4Yy0wLjAwNzQsMC4xMjEwOCAtMC4wMTU5OCwwLjIyMzM4IC0wLjAyNDU3LDAuMzI1N2MtMC4wMDg1OSwwLjEwMjMxIC0wLjAxODM3LDAuMTg1ODUgLTAuMDMzNTcsMC4yNDMzNWMtMC4wMjAwOSwwLjA5OTI3IC0wLjA2MDEzLDAuMTgwOTUgLTAuMTA0NDEsMC4yNTUzOGMtMC4wNDQyOCwwLjA3NDQyIC0wLjExNTc5LDAuMTM1NDkgLTAuMTk1NzUsMC4xODIwMmMtMC4wOTQ1MSwwLjA1NSAtMC4yMDE3LDAuMDg4MTcgLTAuMzI0NjQsMC4xMTEwNGMtMC4xMjI5MiwwLjAyMjg3IC0wLjI0MjgxLDAuMDM0MjQgLTAuMzYyNywwLjA0NTYyYy0wLjExOTg5LDAuMDExMzggLTAuMjQ3MDQsMC4wMjY5NyAtMC4zNjI3LDAuMDQ1NjJjLTAuMTE1NjYsMC4wMTg2NSAtMC4yMjI4NSwwLjA1MTgyIC0wLjMxNzM3LDAuMTA2ODFjLTAuMTIzNTgsMC4wNzE5MSAtMC4yMDExNywwLjE1NTk5IC0wLjI0NDI2LDAuMjQ5MTdjLTAuMDQzMDksMC4wOTMxOSAtMC4wNTU5LDAuMTg4MjMgLTAuMDQ1NzMsMC4yODkzNGMwLjAxMDE5LDAuMTAxMTIgMC4wMzE4NiwwLjIwNTI4IDAuMDc2NTUsMC4zMTU1MmMwLjA0NDY4LDAuMTEwMjMgMC4wODA5LDAuMjA1OTMgMC4xMTQwOCwwLjMxMzE0YzAuMDI3NzYsMC4wODExNiAwLjA1NTUyLDAuMTYyMzIgMC4wODMyOSwwLjI0MzQ3YzAuMDI3NzYsMC4wODExNiAwLjA1MTI5LDAuMTU1MDUgMC4wODMyOSwwLjI0MzQ3YzAuMDUwMSwwLjEzNjI3IDAuMDU0MiwwLjI2MDQgMC4wMjA3NywwLjM4NjljLTAuMDMzNDQsMC4xMjY1IC0wLjEwOTg0LDAuMjI5MzQgLTAuMjIwNzMsMC4zMjMwNmMtMC4xMDM2MywwLjA4OTQ5IC0wLjIwNDIyLDAuMTY3NDggLTAuMzE2MzEsMC4yNDI0M2MtMC4xMTIwOSwwLjA3NDk1IC0wLjIyODQsMC4xNDI2MyAtMC4zNDQ3MiwwLjIxMDMxYy0wLjExNjMyLDAuMDY3NjggLTAuMjQ0MTMsMC4xMzIzMiAtMC4zNjQ2OCwwLjE5Mjc0Yy0wLjEyMDU1LDAuMDYwNDEgLTAuMjUyNTksMC4xMTc3OSAtMC4zODE2LDAuMTYzNjZjLTAuMTI5MDEsMC4wNDU4OCAtMC4yNjA0LDAuMDU0MiAtMC4zNzk2MywwLjAxNjU0Yy0wLjExOTIzLC0wLjAzNzY3IC0wLjIyNTEsLTAuMTAyNTcgLTAuMzI2MSwtMC4yMDkyM2MtMC4xMDk0NiwtMC4xMjEyIC0wLjIxMTY0LC0wLjI0NjY0IC0wLjMxMzgxLC0wLjM3MjA4Yy0wLjEwMjE4LC0wLjEyNTQ0IC0wLjIwNDM2LC0wLjI1MDg4IC0wLjMxMzgxLC0wLjM3MjA4Yy0wLjA5MzcyLC0wLjExMDg5IC0wLjIxMTEsLTAuMTc4ODMgLTAuMzUyMTQsLTAuMjAzODFjLTAuMTQxMDUsLTAuMDI0OTcgLTAuMjYzOTYsLTAuMDAyMTEgLTAuMzg3NTUsMC4wNjk4ek0yNDIuNzg3NjMsMTgzLjQyMjQxYy0wLjAyMzUzLC0wLjA3Mzg5IC0wLjA1ODU3LC0wLjE1MDgyIC0wLjA5OTAyLC0wLjI1Mzc4Yy0wLjA0MDQ2LC0wLjEwMjk3IC0wLjA4MDksLTAuMjA1OTMgLTAuMTIxMzYsLTAuMzA4OWMtMC4wNDA0NiwtMC4xMDI5NyAtMC4wNzM2MywtMC4yMTAxNiAtMC4xMDI1OCwtMC4zMTAxYy0wLjAyODk1LC0wLjA5OTkzIC0wLjA1NjcyLC0wLjE4MTA4IC0wLjA2NDUxLC0wLjI0NDY3Yy0wLjA0MjcxLC0wLjI1NzM2IC0wLjAxMzM3LC0wLjUwNzk3IDAuMDg5MTksLTAuNzMzMDljMC4xMDI1NywtMC4yMjUxIDAuMjY4MDUsLTAuNDA4OTggMC41MDA2OSwtMC41NDQzNGMwLjA3OTk3LC0wLjA0NjUzIDAuMTc1NjYsLTAuMDgyNzUgMC4yOTQzNywtMC4xMTI5YzAuMTE4NywtMC4wMzAxMyAwLjIzNzQsLTAuMDYwMjggMC4zNjc2LC0wLjA4NzM4YzAuMTMwMTksLTAuMDI3MSAwLjI1MzEzLC0wLjA0OTk4IDAuMzczMDIsLTAuMDYxMzRjMC4xMTk4OSwtMC4wMTEzOCAwLjIzMTMxLC0wLjAzNzI4IDAuMzIwOTMsLTAuMDUwNTFjMC4wMzc4LC0wLjIzNjA4IDAuMDY0MDksLTAuNDc1MTkgMC4wNjQzNSwtMC43MDg4OWMwLjAwMDI1LC0wLjIzMzY5IC0wLjAyMjQ5LC0wLjQ3MzQ3IC0wLjA1MjUsLTAuNzA5MDJsLTAuMDA0MjMsLTAuMDA3MjdsLTAuOTc1NzcsLTAuMTcxNzljLTAuMTc1NTQsLTAuMDM0MDkgLTAuMzM3NzMsLTAuMDk1NDIgLTAuNDg3NzYsLTAuMjAyNzVjLTAuMTUwMDMsLTAuMTA3MzMgLTAuMjYzNzIsLTAuMjM1OCAtMC4zNTI1NSwtMC4zODg0N2MtMC4wODg4MywtMC4xNTI2NyAtMC4xNDEzMiwtMC4zMjY0OCAtMC4xNjA0OSwtMC41MDk5NWMtMC4wMTkxNywtMC4xODM0NyAwLjAwNzY1LC0wLjM1NDc3IDAuMDY0NzUsLTAuNTI0MjRsMC4zMjY3MiwtMC45MTAyMWwtMC4wMDQyMywtMC4wMDcyN2MwLDAgLTAuMDE5OTYsLTAuMDE3NTggLTAuMDQ0MTUsLTAuMDQyNDNjLTAuMDI0MTksLTAuMDI0ODYgLTAuMDQ3MTgsLTAuMDMwOTMgLTAuMDUxNDIsLTAuMDM4MmMtMC4xNjY5NSwtMC4xMzY0IC0wLjM1MTQ4LC0wLjI1Mjg1IC0wLjUzOTA1LC0wLjM1Nzc5Yy0wLjE4NzU4LC0wLjEwNDk0IC0wLjM4NTQ1LC0wLjE5NDE2IC0wLjU5MDYsLTAuMjc5MTVsLTAuMDA3MjcsMC4wMDQyM2wtMC42MzA0NywwLjc1NjFjLTAuMDk1MTcsMC4xMDQwMyAtMC4xOTg3OSwwLjE5MzUyIC0wLjMxNTEsMC4yNjEyYy0wLjE5NjI4LDAuMTE0MjEgLTAuMzk2MTMsMC4xNzIxMiAtMC42MTEwNywwLjE3MDY3Yy0wLjE4NDY2LDAuMDAwNCAtMC4zNTI5MywtMC4wMzc5MyAtMC41MTkzNSwtMC4xMDY1MmMtMC4xNjY0MiwtMC4wNjg1OSAtMC4zMDE5MSwtMC4xODQzOSAtMC40MTk4MiwtMC4zMjAxM2wtMC42Mjc2MywtMC43NDQxNmMtMC4yMjQ3MSwwLjA4MjEgLTAuNDM2NzMsMC4xODYgLTAuNjQ3NTUsMC4zMDg2N2MtMC4xMDE3NywwLjA1OTIyIC0wLjIwMzU2LDAuMTE4NDQgLTAuMzAxMSwwLjE4NDkzYy0wLjA5NzU1LDAuMDY2NDkgLTAuMTk1MSwwLjEzMjk4IC0wLjI4ODQxLDAuMjA2NzVjMC4wNTU1MiwwLjE2MjMyIDAuMTE0MDgsMC4zMTMxNCAwLjE3MjY1LDAuNDYzOTZjMC4wNTg1NywwLjE1MDgyIDAuMTA5ODUsMC4zMDU4NyAwLjE2MTE1LDAuNDYwOTFjMC4wNDI4MiwwLjE0MDUxIDAuMDY2ODksMC4yODIyIDAuMDcyMTgsMC40MjUwOWMwLjAwNTI5LDAuMTQyODkgLTAuMDE5NjgsMC4yODM5MyAtMC4wNjAzOSwwLjQxNDY2Yy0wLjA0MDcxLDAuMTMwNzMgLTAuMTE1OTEsMC4yNTIzNCAtMC4xOTk1OCwwLjM1OTQyYy0wLjA4MzY3LDAuMTA3MDYgLTAuMTk0NTYsMC4yMDA3OSAtMC4zMjU0MiwwLjI3Njk0Yy0wLjEzMDg2LDAuMDc2MTQgLTAuMjU5ODYsMC4xMjIwMSAtMC40MDE1NywwLjE0NjA4bC0wLjAwNzI3LDAuMDA0MjNsLTAuOTU0MzQsMC4xNjYwNWwtMC4wMDcyNywwLjAwNDIzYy0wLjAzNzgsMC4yMzYwOCAtMC4wNTY4MiwwLjQ3MDk2IC0wLjA2NDM1LDAuNzA4ODljLTAuMDA3NTIsMC4yMzc5MiAwLjAxMSwwLjQ3MDQzIDAuMDUyNSwwLjcwOTAybDAuMDA0MjMsMC4wMDcyN2wwLjk3NTc3LDAuMTcxNzljMC4xNzU1NCwwLjAzNDA5IDAuMzM3NzMsMC4wOTU0MiAwLjQ4Nzc2LDAuMjAyNzVjMC4xNTAwMywwLjEwNzMzIDAuMjYzNzIsMC4yMzU4IDAuMzUyNTUsMC4zODg0N2MwLjA4ODgzLDAuMTUyNjcgMC4xNTU4NiwwLjMxODAyIDAuMTcwOCwwLjQ5NDIyYzAuMDE0OTQsMC4xNzYyIC0wLjAwNzY1LDAuMzU0NzcgLTAuMDY0NzUsMC41MjQyNGwtMC4zMjY3MiwwLjkxMDIxbDAuMDA0MjMsMC4wMDcyN2MwLDAgMC4wMTk5NiwwLjAxNzU4IDAuMDQ0MTUsMC4wNDI0M2MwLjAyNDE5LDAuMDI0ODYgMC4wNDcxOCwwLjAzMDkzIDAuMDUxNDIsMC4wMzgyYzAuMTY2OTUsMC4xMzY0IDAuMzUxNDgsMC4yNTI4NSAwLjUzOTA1LDAuMzU3NzljMC4xODc1OCwwLjEwNDk0IDAuMzg1NDUsMC4xOTQxNiAwLjU5MDYsMC4yNzkxNWwwLjAwNzI3LC0wLjAwNDIzbDAuNjMwNDcsLTAuNzU2MWMwLjA5NTE3LC0wLjEwNDAzIDAuMTk4NzksLTAuMTkzNTIgMC4zMTUxLC0wLjI2MTJjMC4xOTYyOCwtMC4xMTQyMSAwLjM5NjEzLC0wLjE3MjEyIDAuNjExMDcsLTAuMTcwNjdjMC4xODQ2NiwtMC4wMDA0IDAuMzUyOTMsMC4wMzc5MyAwLjUxOTM1LDAuMTA2NTJjMC4xNjY0MiwwLjA2ODU5IDAuMzAxOTEsMC4xODQzOSAwLjQxOTgyLDAuMzIwMTNsMC42Mjc2MywwLjc0NDE2YzAuMjI0NzEsLTAuMDgyMSAwLjQzNjczLC0wLjE4NiAwLjY0NzU1LC0wLjMwODY3YzAuMTAxNzcsLTAuMDU5MjIgMC4yMDM1NiwtMC4xMTg0NCAwLjMwMTEsLTAuMTg0OTNjMC4wOTc1NSwtMC4wNjY0OSAwLjE4MzU5LC0wLjEzNjAyIDAuMjY5NjUsLTAuMjA1NTV6TTIzOC4zNTMxMSwxODAuOTUyMjRjLTAuMTMxMTMsLTAuMjI1MzcgLTAuMjE0NDIsLTAuNDY4ODQgLTAuMjQxMzksLTAuNzE1ODhjLTAuMDI2OTcsLTAuMjQ3MDQgLTAuMDEyMTcsLTAuNDg5MiAwLjA0ODYxLC0wLjcxOTJjMC4wNjA4LC0wLjIzIDAuMTY3NTksLTAuNDQ3ODMgMC4zMTMxMiwtMC42NDkyOGMwLjE0NTUyLC0wLjIwMTQ1IDAuMzM4MjMsLTAuMzcxOTcgMC41NjM2LC0wLjUwMzExYzAuMjI1MzcsLTAuMTMxMTMgMC40Njg4NCwtMC4yMTQ0MiAwLjcxNTg4LC0wLjI0MTM5YzAuMjQ3MDQsLTAuMDI2OTcgMC40ODkyLC0wLjAxMjE3IDAuNzE5MiwwLjA0ODYxYzAuMjMsMC4wNjA4IDAuNDQ3ODMsMC4xNjc1OSAwLjY0OTI4LDAuMzEzMTJjMC4yMDE0NSwwLjE0NTUyIDAuMzcxOTcsMC4zMzgyMyAwLjUwMzExLDAuNTYzNmMwLjEzMTEzLDAuMjI1MzcgMC4yMTQ0MiwwLjQ2ODg0IDAuMjQxMzksMC43MTU4OGMwLjAyNjk3LDAuMjQ3MDQgMC4wMTIxNywwLjQ4OTIgLTAuMDQ4NjEsMC43MTkyYy0wLjA2MDgsMC4yMyAtMC4xNjc1OSwwLjQ0NzgzIC0wLjMxMzEyLDAuNjQ5MjhjLTAuMTQ1NTIsMC4yMDE0NSAtMC4zMzgyMywwLjM3MTk3IC0wLjU2MzYsMC41MDMxMWMtMC4yMjUzNywwLjEzMTEzIC0wLjQ2ODg0LDAuMjE0NDIgLTAuNzE1ODgsMC4yNDEzOWMtMC4yNDcwNCwwLjAyNjk3IC0wLjQ4OTIsMC4wMTIxNyAtMC43MTkyLC0wLjA0ODYxYy0wLjIzLC0wLjA2MDggLTAuNDQ3ODMsLTAuMTY3NTkgLTAuNjQ5MjgsLTAuMzEzMTJjLTAuMjAxNDUsLTAuMTQ1NTIgLTAuMzcxOTcsLTAuMzM4MjMgLTAuNTAzMTEsLTAuNTYzNnpNMjQxLjA3OTMsMTc5LjM2NTk2Yy0wLjA4ODgzLC0wLjE1MjY3IC0wLjE5ODI5LC0wLjI3Mzg3IC0wLjMzMjU4LC0wLjM3MDg5Yy0wLjEzNDMsLTAuMDk3MDIgLTAuMjgxOTUsLTAuMTY2OCAtMC40MzU2OCwtMC4yMTM1OGMtMC4xNTM3MywtMC4wNDY3OCAtMC4zMTk2MiwtMC4wNDc1NyAtMC40ODQzMSwtMC4wMjk1OWMtMC4xNjQ3LDAuMDE3OTggLTAuMzI3MDIsMC4wNzM1MSAtMC40NzI0MSwwLjE1ODExYy0wLjE0NTQsMC4wODQ2IC0wLjI3Mzg3LDAuMTk4MjkgLTAuMzcwODksMC4zMzI1OGMtMC4wOTcwMiwwLjEzNDMgLTAuMTY2OCwwLjI4MTk1IC0wLjIxMzU4LDAuNDM1NjhjLTAuMDQ2NzgsMC4xNTM3MyAtMC4wNDc1NywwLjMxOTYyIC0wLjAyOTU5LDAuNDg0MzFjMC4wMTc5OCwwLjE2NDcgMC4wNzM1MSwwLjMyNzAyIDAuMTU4MTEsMC40NzI0MWMwLjA4NDYsMC4xNDU0IDAuMTk4MjksMC4yNzM4NyAwLjMzMjU4LDAuMzcwODljMC4xMzQzLDAuMDk3MDIgMC4yODE5NSwwLjE2NjggMC40MzU2OCwwLjIxMzU4YzAuMTUzNzMsMC4wNDY3OCAwLjMxOTYyLDAuMDQ3NTcgMC40ODQzMSwwLjAyOTU5YzAuMTY0NywtMC4wMTc5OCAwLjMyNzAyLC0wLjA3MzUxIDAuNDcyNDEsLTAuMTU4MTFjMC4xNDU0LC0wLjA4NDYgMC4yNzM4NywtMC4xOTgyOSAwLjM3MDg5LC0wLjMzMjU4YzAuMDk3MDIsLTAuMTM0MyAwLjE2NjgsLTAuMjgxOTUgMC4yMTM1OCwtMC40MzU2OGMwLjA0Njc4LC0wLjE1MzczIDAuMDQ3NTcsLTAuMzE5NjIgMC4wMjk1OSwtMC40ODQzMWMtMC4wMTc5OCwtMC4xNjQ3IC0wLjA3MzUxLC0wLjMyNzAyIC0wLjE1ODExLC0wLjQ3MjQxeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzAzMjI0NjMwMjQ4MTk1OjQuOTY5Njg4NDU4NTg4MDI0LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                      </div>`;

                alwaysVisibleContentHtml = `
                    <div class="variable-slider-wrapper">
                        <div id="variable-slider-${index}" class="custom-slider-container"></div>
                    </div>`;
                    const playModeNames = ['往返', '正向', '反向', '单次递增', '单次递减'];
                expandableContentHtml = `
                    <div class="variable-controls">
                        <div class="slider-props">
                            Min: <span class="slider-min-value">${Number.isFinite(entry.min) ? entry.min : 'NaN'}</span>
                            Max: <span class="slider-max-value">${Number.isFinite(entry.max) ? entry.max : 'NaN'}</span>
                            Step: <span class="slider-step-value">${Number.isFinite(entry.step) ? entry.step : 'NaN'}</span>
                        </div>
                        <div class="settings-item-row" style="margin-bottom: 8px;">
                            <span class="slider-props" style="margin-bottom: 0;">播放模式: <span class="play-mode-value" style="cursor:pointer; text-decoration: underline dotted #888;">${playModeNames[entry.playMode || 0]}</span></span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 0.9em; color: var(--text-color-subtle);">在坐标系显示</span>
                                <label class="custom-switch-container">
                                    <input type="checkbox" class="toggle-plot-card-btn" ${entry.showOnPlot ? 'checked' : ''}>
                                    <span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span>
                                </label>
                            </div>
                        </div>
                    </div>`;

} else if ((entry.type === 'variable' && !entry.isEditableIndependent) || entry.type === 'constant') {
                const displayValue = Number.isFinite(entry.value) ? `→ ${entry.value.toPrecision(4)}` : (entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : '...');
                

                mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>
                            ${formattedExpr}
                            <span style="color: var(--text-color-subtle); margin-left: 5px;">${displayValue}</span>
                        </div>
                    </div>`;
                
                actionsHtml = `
                    <div class="entry-actions-new">
 <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                   
                    </div>`;
            
} else if (entry.type === 'custom_function_definition' || entry.type === 'advanced_custom_function_definition') {

                const formattedExpr = this.generateHighlightedText(entry);
                mainContentHtml = `<div class="entry-text-area" data-index="${index}"><div>${formattedExpr}</div></div>`;
                actionsHtml = `
                    <div class="entry-actions-new">
 <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                    </div>`;
            }

return `
                <div class="${classes.join(' ')}" style="${style}" title="${title}" data-index="${index}">
                    <div class="entry-main-row">
                        ${mainContentHtml}
                        ${actionsHtml}
                    </div>
                    ${alwaysVisibleContentHtml}
                    ${expandableContentHtml ? `<div class="entry-expandable-content">${expandableContentHtml}</div>` : ''}
                </div>`;
        }).join('');
        
          this.entries.forEach((entry, index) => {
            if (entry.type === 'variable' && entry.isEditableIndependent) {
                const containerId = `variable-slider-${index}`;
                if (document.getElementById(containerId)) {
                    const slider = new CustomSlider(containerId, {
                        min: Number.isFinite(entry.min) ? entry.min : 0,
                        max: Number.isFinite(entry.max) ? entry.max : 10,
                        step: Number.isFinite(entry.step) && entry.step > 0 ? entry.step : 0.01,
                        value: Number.isFinite(entry.value) ? entry.value : 0,
                        onInput: (e) => {
                            entry.value = e.target.options.value;
                            this.recalculateForAnimation();
                        },
                        onChange: () => {
                            entry.playDirection = 1;
                            this.recalculateAll();
                        }
                    });
                    this.activeSliders.push(slider);
                    document.getElementById(containerId).sliderInstance = slider;
                }
} else if (['function', 'geometry', 'text', 'point_list'].includes(entry.type) && entry.expanded) {
                const sliderInstances = {};
                const createColorSlider = (prop, type) => {
                    const containerId = `color-slider-${prop}-${index}`;
                    if(document.getElementById(containerId)) {
                        const slider = new CustomSlider(containerId, {
                            min: 0, max: 100, step: 1, value: entry.color[prop], type: type,
                            context: entry.color, 
                            onInput: (e) => {
                                entry.color[prop] = e.target.options.value;
                                this.updateEntryColorDisplay(index);

                                Object.values(sliderInstances).forEach(s => {
                                    if (s !== slider) {
                                        s.options.context = entry.color;
                                        s.draw();
                                    }
                                });
                                this.requestDraw();
                            },
                            onChange: () => {
                                if (entry.type === 'geometry') {
                                    entry.webglVertices = null;
                                    entry.webglFillVertices = null;
                                }
                                this.requestDraw();
                            }
                        });
                        this.activeSliders.push(slider);
                        sliderInstances[prop] = slider;
                    }
                };
                createColorSlider('h', 'hue');
                createColorSlider('s', 'saturation');
                createColorSlider('b', 'brightness');
                createColorSlider('a', 'alpha');

                const thicknessContainerId = `thickness-slider-${index}`;
                if (document.getElementById(thicknessContainerId)) {
                    const tSlider = new CustomSlider(thicknessContainerId, {
                        min: 1, max: 20, step: 1, value: entry.thickness, type: 'default',
                        onInput: (e) => {
                            entry.thickness = e.target.options.value;
                            if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                                entry.webglVertices = null; 
                            }
                            if (entry.type === 'geometry') {
                                entry.webglVertices = null;
                            }
                            this.requestDraw();
                        },
                        onChange: () => {
                            this.clearPlotData(); 
                            this.recalculateAll(); 
                        }
                    });
this.activeSliders.push(tSlider);
                }
            }
        });

        if (this.showPlaybackControls) {
            const frameSliderContainer = document.getElementById('frame-slider-container');
            if (frameSliderContainer) {
                const frameSlider = new CustomSlider('frame-slider-container', {
                    min: 0,
                    max: this.totalFrames,
                    step: 1,
                    value: this.currentFrame,
                    type: 'default',
                    onInput: (e) => {
                        this.currentFrame = Math.round(e.target.options.value);
                        const valSpan = document.querySelector('.frame-current-value');
                        if (valSpan) valSpan.textContent = this.currentFrame;
                        this.requestDraw();
                    },
                    onChange: (e) => {
                        this.currentFrame = Math.round(e.target.options.value);
                        this.requestDraw();
                    }
                });
                this.activeSliders.push(frameSlider);
                frameSliderContainer.sliderInstance = frameSlider;
            }
        }

        this.updateEntryVariableValuesDisplay();
        this.updateGeometryMeasurementDisplay();
    }


updateEntryColorDisplay(index) {
        const itemElement = this.entryList.querySelector(`.entry-item[data-index="${index}"]`);
        if (!itemElement) return;

        const entry = this.entries[index];
        if (!entry || (entry.type !== 'function' && entry.type !== 'text' && entry.type !== 'geometry' && entry.type !== 'point_list') || !entry.color) return;

        const entryColor = entry.color;
        
        if (entry.type === 'function' || entry.type === 'geometry' || entry.type === 'text' || entry.type === 'point_list') {
            const hexColor = this.hsbToHex(entryColor.h, entryColor.s, entryColor.b);
            itemElement.style.setProperty('--entry-color', entry.visible ? hexColor : 'rgba(128,128,128,0.4)');
            itemElement.style.setProperty('--entry-visible-opacity', entry.visible ? 1 : 0.3);
        }

        const colorSliders = itemElement.querySelectorAll('.color-slider');
        colorSliders.forEach(slider => {
           const colorProp = slider.dataset.colorProp;
           if (colorProp && entryColor[colorProp] !== undefined) {
               slider.value = entryColor[colorProp];
           }
        });
    }


updateEntryVariableValuesDisplay() {
    this.entries.forEach((entry, index) => {
        const itemElement = this.entryList.querySelector(`.entry-item[data-index="${index}"]`);
        if (!itemElement) return;

        if (entry.type === 'variable' || entry.type === 'constant') {
            const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : (Number.isNaN(entry.value) ? 'NaN' : '计算中...');
            
            if (entry.isEditableIndependent) {
                const valueSpan = itemElement.querySelector('.entry-value');
                if (valueSpan) valueSpan.textContent = displayValue;
            } else {
                const textDivs = itemElement.querySelectorAll('.entry-text-area div');
                if (textDivs.length > 1) {
                     textDivs[1].innerHTML = Number.isFinite(entry.value) ? `→ ${entry.value.toPrecision(4)}` : (entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : '...');
                }
            }

            let varIndicatorColor = '';
            if (entry.type === 'variable') {
                varIndicatorColor = entry.isEditableIndependent ? (entry.playState === 1 ? 'var(--variable-indicator-independent-playing-color)' : 'var(--variable-indicator-independent-paused-color)') : 'var(--variable-indicator-dependent-color)';
            } else if (entry.type === 'constant') {
                varIndicatorColor = 'var(--variable-indicator-dependent-color)';
            }
            itemElement.style.setProperty('--variable-indicator-color', varIndicatorColor);

            if (entry.isEditableIndependent) {
                const sliderContainer = itemElement.querySelector('.custom-slider-container');
                if (sliderContainer && sliderContainer.sliderInstance) {
                    sliderContainer.sliderInstance.setValue(entry.value);
                }

                if (itemElement.classList.contains('expanded')) {
                    const minSpan = itemElement.querySelector('.slider-min-value');
                    const maxSpan = itemElement.querySelector('.slider-max-value');
                    const stepSpan = itemElement.querySelector('.slider-step-value');
                    const step = entry.step;
                    let propPrecision = 4;
                    if (Number.isFinite(step) && step !== 0) propPrecision = Math.max(0, -Math.floor(Math.log10(Math.abs(step) + 1e-9)));
                    else if (Number.isFinite(entry.max) && Number.isFinite(entry.min)) propPrecision = Math.max(0, -Math.floor(Math.log10(Math.abs(entry.max - entry.min) / 100 + 1e-9)));
                    
                    if (minSpan) minSpan.textContent = Number.isFinite(entry.min) ? entry.min.toFixed(propPrecision) : 'NaN';
                    if (maxSpan) maxSpan.textContent = Number.isFinite(entry.max) ? entry.max.toFixed(propPrecision) : 'NaN';
                    if (stepSpan) stepSpan.textContent = Number.isFinite(entry.step) ? entry.step.toFixed(propPrecision) : 'NaN';
                }
            }
        }
         const errorSpan = itemElement.querySelector('span[style*="color: var(--text-color-error)"]');
         if (errorSpan) {
              if (entry.compilationError) { errorSpan.textContent = `(${entry.compilationError})`; errorSpan.style.display = 'inline';} 
              else {errorSpan.style.display = 'none';}
         }
    });
}


calculateGridStep(cssWidth, cssHeight) {
 const targetPixelStep = 75;
 const minUnits = targetPixelStep / this.scale;
 const exponent = Math.floor(Math.log10(minUnits));
 const magnitude = Math.pow(10, exponent);
 const normalizedMinUnits = minUnits / magnitude;
 let unitStep;
 if (normalizedMinUnits < 1.5) unitStep = 1 * magnitude;
 else if (normalizedMinUnits < 3.5) unitStep = 2 * magnitude;
 else if (normalizedMinUnits < 7.5) unitStep = 5 * magnitude;
 else unitStep = 10 * magnitude;
 const minPixelDist = 15;
 if (unitStep * this.scale < minPixelDist) {
     const requiredMagnitude = minPixelDist / this.scale;
     const exponentAdj = Math.floor(Math.log10(requiredMagnitude));
     const magnitudeAdj = Math.pow(10, exponentAdj);
     const normalizedAdj = requiredMagnitude / magnitudeAdj;
     if (normalizedAdj < 1.5) unitStep = 1 * magnitudeAdj;
     else if (normalizedAdj < 3.5) unitStep = 2 * magnitudeAdj;
     else if (normalizedAdj < 7.5) unitStep = 5 * magnitudeAdj;
     else unitStep = 10 * magnitudeAdj;
 }
 if (unitStep === 0) unitStep = magnitude > 0 ? magnitude : 1e-6;
 const log10Step = Math.log10(Math.abs(unitStep));
 const precision = Math.max(0, -Math.floor(log10Step + 1e-9));
 const maxDisplayPrecision = 6;
 const finalPrecision = Math.min(precision, maxDisplayPrecision);
 return { unitStep, precision: finalPrecision };
}


calculateAuxiliary3D() {
        const b = this.bounds3D;
        
        const boxV = [ -b,-b,-b, b,-b,-b, b,b,-b, -b,b,-b, -b,-b,b, b,-b,b, b,b,b, -b,b,b ];
        const boxI = [ 0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 0,4, 1,5, 2,6, 3,7 ];
        this.cache3D.box = { 
            vbo: this.createBuffer(boxV), 
            ibo: this.gl.createBuffer(), 
            count: boxI.length 
        };
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.cache3D.box.ibo);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boxI), this.gl.STATIC_DRAW);

        const axesV = [];
        const ox = -this.offset3D.x;
        const oy = -this.offset3D.y;

        this.pushBox(axesV, -b, oy, 0, b, oy, 0);
        this.pushBox(axesV, ox, -b, 0, ox, b, 0);
        this.pushBox(axesV, ox, oy, -b, ox, oy, b);
        this.cache3D.axes = { vbo: this.createBuffer(axesV), count: axesV.length / 6 };

        const tickV = [], gridV = [];
        this.cache3D.labels = [];
        
        const visibleMathRange = (b * 2) * this.scale3D; 
        const { step, precision } = this.getAdaptiveStep3D(visibleMathRange);
        const formatNum = (num) => parseFloat(num.toFixed(precision)).toString();
        const tickLen = 0.2;

        const minXMath = this.scale3D * (-b + this.offset3D.x);
        const maxXMath = this.scale3D * (b + this.offset3D.x);
        const startIdxX = Math.ceil(minXMath / step);
        const endIdxX = Math.floor(maxXMath / step);

        if (Math.abs(oy) <= b) {
            for(let i = startIdxX; i <= endIdxX; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D - this.offset3D.x;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(valScreen, oy, 0, valScreen, oy - tickLen, 0);
                 this.cache3D.labels.push({x: valScreen, y: oy - tickLen*1.8, z: 0, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: b+0.5, y:oy, z:0, text: "X"});
        }
        
        for(let i = startIdxX; i <= endIdxX; i++) {
             const valMath = i * step;
             if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
             const valScreen = valMath / this.scale3D - this.offset3D.x;
             gridV.push(valScreen, -b, 0, valScreen, b, 0);
        }
        
        const minYMath = this.scale3D * (-b + this.offset3D.y);
        const maxYMath = this.scale3D * (b + this.offset3D.y);
        const startIdxY = Math.ceil(minYMath / step);
        const endIdxY = Math.floor(maxYMath / step);

        if (Math.abs(ox) <= b) {
            for(let i = startIdxY; i <= endIdxY; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D - this.offset3D.y;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(ox, valScreen, 0, ox - tickLen, valScreen, 0);
                 this.cache3D.labels.push({x: ox - tickLen*1.8, y: valScreen, z: 0, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: ox, y:b+0.5, z:0, text: "Y"});
        }
        
        for(let i = startIdxY; i <= endIdxY; i++) {
             const valMath = i * step;
             if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
             const valScreen = valMath / this.scale3D - this.offset3D.y;
             gridV.push(-b, valScreen, 0, b, valScreen, 0);
        }
        
        const minZMath = -b * this.scale3D;
        const maxZMath = b * this.scale3D;
        const startIdxZ = Math.ceil(minZMath / step);
        const endIdxZ = Math.floor(maxZMath / step);

        if (Math.abs(ox) <= b && Math.abs(oy) <= b) {
            for(let i = startIdxZ; i <= endIdxZ; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(ox, oy, valScreen, ox, oy - tickLen, valScreen);
                 this.cache3D.labels.push({x: ox, y: oy - tickLen*1.8, z: valScreen, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: ox, y:oy, z:b+0.5, text: "Z"});
        }

        this.cache3D.ticks = { vbo: this.createBuffer(tickV), count: tickV.length/3 };
        this.cache3D.grid = { vbo: this.createBuffer(gridV), count: gridV.length/3 };
    }
generateQuadVertices(p1x, p1y, p2x, p2y, thickness) {
const dx = p2x - p1x;
const dy = p2y - p1y;
const len = Math.sqrt(dx * dx + dy * dy);
if (len === 0) return [];
const nx = dx / len;
const ny = dy / len;
const halfThickness = thickness / 2;
const offsetX = -ny * halfThickness;
const offsetY = nx * halfThickness;
return [
   p1x - offsetX, p1y - offsetY, p1x + offsetX, p1y + offsetY, p2x - offsetX, p2y - offsetY,
   p1x + offsetX, p1y + offsetY, p2x + offsetX, p2y + offsetY, p2x - offsetX, p2y - offsetY,
];
}

drawGridGL(cssWidth, cssHeight) {
    if (this.gridStyle === 'hidden') return;
    const gl = this.gl;
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep } = gridStepInfo;
    this.currentUnitStep = unitStep;
    const { x: offsetX, y: offsetY } = this.offset;
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const endXMath = Math.floor(maxXMath / unitStep + 1e-9) * unitStep;
    const endYMath = Math.floor(maxYMath / unitStep + 1e-9) * unitStep;
    const zeroThreshold = unitStep * 1e-9;
    const vertices = [];
    const gridThicknessMath = 2.0 / this.scale;
    
    switch (this.gridStyle) {
        case 'grid':
            for (let x = startXMath; x <= endXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
                if (this.showAxes && Math.abs(x) < zeroThreshold && Math.abs(offsetX + x * this.scale - cssWidth/2) < cssWidth/2 - 10) continue;
                vertices.push(...this.generateQuadVertices(x, minYMath - unitStep*2, x, maxYMath + unitStep*2, gridThicknessMath));
            }
            for (let y = startYMath; y <= endYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
                if (this.showAxes && Math.abs(y) < zeroThreshold && Math.abs(offsetY - y * this.scale - cssHeight/2) < cssHeight/2 - 10) continue;
                vertices.push(...this.generateQuadVertices(minXMath - unitStep*2, y, maxXMath + unitStep*2, y, gridThicknessMath));
            }
            break;
        case 'dots':
            const dotSize = 1.0 / this.scale;
            for (let x = startXMath; x <= endXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
                for (let y = startYMath; y <= endYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
                    vertices.push(x - dotSize, y - dotSize, x + dotSize, y - dotSize, x - dotSize, y + dotSize);
                    vertices.push(x + dotSize, y - dotSize, x + dotSize, y + dotSize, x - dotSize, y + dotSize);
                }
            }
            break;
        case 'polar':
            const numCircles = 20;
            const numSegments = 100;
            for (let i = 1; i <= numCircles; i++) {
                const radius = i * unitStep;
                let lastX = radius, lastY = 0;
                for (let j = 1; j <= numSegments; j++) {
                    const angle = (j / numSegments) * 2 * Math.PI;
                    const nextX = radius * Math.cos(angle);
                    const nextY = radius * Math.sin(angle);
                    vertices.push(...this.generateQuadVertices(lastX, lastY, nextX, nextY, gridThicknessMath));
                    lastX = nextX; lastY = nextY;
                }
            }
            break;
    }

    if (vertices.length === 0) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
    let gridColor = this.isDarkModeActive ? this.hsbToRgbaArray(0, 0, 35, 0) : this.hsbToRgbaArray(0, 0, 87.8, 0);
    gl.uniform4fv(this.uniformLocations.color, gridColor);
    const drawMode = this.gridStyle === 'dots' ? gl.TRIANGLES : gl.TRIANGLES;
    gl.drawArrays(drawMode, 0, vertices.length / 2);
}



drawAxesGL(cssWidth, cssHeight) {
    if (!this.showAxes) return;
    const gl = this.gl;
    const { x: offsetX, y: offsetY } = this.offset;
    const xVertices = [];
    const yVertices = [];
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const axisThicknessMath = 4.0 / this.scale;
    xVertices.push(...this.generateQuadVertices(minXMath - 1000/this.scale, 0, maxXMath + 1000/this.scale, 0, axisThicknessMath));
    yVertices.push(...this.generateQuadVertices(0, minYMath - 1000/this.scale, 0, maxYMath + 1000/this.scale, axisThicknessMath));
    gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
    gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
    gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
    const xAxisColor = [1.0, 0.0, 0.0, 1.0];
    gl.uniform4fv(this.uniformLocations.color, xAxisColor);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(xVertices), gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.TRIANGLES, 0, xVertices.length / 2);
    const yAxisColor = [0.0, 0.0, 1.0, 1.0];
    gl.uniform4fv(this.uniformLocations.color, yAxisColor);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(yVertices), gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.TRIANGLES, 0, yVertices.length / 2);
}


drawOrigin2D(cssWidth, cssHeight) {
const dpr = window.devicePixelRatio || 1;
const screenX = this.offset.x;
const screenY = this.offset.y;
if (screenX >= -10 && screenX <= cssWidth + 10 && screenY >= -10 && screenY <= cssHeight + 10) {
   this.axisCtx.save();
   this.axisCtx.scale(dpr, dpr);
   this.axisCtx.beginPath();
   this.axisCtx.arc(screenX, screenY, 6, 0, 2 * Math.PI);
   this.axisCtx.fillStyle = 'black';
   this.axisCtx.fill();
   this.axisCtx.restore();
}
}
 

 drawAxisNumbers(cssWidth, cssHeight) {
    if (!this.showAxes || !this.showAxisNumbers) {
        this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        return;
    }
    const dpr = window.devicePixelRatio || 1;
    this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
    this.axisCtx.save();
    this.axisCtx.scale(dpr, dpr);
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep, precision } = gridStepInfo;
    const { x: offsetX, y: offsetY } = this.offset;
    this.axisCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
   this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const yAxisScreenX = offsetX;
    const xAxisScreenY = offsetY;
    const originScreenX = this.offset.x;
    const originScreenY = this.offset.y;
    const originVisible = originScreenX >= -5 && originScreenX <= cssWidth + 5 && originScreenY >= -5 && originScreenY <= cssHeight + 5;
    const zeroTolerance = 1e-9; 

    this.axisCtx.textAlign = 'center';
    this.axisCtx.textBaseline = 'top';
    for (let x = startXMath; x <= maxXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
        if (Math.abs(x) < zeroTolerance && x !== 0) continue; 
        const screenX = offsetX + x * this.scale;
        if (screenX > 20 && screenX < cssWidth - 20) {
            let textY = xAxisScreenY + 8;
            if (textY < 20) textY = 20;
            if (textY > cssHeight - 20) textY = cssHeight - 20;
            const labelText = (Math.abs(x) < zeroTolerance) ? "0" : x.toFixed(precision);
            this.axisCtx.fillText(labelText, screenX, textY);
        }
    }

    this.axisCtx.textBaseline = 'middle';
    for (let y = startYMath; y <= maxYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
        if (Math.abs(y) < zeroTolerance && y !== 0) continue; 
        const screenY = offsetY - y * this.scale;
        if (screenY > 15 && screenY < cssHeight - 15) {
            if (originVisible && Math.abs(y) < zeroTolerance) continue; 
            let textX, align;
            const yLabelPadding = 8;
            if (yAxisScreenX < 40) { align = 'left'; textX = yAxisScreenX + yLabelPadding; if (textX < yLabelPadding) textX = yLabelPadding; }
            else if (yAxisScreenX > cssWidth - 25) { align = 'right'; textX = cssWidth - yLabelPadding; }
            else { align = 'right'; textX = yAxisScreenX - yLabelPadding; }
            this.axisCtx.textAlign = align;
            const labelText = (Math.abs(y) < zeroTolerance) ? "0" : y.toFixed(precision);
            this.axisCtx.fillText(labelText, textX, screenY);
        }
    }
    this.axisCtx.restore();
} 
isHiddenByCheckbox(entry) {
        
        const id = entry.name || entry.expr;
        for (const anno of this.annotations) {
            if (anno.type === 'checkbox' && anno.controlledNames && anno.controlledNames.includes(id)) {
                if (!anno.checked) return true;
            }
        }
        return false;
    }plotAllGeometryGL(cssWidth, cssHeight) {
        const geometryEntries = this.entries.filter(e => {
            const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || e.displayFrame === 0 || e.displayFrame === this.currentFrame;
            

            if (this.isHiddenByCheckbox(e)) return false;


            const isVisible = this.getEffectiveVisibility(e);
            

            if (!isVisible && !this.showHiddenGeo) return false;

            return e.type === 'geometry' && e.isMeaningful && isFrameVisible;
        });        
        if (geometryEntries.length === 0) return;
        const polygons = geometryEntries.filter(e => e.geometryType === 'polygon');
        const points = geometryEntries.filter(e => ['point', 'midpoint', 'intercept'].includes(e.geometryType));
        const otherGeometry = geometryEntries.filter(e => e.geometryType !== 'polygon' && !points.includes(e));
        
        otherGeometry.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
        polygons.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
        points.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
    }

plotSingleGeometryGL(entry, cssWidth, cssHeight) {

        if (this.isHiddenByCheckbox(entry)) return;

        const gl = this.gl;
        const isHighlighted = this.highlightedObject === entry;


        const isEffectiveVisible = this.getEffectiveVisibility(entry);
        
        // 如果不可见，且“显示隐藏对象”开关未开启，则直接不画
        if (!isEffectiveVisible && !this.showHiddenGeo) return;

        let finalColor = entry.color;
        
        // 如果不可见但因“显示隐藏对象”而绘制，设置为半透明
        if (!isEffectiveVisible && this.showHiddenGeo) {
            finalColor = {...entry.color};
            finalColor.a = finalColor.a + (100 - finalColor.a) * 0.75;
        }

        if (entry.isSelected || !entry.webglVertices || isHighlighted) {
            const vertices = [];       
 const fillVertices = [];
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        let lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
        
        if (isHighlighted) {
            lineThicknessMath *= 2;
        }
        let pointRadiusMath = (entry.thickness + 2) / this.scale; 
            if (entry.isSelected) {
                pointRadiusMath *= 1.5;
            }

            switch (entry.geometryType) {
                case 'point': case 'midpoint': case 'intercept': case 'rotate': case 'reflect': case 'translate': {
                    const center_x = entry.x_val;
                    const center_y = entry.y_val;
                    const segments = 12;
                    for (let i = 0; i < segments; i++) {
                        const angle1 = (i / segments) * 2 * Math.PI;
                        const angle2 = ((i + 1) / segments) * 2 * Math.PI;
                        const x1 = center_x + pointRadiusMath * Math.cos(angle1);
                        const y1 = center_y + pointRadiusMath * Math.sin(angle1);
                        const x2 = center_x + pointRadiusMath * Math.cos(angle2);
                        const y2 = center_y + pointRadiusMath * Math.sin(angle2);
                        vertices.push(center_x, center_y, x1, y1, x2, y2);
                    }
                    break;
                }
                case 'segment':
                case 'vector': {
                    const {x_val: x1, y_val: y1} = entry.p1;
                    const {x_val: x2, y_val: y2} = entry.p2;
                    if (useQuads) vertices.push(...this.generateQuadVertices(x1, y1, x2, y2, lineThicknessMath));
                    else vertices.push(x1, y1, x2, y2);
                    if (entry.geometryType === 'vector') {
                        const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                        if (len > 0) {
                            const arrowSize = 10 / this.scale;
                            const dx = (x2-x1)/len, dy = (y2-y1)/len;
                            const ax1 = x2 - arrowSize * (dx * 0.866 - dy * 0.5);
                            const ay1 = y2 - arrowSize * (dy * 0.866 + dx * 0.5);
                            const ax2 = x2 - arrowSize * (dx * 0.866 + dy * 0.5);
                            const ay2 = y2 - arrowSize * (dy * 0.866 - dx * 0.5);
                            if (useQuads) {
                                vertices.push(...this.generateQuadVertices(x2, y2, ax1, ay1, lineThicknessMath));
                                vertices.push(...this.generateQuadVertices(x2, y2, ax2, ay2, lineThicknessMath));
                            } else {
                                vertices.push(x2, y2, ax1, ay1, x2, y2, ax2, ay2);
                            }
                        }
                    }
                    break;
                }
                case 'ray':
                case 'line':
                case 'perpendicularline':
                case 'parallelline':
                case 'anglebisector':
                    case 'fitline': case 'tangent':{
                    const {x_val: x1, y_val: y1} = entry.p1;
                    const {x: dx, y: dy} = entry.dir;
                    const minMathX = (-this.offset.x - 10) / this.scale;
                    const maxMathX = (cssWidth - this.offset.x + 10) / this.scale;
                    const minMathY = (this.offset.y - cssHeight - 10) / this.scale;
                    const maxMathY = (this.offset.y + 10) / this.scale;
                    let t_vals = [];

                    if (Math.abs(dx) > 1e-9) { 
                        t_vals.push((minMathX - x1)/dx, (maxMathX - x1)/dx);
                    }
                    if (Math.abs(dy) > 1e-9) { 
                        t_vals.push((minMathY - y1)/dy, (maxMathY - y1)/dy);
                    }
                    
                    if (t_vals.length === 0) break;

                    if (entry.geometryType === 'ray') {
                         t_vals.push(0);
                         t_vals = t_vals.filter(t => t >= -1e-9);
                    }

                    t_vals.sort((a,b) => a - b);

                    if (t_vals.length >= 2) {
                        const t_start = t_vals[0];
                        const t_end = t_vals[t_vals.length-1];
                        const start_pt = { x: x1 + t_start * dx, y: y1 + t_start * dy };
                        const end_pt = { x: x1 + t_end * dx, y: y1 + t_end * dy };
                        if (useQuads) vertices.push(...this.generateQuadVertices(start_pt.x, start_pt.y, end_pt.x, end_pt.y, lineThicknessMath));
                        else vertices.push(start_pt.x, start_pt.y, end_pt.x, end_pt.y);
                    }
                    break;
                }
case 'circle': {
                    const {x_val: cx, y_val: cy} = entry.center;
                    const r = entry.radius;
                    const segments = Math.max(36, Math.min(360, Math.floor(this.scale * r / 1.5)));
                    let last_x = cx + r, last_y = cy;
                    for (let i = 1; i <= segments; i++) {
                        const angle = (i / segments) * 2 * Math.PI;
                        const next_x = cx + r * Math.cos(angle);
                        const next_y = cy + r * Math.sin(angle);
                        if (useQuads) vertices.push(...this.generateQuadVertices(last_x, last_y, next_x, next_y, lineThicknessMath));
                        else vertices.push(last_x, last_y, next_x, next_y);
                        last_x = next_x; last_y = next_y;
                    }
                    break;
                }
                case 'circulararc': {
                    const { center, radius, startAngle } = entry;
                    let { endAngle } = entry;
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const arcAngle = endAngle - startAngle;
                    const segments = Math.max(2, Math.min(360, Math.floor(this.scale * radius * arcAngle / 1.5)));
                    
                    let last_x = center.x_val + radius * Math.cos(startAngle);
                    let last_y = center.y_val + radius * Math.sin(startAngle);

                    for (let i = 1; i <= segments; i++) {
                        const angle = startAngle + (i / segments) * arcAngle;
                        const next_x = center.x_val + radius * Math.cos(angle);
                        const next_y = center.y_val + radius * Math.sin(angle);
                        if (useQuads) vertices.push(...this.generateQuadVertices(last_x, last_y, next_x, next_y, lineThicknessMath));
                        else vertices.push(last_x, last_y, next_x, next_y);
                        last_x = next_x; last_y = next_y;
                    }
                    break;
                }
                case 'ellipse_ab': {
                    const { center, a, b, rotation } = entry;
                    if (!center || !a || !b || rotation === undefined) break;
                    
                    const segments = 200;
                    let last_pt = null;
                    
                    for(let i=0; i<=segments; i++) {
                        const t = (i/segments) * 2 * Math.PI;
                        const localX = a * Math.cos(t);
                        const localY = b * Math.sin(t);
                        const pt = {
                            x: center.x + localX * Math.cos(rotation) - localY * Math.sin(rotation),
                            y: center.y + localX * Math.sin(rotation) + localY * Math.cos(rotation)
                        };
                        if (last_pt) {
                            if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                            else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                        }
                        last_pt = pt;
                    }
                    break;
                }
                case 'ellipse':
                case 'hyperbola':
                case 'parabola':
                case 'polygon': {
                    if(entry.geometryType === 'polygon' && entry.points.length > 1) {
                    } else if (entry.geometryType === 'ellipse') {
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2)/2;
                        const a = entry.dist_sum / 2;
                        if (a <= c) break;
                        const b = Math.sqrt(a*a - c*c);
                        const angle = Math.atan2(f2y-f1y, f2x-f1x);
                        const segments = 200; let last_pt = null;
                        for(let i=0; i<=segments; i++) {
                            const t = (i/segments) * 2 * Math.PI;
                            const localX = a * Math.cos(t), localY = b * Math.sin(t);
                            const pt = {
                                x: center.x + localX * Math.cos(angle) - localY * Math.sin(angle),
                                y: center.y + localX * Math.sin(angle) + localY * Math.cos(angle)
                            };
                            if (last_pt) {
                                if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                            }
                            last_pt = pt;
                        }
                    } else if (entry.geometryType === 'hyperbola') {
                        const { center, a, b, rotation } = entry;
                        const segments = 200;

                        const minMathX = (-this.offset.x - 20) / this.scale;
                        const maxMathX = (cssWidth - this.offset.x + 20) / this.scale;
                        const minMathY = (this.offset.y - cssHeight - 20) / this.scale;
                        const maxMathY = (this.offset.y + 20) / this.scale;
                        const cos_r = Math.cos(-rotation), sin_r = Math.sin(-rotation);

                        let max_local_abs_x = 0;
                        [minMathX, maxMathX].forEach(x => {
                            [minMathY, maxMathY].forEach(y => {
                                const relX = x - center.x;
                                const relY = y - center.y;
                                max_local_abs_x = Math.max(max_local_abs_x, Math.abs(relX * cos_r - relY * sin_r));
                            });
                        });
                        
                        let t_range = Math.acosh(Math.max(1, max_local_abs_x / a));
                        if (!Number.isFinite(t_range) || t_range < 2) t_range = 5;

                        for (let branch = -1; branch <= 1; branch += 2) {
                            let last_pt = null;
                            for (let i = 0; i <= segments; i++) {
                                const t = -t_range + (i / segments) * 2 * t_range;
                                const localX = branch * a * Math.cosh(t);
                                const localY = b * Math.sinh(t);
                                const pt = {
                                    x: center.x + localX * Math.cos(rotation) - localY * Math.sin(rotation),
                                    y: center.y + localX * Math.sin(rotation) + localY * Math.cos(rotation)
                                };
                                if (last_pt) {
                                    if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                    else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                                }
                                last_pt = pt;
                            }
                        }
                    } else if (entry.geometryType === 'parabola') {
                        const {x_val: fx, y_val: fy} = entry.focus;
                        const {x_val: p1x, y_val: p1y} = entry.directrix.p1;
                        const {x: dirx, y: diry} = entry.directrix.dir;
                        const p2x = p1x + dirx, p2y = p1y + diry;
                        const k = ((p2y-p1y)*(fx-p1x) - (p2x-p1x)*(fy-p1y)) / ((p2y-p1y)**2 + (p2x-p1x)**2);
                        const proj_x = fx - k*(p2y-p1y), proj_y = fy + k*(p2x-p1x);
                        const vertex = {x: (fx+proj_x)/2, y: (fy+proj_y)/2};
                        const p_dist = Math.sqrt((fx-vertex.x)**2 + (fy-vertex.y)**2);
                        const axis_angle = Math.atan2(fy-proj_y, fx-proj_x);
                        const segments = 200; const t_range = Math.max(5, 500/this.scale);
                        let last_pt = null;
                        for(let i=0; i<=segments; i++) {
                            const t = -t_range + (i / segments) * 2 * t_range;
                            const localX = t*t / (4*p_dist);
                            const localY = t;
                            const rotatedLocalX = localX * Math.cos(axis_angle) - localY * Math.sin(axis_angle);
                            const rotatedLocalY = localX * Math.sin(axis_angle) + localY * Math.cos(axis_angle);
                            const pt = {
                                x: vertex.x + rotatedLocalX,
                                y: vertex.y + rotatedLocalY
                            };
                             if (last_pt) {
                                if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                            }
                            last_pt = pt;
                        }
                    }
                    break;
                }
            }
            entry.webglVertices = new Float32Array(vertices);
            entry.webglFillVertices = new Float32Array(fillVertices);
        }

        if (entry.webglFillVertices && entry.webglFillVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglFillVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            const fillAlpha = 100 - 0.5 * (100 - finalColor.a);
            const fillColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, fillAlpha);
            gl.uniform4fv(this.uniformLocations.color, fillColorArray);
            gl.drawArrays(gl.TRIANGLES, 0, entry.webglFillVertices.length / 2);
        }
        
        if (entry.webglVertices && entry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            
            let plotColorArray;
            if (isHighlighted) {
                const rootStyle = getComputedStyle(document.documentElement);
                const accentColor = rootStyle.getPropertyValue('--text-color-accent').trim();
                plotColorArray = this.cssColorToRgbaArray(accentColor);
            } else {
                plotColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
            }
            
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);
            const useQuads = this.lineWidth > 1.5;
const drawMode = ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(entry.geometryType) ? gl.TRIANGLES : (useQuads ? gl.TRIANGLES : gl.LINES);
             if (!useQuads && drawMode === gl.LINES) gl.lineWidth(1.5);
            gl.drawArrays(drawMode, 0, entry.webglVertices.length / 2);
        }
    }
cssColorToRgbaArray(colorString) {
    if (!colorString) return [0, 0, 0, 1];
    const tempDiv = document.createElement('div');
    tempDiv.style.color = colorString;
    document.body.appendChild(tempDiv);
    const computedColor = getComputedStyle(tempDiv).color;
    document.body.removeChild(tempDiv);
    const match = computedColor.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (match) {
        return [
            parseInt(match[1]) / 255,
            parseInt(match[2]) / 255,
            parseInt(match[3]) / 255,
            match[4] ? parseFloat(match[4]) : 1.0
        ];
    }
    return [0, 0, 0, 1];
} 
 drawAxisNumbers(cssWidth, cssHeight) {
    if (!this.showAxes || !this.showAxisNumbers) {
        this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        return;
    }
    const dpr = window.devicePixelRatio || 1;
    this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
    this.axisCtx.save();
    this.axisCtx.scale(dpr, dpr);
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep, precision } = gridStepInfo;
    const { x: offsetX, y: offsetY } = this.offset;
    this.axisCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const yAxisScreenX = offsetX;
    const xAxisScreenY = offsetY;
    const originScreenX = this.offset.x;
    const originScreenY = this.offset.y;
    const originVisible = originScreenX >= -5 && originScreenX <= cssWidth + 5 && originScreenY >= -5 && originScreenY <= cssHeight + 5;
    const zeroTolerance = 1e-9; 

    this.axisCtx.textAlign = 'center';
    this.axisCtx.textBaseline = 'top';
    for (let x = startXMath; x <= maxXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
        if (Math.abs(x) < zeroTolerance && x !== 0) continue; 
        const screenX = offsetX + x * this.scale;
        if (screenX > 20 && screenX < cssWidth - 20) {
            let textY = xAxisScreenY + 8;
            if (textY < 20) textY = 20;
            if (textY > cssHeight - 20) textY = cssHeight - 20;
            const labelText = (Math.abs(x) < zeroTolerance) ? "0" : x.toFixed(precision);
            this.axisCtx.fillText(labelText, screenX, textY);
        }
    }

    this.axisCtx.textBaseline = 'middle';
    for (let y = startYMath; y <= maxYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
        if (Math.abs(y) < zeroTolerance && y !== 0) continue; 
        const screenY = offsetY - y * this.scale;
        if (screenY > 15 && screenY < cssHeight - 15) {
            if (originVisible && Math.abs(y) < zeroTolerance) continue; 
            let textX, align;
            const yLabelPadding = 8;
            if (yAxisScreenX < 40) { align = 'left'; textX = yAxisScreenX + yLabelPadding; if (textX < yLabelPadding) textX = yLabelPadding; }
            else if (yAxisScreenX > cssWidth - 25) { align = 'right'; textX = cssWidth - yLabelPadding; }
            else { align = 'right'; textX = yAxisScreenX - yLabelPadding; }
            this.axisCtx.textAlign = align;
            const labelText = (Math.abs(y) < zeroTolerance) ? "0" : y.toFixed(precision);
            this.axisCtx.fillText(labelText, textX, screenY);
        }
    }
    this.axisCtx.restore();
} 

drawGeometryLabels(cssWidth, cssHeight) {
        if (!this.showPointLabels) return;
        const dpr = window.devicePixelRatio || 1;
        this.axisCtx.save();
        this.axisCtx.scale(dpr, dpr);
        this.axisCtx.textBaseline = 'bottom';
        this.axisCtx.textAlign = 'left';
        this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";

        const pointEntries = this.entries.filter(e => {
            const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || e.displayFrame === 0 || e.displayFrame === this.currentFrame;
            
            // 核心修改：增加复选框和有效可见性检查
            if (this.isHiddenByCheckbox(e)) return false;
            const isVisible = this.getEffectiveVisibility(e);
            
            // 只有当对象“有效可见”时才显示标签 (隐藏对象通常不显示标签，以免杂乱)
            // 如果你希望显示隐藏对象的标签，可以将 isVisible 改为 (isVisible || this.showHiddenGeo)
            return (e.type === 'geometry' && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(e.geometryType)) && 
            isVisible && 
            e.isMeaningful &&
            isFrameVisible &&
            Number.isFinite(e.x_val) &&
            Number.isFinite(e.y_val);
        });

        for (const entry of pointEntries) {      
const screenX = this.offset.x + entry.x_val * this.scale;
            const screenY = this.offset.y - entry.y_val * this.scale;

            if (screenX > -50 && screenX < cssWidth + 50 && screenY > -50 && screenY < cssHeight + 50) {
                let colorArray = this.hsbToRgbaArray(entry.color.h, entry.color.s, entry.color.b, entry.color.a);
                this.axisCtx.fillStyle = `rgba(${colorArray[0]*255}, ${colorArray[1]*255}, ${colorArray[2]*255}, ${colorArray[3]})`;
                this.axisCtx.fillText(entry.name, screenX + 6, screenY - 6);
            }
        }
        this.axisCtx.restore();
    }
drawPolygons2D(cssWidth, cssHeight) {
        const dpr = window.devicePixelRatio || 1;
        this.axisCtx.save();
        this.axisCtx.scale(dpr, dpr);
        
        const polygonEntries = this.entries.filter(e => {
    const isVisible = this.getEffectiveVisibility(e);
    return e.type === 'geometry' && 
    e.geometryType === 'polygon' && 
    (isVisible || this.showHiddenGeo) && 
    e.isMeaningful && 
    e.points && e.points.length > 2;
});

        for (const entry of polygonEntries) {
         let finalColor = entry.color; const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && this.showHiddenGeo) {

                finalColor = {...entry.color};
                finalColor.a = finalColor.a + (100 - finalColor.a) * 0.75;
            }

            const path = new Path2D();
            const p0 = entry.points[0];
            const screenX0 = this.offset.x + p0.x_val * this.scale;
            const screenY0 = this.offset.y - p0.y_val * this.scale;
            path.moveTo(screenX0, screenY0);

            for (let i = 1; i < entry.points.length; i++) {
                const p = entry.points[i];
                const screenX = this.offset.x + p.x_val * this.scale;
                const screenY = this.offset.y - p.y_val * this.scale;
                path.lineTo(screenX, screenY);
            }
            path.closePath();
            
            if (finalColor.a < 100) {
                const fillTransparency = 50 + 0.5 * finalColor.a;
                this.axisCtx.fillStyle = this.hsbToRgba(finalColor.h, finalColor.s, finalColor.b, fillTransparency);
                this.axisCtx.fill(path, 'evenodd');
            }

const isHighlighted = this.highlightedObject === entry;
if (isHighlighted) {
    const rootStyle = getComputedStyle(document.documentElement);
    this.axisCtx.strokeStyle = rootStyle.getPropertyValue('--text-color-accent').trim();
} else {
    this.axisCtx.strokeStyle = this.hsbToRgba(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
}

const currentThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
this.axisCtx.lineWidth = currentThickness * (isHighlighted ? 1.5 : 1);
this.axisCtx.stroke(path);
        }

        this.axisCtx.restore();
    }

draw() {
        if (this.is3DMode) {
            this.draw3D();
            return;
        }

        if (this.gl) this.gl.disable(this.gl.DEPTH_TEST);

        if (this.isTransformingCache) {
            const gl = this.gl;
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;

        const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
        let r = 1.0, g = 1.0, b_val = 1.0;
        const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
        if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
        } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
        gl.clearColor(r, g, b_val, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        ctx.save();
        const scaleFactor = this.scale / this.transformInitialState.scale;
        const tx = this.offset.x - this.transformInitialState.offset.x * scaleFactor;
        const ty = this.offset.y - this.transformInitialState.offset.y * scaleFactor;
        
        ctx.translate(tx * dpr, ty * dpr);
        ctx.scale(scaleFactor, scaleFactor);
        
        ctx.drawImage(this.offscreenCanvas, 0, 0);
        ctx.restore();
        return;
    }

    if ((this.isPanning || this.dragging || this.isSmoothPanningActive) && this.isUsingPanOptimization) {
        const gl = this.gl;
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;

        const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
        let r = 1.0, g = 1.0, b_val = 1.0;
        const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
        if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
        } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
        gl.clearColor(r, g, b_val, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        const dx = this.offset.x - this.panStartOffset.x;
        const dy = this.offset.y - this.panStartOffset.y;
        
        ctx.drawImage(this.offscreenCanvas, dx * dpr, dy * dpr);
        return;
    }

    const gl = this.gl; if (!gl) return;
    const container = this.canvasContainer;
    const cssWidth = container.clientWidth; const cssHeight = container.clientHeight;
    if (cssWidth <= 0 || cssHeight <= 0) return;
    const dpr = window.devicePixelRatio || 1;
    if (this.canvas.width !== cssWidth*dpr || this.canvas.height !== cssHeight*dpr) this.resizeCanvas();
    gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);

    const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
    let r = 1.0, g = 1.0, b_val = 1.0;
    const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
    if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
    } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
    gl.clearColor(r, g, b_val, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (!this.shaderProgramLines) return;

    gl.useProgram(this.shaderProgramLines);
    gl.uniform2f(this.uniformLocations.canvasCssSize, cssWidth, cssHeight);
    gl.uniform2f(this.uniformLocations.viewOffset, this.offset.x, this.offset.y);
    gl.uniform1f(this.uniformLocations.viewScale, this.scale);
    
    this.drawGridGL(cssWidth, cssHeight);
    this.drawAxesGL(cssWidth, cssHeight);
    
    this.processImplicitBlocksOnGrid(cssWidth, cssHeight);

    this.entries.forEach(entry => {
        const isMath = entry.type === 'function';
        const isGeo = entry.type === 'geometry';
        
       
        const hiddenByCheckbox = this.isHiddenByCheckbox(entry);
        if (hiddenByCheckbox) return; // 如果被复选框关闭，彻底不画

        const isVisible = this.getEffectiveVisibility(entry);
        const shouldShow = isVisible || (isMath && this.showHiddenMath) || (isGeo && this.showHiddenGeo);

        const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || entry.displayFrame === 0 || entry.displayFrame === this.currentFrame;
if (entry.type === 'point_list' && shouldShow && isFrameVisible && !this.is3DMode) {
                this.plotPointListGL(entry, cssWidth, cssHeight);
            } else if (isMath && shouldShow && isFrameVisible && !entry.compilationError) {
                const is3DType = ['z', 'x3d', 'y3d', 'implicit3d', 'parametric3d'].includes(entry.plotType);
                if (is3DType && !this.overlayDrawingEnabled) return;

            
            let originalAlpha; const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && this.showHiddenMath) { originalAlpha = entry.color.a;

                entry.color.a = 100 - (100 - originalAlpha) * 0.5;
            }
            
            if (entry.plotType === 'y' || entry.plotType === 'x') {
               if (entry.func) this.plotExplicitFunctionGL(entry, cssWidth, cssHeight);
           } else if (entry.plotType === 'parametric') {
               if (entry.funcX && entry.funcY) this.plotParametricFunctionGL(entry, cssWidth, cssHeight);
            }
            
        if (!isVisible && this.showHiddenMath) { 

                entry.color.a = originalAlpha;
            }
        }
    });

     this.implicitFillData.forEach((vertices, funcEntryOriginalIndex) => {
        const funcEntry = this.entries[funcEntryOriginalIndex];
if (this.isHiddenByCheckbox(funcEntry)) return;

 const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || funcEntry.displayFrame === 0 || funcEntry.displayFrame === this.currentFrame;
        const isVisible = this.getEffectiveVisibility(funcEntry); const shouldShow = (isVisible || (this.showHiddenMath && !isVisible)) && isFrameVisible;
        if (!funcEntry || !funcEntry.color || !shouldShow || vertices.length === 0) return;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
        
        let finalColor = funcEntry.color;
        if (!funcEntry.visible && this.showHiddenMath) {
            finalColor = {...funcEntry.color};
            finalColor.a = 100 - (100 - finalColor.a) * 0.5;
        }

        const fillAlpha = 100 - 0.5 * (100 - finalColor.a);
        const fillColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, fillAlpha);
        gl.uniform4fv(this.uniformLocations.color, fillColorArray);
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
    });

    const implicitVerticesByFunc = new Map();
    if (this.implictplotindex.length > 1) {
        for (let i = 0; i < this.implictplotindex.length - 1; i++) {
            const ip01 = this.implictplotindex[i]; const ip02 = this.implictplotindex[i + 1];
            if (ip01 === undefined || ip02 === undefined || ip01 >= ip02) continue;
            for (let j = ip01; j < ip02; j++) {
                const segment = this.implictplotdata[j]; if (!segment) continue;
                const [mX1, mY1, mX2, mY2, funcIdx] = segment;
                const entry = this.entries[funcIdx];
                if (!entry) continue;

                if (!implicitVerticesByFunc.has(funcIdx)) implicitVerticesByFunc.set(funcIdx, []);
                
                const currentThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useQuadsForImplicit = currentThickness > 1.5;
                const lineThicknessMathImplicit = currentThickness / this.scale;

                if (useQuadsForImplicit) implicitVerticesByFunc.get(funcIdx).push(...this.generateQuadVertices(mX1, mY1, mX2, mY2, lineThicknessMathImplicit));
                else implicitVerticesByFunc.get(funcIdx).push(mX1, mY1, mX2, mY2);
            }
        }
    }

    implicitVerticesByFunc.forEach((vertices, funcEntryOriginalIndex) => {
        const funcEntry = this.entries[funcEntryOriginalIndex];
if (this.isHiddenByCheckbox(funcEntry)) return;

 const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || funcEntry.displayFrame === 0 || funcEntry.displayFrame === this.currentFrame;
        const isVisible = this.getEffectiveVisibility(funcEntry); const shouldShow = (isVisible || (this.showHiddenMath && !isVisible)) && isFrameVisible;
        if (!funcEntry || !funcEntry.color || !shouldShow || vertices.length === 0) return;

        gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);

        let finalColor = funcEntry.color;
        if (!funcEntry.visible && this.showHiddenMath) {
            finalColor = {...funcEntry.color};
            finalColor.a = 100 - (100 - finalColor.a) * 0.5;
        }

        let outlineAlpha;
        if (['>', '<'].includes(funcEntry.sign)) {
            outlineAlpha = 100 - 0.5 * (100 - finalColor.a);
        } else {
            outlineAlpha = finalColor.a;
        }
        const plotColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
        gl.uniform4fv(this.uniformLocations.color, plotColorArray);
        
        const currentThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
        const useQuadsForImplicit = currentThickness > 1.5;
        
        if (useQuadsForImplicit) gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
        else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, vertices.length / 2); }
    });

    this.plotAllGeometryGL(cssWidth, cssHeight);
    

    this.drawAxisNumbers(cssWidth, cssHeight);
    this.drawPolygons2D(cssWidth, cssHeight);
    this.drawOrigin2D(cssWidth, cssHeight);
    this.drawGeometryLabels(cssWidth, cssHeight);
    this.drawAnnotations();
    this.drawActiveTrajectory();
    this.drawVariableCards();
    this.drawPenStrokesGL();
} 


plotExplicitFunctionGL(funcEntry, cssWidth, cssHeight) {
        if (funcEntry.compilationError || !funcEntry.func || !funcEntry.color) return;
        const gl = this.gl;
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
        const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();
    
        if (!funcEntry.webglVertices) {
            const finalPointsForGL = [];
            const pixelStep = Math.max(0.005, 1 / this.explicitPrecisionStep);
            const bufferPixels = Math.max(50, Math.max(cssWidth, cssHeight) * 0.1);
            const { x: offsetX, y: offsetY } = this.offset;
            

            const isYType = funcEntry.plotType === 'y' || funcEntry.plotType === 'y3d';
            const isXType = funcEntry.plotType === 'x' || funcEntry.plotType === 'x3d';

            if (this.adaptivePlottingEnabled && (isYType || isXType)) {
                const collectedPoints = [];
                const slopeFactor = 0.1;
                const defaultPixelStep = pixelStep;
                const minPixelStep = defaultPixelStep / 16.0;
                const dependentAxis = isYType ? 'y' : 'x';
                
                let consecutiveInvalidCount = 0;
                let consecutiveOffscreenMonotonicCount = 0;
                let lastDerivativeSign = 0;
                const RESET_THRESHOLD = 30;
    
                if (isYType) {
                    let px = -bufferPixels;
                    while (px < cssWidth + bufferPixels) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try { 
                            if (funcEntry.plotType === 'y3d') {

                                y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                            }
                        } catch (e) { y_math = NaN; }
                        const isValid = Number.isFinite(y_math);
                        
                        if (isValid) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            consecutiveInvalidCount = 0;
                            
                            const screenY = offsetY - y_math * this.scale;
                            
                            const screenTop = -bufferPixels;
                            const screenBottom = cssHeight + bufferPixels;
                            const xAxisScreenY = this.offset.y;
                            let checkTop, checkBottom;
    
                            if (xAxisScreenY < screenTop) { 
                                checkTop = this.offset.y - 10 * this.scale;
                                checkBottom = screenBottom;
                            } else if (xAxisScreenY > screenBottom) { 
                                checkTop = screenTop;
                                checkBottom = this.offset.y + 10 * this.scale;
                            } else { 
                                checkTop = screenTop;
                                checkBottom = screenBottom;
                            }
                            const isOffscreen = screenY < checkTop || screenY > checkBottom;
    
                            const h = 0.0001 / this.scale;
                            let y_plus_h, y_minus_h;
                            if (funcEntry.plotType === 'y3d') {
                                y_plus_h = funcEntry.func(x_math + h, 0, this.variables, Math, advancedFuncsMap);
                                y_minus_h = funcEntry.func(x_math - h, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_plus_h = funcEntry.func(x_math + h, this.variables, Math, advancedFuncsMap);
                                y_minus_h = funcEntry.func(x_math - h, this.variables, Math, advancedFuncsMap);
                            }
    
                            if (Number.isFinite(y_plus_h) && Number.isFinite(y_minus_h)) {
                                const currentDerivativeSign = Math.sign(y_plus_h - y_minus_h);
                                if (isOffscreen && currentDerivativeSign !== 0 && currentDerivativeSign === lastDerivativeSign) {
                                    consecutiveOffscreenMonotonicCount++;
                                } else {
                                    consecutiveOffscreenMonotonicCount = 0;
                                }
                                lastDerivativeSign = currentDerivativeSign;
                            } else {
                                consecutiveOffscreenMonotonicCount = 0;
                                lastDerivativeSign = 0;
                            }
                        } else {
                            consecutiveInvalidCount++;
                            consecutiveOffscreenMonotonicCount = 0;
                            lastDerivativeSign = 0;
                        }
                        collectedPoints.push({ x: x_math, y: y_math, valid: isValid });
                        
                        let step = defaultPixelStep;
                        if (consecutiveInvalidCount < RESET_THRESHOLD && consecutiveOffscreenMonotonicCount < RESET_THRESHOLD) {
                            if (isValid) {
                                const h = 0.0001 / this.scale;
                                let y_plus_h, y_minus_h;
                                if (funcEntry.plotType === 'y3d') {
                                    y_plus_h = funcEntry.func(x_math + h, 0, this.variables, Math, advancedFuncsMap);
                                    y_minus_h = funcEntry.func(x_math - h, 0, this.variables, Math, advancedFuncsMap);
                                } else {
                                    y_plus_h = funcEntry.func(x_math + h, this.variables, Math, advancedFuncsMap);
                                    y_minus_h = funcEntry.func(x_math - h, this.variables, Math, advancedFuncsMap);
                                }

                                if (Number.isFinite(y_plus_h) && Number.isFinite(y_minus_h)) {
                                    const derivative = (y_plus_h - y_minus_h) / (2 * h);
                                    step = defaultPixelStep / (1 + slopeFactor * Math.abs(derivative));
                                    step = Math.max(step, minPixelStep);
                                }
                            }
                        }
                        px += step;
                    }
                } else { 
                    let py = -bufferPixels;
                    while (py < cssHeight + bufferPixels) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try { 
                            if (funcEntry.plotType === 'x3d') {
              
                                x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap); 
                            }
                        } catch (e) { x_math = NaN; }
                        const isValid = Number.isFinite(x_math);
    
                        if (isValid) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            consecutiveInvalidCount = 0;
    
                            const screenX = offsetX + x_math * this.scale;
                            
                            const screenLeft = -bufferPixels;
                            const screenRight = cssWidth + bufferPixels;
                            const yAxisScreenX = this.offset.x;
                            let checkLeft, checkRight;
    
                            if (yAxisScreenX < screenLeft) { 
                                checkLeft = this.offset.x + 10 * this.scale;
                                checkRight = screenRight;
                            } else if (yAxisScreenX > screenRight) { 
                                checkLeft = screenLeft;
                                checkRight = this.offset.x - 10 * this.scale;
                            } else { 
                                checkLeft = screenLeft;
                                checkRight = screenRight;
                            }
                            const isOffscreen = screenX < checkLeft || screenX > checkRight;
    
                            const h = 0.0001 / this.scale;
                            let x_plus_h, x_minus_h;
                            if (funcEntry.plotType === 'x3d') {
                                x_plus_h = funcEntry.func(y_math + h, 0, this.variables, Math, advancedFuncsMap);
                                x_minus_h = funcEntry.func(y_math - h, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                x_plus_h = funcEntry.func(y_math + h, this.variables, Math, advancedFuncsMap);
                                x_minus_h = funcEntry.func(y_math - h, this.variables, Math, advancedFuncsMap);
                            }
                            
                            if (Number.isFinite(x_plus_h) && Number.isFinite(x_minus_h)) {
                                const currentDerivativeSign = Math.sign(x_plus_h - x_minus_h);
                                if (isOffscreen && currentDerivativeSign !== 0 && currentDerivativeSign === lastDerivativeSign) {
                                    consecutiveOffscreenMonotonicCount++;
                                } else {
                                    consecutiveOffscreenMonotonicCount = 0;
                                }
                                lastDerivativeSign = currentDerivativeSign;
                            } else {
                                consecutiveOffscreenMonotonicCount = 0;
                                lastDerivativeSign = 0;
                            }
                        } else {
                            consecutiveInvalidCount++;
                            consecutiveOffscreenMonotonicCount = 0;
                            lastDerivativeSign = 0;
                        }
                        collectedPoints.push({ x: x_math, y: y_math, valid: isValid });
                        
                        let step = defaultPixelStep;
                        if (consecutiveInvalidCount < RESET_THRESHOLD && consecutiveOffscreenMonotonicCount < RESET_THRESHOLD) {
                            if (isValid) {
                                const h = 0.0001 / this.scale;
                                let x_plus_h, x_minus_h;
                                if (funcEntry.plotType === 'x3d') {
                                    x_plus_h = funcEntry.func(y_math + h, 0, this.variables, Math, advancedFuncsMap);
                                    x_minus_h = funcEntry.func(y_math - h, 0, this.variables, Math, advancedFuncsMap);
                                } else {
                                    x_plus_h = funcEntry.func(y_math + h, this.variables, Math, advancedFuncsMap);
                                    x_minus_h = funcEntry.func(y_math - h, this.variables, Math, advancedFuncsMap);
                                }
                                if (Number.isFinite(x_plus_h) && Number.isFinite(x_minus_h)) {
                                    const derivative = (x_plus_h - x_minus_h) / (2 * h);
                                    step = defaultPixelStep / (1 + slopeFactor * Math.abs(derivative));
                                    step = Math.max(step, minPixelStep);
                                }
                            }
                        }
                        py += step;
                    }
                }
    
                const segments = [];
                const breakTypes = [];
                let currentSegmentPoints = [];
                for (let i = 0; i < collectedPoints.length; i++) {
                    const p = collectedPoints[i];
                    const breakType = this._isAdaptiveBreakPoint(collectedPoints, i, dependentAxis);
                    
                    if (p.valid && !breakType) {
                        currentSegmentPoints.push(p);
                    }
    
                    if (!p.valid || breakType || i === collectedPoints.length - 1) {
                        if (currentSegmentPoints.length > 1) {
                            segments.push(currentSegmentPoints);
                            breakTypes.push(breakType || (!p.valid ? 'invalid' : null));
                        }
                        currentSegmentPoints = [];
                        if (p.valid && breakType) {
                            currentSegmentPoints.push(p);
                        }
                    }
                }
                
                segments.forEach((segment, segIndex) => {
                    const startsWithDiscontinuity = segIndex > 0;
                    const endsWithDiscontinuity = segIndex < segments.length - 1;
                    const reasonForStart = segIndex > 0 ? breakTypes[segIndex - 1] : null;
                    const reasonForEnd = breakTypes[segIndex];
                    
                    let canExtendStart = false;
                    if (this.adaptiveExtendEnabled && startsWithDiscontinuity && reasonForStart !== 'step') {
                        const prevSegment = segments[segIndex - 1];
                        if (prevSegment && prevSegment.length >= 2 && segment.length >= 2) {
                            const p_prev_last = prevSegment[prevSegment.length - 1];
                            const p_prev_penultimate = prevSegment[prevSegment.length - 2];
                            const p_curr_first = segment[0];
                            const p_curr_second = segment[1];
                            const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
                            const leftSlope = (p_prev_last[dependentAxis] - p_prev_penultimate[dependentAxis]) / (p_prev_last[independentAxis] - p_prev_penultimate[independentAxis]);
                            const rightSlope = (p_curr_second[dependentAxis] - p_curr_first[dependentAxis]) / (p_curr_second[independentAxis] - p_curr_first[independentAxis]);
                            const valueDiff = Math.abs(p_curr_first[dependentAxis] - p_prev_last[dependentAxis]);
                            if (Math.abs(leftSlope) > 20 && Math.abs(rightSlope) > 20 && valueDiff > 60) {
                                canExtendStart = true;
                            }
                        }
                    }
    
                    if (canExtendStart) {
                        const p_first = segment[0];
                        if (isYType) {
                            const slope_start = (segment[1].y - p_first.y) / (segment[1].x - p_first.x);
                            const start_extension_y = (slope_start > 0) ? (offsetY - cssHeight) / this.scale : offsetY / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_first.x, start_extension_y, p_first.x, p_first.y, lineThicknessMath));
                            else finalPointsForGL.push(p_first.x, start_extension_y, p_first.x, p_first.y);
                        } else {
                            const slope_start = (segment[1].x - p_first.x) / (segment[1].y - p_first.y);
                            const start_extension_x = (slope_start > 0) ? (-offsetX) / this.scale : (cssWidth - offsetX) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(start_extension_x, p_first.y, p_first.x, p_first.y, lineThicknessMath));
                            else finalPointsForGL.push(start_extension_x, p_first.y, p_first.x, p_first.y);
                        }
                    }
    
                    for (let i = 0; i < segment.length - 1; i++) {
                        const p1 = segment[i];
                        const p2 = segment[i+1];
                        if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(p1.x, p1.y, p2.x, p2.y, lineThicknessMath));
                        else finalPointsForGL.push(p1.x, p1.y, p2.x, p2.y);
                    }
    
                    let canExtendEnd = false;
                    if (this.adaptiveExtendEnabled && endsWithDiscontinuity && reasonForEnd !== 'step') {
                        const nextSegment = segments[segIndex + 1];
                        if (nextSegment && nextSegment.length >= 2 && segment.length >= 2) {
                            const p_curr_last = segment[segment.length - 1];
                            const p_curr_penultimate = segment[segment.length - 2];
                            const p_next_first = nextSegment[0];
                            const p_next_second = nextSegment[1];
                            const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
                            const leftSlope = (p_curr_last[dependentAxis] - p_curr_penultimate[dependentAxis]) / (p_curr_last[independentAxis] - p_curr_penultimate[independentAxis]);
                            const rightSlope = (p_next_second[dependentAxis] - p_next_first[dependentAxis]) / (p_next_second[independentAxis] - p_next_first[independentAxis]);
                            const valueDiff = Math.abs(p_next_first[dependentAxis] - p_curr_last[dependentAxis]);
                            if (Math.abs(leftSlope) > 20 && Math.abs(rightSlope) > 20 && valueDiff > 60) {
                                canExtendEnd = true;
                            }
                        }
                    }
    
                    if (canExtendEnd) {
                        const p_last = segment[segment.length - 1];
                         if (isYType) {
                            const slope_end = (p_last.y - segment[segment.length - 2].y) / (p_last.x - segment[segment.length - 2].x);
                            const end_extension_y = (slope_end > 0) ? offsetY / this.scale : (offsetY - cssHeight) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_last.x, p_last.y, p_last.x, end_extension_y, lineThicknessMath));
                            else finalPointsForGL.push(p_last.x, p_last.y, p_last.x, end_extension_y);
                        } else {
                            const slope_end = (p_last.x - segment[segment.length - 2].x) / (p_last.y - segment[segment.length - 2].y);
                            const end_extension_x = (slope_end > 0) ? (cssWidth - offsetX) / this.scale : (-offsetX) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_last.x, p_last.y, end_extension_x, p_last.y, lineThicknessMath));
                            else finalPointsForGL.push(p_last.x, p_last.y, end_extension_x, p_last.y);
                        }
                    }
                });
    
            } else if (this.autoBreakpointDetectionEnabled && (isYType || isXType)) {
                const collectedPoints = []; 
                if (isYType) {
                    for (let px = -bufferPixels; px < cssWidth + bufferPixels; px += pixelStep) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try {
                            if (funcEntry.plotType === 'y3d') y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            else y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                        } catch (e) { y_math = NaN; }
                        if (Number.isFinite(y_math)) this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                        collectedPoints.push({ x: x_math, y: y_math, val: y_math, valid: Number.isFinite(y_math) });
                    }
                } else { 
                    for (let py = -bufferPixels; py < cssHeight + bufferPixels; py += pixelStep) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try {
                            if (funcEntry.plotType === 'x3d') x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            else x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) { x_math = NaN; }
                        if (Number.isFinite(x_math)) this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                        collectedPoints.push({ x: x_math, y: y_math, val: x_math, valid: Number.isFinite(x_math) });
                    }
                }
    
                for (let i = 0; i < collectedPoints.length - 1; i++) {
                    const pCurr = collectedPoints[i];
                    const pNext = collectedPoints[i+1];
    
                    if (pCurr.valid && pNext.valid) {
                        let connect = true;
                        if (i >= 2 && (i + 1) < collectedPoints.length) { 
                            const pPrev = collectedPoints[i-1];
                            const pPrev2 = collectedPoints[i-2];
                            connect = !this._isBreakPoint(pNext.val, pCurr.val, pPrev.val, pPrev2.val);
                        }
                        
                        if (connect) {
                            if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(pCurr.x, pCurr.y, pNext.x, pNext.y, lineThicknessMath));
                            else finalPointsForGL.push(pCurr.x, pCurr.y, pNext.x, pNext.y);
                        }
                    }
                }
            } else { 
                if (isYType) {
                    let lastValidPoint = null;
                    for (let px = -bufferPixels; px < cssWidth + bufferPixels; px += pixelStep) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try {
                            if (funcEntry.plotType === 'y3d') y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            else y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                        } catch (e) { y_math = NaN; }
                        if (Number.isFinite(y_math)) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            const currentPoint = { x: x_math, y: y_math };
                            if (lastValidPoint) {
                                if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y, lineThicknessMath));
                                else finalPointsForGL.push(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y);
                            }
                            lastValidPoint = currentPoint;
                        } else lastValidPoint = null;
                    }
                } else { 
                    let lastValidPoint = null;
                    for (let py = -bufferPixels; py < cssHeight + bufferPixels; py += pixelStep) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try {
                            if (funcEntry.plotType === 'x3d') x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            else x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) { x_math = NaN; }
                        if (Number.isFinite(x_math)) {
                             this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                             const currentPoint = { x: x_math, y: y_math };
                             if (lastValidPoint) {
                                if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y, lineThicknessMath));
                                else finalPointsForGL.push(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y);
                             }
                             lastValidPoint = currentPoint;
                        } else lastValidPoint = null;
                    }
                }
            }
            funcEntry.webglVertices = new Float32Array(finalPointsForGL);
        }
    
        if (funcEntry.webglVertices && funcEntry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, funcEntry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            const plotColorArray = this.hsbToRgbaArray(funcEntry.color.h, funcEntry.color.s, funcEntry.color.b, funcEntry.color.a);
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);
            if (useQuads) gl.drawArrays(gl.TRIANGLES, 0, funcEntry.webglVertices.length / 2);
            else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, funcEntry.webglVertices.length / 2); }
        }
    }

recalculateParametricCache(funcEntry) {
    if (!funcEntry.funcX || !funcEntry.funcY) return;
    const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();
    funcEntry.cachedPoints = [];
    const numSteps = Math.max(2, Math.floor(this.explicitPrecisionStep * 100));
    const tStep = (this.tmax - this.tmin) / numSteps;
    const is3D = funcEntry.plotType === 'parametric3d';

    for (let i = 0; i <= numSteps; i++) {
       const t = this.tmin + i * tStep;
       let x_math = NaN, y_math = NaN;
       try {
           x_math = funcEntry.funcX(t, this.variables, Math, advancedFuncsMap);
           y_math = funcEntry.funcY(t, this.variables, Math, advancedFuncsMap);

           if (is3D && funcEntry.funcZ) {
               funcEntry.funcZ(t, this.variables, Math, advancedFuncsMap); 
           }
       } catch (e) {  }
       if (Number.isFinite(x_math) && Number.isFinite(y_math)) {
           const point = { x: x_math, y: y_math };
           funcEntry.cachedPoints.push(point);
           this.plottedFunctionPoints.push(point);
       }
       else if (funcEntry.cachedPoints.length > 0 && funcEntry.cachedPoints[funcEntry.cachedPoints.length-1] !== null) {
            funcEntry.cachedPoints.push(null);
       }
    }
    funcEntry.webglVertices = null;
}

plotParametricFunctionGL(funcEntry, cssWidth, cssHeight) {
    if (funcEntry.compilationError || !funcEntry.funcX || !funcEntry.funcY || !funcEntry.color) return;
    

    const gl = this.gl;
    const entryThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
    const useQuads = entryThickness > 1.5;
    const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
    if (!funcEntry.webglVertices) {
       if (!funcEntry.cachedPoints || funcEntry.cachedPoints.length === 0) {
           this.recalculateParametricCache(funcEntry);
           if (!funcEntry.cachedPoints || funcEntry.cachedPoints.length === 0) return;
       }
       const points = [];
       let lastValidPoint = null;
       funcEntry.cachedPoints.forEach(p_math => {
           if (p_math === null) { lastValidPoint = null; return; }
           if (lastValidPoint) {
               if (useQuads) points.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, p_math.x, p_math.y, lineThicknessMath));
               else points.push(lastValidPoint.x, lastValidPoint.y, p_math.x, p_math.y);
           }
           lastValidPoint = p_math;
       });
       funcEntry.webglVertices = new Float32Array(points);
    }
    if (funcEntry.webglVertices && funcEntry.webglVertices.length > 0) {
       gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
       gl.bufferData(gl.ARRAY_BUFFER, funcEntry.webglVertices, gl.DYNAMIC_DRAW);
       gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
       gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
const isVisible = this.getEffectiveVisibility(funcEntry); let tempColor = { ...funcEntry.color }; if (!isVisible && this.showHiddenMath) { tempColor.a = 100 - (100 - tempColor.a) * 0.5; }

       const plotColorArray = this.hsbToRgbaArray(funcEntry.color.h, funcEntry.color.s, funcEntry.color.b, funcEntry.color.a);
       gl.uniform4fv(this.uniformLocations.color, plotColorArray);
       if (useQuads) gl.drawArrays(gl.TRIANGLES, 0, funcEntry.webglVertices.length / 2);
       else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, funcEntry.webglVertices.length / 2); }
    }
}

processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, unitStep) {
        this.implicttempdata.length = 0;
        const cellSizeInPixels = unitStep * this.scale;
        this.implictjump = Math.ceil(cellSizeInPixels / this.implicitPrecisionStep);
        if (this.implictjump <= 0) this.implictjump = 1;
        const numPoints1D = this.implictjump + 1;
        const subCellStepMath = unitStep / this.implictjump;
        const cellMinXMath = cellCenterXMath - unitStep / 2;
        const cellMaxYMath = cellCenterYMath + unitStep / 2;
        

const implicitFunctions = this.entries.filter(e => 
            e.type === 'function' && 
            (e.plotType === 'implicit' || e.plotType === 'implicit3d' || e.plotType === 'z' || e.plotType === 'x3d' || e.plotType === 'y3d') && 
            e.func && !e.compilationError && (e.visible || this.showHiddenMath) &&
            (this.overlayDrawingEnabled || !['implicit3d', 'z', 'x3d', 'y3d'].includes(e.plotType))
        );

        if (implicitFunctions.length === 0) return;
       const baseMap = this.calcJSUtils.getAdvancedFuncsMap();
        const advancedFuncsMap = { ...baseMap };
        const originalPow = advancedFuncsMap.pow;
        advancedFuncsMap.pow = (a, b) => {
            if (a < 0 && Math.abs(b - Math.round(b)) > 1e-10) return NaN;
            return originalPow(a, b);
        };

        for (let iy_subgrid = 0; iy_subgrid < numPoints1D; iy_subgrid++) {
            const y_math_subgrid = cellMaxYMath - iy_subgrid * subCellStepMath;
            for (let ix_subgrid = 0; ix_subgrid < numPoints1D; ix_subgrid++) {
                const x_math_subgrid = cellMinXMath + ix_subgrid * subCellStepMath;
                for (const funcEntry of implicitFunctions) {
                    try {
                        let value = NaN;
                        if (funcEntry.plotType === 'implicit3d' || funcEntry.plotType === 'z') {
        
                            const z_val = 0;
                            if (funcEntry.plotType === 'z') {

                                value = funcEntry.func(x_math_subgrid, y_math_subgrid, z_val, this.variables, Math, advancedFuncsMap);
                            } else {
                                value = funcEntry.func(x_math_subgrid, y_math_subgrid, z_val, this.variables, Math, advancedFuncsMap);
                            }
                        } else if (funcEntry.plotType === 'x3d') {

                            const val = funcEntry.func(0, y_math_subgrid, 0, this.variables, Math, advancedFuncsMap);
                            value = x_math_subgrid - val;
                        } else if (funcEntry.plotType === 'y3d') {

                            const val = funcEntry.func(x_math_subgrid, 0, 0, this.variables, Math, advancedFuncsMap);
                            value = y_math_subgrid - val;
                        } else {

                            value = funcEntry.func(x_math_subgrid, y_math_subgrid, this.variables, Math, advancedFuncsMap);
                        }
                        this.implicttempdata.push(Number.isFinite(value) ? value : NaN);
                    } catch (e) { this.implicttempdata.push(NaN); }
                }
            }
        }
        
        const epsilon = 1e-9;
        for (let iy_cell = 0; iy_cell < this.implictjump; iy_cell++) {
            for (let ix_cell = 0; ix_cell < this.implictjump; ix_cell++) {
                const sub_x0 = cellMinXMath + ix_cell * subCellStepMath;

                const sub_y_top = cellMaxYMath - iy_cell * subCellStepMath;
                const sub_x1 = sub_x0 + subCellStepMath;
                const sub_y_bottom = sub_y_top - subCellStepMath;
                
                for (let funcIdx = 0; funcIdx < implicitFunctions.length; funcIdx++) {
                    const funcEntry = implicitFunctions[funcIdx];
                    const originalFuncEntryIndex = this.entries.indexOf(funcEntry);
                    const idx_v00 = (iy_cell * numPoints1D + ix_cell) * implicitFunctions.length + funcIdx;
                    const idx_v10 = (iy_cell * numPoints1D + (ix_cell + 1)) * implicitFunctions.length + funcIdx;
                    const idx_v01 = ((iy_cell + 1) * numPoints1D + ix_cell) * implicitFunctions.length + funcIdx;
                    const idx_v11 = ((iy_cell + 1) * numPoints1D + (ix_cell + 1)) * implicitFunctions.length + funcIdx;
                    
                    const v00 = this.implicttempdata[idx_v00]; 
                    const v10 = this.implicttempdata[idx_v10]; 
                    const v01 = this.implicttempdata[idx_v01]; 
                    const v11 = this.implicttempdata[idx_v11]; 

                    if (!Number.isFinite(v00) || !Number.isFinite(v10) || !Number.isFinite(v01) || !Number.isFinite(v11)) continue;

                    const lerp = (c1, c2, v1, v2) => { if (Math.abs(v1-v2)<epsilon) return NaN; return c1+(c2-c1)*(0-v1)/(v2-v1); };
                    const pA = { x: lerp(sub_x0, sub_x1, v00, v10), y: sub_y_top };
                    const pB = { x: sub_x1, y: lerp(sub_y_top, sub_y_bottom, v10, v11) };
                    const pC = { x: lerp(sub_x0, sub_x1, v01, v11), y: sub_y_bottom };
                    const pD = { x: sub_x0, y: lerp(sub_y_top, sub_y_bottom, v00, v01) };
                    const c00={x:sub_x0,y:sub_y_top}, c10={x:sub_x1,y:sub_y_top}, c11={x:sub_x1,y:sub_y_bottom}, c01={x:sub_x0,y:sub_y_bottom};

                    let outlineIndex=0; if(v00<0)outlineIndex|=1; if(v10<0)outlineIndex|=2; if(v11<0)outlineIndex|=4; if(v01<0)outlineIndex|=8;
                    

                    const effectiveSign = (funcEntry.plotType === 'z' || funcEntry.plotType === 'x3d' || funcEntry.plotType === 'y3d' || funcEntry.plotType === 'implicit3d') ? '=' : funcEntry.sign;

                    if (['=', '>=', '<='].includes(effectiveSign) && outlineIndex !== 0 && outlineIndex !== 15) {
                        let skipOutline = false;
                        if (this.autoBreakpointDetectionEnabled) {
                            const getValueFromTempData=(ix,iy)=>{if(ix>=0&&ix<numPoints1D&&iy>=0&&iy<numPoints1D){const v_idx=(iy*numPoints1D+ix)*implicitFunctions.length+funcIdx;return this.implicttempdata[v_idx];}return NaN;};
                            const sum_c=Math.abs(v01)+Math.abs(v11)+Math.abs(v00)+Math.abs(v10);
                            const v_outer=[getValueFromTempData(ix_cell,iy_cell+2),getValueFromTempData(ix_cell+1,iy_cell+2),getValueFromTempData(ix_cell,iy_cell-1),getValueFromTempData(ix_cell+1,iy_cell-1)];
                            if(v_outer.every(Number.isFinite)&&(v_outer.reduce((s,v)=>s+Math.abs(v),0)>sum_c*4||sum_c>this.implicitPrecisionStep*unitStep*1.4)) {
                                skipOutline = true;
                            }
                        }
                        if (!skipOutline) {
                            const addSegment = (p1, p2) => {
                                if (Number.isFinite(p1.x) && Number.isFinite(p1.y) && Number.isFinite(p2.x) && Number.isFinite(p2.y)) {
                                    this.implictplotdata.push([p1.x, p1.y, p2.x, p2.y, originalFuncEntryIndex]);

                                    this.plottedFunctionPoints.push(p1);
                                    this.plottedFunctionPoints.push(p2);
                                }
                            };
                            switch(outlineIndex){case 1:case 14:addSegment(pD,pA);break;case 2:case 13:addSegment(pA,pB);break;case 3:case 12:addSegment(pD,pB);break;case 4:case 11:addSegment(pB,pC);break;case 5:addSegment(pD,pA);addSegment(pB,pC);break;case 6:case 9:addSegment(pA,pC);break;case 7:case 8:addSegment(pD,pC);break;case 10:addSegment(pA,pB);addSegment(pD,pC);break;}
                        }
                    }
                    
                 if (['>', '>=', '<', '<='].includes(effectiveSign)) {
                        const fillPositive = ['>', '>='].includes(effectiveSign);
                        const strictEpsilon = 1e-9;
                        const test = (v) => {
                            if (fillPositive) {
                                return effectiveSign === '>' ? (v > strictEpsilon) : (v >= 0);
                            } else {
                                return effectiveSign === '<' ? (v < -strictEpsilon) : (v <= 0);
                            }
                        };
                        
                        let fillCase = 0;
                        if (test(v00)) fillCase |= 1;
                        if (test(v10)) fillCase |= 2;
                        if (test(v11)) fillCase |= 4;
                        if (test(v01)) fillCase |= 8;

                        if (fillCase === 0 || fillCase === 5 || fillCase === 10) {
                            continue;
                        }

                        if (!this.implicitFillData.has(originalFuncEntryIndex)) {
                            this.implicitFillData.set(originalFuncEntryIndex, []);
                        }
                        const fillData = this.implicitFillData.get(originalFuncEntryIndex);
                        
                        const addTri = (p1, p2, p3) => {
                            if ([p1, p2, p3].every(p => p && Number.isFinite(p.x) && Number.isFinite(p.y))) {
                                fillData.push(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                            }
                        };
                        const addQuad = (p1, p2, p3, p4) => {
                            addTri(p1, p2, p3);
                            addTri(p1, p3, p4);
                        };

                        switch (fillCase) {
                            case 1: addTri(c00, pA, pD); break;
                            case 2: addTri(pA, c10, pB); break;
                            case 3: addQuad(c00, c10, pB, pD); break;
                            case 4: addTri(pB, c11, pC); break;
                            case 6: addQuad(c10, c11, pC, pA); break;
                            case 7: addTri(c00, c10, pD); addTri(c10, c11, pD); addTri(c11, pC, pD); break;
                            case 8: addTri(pD, c01, pC); break;
                            case 9: addQuad(c01, c00, pA, pC); break;
                            case 11: addTri(c00, c10, pB); addTri(c00, pB, pC); addTri(c00, pC, c01); break;
                            case 12: addQuad(c01, c11, pB, pD); break;
                            case 13: addTri(c01, c11, pB); addTri(c01, pB, pA); addTri(c01, pA, c00); break;
                            case 14: addTri(c10, c11, c01); addTri(c10, c01, pD); addTri(c10, pD, pA); break;
                            case 15: addQuad(c00, c10, c11, c01); break;
                        }
                    }
                }
            }
        }
    }

updatePrecisionLabels() {
this.explicitPrecisionValueSpan.textContent = `值: ${parseFloat(this.explicitPrecisionSlider.options.value).toFixed(2)}`;
this.implicitPrecisionValueSpan.textContent = `值: ${parseFloat(this.implicitPrecisionSlider.options.value).toFixed(1)}`;
}

updateParametricRangeLabels() {
this.tminValueSpan.textContent = this.tmin.toFixed(4);
this.tmaxValueSpan.textContent = this.tmax.toFixed(4);
}

updatePreferredColorValueLabel() {
this.preferredColorValueSpan.textContent = `值: ${this.preferredColorValue}`;
}

updateIntegralPrecisionLabel() {
if (this.integralPrecisionValueSpan) {
this.integralPrecisionValueSpan.textContent = `值: ${this.integralNumSteps}`;
}
}

enterAnnotationMode(returnMode = null) {
        this.stopTracing();
        const fileNameDisplay = document.getElementById('file-name-display');
        if (fileNameDisplay) fileNameDisplay.style.display = 'none';
        
        const mainContentTitle = document.getElementById('main-content-title');
        if (mainContentTitle) mainContentTitle.style.display = 'none';

        this.previousUIMode = returnMode || this.currentUIMode;
        
        this.currentUIMode = 'annotation';
        this.cancelGeometryInteraction();
        this.annotationMenu.style.display = 'flex';
        
        const showSidebarBtn = document.getElementById('show-sidebar-btn');
        if (showSidebarBtn) showSidebarBtn.style.display = 'none';

        if (!document.body.classList.contains('sidebar-hidden')) {
            document.body.classList.add('sidebar-hidden');
            this.updateLayout();
        }
        
        this.setAnnotationMode('pen');
        this.selectedAnnotationIndex = -1;
        this._rebindAnnotationControlsToGlobalState();
        this.updateAnnotationEditMenu();
        
        this.updateTopBarLayout();
        this.requestDraw();
    }

exitAnnotationMode() {
        const targetMode = this.previousUIMode || 'plot';
        
        this.annotationMenu.style.display = 'none';
        document.body.classList.remove('sidebar-hidden');
        
        const showSidebarBtn = document.getElementById('show-sidebar-btn');
        if (showSidebarBtn) showSidebarBtn.style.display = '';

        this.setUIMode(targetMode);
        
        const geoBtn = this.geometryPanel.querySelector('.geo-btn[data-geo-type="annotation"]');
        if (geoBtn) geoBtn.classList.remove('active');

        this.selectedAnnotationIndex = -1;
        this.updateAnnotationEditMenu();
        
        this.updateLayout();
        this.updateTopBarLayout();
        this.updateOverlayPositions();
    }

setAnnotationMode(mode) {
    this.annotationState.mode = mode;
    const buttons = this.annotationMenu.querySelectorAll('.annotation-mode-switch-btn');
    buttons.forEach(btn => {
        btn.classList.toggle('active', btn.id === `annotation-${mode}-btn`);
    });


    if (mode === 'eraser') {
        this.selectedAnnotationIndex = -1;
    }

    this.updateAnnotationEditMenu();
    this.requestDraw();
}


handleAnnotationInteractionStart(e) {
        if (e.cancelable) e.preventDefault();
        const coords = this.getEventCoordinates(e);
        const mathCoords = {
            x: (coords.x - this.offset.x) / this.scale,
            y: (this.offset.y - coords.y) / this.scale
        };

        if (this.annotationState.mode === 'eraser') {
            this.annotationState.isDrawing = true;
            this.performEraserAction(coords);
        } else if (this.annotationState.mode === 'pen') {
            this.annotationState.isDrawing = true;
            this.annotationState.currentDrawingPath = [mathCoords];
        } else if (this.annotationState.mode === 'text') {
            const textContent = prompt("请输入文本内容:");
            if (textContent) {
                const textAnnotation = {
                    type: 'text',
                    content: textContent,
                    x: mathCoords.x,
                    y: mathCoords.y,
                    width: 8,
                    height: 3,
                    fontSize: this.annotationState.pen.fontSize,
                    color: { ...this.annotationState.pen.color }
                };
                this.annotations.push(textAnnotation);
                this.requestDraw();
            }
        } else if (this.annotationState.mode === 'image') {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';

            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.readAsDataURL(file);

                reader.onload = (loadEvent) => {
                    const base64Data = loadEvent.target.result;
                    const img = new Image();
                    img.onload = () => {
                        const defaultPixelWidth = this.canvas.width / window.devicePixelRatio * 0.25;
                        const aspectRatio = img.height / img.width;
                        const mathWidth = defaultPixelWidth / this.scale;
                        const mathHeight = mathWidth * aspectRatio;

                        const imageAnnotation = {
                            type: 'image',
                            src: base64Data,
                            img: img,
                            x: mathCoords.x,
                            y: mathCoords.y,
                            width: mathWidth,
                            height: mathHeight,
                            scaleX: 1,
                            scaleY: 1,
                            color: { h: 0, s: 0, b: 100, a: 0 }
                        };
                        this.annotations.push(imageAnnotation);
                        this.requestDraw();
                    };
                    img.src = base64Data;
                };
            };
            fileInput.click();
        } else if (this.annotationState.mode === 'pdf') {
            this._ensurePdfJsLoaded().then(() => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/pdf';
                fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async (loadEvent) => {
                    const dataUrl = loadEvent.target.result;
                    const base64Content = dataUrl.split(',')[1]; 
                    
                    const binaryString = window.atob(base64Content);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    try {
                        const pdf = await window.pdfjsLib.getDocument(bytes).promise;
                        const pdfAnnotation = {
                            type: 'pdf',
                            pdfDoc: pdf,
                            pdfData: bytes,        
                            pdfDataBase64: base64Content, 
                            page: 1,
                            totalPages: pdf.numPages,
                            x: mathCoords.x,
                            y: mathCoords.y,
                            width: 10,
                            height: 14,
                            scaleX: 1,
                            scaleY: 1,
                            color: { h: 0, s: 0, b: 100, a: 0 },
                            img: null
                        };
                        await this.renderPdfPage(pdfAnnotation);

                        if (pdfAnnotation.img) {
                            const aspectRatio = pdfAnnotation.img.height / pdfAnnotation.img.width;
                            const defaultWidth = 10;
                            pdfAnnotation.width = defaultWidth;
                            pdfAnnotation.height = defaultWidth * aspectRatio;
                        }

                        this.annotations.push(pdfAnnotation);
                        this.requestDraw();
                    } catch (error) {
                        console.error(error);
                        alert('PDF加载失败: ' + error.message);
                    }
                };
                reader.readAsDataURL(file);
            };
                fileInput.click();
            });
        } else if (this.annotationState.mode === 'audio') {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'audio/*';
            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (loadEvent) => {
                    const base64Data = loadEvent.target.result;
                    const audio = new Audio(base64Data);
                    const audioAnnotation = {
                        type: 'audio',
                        src: base64Data,
                        audioElem: audio,
                        x: mathCoords.x,
                        y: mathCoords.y,
                        width: 2,
                        height: 2,
                        scaleX: 1,
                        scaleY: 1,
                        color: { h: 200, s: 80, b: 90, a: 0 }, 
                        isPlaying: false
                    };

                    audio.addEventListener('ended', () => {
                        audioAnnotation.isPlaying = false;
                        this.requestDraw();
                    });
                    audio.addEventListener('timeupdate', () => {
                        if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === audioAnnotation) {
                            this.requestDraw();
                        }
                    });

                    this.annotations.push(audioAnnotation);
                    this.requestDraw();
                };
                reader.readAsDataURL(file);
            };
            fileInput.click();
        }
    } 


handleAnnotationInteractionMove(e) {
        if (e.cancelable) e.preventDefault();
        const coords = this.getEventCoordinates(e);
        
        if (this.annotationState.mode === 'eraser') {
            this.annotationState.currentPos = coords;
            if (this.annotationState.isDrawing) {
                this.performEraserAction(coords);
            }
            this.requestDraw();
        } else if (this.annotationState.isDrawing && this.annotationState.mode === 'pen') {
            const mathCoords = {
                x: (coords.x - this.offset.x) / this.scale,
                y: (this.offset.y - coords.y) / this.scale
            };
            this.annotationState.currentDrawingPath.push(mathCoords);
            this.requestDraw();
        }
    }

handleAnnotationInteractionEnd(e) {
        if (!this.annotationState.isDrawing) return;
        this.annotationState.isDrawing = false;
        
        if (this.annotationState.mode === 'eraser') {
            this.requestDraw();
            return;
        }

        if (this.annotationState.currentDrawingPath.length > 1) {
            const path = this.annotationState.currentDrawingPath;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);

            const penAnnotation = {
                type: 'pen',
                path: path.map(p => ({ x: p.x - minX, y: p.y - minY })),
                color: {...this.annotationState.pen.color},
                thickness: this.annotationState.pen.thickness,
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                scaleX: 1,
                scaleY: 1
            };
            this.annotations.push(penAnnotation);
        }
        this.annotationState.currentDrawingPath = [];
        this.requestDraw();
    }

    performEraserAction(screenCoords) {
        const eraserRadius = (this.annotationState.pen.thickness * this.scale) / 2;
        
        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const anno = this.annotations[i];
            if (anno.type !== 'pen' && anno.type !== 'text') continue;

            const screenX = this.offset.x + anno.x * this.scale;
            const screenY = this.offset.y - anno.y * this.scale;
            const screenW = anno.width * (anno.scaleX || 1) * this.scale;
            const screenH = anno.height * (anno.scaleY || 1) * this.scale;
            
            let hit = false;
            if (anno.type === 'text') {
                const closestX = Math.max(screenX, Math.min(screenCoords.x, screenX + screenW));
                const closestY = Math.max(screenY, Math.min(screenCoords.y, screenY + screenH));
                const distance = Math.hypot(screenCoords.x - closestX, screenCoords.y - closestY);
                if (distance < eraserRadius) hit = true;
            } else if (anno.type === 'pen') {
                for (let j = 0; j < anno.path.length - 1; j++) {
                    const p1 = {
                        x: screenX + anno.path[j].x * (anno.scaleX || 1) * this.scale,
                        y: screenY - anno.path[j].y * (anno.scaleY || 1) * this.scale
                    };
                    const p2 = {
                        x: screenX + anno.path[j+1].x * (anno.scaleX || 1) * this.scale,
                        y: screenY - anno.path[j+1].y * (anno.scaleY || 1) * this.scale
                    };
                    
                    const l2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2;
                    if (l2 === 0) continue;
                    let t = ((screenCoords.x - p1.x) * (p2.x - p1.x) + (screenCoords.y - p1.y) * (p2.y - p1.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    const dist = Math.hypot(screenCoords.x - (p1.x + t * (p2.x - p1.x)), screenCoords.y - (p1.y + t * (p2.y - p1.y)));
                    
                    if (dist < eraserRadius + (anno.thickness * this.scale / 2)) {
                        hit = true;
                        break;
                    }
                }
            }

            if (hit) {
                this.annotations.splice(i, 1);
            }
        }
    }


drawVariableCards() {
    if (this.is3DMode) return;

    const ctx = this.axisCtx;
    const dpr = window.devicePixelRatio || 1;
    ctx.save();
    ctx.scale(dpr, dpr);

    const roundRect = (x, y, w, h, r) => {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    };

    const isDark = this.isDarkModeActive;
    const bgColor = isDark ? "rgba(45, 45, 45, 0.8)" : "rgba(245, 245, 245, 0.8)";
    const textColor = isDark ? "#fff" : "#000";
    const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color-accent').trim();

    this.entries.forEach((entry, index) => {
        if (entry.type === 'variable' && entry.isEditableIndependent && entry.showOnPlot) {
            const x = this.offset.x + entry.cardX * this.scale;
            const y = this.offset.y - entry.cardY * this.scale;
            const w = entry.cardW;
            const h = entry.cardH;

            ctx.fillStyle = bgColor;
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = 10;
            roundRect(x, y, w, h, 15);
            ctx.fill();
            ctx.shadowBlur = 0;

           

            ctx.font = "bold 16px 'HarmonyOS_SC', Arial";
            ctx.fillStyle = textColor;
            ctx.textBaseline = "top";
            ctx.textAlign = "left";
            
            const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : "NaN";
            ctx.fillText(`${entry.name} = ${displayValue}`, x + 15, y + 15);

            const btnRadius = 16;
            const btnX = x + w - 15 - btnRadius;
            const btnY = y + 15 + 8;
            
            ctx.fillStyle = isDark ? "rgba(80,80,80,0.5)" : "rgba(220,220,220,0.5)";
            ctx.beginPath();
            ctx.arc(btnX, btnY, btnRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = isDark ? "#fff" : "#333";
            if (entry.playState === 1) {
                const bw = 4, bh = 12;
                ctx.fillRect(btnX - 5, btnY - 6, bw, bh);
                ctx.fillRect(btnX + 1, btnY - 6, bw, bh);
            } else {
                ctx.beginPath();
                ctx.moveTo(btnX - 4, btnY - 7);
                ctx.lineTo(btnX + 6, btnY);
                ctx.lineTo(btnX - 4, btnY + 7);
                ctx.fill();
            }

            const sliderMargin = 15;
            const sliderY = y + 60;
            const sliderH = 6;
            const sliderW = w - sliderMargin * 2;
            const trackRadius = sliderH / 2;

            ctx.fillStyle = isDark ? "#555" : "#ccc";
            roundRect(x + sliderMargin, sliderY, sliderW, sliderH, trackRadius);
            ctx.fill();

            let norm = 0;
            if (Number.isFinite(entry.min) && Number.isFinite(entry.max) && entry.max > entry.min) {
                norm = Math.max(0, Math.min(1, (entry.value - entry.min) / (entry.max - entry.min)));
            }

            const fillW = sliderW * norm;
            if (fillW > 0) {
                ctx.fillStyle = accentColor;
                roundRect(x + sliderMargin, sliderY, fillW, sliderH, trackRadius);
                ctx.fill();
            }

            const knobX = x + sliderMargin + fillW;
            const knobY = sliderY + sliderH / 2;
            const knobR = 8;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(knobX, knobY, knobR, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 4;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    });

    ctx.restore();
}

showCheckboxSelectionModal() {

        const candidates = this.entries.filter(e => 
            (e.type === 'function' || e.type === 'geometry' || e.type === 'point_list') && 
            (e.name || e.expr)
        );

        if (candidates.length === 0) {
            alert("没有可控制的对象。");
            return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'checkbox-modal-overlay';
        
        let listHtml = candidates.map(e => {
            let typeDesc = '未知';
            if (e.type === 'point_list') typeDesc = '点列';
            else if (e.type === 'geometry') typeDesc = '几何';
            else if (e.type === 'function') {
                if (e.plotType === 'implicit' || e.plotType === 'implicit3d') typeDesc = '隐函数';
                else if (e.plotType === 'parametric' || e.plotType === 'parametric3d') typeDesc = '参数曲线';
                else typeDesc = '函数';
            }
            
            // 关键修改：使用 name 优先，没有 name 则使用 expr 作为显示和值
            const displayName = e.name || e.expr;
            const valueId = e.name || e.expr;

            return `
            <div class="checkbox-list-item">
                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;" title="${displayName}">
                    ${displayName} 
                    <span style="color:var(--text-color-subtle); font-size:0.8em;">(${typeDesc})</span>
                </span>
                <input type="checkbox" value="${valueId}" class="obj-selector">
            </div>
        `}).join('');

        overlay.innerHTML = `
            <div class="checkbox-modal">
                <h3>选择要控制的对象</h3>
                <div class="checkbox-list">${listHtml}</div>
                <div class="checkbox-modal-actions">
                    <button class="checkbox-modal-btn checkbox-cancel">取消</button>
                    <button class="checkbox-modal-btn checkbox-confirm">确定</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);

        overlay.querySelector('.checkbox-cancel').onclick = () => overlay.remove();
        overlay.querySelector('.checkbox-confirm').onclick = () => {
            const selected = Array.from(overlay.querySelectorAll('.obj-selector:checked')).map(cb => cb.value);
            if (selected.length === 0) {
                alert("请至少选择一个对象");
                return;
            }
            const name = prompt("请输入复选框名称:", "显示/隐藏");
            if (name) {
                this.createCheckboxAnnotation(name, selected);
            }
            overlay.remove();
        };
    }

createCheckboxAnnotation(name, controlledNames) {
    // 计算屏幕中心位置
    const cssWidth = this.canvas.clientWidth;
    const cssHeight = this.canvas.clientHeight;
    const x = (cssWidth / 2 - this.offset.x) / this.scale;
    const y = (this.offset.y - cssHeight / 2) / this.scale;

    const checkbox = {
        type: 'checkbox',
        name: name,
        controlledNames: controlledNames,
        checked: true,
        x: x,
        y: y,
        width: 150 / this.scale, // 预估宽度，绘制时会更新
        height: 40 / this.scale,
        color: { h: 0, s: 0, b: 0, a: 100 } // 颜色占位
    };
    this.annotations.push(checkbox);
    this.requestDraw();
}

drawAnnotations() {
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        ctx.save();
        ctx.scale(dpr, dpr);

        const roundRect = (ctx, x, y, width, height, radius) => {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
        };

        this.annotations.forEach((annotation, index) => {
      if (annotation.type === 'checkbox') {
        const screenX = this.offset.x + annotation.x * this.scale;
        const screenY = this.offset.y - annotation.y * this.scale;
        const width = 160; 
        const height = 40;
        
        annotation.width = width / this.scale;
        annotation.height = height / this.scale;

        ctx.save();
        
        const isDark = this.isDarkModeActive;
        // 背景颜色，稍微增加不透明度以弥补没有边框
        ctx.fillStyle = isDark ? "rgba(60, 60, 60, 0.95)" : "rgba(255, 255, 255, 0.95)";
        
        // 阴影效果替代边框，增加层次感
        ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
        ctx.shadowBlur = 6;
        ctx.shadowOffsetY = 2;

        const r = 10;
        ctx.beginPath();
        ctx.roundRect(screenX, screenY, width, height, r);
        ctx.fill();
        
        // 移除 ctx.stroke() 以去除外边框
        ctx.shadowBlur = 0; // 重置阴影以免影响后续绘制
        ctx.shadowOffsetY = 0;

        // 文字
        ctx.font = "bold 14px 'HarmonyOS_SC', Arial";
        ctx.fillStyle = isDark ? "#fff" : "#333";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        
        // 限制文字长度，防止与开关重叠
        const maxTextWidth = width - 60; 
        let text = annotation.name;
        if (ctx.measureText(text).width > maxTextWidth) {
             // 简单截断，实际可做更精细处理
             text = text.substring(0, 8) + "...";
        }
        ctx.fillText(text, screenX + 15, screenY + height / 2);

        // 开关
        const switchW = 40;
        const switchH = 22;
        const switchX = screenX + width - switchW - 15;
        const switchY = screenY + (height - switchH) / 2;
        
        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color-accent').trim();
        ctx.fillStyle = annotation.checked ? accentColor : (isDark ? "#555" : "#ccc");
        
        ctx.beginPath();
        ctx.roundRect(switchX, switchY, switchW, switchH, switchH/2);
        ctx.fill();

        // 开关圆钮
        const knobSize = 18;
        const knobX = annotation.checked ? (switchX + switchW - knobSize - 2) : (switchX + 2);
        const knobY = switchY + 2;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(knobX + knobSize/2, knobY + knobSize/2, knobSize/2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    } else if (annotation.type === 'pen') {
                ctx.save();
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;

                ctx.translate(screenX, screenY);

                ctx.beginPath();
                annotation.path.forEach((p, i) => {
                    const px = p.x * annotation.scaleX * this.scale;
                    const py = -p.y * annotation.scaleY * this.scale;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });

                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                ctx.strokeStyle = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;

                ctx.lineWidth = annotation.thickness * this.scale;

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.restore();

            } else if (annotation.type === 'text') {
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;

                const boxWidth = annotation.width * this.scale;
                const boxHeight = annotation.height * this.scale;

                ctx.save();
                ctx.beginPath();
                ctx.rect(screenX, screenY, boxWidth, boxHeight);
                ctx.clip();

                const pixelFontSize = annotation.fontSize * this.scale;
                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                const colorRgbaString = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;
                
                ctx.textBaseline = 'top';

                if (annotation.content.startsWith('<smart>')) {
                    const processedText = this._processSmartTextLogic(annotation.content);
                    this._drawSmartText(ctx, processedText, screenX, screenY, pixelFontSize, colorRgbaString, boxWidth);
                } else {
                    ctx.font = `${pixelFontSize}px 'HarmonyOS_SC', Arial`;
                    ctx.fillStyle = colorRgbaString;
                    const textContent = annotation.content;
                    const lineHeight = pixelFontSize * 1.2;
                    let currentY = screenY;

                    const paragraphs = annotation.content.split('\\n');
                    paragraphs.forEach(paragraph => {
                        let currentLine = '';
                        for (let i = 0; i < paragraph.length; i++) {
                            const char = paragraph[i];
                            const testLine = currentLine + char;
                            const metrics = ctx.measureText(testLine);
                            if (metrics.width > boxWidth && i > 0) {
                                ctx.fillText(currentLine, screenX, currentY);
                                currentY += lineHeight;
                                currentLine = char;
                            } else {
                                currentLine = testLine;
                            }
                        }
                        ctx.fillText(currentLine, screenX, currentY);
                        currentY += lineHeight;
                    });
                }

                ctx.restore();
            } else if (annotation.type === 'image' || annotation.type === 'pdf') {
                if (annotation.img) {
                    const screenX = this.offset.x + annotation.x * this.scale;
                    const screenY = this.offset.y - annotation.y * this.scale;

                    const w = annotation.width * annotation.scaleX * this.scale;
                    const h = annotation.height * annotation.scaleY * this.scale;

                    ctx.save();
                    // 圆角裁剪
                    roundRect(ctx, screenX, screenY, w, h, 15);
                    ctx.clip();

                    ctx.globalAlpha = 1.0 - (annotation.color.a / 100);
                    ctx.drawImage(annotation.img, screenX, screenY, w, h);
                    ctx.restore();
                }
            } else if (annotation.type === 'audio') {
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;
                const w = annotation.width * annotation.scaleX * this.scale;
                const h = annotation.height * annotation.scaleY * this.scale;
                
                ctx.save();
                
                // 恢复为圆形背景图标
                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                const colorString = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;
                
                const cx = screenX + w/2;
                const cy = screenY + h/2;
                const r = Math.min(w, h)/2;

                ctx.fillStyle = colorString;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.fill();
                
                // 绘制扬声器图标
                ctx.fillStyle = 'white';
                ctx.globalAlpha = 1.0 - (annotation.color.a / 100); 
                
                const size = r; 
                ctx.beginPath();
                ctx.moveTo(cx - size/2, cy - size/2);
                ctx.lineTo(cx + size/2, cy);
                ctx.lineTo(cx - size/2, cy + size/2);
                ctx.fill();
                ctx.restore();
            }
        });

        if (this.annotationState.isDrawing && this.annotationState.currentDrawingPath.length > 1) {
            const path = this.annotationState.currentDrawingPath;
            ctx.beginPath();
            path.forEach((p, i) => {
                const screenX = this.offset.x + p.x * this.scale;
                const screenY = this.offset.y - p.y * this.scale;
                if (i === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
            });
            const rgba = this.hsbToRgbaArray(this.annotationState.pen.color.h, this.annotationState.pen.color.s, this.annotationState.pen.color.b, this.annotationState.pen.color.a);
            ctx.strokeStyle = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;

            ctx.lineWidth = this.annotationState.pen.thickness * this.scale;
            ctx.stroke();
        }

        if (this.selectedAnnotationIndex !== -1) {
            this.drawAnnotationSelectionBox(this.annotations[this.selectedAnnotationIndex]);
        }

        ctx.restore();
    }

_processSmartTextLogic(rawText) {
        let text = rawText.replace('<smart>', '');
        const maxIterations = 50;
        let iteration = 0;

        const getContextSymbols = () => {
            return new Set([
                ...this.calcJSUtils.calc1,
                ...this.calcJSUtils.calc3,
                ...this.calcJSUtils.advancedCustomFunctionNames,
                ...Object.keys(this.calcJSUtils.constants),
                ...this.entries.map(e => (e.key || e.name)),
                ...this.variables.keys()
            ].filter(Boolean).map(n => n.toLowerCase()));
        };

        while (iteration < maxIterations) {
            let changed = false;
            
            const valueMatch = text.match(/\{value\((.*?)\)\}/);
            if (valueMatch) {
                const expr = valueMatch[1];
                let val = NaN;
                try {
                    const contextSymbols = getContextSymbols();
                    const tokens = this.improvedTokenize(expr, contextSymbols);
                    val = this.evaluateExpressionWithCalcJS(tokens, Object.fromEntries(this.variables));
                } catch (e) { }
                const replacement = Number.isFinite(val) ? parseFloat(val.toPrecision(6)).toString() : 'NaN';
                text = text.replace(valueMatch[0], replacement);
                changed = true;
            }

            if (!changed) {
                const ifStart = text.indexOf('{if(');
                if (ifStart !== -1) {
                    let depth = 0;
                    let cursor = ifStart + 4; 
                    let condEnd = -1, thenEnd = -1, elseEnd = -1;
                    let condStr = '', thenStr = '', elseStr = '';

                    while (cursor < text.length) {
                        if (text.substring(cursor).startsWith('),then(') && depth === 0) {
                            condEnd = cursor;
                            cursor += 7; 
                            continue;
                        }
                        if (text.substring(cursor).startsWith('),else(') && depth === 0) {
                            thenEnd = cursor;
                            cursor += 7;
                            continue;
                        }
                        if (text[cursor] === ')' && text[cursor + 1] === '}' && depth === 0) {
                            elseEnd = cursor;
                            break;
                        }
                        
                        if (text[cursor] === '(') depth++;
                        if (text[cursor] === ')') depth--;
                        cursor++;
                    }

                    if (condEnd !== -1 && thenEnd !== -1 && elseEnd !== -1) {
                        condStr = text.substring(ifStart + 4, condEnd);
                        thenStr = text.substring(condEnd + 7, thenEnd);
                        elseStr = text.substring(thenEnd + 7, elseEnd);
                        const fullMatch = text.substring(ifStart, elseEnd + 2);

                        let condVal = NaN;
                        try {
                            const contextSymbols = getContextSymbols();
                            const tokens = this.improvedTokenize(condStr, contextSymbols);
                            condVal = this.evaluateExpressionWithCalcJS(tokens, Object.fromEntries(this.variables));
                        } catch (e) { }
                        
                        const replacement = (Number.isFinite(condVal) && condVal >= 0) ? thenStr : elseStr;
                        text = text.replace(fullMatch, replacement);
                        changed = true;
                    }
                }
            }

            if (!changed) break;
            iteration++;
        }
        return text;
    }
    _drawSmartText(ctx, text, x, y, fontSize, colorRgba, boxWidth) {
        const lines = text.split('\\n');
        const lineHeight = fontSize * 1.2;
        let currentY = y;

        lines.forEach(line => {
            let parts = line.split(/(\/[rbi])/g); 
            let currentX = x;
            let currentFontType = 'normal'; 

            let lineBuffer = []; 

            parts.forEach(part => {
                if (part === '/r') currentFontType = 'normal';
                else if (part === '/b') currentFontType = 'bold';
                else if (part === '/i') currentFontType = 'italic';
                else if (part !== '') {
                    lineBuffer.push({ text: part, type: currentFontType });
                }
            });

            
            lineBuffer.forEach(segment => {
                let fontPrefix = '';
                if (segment.type === 'bold') fontPrefix = 'bold ';
                else if (segment.type === 'italic') fontPrefix = 'italic ';
                
                ctx.font = `${fontPrefix}${fontSize}px 'HarmonyOS_SC', Arial`;
                ctx.fillStyle = colorRgba;
                
                const metrics = ctx.measureText(segment.text);
                
                if (currentX + metrics.width > x + boxWidth && currentX > x) {
                    currentX = x;
                    currentY += lineHeight;
                }
                
                ctx.fillText(segment.text, currentX, currentY);
                currentX += metrics.width;
            });

            currentY += lineHeight;
        });
    }

drawAnnotationSelectionBox(annotation) {
        const ctx = this.axisCtx;
        const screenX = this.offset.x + annotation.x * this.scale;
        const screenY = this.offset.y - annotation.y * this.scale;

        const roundRect = (ctx, x, y, width, height, radius) => {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
        };

        let screenWidth, screenHeight;
        let boxTopY;

        if (annotation.type === 'pen') {
            screenWidth = annotation.width * annotation.scaleX * this.scale;
            screenHeight = annotation.height * annotation.scaleY * this.scale;
            boxTopY = screenY - screenHeight;
        } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
            screenWidth = annotation.width * annotation.scaleX * this.scale;
            screenHeight = annotation.height * annotation.scaleY * this.scale;
            boxTopY = screenY;
        } else {
            screenWidth = annotation.width * this.scale;
            screenHeight = annotation.height * this.scale;
            boxTopY = screenY;
        }

        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(screenX, boxTopY, screenWidth, screenHeight);
        ctx.setLineDash([]);

        const handleSize = 8;
        const handles = {
            tl: { x: screenX, y: boxTopY },
            t: { x: screenX + screenWidth / 2, y: boxTopY },
            tr: { x: screenX + screenWidth, y: boxTopY },
            l: { x: screenX, y: boxTopY + screenHeight / 2 },
            r: { x: screenX + screenWidth, y: boxTopY + screenHeight / 2 },
            bl: { x: screenX, y: boxTopY + screenHeight },
            b: { x: screenX + screenWidth / 2, y: boxTopY + screenHeight },
            br: { x: screenX + screenWidth, y: boxTopY + screenHeight }
        };

        ctx.fillStyle = '#007bff';
        for (const key in handles) {
            const pos = handles[key];
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, handleSize / 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        if (annotation.type === 'pdf') {
            const btnSize = 36;
            const prevX = screenX + screenWidth / 2 - 40;
            const nextX = screenX + screenWidth / 2 + 10;
            const btnY = boxTopY + screenHeight + 25; 

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.arc(prevX + btnSize/2, btnY, btnSize/2, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(nextX + btnSize/2, btnY, btnSize/2, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('←', prevX + btnSize / 2, btnY + 1);
            ctx.fillText('→', nextX + btnSize / 2, btnY + 1);
            
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`${annotation.page}/${annotation.totalPages}`, screenX + screenWidth / 2, boxTopY + screenHeight + 15);
        }

        if (annotation.type === 'audio') {
            // 在图标下方绘制进度条控件
            const controlsY = boxTopY + screenHeight + 20; // 图标下方 20px
            const playSize = 24;
            // 播放按钮放在图标左下方对齐
            const playX = screenX + playSize/2; 
            
            // 播放/暂停按钮背景
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(playX, controlsY, playSize/2, 0, 2*Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            if (annotation.isPlaying) {
                const barW = 3;
                const barH = 10;
                const gap = 4;
                ctx.fillRect(playX - gap/2 - barW, controlsY - barH/2, barW, barH);
                ctx.fillRect(playX + gap/2, controlsY - barH/2, barW, barH);
            } else {
                const size = 10;
                ctx.beginPath();
                ctx.moveTo(playX - size/3, controlsY - size/2);
                ctx.lineTo(playX + size/1.5, controlsY);
                ctx.lineTo(playX - size/3, controlsY + size/2);
                ctx.fill();
            }
            
            // 进度条背景 (圆角矩形)
            const barX = playX + 20; // 按钮右侧
            const barY = controlsY - 4; // 垂直居中 (controlsY is center of play button, height 8 -> -4)
            // 宽度至少 100px，或者与图标宽度一致
            const barW = Math.max(120, screenWidth - 30); 
            const barH = 8;
            const barRadius = 4;
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            roundRect(ctx, barX, barY, barW, barH, barRadius);
            ctx.fill();
            
            // 进度条前景
            if (annotation.audioElem && annotation.audioElem.duration) {
                const progress = annotation.audioElem.currentTime / annotation.audioElem.duration;
                ctx.fillStyle = '#007bff';
                roundRect(ctx, barX, barY, barW * progress, barH, barRadius);
                ctx.fill();
            }
        }
    }

    updateAnnotationEditMenu() {
    const isEditing = this.selectedAnnotationIndex !== -1 && this.currentUIMode !== 'annotation';
    const annotation = isEditing ? this.annotations[this.selectedAnnotationIndex] : null;
    const currentMode = isEditing ? annotation.type : this.annotationState.mode;

    // 控制滑块显示的辅助函数
const updateSliderVisibility = (type) => {
        const groups = {
            h: document.getElementById('slider-group-h'),
            s: document.getElementById('slider-group-s'),
            b: document.getElementById('slider-group-b'),
            a: document.getElementById('slider-group-a'),
            thickness: document.getElementById('pen-thickness-group').closest('.slider-group'),
            size: document.getElementById('text-size-group').closest('.slider-group')
        };

        Object.values(groups).forEach(g => g && (g.style.display = 'flex'));
if (annotation && annotation.type === 'checkbox') {
        // 隐藏所有滑块
        Object.values(groups).forEach(g => g && (g.style.display = 'none'));
        

        this.annotationEditTextBtn.style.display = 'flex';
        

        this.annotationEditTextBtn.onclick = () => {
            this.editCheckboxControlledObjects(annotation);
        };
        
        // 确保显示删除按钮
        this.annotationDeleteBtn.style.display = 'flex';
        
        // 绑定删除按钮
        this.annotationDeleteBtn.onclick = () => {
             this.annotations.splice(this.selectedAnnotationIndex, 1);
             this.selectedAnnotationIndex = -1;
             this.updateAnnotationEditMenu();
             this.requestDraw();
        };

        // 确保菜单展开
        this.annotationMenu.style.display = 'flex';
        this.annotationMenu.classList.add('expanded');
        return; // 提前返回，跳过后续通用逻辑
    }
        if (type === 'image' || type === 'pdf' || type === 'audio') {
            if (groups.h) groups.h.style.display = 'none';
            if (groups.s) groups.s.style.display = 'none';
            if (groups.b) groups.b.style.display = 'none';
            if (groups.thickness) groups.thickness.style.display = 'none';
            if (groups.size) groups.size.style.display = 'none';
        } else if (type === 'text') {
            if (groups.thickness) groups.thickness.style.display = 'none';
        } else if (type === 'eraser') {

            if (groups.h) groups.h.style.display = 'none';
            if (groups.s) groups.s.style.display = 'none';
            if (groups.b) groups.b.style.display = 'none';
            if (groups.a) groups.a.style.display = 'none';
            if (groups.size) groups.size.style.display = 'none';
        } else {
            if (groups.size) groups.size.style.display = 'none';
        }
    };

    if (isEditing) {

        this.annotationMenu.style.display = 'flex';
        this.annotationMenu.classList.add('expanded'); 
        if (this.annotationColorBtn) {
            this.annotationColorBtn.style.display = 'none'; 
        }
        
        this._setupAnnotationEditControls(annotation);

        this.annotationModeSwitchBtns.forEach(btn => btn.style.display = 'none');
        this.annotationDeleteBtn.style.display = 'flex';
        this.annotationEditTextBtn.style.display = annotation.type === 'text' ? 'flex' : 'none';
        
        updateSliderVisibility(annotation.type);

    } else {
        // 批注/创建模式
        this.annotationDeleteBtn.style.display = 'none';
        this.annotationEditTextBtn.style.display = 'none';
        
        if (this.currentUIMode === 'annotation') {
            this.annotationMenu.style.display = 'flex';
            if (this.annotationColorBtn) {
                this.annotationColorBtn.style.display = 'flex';
                this.annotationColorBtn.classList.toggle('active', this.isAnnotationMenuExpanded);
            }
            this.annotationMenu.classList.toggle('expanded', this.isAnnotationMenuExpanded); // 恢复之前的折叠状态
            this.annotationModeSwitchBtns.forEach(btn => btn.style.display = 'flex');
            
            updateSliderVisibility(this.annotationState.mode);
        } else {
            this.annotationMenu.style.display = 'none';
        }
    }
    
    // 强制重绘滑块以适应布局变化
    requestAnimationFrame(() => {
        this.activeSliders.forEach(slider => slider.resizeCanvas && slider.resizeCanvas());
        Object.values(this.penColorSliders).forEach(slider => slider.resizeCanvas && slider.resizeCanvas());
        if(this.penThicknessSlider) this.penThicknessSlider.resizeCanvas();
        if(this.penFontSizeSlider) this.penFontSizeSlider.resizeCanvas();
    });
}
editCheckboxControlledObjects(checkboxAnno) {
        // 筛选所有有效的可控制对象
        const candidates = this.entries.filter(e => 
            (e.type === 'function' || e.type === 'geometry' || e.type === 'point_list') && 
            (e.name || e.expr)
        );

        if (candidates.length === 0) {
            alert("没有可控制的对象。");
            return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'checkbox-modal-overlay';
        
        // 生成列表，并根据 checkboxAnno.controlledNames 预选
        let listHtml = candidates.map(e => {
            let typeDesc = '未知';
            if (e.type === 'point_list') typeDesc = '点列';
            else if (e.type === 'geometry') typeDesc = '几何';
            else if (e.type === 'function') {
                if (e.plotType === 'implicit' || e.plotType === 'implicit3d') typeDesc = '隐函数';
                else if (e.plotType === 'parametric' || e.plotType === 'parametric3d') typeDesc = '参数曲线';
                else typeDesc = '函数';
            }
            
            const valueId = e.name || e.expr;
            const isChecked = checkboxAnno.controlledNames.includes(valueId) ? 'checked' : '';

            return `
            <div class="checkbox-list-item">
                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;" title="${valueId}">
                    ${valueId} 
                    <span style="color:var(--text-color-subtle); font-size:0.8em;">(${typeDesc})</span>
                </span>
                <input type="checkbox" value="${valueId}" class="obj-selector" ${isChecked}>
            </div>
        `}).join('');

        overlay.innerHTML = `
            <div class="checkbox-modal">
                <h3>编辑控制对象</h3>
                <div class="checkbox-list">${listHtml}</div>
                <div class="checkbox-modal-actions">
                    <button class="checkbox-modal-btn checkbox-cancel">取消</button>
                    <button class="checkbox-modal-btn checkbox-confirm">确定</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);

        overlay.querySelector('.checkbox-cancel').onclick = () => overlay.remove();
        overlay.querySelector('.checkbox-confirm').onclick = () => {
            const selected = Array.from(overlay.querySelectorAll('.obj-selector:checked')).map(cb => cb.value);
            
            // 更新复选框的控制列表
            checkboxAnno.controlledNames = selected;
            
            // 还可以顺便允许修改名称
            const newName = prompt("修改复选框名称 (留空保持不变):", checkboxAnno.name);
            if (newName && newName.trim() !== "") {
                checkboxAnno.name = newName;
            }
            
            this.requestDraw(); // 重绘以应用更改
            overlay.remove();
        };
    }

_setupAnnotationEditControls(annotation) {
        if (!annotation) return; if (annotation.type === 'checkbox') return;


        this.penColorSliders.h.setValue(annotation.color.h);
        this.penColorSliders.s.setValue(annotation.color.s);
        this.penColorSliders.b.setValue(annotation.color.b);
        this.penColorSliders.a.setValue(annotation.color.a);

        const thicknessGroup = document.getElementById('pen-thickness-group').closest('.slider-group');
        const textSizeGroup = document.getElementById('text-size-group').closest('.slider-group');

        if (annotation.type === 'pen') {
            if (thicknessGroup) thicknessGroup.style.display = 'flex';
            if (textSizeGroup) textSizeGroup.style.display = 'none';

            this.penThicknessSlider.setValue(annotation.thickness);
            this.penThicknessSlider.options.onInput = (e) => {
                annotation.thickness = e.target.options.value;
                this.requestDraw();
            };
            this.penThicknessSlider.draw();

        } else if (annotation.type === 'text') {
            if (thicknessGroup) thicknessGroup.style.display = 'none';
            if (textSizeGroup) textSizeGroup.style.display = 'flex';

            this.penFontSizeSlider.setValue(annotation.fontSize);
            this.penFontSizeSlider.options.onInput = (e) => {
                annotation.fontSize = e.target.options.value;
                this.requestDraw();
            };
            this.penFontSizeSlider.draw();
        } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
            if (thicknessGroup) thicknessGroup.style.display = 'none';
            if (textSizeGroup) textSizeGroup.style.display = 'none';
        }

        const rebindColorSlider = (slider, prop) => {
            slider.options.context = annotation.color;
            slider.options.onInput = (e) => {
                annotation.color[prop] = e.target.options.value;
                Object.values(this.penColorSliders).forEach(s => {
                    s.options.context = annotation.color;
                    s.draw();
                });
                this.requestDraw();
            };
            slider.draw();
        };

        rebindColorSlider(this.penColorSliders.h, 'h');
        rebindColorSlider(this.penColorSliders.s, 's');
        rebindColorSlider(this.penColorSliders.b, 'b');
        rebindColorSlider(this.penColorSliders.a, 'a');

        this.annotationDeleteBtn.onclick = () => {
            if (annotation.type === 'audio' && annotation.audioElem) {
                annotation.audioElem.pause();
            }
            this.annotations.splice(this.selectedAnnotationIndex, 1);
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        };

        this.annotationEditTextBtn.onclick = () => {
            const newText = prompt("编辑文本:", annotation.content);
            if (newText !== null) {
                annotation.content = newText;
                this.requestDraw();
            }
        };

        document.getElementById('annotation-exit-btn').onclick = () => {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        };
    }

findAnnotationAt(coords) {
        const result = { index: -1, handle: null };
        const hitPadding = 15;

        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const annotation = this.annotations[i];
            const screenX = this.offset.x + annotation.x * this.scale;
            const screenY = this.offset.y - annotation.y * this.scale;

            let screenWidth, screenHeight;
            let drawYMin, drawYMax;

            if (annotation.type === 'pen') {
                screenWidth = annotation.width * annotation.scaleX * this.scale;
                screenHeight = annotation.height * annotation.scaleY * this.scale;
                drawYMin = screenY - screenHeight;
                drawYMax = screenY;
            } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
                screenWidth = annotation.width * annotation.scaleX * this.scale;
                screenHeight = annotation.height * annotation.scaleY * this.scale;
                drawYMin = screenY;
                drawYMax = screenY + screenHeight;
            } else {
                screenWidth = annotation.width * this.scale;
                screenHeight = annotation.height * this.scale;
                drawYMin = screenY;
                drawYMax = screenY + screenHeight;
            }

            if (this.selectedAnnotationIndex === i) {
                const handleSize = 20;

                const handles = {
                    tl: { x: screenX, y: drawYMin },
                    t: { x: screenX + screenWidth / 2, y: drawYMin },
                    tr: { x: screenX + screenWidth, y: drawYMin },
                    l: { x: screenX, y: drawYMin + screenHeight / 2 },
                    r: { x: screenX + screenWidth, y: drawYMin + screenHeight / 2 },
                    bl: { x: screenX, y: drawYMax },
                    b: { x: screenX + screenWidth / 2, y: drawYMax },
                    br: { x: screenX + screenWidth, y: drawYMax }
                };

                for (const key in handles) {
                    if (Math.hypot(coords.x - handles[key].x, coords.y - handles[key].y) <= handleSize) {
                        result.index = i;
                        result.handle = key;
                        return result;
                    }
                }
            }

            if (coords.x >= screenX - hitPadding &&
                coords.x <= screenX + screenWidth + hitPadding &&
                coords.y >= drawYMin - hitPadding &&
                coords.y <= drawYMax + hitPadding) {

                result.index = i;
                result.handle = 'move';
                return result;
            }
        }
        return result;
    }

 handleAnnotationResizeOrMove(e) {
    if (!this.annotationInteraction.type) return;
    if (e.cancelable) e.preventDefault();

    const coords = this.getEventCoordinates(e);
    const annotation = this.annotations[this.selectedAnnotationIndex];
    const dx_math = (coords.x - this.annotationInteraction.startX) / this.scale;
    const dy_math = -(coords.y - this.annotationInteraction.startY) / this.scale;
    
    const o = this.annotationInteraction.original;

    if (this.annotationInteraction.type === 'move') {
        annotation.x = o.x + dx_math;
        annotation.y = o.y + dy_math;
        this.requestDraw();
        return;
    }

    const handle = this.annotationInteraction.type;
    const minSize = 20 / this.scale;

    let new_w_math = (annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width;
    let new_x = o.x;

    if (handle.includes('l')) {
        new_x = o.x + dx_math;
        new_w_math = ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) - dx_math;
    }
    if (handle.includes('r')) {
        new_w_math = ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) + dx_math;
    }

    if (new_w_math < minSize) {
        if (handle.includes('l')) new_x = o.x + ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) - minSize;
        new_w_math = minSize;
    }
    
    annotation.x = new_x;
    if (annotation.type === 'pen' || annotation.type === 'image') {
        if (annotation.width > 1e-9) annotation.scaleX = new_w_math / annotation.width;
    } else {
        annotation.width = new_w_math;
    }

    if (annotation.type === 'pen') {
         const pen_orig_bottom = o.y;
         const pen_orig_top = o.y + (o.height * o.scaleY);
         
         if (handle.includes('t')) {
            const new_top = pen_orig_top + dy_math;
            let new_h = new_top - pen_orig_bottom;
            if (new_h < minSize) new_h = minSize;
            annotation.y = pen_orig_bottom;
            if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
         } else if (handle.includes('b')) {
            const new_bottom = pen_orig_bottom + dy_math;
            let new_h = pen_orig_top - new_bottom;
            if (new_h < minSize) {
                new_h = minSize;
                annotation.y = pen_orig_top - minSize;
            } else {
                annotation.y = new_bottom;
            }
            if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
         }
    } else {
        const obj_orig_top = o.y;
        const obj_orig_height = (annotation.type === 'image' ? o.height * o.scaleY : o.height);
        const obj_orig_bottom = o.y - obj_orig_height;

        if (handle.includes('t')) {
            const new_top = obj_orig_top + dy_math;
            let new_h = new_top - obj_orig_bottom;
            if (new_h < minSize) {
                 new_h = minSize;
                 annotation.y = obj_orig_bottom + minSize;
            } else {
                 annotation.y = new_top;
            }
            
            if (annotation.type === 'image') {
                 if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
            } else {
                 annotation.height = new_h;
            }

        } else if (handle.includes('b')) {
            const new_bottom = obj_orig_bottom + dy_math;
            let new_h = obj_orig_top - new_bottom;
            if (new_h < minSize) {
                new_h = minSize;
            }
            
            if (annotation.type === 'image') {
                 if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
            } else {
                 annotation.height = new_h;
            }
        }
    }
    
    this.requestDraw();
}

stopTracing() {
        if (!this.traceState.active) return;
        
        if (this.traceState.path.length > 1) {
            let pointListStr = '/-/ ';
            for (let i = 0; i < this.traceState.path.length; i++) {
                const p = this.traceState.path[i];
                pointListStr += `(${p.x.toPrecision(6)},${p.y.toPrecision(6)})`;
            }
            this.addEntry(pointListStr);
            const newEntry = this.entries[this.entries.length - 1];
            if (newEntry && newEntry.type === 'point_list') {
                newEntry.color = { h: 0, s: 0, b: 0, a: 0 };
            }
        }

        this.traceState.active = false;
        this.traceState.targetName = null;
        this.traceState.path = [];
        document.getElementById('stop-trace-btn').style.display = 'none';
        this.hideInfoMessage();
        this.requestDraw();
    }

    drawActiveTrajectory() {
        if (!this.traceState.active || this.traceState.path.length < 2) return;
        
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        ctx.save();
        ctx.scale(dpr, dpr);
        
        ctx.beginPath();
        const path = this.traceState.path;
        path.forEach((p, i) => {
            const screenX = this.offset.x + p.x * this.scale;
            const screenY = this.offset.y - p.y * this.scale;
            if (i === 0) ctx.moveTo(screenX, screenY);
            else ctx.lineTo(screenX, screenY);
        });
        
        ctx.strokeStyle = this.isDarkModeActive ? 'white' : 'black';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        
        ctx.restore();
    }


applyDarkMode(isDark) {
    const root = document.documentElement;
    if (isDark) {
        root.setAttribute('data-theme', 'dark');
        this.isDarkModeActive = true;
        if(this.preferredColorSlider) this.preferredColorSlider.value = 0;
        this.preferredColorValue = 0;
        this.updatePreferredColorValueLabel();
    } else {
        root.removeAttribute('data-theme');
        this.isDarkModeActive = false;
    }
    this.applyThemeColors(); 
    this.requestDraw();
}

getContrastingTextColor(bgColor, lightnessPercent, subtle = false) {
    if (lightnessPercent > 70) {
        return subtle ? '#777' : '#333';
    }

    return subtle ? '#ccc' : '#f0f0f0';
}

applyTransparency(isEnabled) {
    const sidebarBg = document.getElementById('sidebar-background');
    const isSidebarVisibleAndRelevant = !document.body.classList.contains('sidebar-hidden') && !this.isPortraitMode && sidebarBg;
    
    let sidebarWidthBefore = 0;
    if (isSidebarVisibleAndRelevant) {
        sidebarWidthBefore = sidebarBg.getBoundingClientRect().width;
    }

    const wasEnabled = this.isTransparencyEnabled;
    this.isTransparencyEnabled = isEnabled;
    
    const root = document.documentElement;
    if (isEnabled) {
        root.removeAttribute('data-transparency-enabled');
    } else {
        root.setAttribute('data-transparency-enabled', 'false');
    }

    this.applyThemeColors();

    if (isSidebarVisibleAndRelevant && wasEnabled !== isEnabled) {
        if (isEnabled) {
            this.offset.x += 400;
        } 
        else {
            this.offset.x -= 400;
        }
    }
    
    this.updateCanvasPosition();
    this.updateOverlayPositions();
    this.requestDraw();
}

applyThemeColors() {
    const root = document.documentElement;
    root.removeAttribute('data-theme-preferred-color-value');
    root.style.cssText = '';

    if (this.isDarkModeActive) {
        root.setAttribute('data-theme', 'dark');
    } else if (this.preferredColorValue === 0) {
        root.style.setProperty('--bg-color', '#ddd');
        root.style.setProperty('--sidebar-bg-color', '#f0f0f0');
        root.style.setProperty('--sidebar-border-color', '#ccc');
        root.style.setProperty('--entry-item-bg-color', '#f8f8f8');
        root.style.setProperty('--entry-item-hover-bg-color', '#efefef');
        root.style.setProperty('--entry-item-separator-color', '#c3c3c3');
        root.style.setProperty('--controls-border-color', '#eee');
        root.style.setProperty('--add-btn-bg-color', '#e0e0e0');
        root.style.setProperty('--add-btn-text-color', '#000000');
        root.style.setProperty('--text-color-default', '#333');
        root.style.setProperty('--text-color-subtle', '#555');
        root.style.setProperty('--text-color-error', '#cc0000');
        root.style.setProperty('--text-color-accent', '#007bff');
        root.style.setProperty('--variable-indicator-dependent-color', '#999999');
        root.style.setProperty('--variable-indicator-independent-paused-color', 'var(--text-color-accent)');
        root.style.setProperty('--variable-indicator-independent-playing-color', 'orange');
        root.style.setProperty('--canvas-bg-color', 'rgb(255, 255, 255)');
        root.style.setProperty('--input-range-track-bg', '#d3d3d3');
        root.style.setProperty('--overlay-bg-color', 'rgba(255, 255, 255, 0.85)');
        root.style.setProperty('--overlay-text-color', '#333');
        root.style.setProperty('--switch-off-bg-color', '#ccc');
        root.style.setProperty('--switch-on-bg-color', 'var(--text-color-accent)');
        root.style.setProperty('--axis-number-color', '#333');
        root.style.setProperty('--menu-bg-color', 'rgba(255, 255, 255, 0.95)');
        root.style.setProperty('--keyboard-bg-color', 'rgba(255, 255, 255, 0.95)');
    } else {
        const hue = (this.preferredColorValue / 100) * 360;
        root.setAttribute('data-theme-preferred-color-value', String(this.preferredColorValue));
        root.style.setProperty('--preferred-hue', String(hue));
        root.style.setProperty('--bg-color', `hsl(${hue}, 30%, 85%)`);
        root.style.setProperty('--sidebar-bg-color', `hsl(${hue}, 25%, 90%)`);
        root.style.setProperty('--sidebar-border-color', `hsl(${hue}, 20%, 75%)`);
        root.style.setProperty('--entry-item-bg-color', `hsl(${hue}, 25%, 92%)`);
        root.style.setProperty('--entry-item-hover-bg-color', `hsl(${hue}, 25%, 88%)`);
        root.style.setProperty('--entry-item-separator-color', `hsl(${hue}, 15%, 65%)`);
        root.style.setProperty('--controls-border-color', `hsl(${hue}, 20%, 88%)`);
        const addBtnBgColor = `hsl(${hue}, 40%, 65%)`;
        root.style.setProperty('--add-btn-bg-color', addBtnBgColor);
        root.style.setProperty('--add-btn-text-color', this.getContrastingTextColor(addBtnBgColor, 65));
        root.style.setProperty('--text-color-default', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85));
        root.style.setProperty('--text-color-subtle', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85, true));
        root.style.setProperty('--text-color-error', '#cc0000');
        const accentColor = `hsl(${hue}, 60%, 50%)`;
        root.style.setProperty('--text-color-accent', accentColor);
        root.style.setProperty('--variable-indicator-dependent-color', `hsl(${hue}, 15%, 60%)`);
        root.style.setProperty('--variable-indicator-independent-paused-color', accentColor);
        root.style.setProperty('--variable-indicator-independent-playing-color', 'orange');
        root.style.setProperty('--canvas-bg-color', 'rgb(255, 255, 255)'); 
        root.style.setProperty('--input-range-track-bg', `hsl(${hue}, 20%, 80%)`);
        const overlayBg = `hsla(${hue}, 30%, 95%, 0.85)`;
        root.style.setProperty('--overlay-bg-color', overlayBg);
        root.style.setProperty('--overlay-text-color', this.getContrastingTextColor(overlayBg, 95));
        root.style.setProperty('--switch-off-bg-color', `hsl(${hue}, 15%, 75%)`);
        root.style.setProperty('--switch-on-bg-color', `hsl(${hue}, 70%, 45%)`);
        root.style.setProperty('--axis-number-color', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85));
        root.style.setProperty('--menu-bg-color', `hsla(${hue}, 25%, 96%, 0.95)`);
        root.style.setProperty('--keyboard-bg-color', `hsla(${hue}, 25%, 96%, 0.95)`);
    }

    if (!this.isTransparencyEnabled) {
        const canvasBgColor = getComputedStyle(root).getPropertyValue('--canvas-bg-color').trim();
        document.body.style.backgroundColor = canvasBgColor;
    } else {
        document.body.style.backgroundColor = '';
    }

    this.canvas.style.background = getComputedStyle(root).getPropertyValue('--canvas-bg-color').trim();

    this.activeSliders.forEach(slider => {
        if (slider && typeof slider.draw === 'function') {
            slider.draw();
        }
    });

    if (this.explicitPrecisionSlider) this.explicitPrecisionSlider.draw();
    if (this.implicitPrecisionSlider) this.implicitPrecisionSlider.draw();
    if (this.integralPrecisionSlider) this.integralPrecisionSlider.draw();
    if (this.preferredColorSlider) this.preferredColorSlider.draw();

    this.updateEntryVariableValuesDisplay(); 
    this.requestDraw();
}




checkTouchSupport() {
    this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

updateTraceRecording(now) {
        if (!this.traceState.active || !this.traceState.targetName) return;
        if (now - this.traceState.lastRecordTime < 5) return; 

        const targetEntry = this.entries.find(e => e.name === this.traceState.targetName);
        if (targetEntry && targetEntry.isMeaningful) {
            const newPoint = {x: targetEntry.x_val, y: targetEntry.y_val};
            const lastPoint = this.traceState.path[this.traceState.path.length - 1];
            

            if (!lastPoint || Math.abs(newPoint.x - lastPoint.x) > 1e-6 || Math.abs(newPoint.y - lastPoint.y) > 1e-6) {
                this.traceState.path.push(newPoint);
                this.traceState.lastRecordTime = now;

                this.needsRedraw = true;
            }
        }
    }

    animationLoop(now) {
const deltaTime = now - this.lastAnimationTime;
this.updateTraceRecording(now);
this.lastAnimationTime = now;
this.frameCounter++;
if (now - this.lastFPSUpdateTime >= 1000) {
   this.fps = (this.frameCounter / (now - this.lastFPSUpdateTime)) * 1000;
   this.fpsDisplay.textContent = `FPS: ${this.fps.toFixed(0)}`;
   this.lastFPSUpdateTime = now;
   this.frameCounter = 0;
}
let animatedVarsChanged = false;

if (this.isFramePlaying) {
    this.frameAccumulator += deltaTime;
    const msPerFrame = 1000 / this.playbackFPS;
    if (this.frameAccumulator >= msPerFrame) {
        const framesToAdvance = Math.floor(this.frameAccumulator / msPerFrame);
        this.currentFrame += framesToAdvance;
        this.frameAccumulator -= framesToAdvance * msPerFrame;
        
        if (this.currentFrame >= this.totalFrames) {
            this.currentFrame = this.totalFrames;
            this.isFramePlaying = false;
            this.updateGlobalPlayState(); 
            this.updateEntryList();
        } else {
            const frameSliderContainer = document.getElementById('frame-slider-container');
            if (frameSliderContainer && frameSliderContainer.sliderInstance) {
                frameSliderContainer.sliderInstance.setValue(this.currentFrame);
            }
            const valSpan = document.querySelector('.frame-current-value');
            if (valSpan) valSpan.textContent = this.currentFrame;
        }
        this.needsRedraw = true;
    }
}

if (this.globalPlayState === 1) {
   this.entries.forEach(entry => {
       if (entry.type === 'variable' && entry.isEditableIndependent && entry.playState === 1) {
           let { value, min, max, step, playDirection, playMode = 0 } = entry;
           if (!Number.isFinite(min) || !Number.isFinite(max) || !Number.isFinite(step) || step <= 0 || min >= max) {
                entry.playState = 0; this.updateGlobalPlayState(); this.updateEntryList(); animatedVarsChanged = true; return;
           }
           if (!Number.isFinite(value)) { 
               value = (playDirection === 1 || playMode === 1 || playMode === 3) ? min : max; 
               entry.value = value; 
               animatedVarsChanged = true; 
           }
           
           const stepAmount = step * (deltaTime / 1000) * 100;
           let newValue;
           let newDirection = playDirection;
           let valueChanged = false;

           switch (playMode) {
               case 0:  
                   newValue = value + stepAmount * playDirection;
                   if (playDirection === 1) {
                       if (newValue >= max) { 
                           newValue = max; 
                           newDirection = -1; 
                       }
                   } else {
                       if (newValue <= min) { 
                           newValue = min; 
                           newDirection = 1; 
                       }
                   }
                   break;
               
               case 1:
                   entry.playDirection = 1; 
                   newValue = value + stepAmount;
                   if (newValue > max) {
                       newValue = min; 
                   }
                   break;

               case 2:
                   entry.playDirection = -1;
                   newValue = value - stepAmount;
                   if (newValue < min) {
                       newValue = max;
                   }
                   break;

               case 3:
                   entry.playDirection = 1; 
                   newValue = value + stepAmount;
                   if (newValue >= max) {
                       newValue = max;
                       entry.playState = 0; 
                       this.updateGlobalPlayState();
                       this.updateEntryList();
                   }
                   break;

               case 4: 
                   entry.playDirection = -1;
                   newValue = value - stepAmount;
                   if (newValue <= min) {
                       newValue = min;
                       entry.playState = 0;
                       this.updateGlobalPlayState();
                       this.updateEntryList();
                   }
                   break;
               
               default: 
                   newValue = value + stepAmount * playDirection;
                   if (newValue >= max || newValue <= min) newDirection = -playDirection;
                   break;
           }

           if (Math.abs(newValue - value) > 1e-9 || newDirection !== playDirection) {
              entry.value = newValue; 
              entry.playDirection = newDirection; 
              animatedVarsChanged = true;
           }
       }
   });
}
if (animatedVarsChanged) this.recalculateForAnimation();

if (this.isSmoothPanningActive) {
    const smoothDeltaTime = (now - this.lastSmoothPanTime) / 1000;
    this.lastSmoothPanTime = now;

    this.offset.x += this.smoothPanVelocity.x * smoothDeltaTime;
    this.offset.y += this.smoothPanVelocity.y * smoothDeltaTime;

    this.smoothPanVelocity.x *= (1 - this.accsmooth);
    this.smoothPanVelocity.y *= (1 - this.accsmooth);

    const velocityMagnitude = Math.sqrt(this.smoothPanVelocity.x * this.smoothPanVelocity.x + this.smoothPanVelocity.y * this.smoothPanVelocity.y);
    if (velocityMagnitude < 1) {
        this.isSmoothPanningActive = false;
        this.finalizePanInteraction(); 
    }
    this.needsRedraw = true;
} else if (this.isSmoothZoomingActive) {
    const zoomDecayFactor = 0.92;
    this.smoothZoomVelocity = 1.0 + (this.smoothZoomVelocity - 1.0) * zoomDecayFactor;

    const mouseX = this.smoothZoomTarget.x;
    const mouseY = this.smoothZoomTarget.y;
    const mouseXMath = (mouseX - this.offset.x) / this.scale;
    const mouseYMath = (this.offset.y - mouseY) / this.scale;
    let newScale = this.scale * this.smoothZoomVelocity;
    newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));
    this.offset.x = mouseX - mouseXMath * newScale;
    this.offset.y = mouseY + mouseYMath * newScale;
    this.scale = newScale;

    if (Math.abs(this.smoothZoomVelocity - 1.0) < 0.001) {
        this.isSmoothZoomingActive = false;
        this.handleZoomEnd();
    }
    this.needsRedraw = true;
}


if (this.needsRedraw) { this.draw(); this.needsRedraw = false; }
if (this.globalPlayState === 1 || this.needsRedraw || animatedVarsChanged || this.isResizingSidebar || this.isResizingSidebarTouch || this.isPanning || this.isZooming || this.isSmoothPanningActive || this.isSmoothZoomingActive) {
    this.rafId = requestAnimationFrame(this.animationLoop.bind(this));
} else {
    this.rafId = null;
}
}



requestDraw() {
        this.needsRedraw = true;
        if (!this.rafId) {
            this.lastAnimationTime = performance.now();
            this.rafId = requestAnimationFrame(this.animationLoop.bind(this));
        }
    }

updateGlobalPlayState() {
    const anyPlaying = this.isFramePlaying || this.entries.some(entry => entry.type === 'variable' && entry.isEditableIndependent && entry.playState === 1);
    const newGlobalPlayState = anyPlaying ? 1 : 0;

   if (this.globalPlayState !== newGlobalPlayState) {
            this.globalPlayState = newGlobalPlayState;
            if (this.globalPlayState === 1) {
                if(!this.lastAnimationTime) this.lastAnimationTime = performance.now();
                this.recalculateForAnimation();
                this.requestDraw();
            } else {
                if (this.isAnimatingWithPerformanceMode || this.isUsingLowPrecisionBuffer) { 
                    this.restoreOriginalPrecisions();
                    this.isAnimatingWithPerformanceMode = false;
                    this.isUsingLowPrecisionBuffer = false;
                }
                if (!(this.isPanning || this.dragging) && !this.isZooming && !this.isSmoothPanningActive) { 
                        const cssWidth = this.canvasContainer.clientWidth;
                        const cssHeight = this.canvasContainer.clientHeight;
                        this.processImplicitBlocksOnGrid(cssWidth, cssHeight);
                        if (this.performanceModeEnabled) {
                            this.cleanupUnusedCache(cssWidth, cssHeight);
                        }
                        this.recalculateAll(); 
                } else {
                        this.recalculateAll(); 
                }
            }
        }
    }

exportStateObject() {
        const userCustomFunctions = {};
        const userCalc3 = [];

        for (const funcName in this.calcJSUtils.customFunctions) {
            if (!this.builtinFuncNames.includes(funcName)) {
                userCustomFunctions[funcName] = this.calcJSUtils.customFunctions[funcName];
            }
        }
        this.calcJSUtils.calc3.forEach(funcName => {
            if (!this.builtinFuncNames.includes(funcName)) {
                userCalc3.push(funcName);
            }
        });
        const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        const customAdvancedFunctionsToSave = ADVANCED_FUNCTION_DEFINITIONS
            .filter(def => !defaultAdvancedFunctionNames.has(def.name))
            .map(def => ({
                name: def.name,
                params: def.params,
                bodyJsString: def.bodyJsString
            }));

        const serializableAnnotations = this.annotations.map(anno => {
            const savedAnno = { ...anno };
            delete savedAnno.img;
            delete savedAnno.audioElem;
            delete savedAnno.pdfDoc;
            
            if (anno.type === 'pdf') {

                delete savedAnno.pdfData;
                

                if (!savedAnno.pdfDataBase64 && anno.pdfData) {
                    savedAnno.pdfDataBase64 = this._uint8ArrayToBase64(anno.pdfData);
                }
            }
            return savedAnno;
        });

        const state = {
            entries: this.entries.map(entry => {
                const savedEntry = {
                    type: entry.type,
                    expr: entry.expr,
                    hasLargeOps: entry.hasLargeOps,
                    integralNumSteps: this.integralNumSteps,
                    displayFrame: entry.displayFrame || 0,
                };
                if (entry.type === 'function') {
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;
                    savedEntry.plotType = entry.plotType;

                    savedEntry.extendTo3D = entry.extendTo3D;
                    savedEntry.sliceAxis = entry.sliceAxis;
                    savedEntry.sliceVal = entry.sliceVal;

                    if (entry.plotType === 'implicit') {
                        savedEntry.sign = entry.sign;
                    }
                    if (entry.hasLargeOps) {
                        if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                            savedEntry.largeOpTokensX = entry.largeOpTokensX;
                            savedEntry.largeOpTokensY = entry.largeOpTokensY;
                            if (entry.plotType === 'parametric3d') {
                                savedEntry.largeOpTokensZ = entry.largeOpTokensZ;
                            }
                        } else {
                            savedEntry.largeOpTokens = entry.largeOpTokens;
                        }
                    } else {
                        if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                            savedEntry.processedExprX = entry.processedExprX;
                            savedEntry.processedExprY = entry.processedExprY;
                            if (entry.plotType === 'parametric3d') {
                                savedEntry.processedExprZ = entry.processedExprZ;
                            }
                        } else {
                            savedEntry.processedExpr = entry.processedExpr;
                        }
                    }
                    if (entry.exprX_raw) savedEntry.exprX_raw = entry.exprX_raw;
                    if (entry.exprY_raw) savedEntry.exprY_raw = entry.exprY_raw;
                    if (entry.exprZ_raw) savedEntry.exprZ_raw = entry.exprZ_raw;

                } else if (entry.type === 'variable') {
                if (entry.isEditableIndependent) {
    savedEntry.showOnPlot = entry.showOnPlot;
    savedEntry.cardX = entry.cardX;
    savedEntry.cardY = entry.cardY;
    savedEntry.cardW = entry.cardW;
    savedEntry.cardH = entry.cardH;
}
                    if (entry.isEditableIndependent) {
                        savedEntry.value = entry.value;
                        savedEntry.min = entry.min;
                        savedEntry.max = entry.max;
                        savedEntry.step = entry.step;
                        savedEntry.playState = entry.playState;
                        savedEntry.playDirection = entry.playDirection;
                        savedEntry.playMode = entry.playMode;
                    } else {
                        savedEntry.value = entry.value;
                        if (entry.hasLargeOps) {
                            savedEntry.largeOpTokens = entry.largeOpTokens;
                        } else {
                            savedEntry.processedExpr = entry.processedExpr;
                        }
                    }
                    savedEntry.name = entry.name;
                    savedEntry.key = entry.key;
                    savedEntry.isEditableIndependent = entry.isEditableIndependent;

                } else if (entry.type === 'custom_function_definition') {
                    savedEntry.name = entry.name;
                    savedEntry.params = entry.params;
                    savedEntry.body = entry.body;
                } else if (entry.type === 'advanced_custom_function_definition') {
                    const defaultNames = ['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim'];
                    if (!defaultNames.includes(entry.name)) {
                        savedEntry.name = entry.name;
                        savedEntry.params = entry.params;
                        savedEntry.bodyJs = entry.bodyJs;
                    } else {
                        return null;
                    }
                } else if (entry.type === 'geometry') {
                    savedEntry.geometryType = entry.geometryType;
                    savedEntry.name = entry.name;
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;

                    if (entry.pointOnObject !== undefined) savedEntry.pointOnObject = entry.pointOnObject;
                    if (entry.onObjectName) savedEntry.onObjectName = entry.onObjectName;
                    if (entry.parameter_expr) savedEntry.parameter_expr = entry.parameter_expr;

                    if (entry.x_expr) savedEntry.x_expr = entry.x_expr;
                    if (entry.y_expr) savedEntry.y_expr = entry.y_expr;
                    if (entry.p1Name) savedEntry.p1Name = entry.p1Name;
                    if (entry.p2Name) savedEntry.p2Name = entry.p2Name;
                    if (entry.p3Name) savedEntry.p3Name = entry.p3Name;
                    if (entry.p4Name) savedEntry.p4Name = entry.p4Name;
                    if (entry.vertexName) savedEntry.vertexName = entry.vertexName;
                    if (entry.lineName) savedEntry.lineName = entry.lineName;
                    if (entry.l1Name) savedEntry.l1Name = entry.l1Name;
                    if (entry.l2Name) savedEntry.l2Name = entry.l2Name;
                    if (entry.pointName) savedEntry.pointName = entry.pointName;
                    if (entry.pointNames) savedEntry.pointNames = entry.pointNames;
                    if (entry.obj1Name) savedEntry.obj1Name = entry.obj1Name;
                    if (entry.obj2Name) savedEntry.obj2Name = entry.obj2Name;
                    if (entry.sign) savedEntry.sign = entry.sign;
                    if (entry.centerName) savedEntry.centerName = entry.centerName;
                    if (entry.pointOnCircleName) savedEntry.pointOnCircleName = entry.pointOnCircleName;
                    if (entry.radius_expr) savedEntry.radius_expr = entry.radius_expr;
                    if (entry.f1Name) savedEntry.f1Name = entry.f1Name;
                    if (entry.f2Name) savedEntry.f2Name = entry.f2Name;
                    if (entry.pName) savedEntry.pName = entry.pName;
                    if (entry.focusName) savedEntry.focusName = entry.focusName;
                    if (entry.directrixName) savedEntry.directrixName = entry.directrixName;
                    if (entry.rotatedPointName) savedEntry.rotatedPointName = entry.rotatedPointName;
                    if (entry.angle_expr) savedEntry.angle_expr = entry.angle_expr;
                    if (entry.axisName) savedEntry.axisName = entry.axisName;
                    if (entry.reflectedPointName) savedEntry.reflectedPointName = entry.reflectedPointName;
                    if (entry.vectorName) savedEntry.vectorName = entry.vectorName;
                    if (entry.translatedPointName) savedEntry.translatedPointName = entry.translatedPointName;
                    if (entry.dx_expr) savedEntry.dx_expr = entry.dx_expr; if (entry.dy_expr) savedEntry.dy_expr = entry.dy_expr; if (entry.a_expr) savedEntry.a_expr = entry.a_expr; if (entry.b_expr) savedEntry.b_expr = entry.b_expr; if (entry.startPointName) savedEntry.startPointName = entry.startPointName; if (entry.endPointName) savedEntry.endPointName = entry.endPointName; if (entry.conicName) savedEntry.conicName = entry.conicName;
                } else if (entry.type === 'constant') {
                    savedEntry.name = entry.name;
                    savedEntry.value = entry.value;
                    if (entry.hasLargeOps) {
                        savedEntry.largeOpTokens = entry.largeOpTokens;
                    } else {
                        savedEntry.processedExpr = entry.processedExpr;
                    }
                } else if (entry.type === 'point_list') {
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;
                } else if (entry.type === 'text') {
                    savedEntry.name = entry.name;
                    savedEntry.content = entry.content;
                    savedEntry.color = entry.color;
                }
                savedEntry.dependencies = entry.dependencies;
                return savedEntry;
            }).filter(e => e !== null),
            name: this.filename,
            version: this.appVersion,
            calcJSCustomFunctions: userCustomFunctions,
            calcJScalc3: userCalc3,
            customAdvancedFunctions: customAdvancedFunctionsToSave,
            scale: this.scale,
            offsetX: this.offset.x,
            offsetY: this.offset.y,
            explicitPrecisionStep: this.explicitPrecisionStep,
            implicitPrecisionStep: this.implicitPrecisionStep,
            highPerformancePlottingEnabled: this.highPerformancePlottingEnabled,
            smoothPanningEnabled: this.smoothPanningEnabled,
            tmin: this.tmin,
            tmax: this.tmax,
            blocks01: Array.from(this.blocks01),
            geometrySnapEnabled: this.geometrySnapEnabled,
            preferredColorValue: this.preferredColorValue,
            originalExplicitPrecision: this.originalExplicitPrecision,
            originalImplicitPrecision: this.originalImplicitPrecision,
            autoBreakpointDetectionEnabled: this.autoBreakpointDetectionEnabled,
            annotations: serializableAnnotations,
            globalScript: document.getElementById('global-script-input').value,
            showPlaybackControls: this.showPlaybackControls,
            currentFrame: this.currentFrame,
            totalFrames: this.totalFrames,
            playbackFPS: this.playbackFPS
        };
        return state;
    }
 saveState() {
        const state = this.exportStateObject();
        const jsonString = JSON.stringify(state, (key, value) => {
            if (key === 'compiledFunc') return undefined;
            return value;
        }, 2);
        const blob = new Blob([jsonString], { type: 'text/plain' });
        const filename = `${this.filename}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }

    getScreenshot() {
        this.draw();
        
        const combinedCanvas = document.createElement('canvas');
        combinedCanvas.width = this.canvas.width;
        combinedCanvas.height = this.canvas.height;
        const ctx = combinedCanvas.getContext('2d');

        ctx.drawImage(this.canvas, 0, 0);

        ctx.drawImage(this.axisCanvas, 0, 0);

        return combinedCanvas.toDataURL('image/png');
    }

importStateObject(loadedState) {
    if (!loadedState || !Array.isArray(loadedState.entries)) {
        throw new Error('存档数据无效');
    }
    this.stopAllAudio();
    this.clearPlotData();
    this.categoryFilterMode = 0;
    this.updateCategoryButtonIcon();

    this.annotations = [];
    
    if (loadedState.name) {
        this.filename = loadedState.name;
    } else {
        const date = new Date();
        this.filename = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    }
    if (this.fileNameDisplay) this.fileNameDisplay.textContent = this.filename;
    this.entries.forEach(entry => entry.webglVertices = null);
    this.entries = [];

    const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
    const defaultDefinitions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => defaultAdvancedFunctionNames.has(def.name));
    ADVANCED_FUNCTION_DEFINITIONS.length = 0;
    Array.prototype.push.apply(ADVANCED_FUNCTION_DEFINITIONS, defaultDefinitions);

    if (loadedState.customAdvancedFunctions && Array.isArray(loadedState.customAdvancedFunctions)) {
        loadedState.customAdvancedFunctions.forEach(customFuncDef => {
            const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === customFuncDef.name);
            if (existingIndex !== -1) {
                ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = customFuncDef;
            } else {
                ADVANCED_FUNCTION_DEFINITIONS.push(customFuncDef);
            }
        });
    }

    this.initializeAdvancedCalcJSFunctions();
    this.calcJSUtils.customFunctions = loadedState.calcJSCustomFunctions || {};
    this.calcJSUtils.calc3 = loadedState.calcJScalc3 || [];
    this.initializeCalcJSBuiltinFunctions();

    this.showPlaybackControls = loadedState.showPlaybackControls || false;
    if (this.showPlaybackControlsToggle) this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
    this.currentFrame = loadedState.currentFrame || 0;
    this.totalFrames = loadedState.totalFrames || 100;
    this.playbackFPS = loadedState.playbackFPS || 10;

    loadedState.entries.forEach(loadedEntry => {
        try {
            const processedEntry = this.loadEntryData(loadedEntry);
            this.entries.push(processedEntry);
        } catch (e) {
            console.warn(`加载存档条目出错: ${e.message}`, loadedEntry);
        }
    });

    this.scale = loadedState.scale;
    this.offset.x = loadedState.offsetX;
    this.offset.y = loadedState.offsetY;
    this.explicitPrecisionStep = loadedState.explicitPrecisionStep ?? 2;
    this.implicitPrecisionStep = loadedState.implicitPrecisionStep ?? 5;
    this.originalExplicitPrecision = loadedState.originalExplicitPrecision ?? this.explicitPrecisionStep;
    this.originalImplicitPrecision = loadedState.originalImplicitPrecision ?? this.implicitPrecisionStep;
    this.highPerformancePlottingEnabled = loadedState.highPerformancePlottingEnabled ?? false;
    this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
    this.smoothPanningEnabled = loadedState.smoothPanningEnabled ?? false;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;
    this.tmin = loadedState.tmin ?? -2 * Math.PI; this.tmax = loadedState.tmax ?? 2 * Math.PI;
    this.integralNumSteps = loadedState.integralNumSteps ?? 100;
    if (this.integralPrecisionSlider) this.integralPrecisionSlider.setValue(this.integralNumSteps, true);
    this.updateIntegralPrecisionLabel();
    this.updateParametricRangeLabels();
    this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep, true);
    this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep, true);
    this.updatePrecisionLabels();
    this.preferredColorValue = loadedState.preferredColorValue ?? 0;
    this.preferredColorSlider.setValue(this.preferredColorValue, true);
    this.updatePreferredColorValueLabel(); this.applyThemeColors();
    this.geometrySnapEnabled = loadedState.geometrySnapEnabled ?? true;
    if (this.geometrySnapToggle) this.geometrySnapToggle.checked = this.geometrySnapEnabled;

    this.autoBreakpointDetectionEnabled = loadedState.autoBreakpointDetectionEnabled ?? false;
    if (this.autoBreakpointDetectionToggle) this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;

    if (Array.isArray(loadedState.blocks01)) {
        this.blocks01.clear(); this.orderedBlocks01ForImplicitProcessing.length = 0;
        this.implictplotindex.length = 0; this.implictplotindex.push(0); this.implictplotdata.length = 0;
        const tempCssWidth = this.canvasContainer.clientWidth || this.canvas.width / (window.devicePixelRatio || 1);
        const tempCssHeight = this.canvasContainer.clientHeight || this.canvas.height / (window.devicePixelRatio || 1);
        const { unitStep: tempUnitStep } = this.calculateGridStep(tempCssWidth, tempCssHeight);
        if (Number.isFinite(tempUnitStep) && tempUnitStep > 0) {
            for (const coordKey of loadedState.blocks01) {
                if (!this.blocks01.has(coordKey)) {
                    this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
                    const parts = coordKey.split(',');
                    if (parts.length === 2) {
                        const cellCenterXMath = parseFloat(parts[0]); const cellCenterYMath = parseFloat(parts[1]);
                        if (Number.isFinite(cellCenterXMath) && Number.isFinite(cellCenterYMath)) this.processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, tempUnitStep);
                    }
                    this.implictplotindex.push(this.implictplotdata.length);
                }
            }
        }
    }

    this.globalScript = loadedState.globalScript || "";
    document.getElementById('global-script-input').value = this.globalScript;
    this.pen.segments = [];
    
    this.annotations = (loadedState.annotations || []).map(a => ({...a}));
    
    this.annotations.forEach(async anno => {
        if (anno.type === 'image' && anno.src) {
            const img = new Image();
            img.onload = () => { anno.img = img; this.requestDraw(); };
            img.src = anno.src;
        } else if (anno.type === 'audio' && anno.src) {
            const audio = new Audio(anno.src);
            anno.audioElem = audio;
            anno.isPlaying = false;
            audio.addEventListener('ended', () => {
                anno.isPlaying = false;
                this.requestDraw();
            });
            audio.addEventListener('timeupdate', () => {
                if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === anno) {
                    this.requestDraw(); 
                }
            });
        } else if (anno.type === 'pdf') {
            if (anno.pdfDataBase64) {
                anno.pdfData = this._base64ToUint8Array(anno.pdfDataBase64);
            }
            if (anno.pdfData) {
                this._restorePdfAnnotation(anno);
            }
        }
    });

    this.updateGlobalPlayState();
    this.recalculateAll();

    if (this.currentUIMode === 'code') this.updateCodeList();
}
loadJsOperator() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt';
    fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const fileContent = event.target.result;
                const newOpData = (new Function('return ' + fileContent))();

                if (!newOpData || typeof newOpData.name !== 'string' || !Array.isArray(newOpData.params) || typeof newOpData.bodyJsString !== 'string') {
                    throw new Error('文件内容不是有效的运算符定义对象。格式应为 { name: "...", params: [...], bodyJsString: "..." }');
                }

              
                newOpData.name = newOpData.name.toLowerCase();
                const { name, params, bodyJsString } = newOpData;
                
                params.forEach(param => {
                    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                        throw new Error(`参数名 '${param}' 不是有效的JS标识符。`);
                    }
                });

                const finalOp = { name, params, bodyJsString };

                const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === name);
                if (existingIndex !== -1) {
                    ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = finalOp;
                } else {
                    ADVANCED_FUNCTION_DEFINITIONS.push(finalOp);
                }

                this.initializeAdvancedCalcJSFunctions();
                this.recalculateAll();
                this.updateCodeList();
                alert(`成功加载并更新/添加了JS运算符: ${name}`);

            } catch (error) {
                alert('加载js运算符失败: ' + error.message);
            }
        };
        reader.readAsText(file);
    };
    fileInput.click();
}
loadState(stateString) {
    try {
        const loadedState = JSON.parse(stateString);
        if (!loadedState || !Array.isArray(loadedState.entries) || typeof loadedState.scale !== 'number' || typeof loadedState.offsetX !== 'number' || typeof loadedState.offsetY !== 'number') {
            throw new Error('存档文件格式无效');
        }
        this.stopAllAudio();
        this.clearPlotData();

        this.annotations = [];

        if (loadedState.name) {
            this.filename = loadedState.name;
        } else {
            const date = new Date();
            this.filename = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
        }
        if (this.fileNameDisplay) this.fileNameDisplay.textContent = this.filename;
        this.entries.forEach(entry => entry.webglVertices = null);
        this.entries = [];


        const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        const defaultDefinitions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => defaultAdvancedFunctionNames.has(def.name));
        ADVANCED_FUNCTION_DEFINITIONS.length = 0;
        Array.prototype.push.apply(ADVANCED_FUNCTION_DEFINITIONS, defaultDefinitions);


        if (loadedState.customAdvancedFunctions && Array.isArray(loadedState.customAdvancedFunctions)) {
            loadedState.customAdvancedFunctions.forEach(customFuncDef => {
                const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === customFuncDef.name);
                if (existingIndex !== -1) {
                    ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = customFuncDef;
                } else {
                    ADVANCED_FUNCTION_DEFINITIONS.push(customFuncDef);
                }
            });
        }

        this.initializeAdvancedCalcJSFunctions();
        this.calcJSUtils.customFunctions = loadedState.calcJSCustomFunctions || {};
        this.calcJSUtils.calc3 = loadedState.calcJScalc3 || [];
        this.initializeCalcJSBuiltinFunctions();

        this.showPlaybackControls = loadedState.showPlaybackControls || false;
        if (this.showPlaybackControlsToggle) this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
        this.currentFrame = loadedState.currentFrame || 0;
        this.totalFrames = loadedState.totalFrames || 100;
        this.playbackFPS = loadedState.playbackFPS || 10;

        loadedState.entries.forEach(loadedEntry => {
            try {
                const processedEntry = this.loadEntryData(loadedEntry);
                this.entries.push(processedEntry);
            } catch (e) {
                alert(`加载存档时发现无效或解析失败的条目 "${loadedEntry.expr || '未知表达式'}", 已跳过. Error: ${e.message}`);
            }
        });
        this.scale = loadedState.scale;
        this.offset.x = loadedState.offsetX; this.offset.y = loadedState.offsetY;
        this.explicitPrecisionStep = loadedState.explicitPrecisionStep ?? parseFloat(this.explicitPrecisionSlider.options.value);
        this.implicitPrecisionStep = loadedState.implicitPrecisionStep ?? 5;
        this.originalExplicitPrecision = loadedState.originalExplicitPrecision ?? this.explicitPrecisionStep;
        this.originalImplicitPrecision = loadedState.originalImplicitPrecision ?? this.implicitPrecisionStep;
        this.highPerformancePlottingEnabled = loadedState.highPerformancePlottingEnabled ?? false;
        this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
        this.smoothPanningEnabled = loadedState.smoothPanningEnabled ?? false;
        this.smoothPanningToggle.checked = this.smoothPanningEnabled;
        this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;
        this.tmin = loadedState.tmin ?? -2 * Math.PI; this.tmax = loadedState.tmax ?? 2 * Math.PI;
        this.integralNumSteps = loadedState.integralNumSteps ?? 100;
        if (this.integralPrecisionSlider) this.integralPrecisionSlider.setValue(this.integralNumSteps, true);
        this.updateIntegralPrecisionLabel();
        this.updateParametricRangeLabels();
        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep, true);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep, true);
        this.updatePrecisionLabels();
        this.preferredColorValue = loadedState.preferredColorValue ?? 0;
        this.preferredColorSlider.setValue(this.preferredColorValue, true);
        this.updatePreferredColorValueLabel(); this.applyThemeColors();
        this.geometrySnapEnabled = loadedState.geometrySnapEnabled ?? true;
        if (this.geometrySnapToggle) this.geometrySnapToggle.checked = this.geometrySnapEnabled;

        this.autoBreakpointDetectionEnabled = loadedState.autoBreakpointDetectionEnabled ?? false;
        if (this.autoBreakpointDetectionToggle) this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;
        this.updateGlobalPlayState();

        if (Array.isArray(loadedState.blocks01) && this.globalPlayState === 0) {
            this.blocks01.clear(); this.orderedBlocks01ForImplicitProcessing.length = 0;
            this.implictplotindex.length = 0; this.implictplotindex.push(0); this.implictplotdata.length = 0;
            const tempCssWidth = this.canvasContainer.clientWidth || this.canvas.width / (window.devicePixelRatio || 1);
            const tempCssHeight = this.canvasContainer.clientHeight || this.canvas.height / (window.devicePixelRatio || 1);
            const { unitStep: tempUnitStep } = this.calculateGridStep(tempCssWidth, tempCssHeight);
            if (Number.isFinite(tempUnitStep) && tempUnitStep > 0) {
                for (const coordKey of loadedState.blocks01) {
                    if (!this.blocks01.has(coordKey)) {
                        this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
                        const parts = coordKey.split(',');
                        if (parts.length === 2) {
                            const cellCenterXMath = parseFloat(parts[0]); const cellCenterYMath = parseFloat(parts[1]);
                            if (Number.isFinite(cellCenterXMath) && Number.isFinite(cellCenterYMath)) this.processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, tempUnitStep);
                        }
                        this.implictplotindex.push(this.implictplotdata.length);
                    }
                }
            }
        }
        this.globalScript = loadedState.globalScript || "";
        document.getElementById('global-script-input').value = this.globalScript;
        this.pen.segments = [];
        
        // 使用浅拷贝，确保批注对象与存档数据对象分离
        this.annotations = (loadedState.annotations || []).map(a => ({...a}));
        
        this.annotations.forEach(async anno => {
            if (anno.type === 'image' && anno.src) {
                const img = new Image();
                img.onload = () => { anno.img = img; this.requestDraw(); };
                img.src = anno.src;
            } else if (anno.type === 'audio' && anno.src) {
                const audio = new Audio(anno.src);
                anno.audioElem = audio;
                anno.isPlaying = false;
                audio.addEventListener('ended', () => {
                    anno.isPlaying = false;
                    this.requestDraw();
                });
                audio.addEventListener('timeupdate', () => {
                    if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === anno) {
                        this.requestDraw(); 
                    }
                });
            } else if (anno.type === 'pdf') {
                if (anno.pdfDataBase64) {
                    anno.pdfData = this._base64ToUint8Array(anno.pdfDataBase64);
                }
                if (anno.pdfData) {
                    this._restorePdfAnnotation(anno);
                }
            }
        });
        this.recalculateAll();
    } catch (error) { alert('加载存档失败: ' + error.message); }
}
loadEntryData(loadedEntry) {
        if (typeof loadedEntry.type !== 'string' || (loadedEntry.type !== 'advanced_custom_function_definition' && typeof loadedEntry.expr !== 'string') ) {
            throw new Error('条目缺少类型或表达式');
        }
        const entry = { ...loadedEntry }; 
        entry.expanded = entry.expanded === undefined ? false : entry.expanded;
        entry.sliderActive = entry.sliderActive === undefined ? false : entry.sliderActive;
        entry.compilationError = entry.compilationError || undefined;
        entry.webglVertices = null; 
        entry.thickness = loadedEntry.thickness || 3;
        entry.displayFrame = loadedEntry.displayFrame || 0;

        if (entry.type === 'function') {
            entry.color = entry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
            entry.visible = entry.visible !== undefined ? entry.visible : true;
            if (entry.plotType === 'parametric') {
               entry.cachedPoints = [];
            }
        } else if (entry.type === 'variable') {
            entry.name = entry.name || entry.key;
            if (entry.isEditableIndependent) {
               if (!Number.isFinite(entry.min) || !Number.isFinite(entry.max) || entry.min >= entry.max) {
                   const initialValue = Number.isFinite(entry.value) ? entry.value : 0; 
                   const absValue = Math.abs(initialValue);
                   entry.min = (initialValue === 0) ? -10 : -2 * absValue;
                   entry.max = (initialValue === 0) ? 10 : 2 * absValue;
                   if (entry.min >= entry.max) { entry.min = entry.max - 100; if (entry.min >= entry.max) entry.max = entry.min + 200; }
               }
               if (!Number.isFinite(entry.step) || entry.step <= 0) {
                   entry.step = (Number.isFinite(entry.max) && Number.isFinite(entry.min)) ? Math.abs(entry.max - entry.min) / 100 : 0.02;
                   if (!Number.isFinite(entry.step) || entry.step <= 0) entry.step = 0.02;
               }
               if (!Number.isFinite(entry.value)) entry.value = Number.isFinite(entry.min) ? entry.min : 0;
               if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
               if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
               entry.playState = entry.playState === 1 ? 1 : 0;
               entry.playDirection = entry.playDirection === -1 ? -1 : 1;
            } else { 
               entry.min = NaN; entry.max = NaN; entry.step = NaN;
               entry.playState = 0; entry.playDirection = 1;
            }
        } else if (entry.type === 'geometry') {
            const parsed = this.parseGeometryDefinition(entry.expr, -1);
            if (!parsed) {
                throw new Error(`Failed to re-parse geometry expression: ${entry.expr}`);
            }
            parsed.name = entry.name;
            parsed.color = entry.color;
            parsed.thickness = entry.thickness;
            parsed.visible = entry.visible;
            parsed.displayFrame = entry.displayFrame || 0;
            parsed.isMeaningful = false; 
            parsed.expanded = false; 
            return parsed;
        } else if (entry.type === 'constant') {
            entry.name = entry.name || this.autonameConstant();
            entry.value = NaN;  
        } else if (entry.type === 'custom_function_definition') {
            entry.params = entry.params || [];
            entry.body = entry.body || "";
        } else if (entry.type === 'advanced_custom_function_definition') {
           entry.params = entry.params || [];
           entry.bodyJs = entry.bodyJs || "";
           entry.expr = `${entry.name}(${entry.params.join(',')}) { /* JS body */ }`;
           if (!this.calcJSUtils.advancedCustomFunctions[entry.name]) {
               try {
                   const compiledFunc = new Function(...entry.params, entry.bodyJs);
                   this.calcJSUtils.advancedCustomFunctions[entry.name] = {
                       params: entry.params,
                       bodyJsString: entry.bodyJs,
                       compiledFunc: compiledFunc
                   };
                   if (!this.calcJSUtils.advancedCustomFunctionNames.includes(entry.name)) {
                       this.calcJSUtils.advancedCustomFunctionNames.push(entry.name);
                       this.calcJSUtils.advancedCustomFunctionNames.sort((a,b) => b.length - a.length);
                   }
               } catch (e) {
                   console.error(`编译加载的高级函数 ${entry.name} 时出错:`, e);
                   entry.compilationError = e.message;
               }
           }
        } else if (entry.type === 'point_list') {
            const parsed = this.parsePointList(entry.expr);
            Object.assign(entry, parsed);
            entry.color = loadedEntry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
            entry.visible = loadedEntry.visible !== undefined ? loadedEntry.visible : true;
            entry.thickness = loadedEntry.thickness || 3;
            entry.displayFrame = loadedEntry.displayFrame || 0;
        } else if (entry.type === 'text') {
            entry.name = entry.name || this.autonameText();
            entry.content = entry.content || "";
            entry.color = entry.color || { h: 0, s: 0, b: 60, a: 0 };
            entry.expanded = false;
        }
        return entry;
    }


loadBuiltinSave(index) {
    if (index < 0 || index >= BUILTINSAVINGSTRING.length) {
        alert("无效的示例存档索引。");
        return;
    }
    const stateString = BUILTINSAVINGSTRING[index];
    this.loadState(stateString);
}


loadEntryData(loadedEntry) {
if (typeof loadedEntry.type !== 'string' || (loadedEntry.type !== 'advanced_custom_function_definition' && typeof loadedEntry.expr !== 'string') ) {
throw new Error('条目缺少类型或表达式');
}
const entry = { ...loadedEntry }; 
entry.expanded = entry.expanded === undefined ? false : entry.expanded;
entry.sliderActive = entry.sliderActive === undefined ? false : entry.sliderActive;
entry.compilationError = entry.compilationError || undefined;
entry.webglVertices = null; 
entry.dependencies = entry.dependencies || [];
entry.hasLargeOps = entry.hasLargeOps || false;
entry.thickness = loadedEntry.thickness || 3;
entry.displayFrame = loadedEntry.displayFrame || 0;

if (entry.type === 'function') {
entry.color = entry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
entry.visible = entry.visible !== undefined ? entry.visible : true;

entry.extendTo3D = loadedEntry.extendTo3D !== undefined ? loadedEntry.extendTo3D : false;
entry.sliceAxis = loadedEntry.sliceAxis || 'none';
entry.sliceVal = loadedEntry.sliceVal !== undefined ? loadedEntry.sliceVal : 0;

if (entry.plotType === 'implicit') {
    entry.sign = entry.sign || '=';
}
if (entry.plotType === 'parametric') {
   entry.cachedPoints = [];
   if (!entry.exprX_raw && entry.processedExprX) entry.exprX_raw = entry.processedExprX; 
   if (!entry.exprY_raw && entry.processedExprY) entry.exprY_raw = entry.processedExprY; 
}
} else if (entry.type === 'variable') {
entry.name = entry.name || entry.key; 
if (entry.isEditableIndependent) {
   if (!Number.isFinite(entry.min) || !Number.isFinite(entry.max) || entry.min >= entry.max) {
       const initialValue = Number.isFinite(entry.value) ? entry.value : 0; 
       const absValue = Math.abs(initialValue);
       entry.min = (initialValue === 0) ? -10 : -2 * absValue;
       entry.max = (initialValue === 0) ? 10 : 2 * absValue;
       if (entry.min >= entry.max) { entry.min = entry.max - 100; if (entry.min >= entry.max) entry.max = entry.min + 200; }
   }
   if (!Number.isFinite(entry.step) || entry.step <= 0) {
       entry.step = (Number.isFinite(entry.max) && Number.isFinite(entry.min)) ? Math.abs(entry.max - entry.min) / 100 : 0.02;
       if (!Number.isFinite(entry.step) || entry.step <= 0) entry.step = 0.02;
   }
   if (!Number.isFinite(entry.value)) entry.value = Number.isFinite(entry.min) ? entry.min : 0;
   if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
   if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
   entry.playState = entry.playState === 1 ? 1 : 0;
   entry.playDirection = entry.playDirection === -1 ? -1 : 1;
   entry.playMode = loadedEntry.playMode !== undefined ? loadedEntry.playMode : 0;
entry.showOnPlot = loadedEntry.showOnPlot || false;
entry.cardX = loadedEntry.cardX !== undefined ? loadedEntry.cardX : 2; // 默认数学坐标 X
entry.cardY = loadedEntry.cardY !== undefined ? loadedEntry.cardY : 2; // 默认数学坐标 Y
entry.cardW = loadedEntry.cardW !== undefined ? loadedEntry.cardW : 220; // 宽高仍保持屏幕像素
entry.cardH = loadedEntry.cardH !== undefined ? loadedEntry.cardH : 110;
} else { 
   entry.min = NaN; entry.max = NaN; entry.step = NaN;
   entry.playState = 0; entry.playDirection = 1;
   entry.playMode = 0;
}
} else if (entry.type === 'geometry') {
    entry.isMeaningful = false; 
    entry.expanded = false;
} else if (entry.type === 'constant') {
    entry.name = entry.name || this.autonameConstant();
    entry.value = NaN;  
}
 else if (entry.type === 'custom_function_definition') {
entry.params = entry.params || [];
entry.body = entry.body || "";
} else if (entry.type === 'advanced_custom_function_definition') {
entry.params = entry.params || [];
entry.bodyJs = entry.bodyJs || "";
entry.expr = `${entry.name}(${entry.params.join(',')}) { /* JS body */ }`;
if (!this.calcJSUtils.advancedCustomFunctions[entry.name]) {
       try {
           const compiledFunc = new Function(...entry.params, entry.bodyJs);
           this.calcJSUtils.advancedCustomFunctions[entry.name] = {
               params: entry.params,
               bodyJsString: entry.bodyJs,
               compiledFunc: compiledFunc
           };
           if (!this.calcJSUtils.advancedCustomFunctionNames.includes(entry.name)) {
               this.calcJSUtils.advancedCustomFunctionNames.push(entry.name);
               this.calcJSUtils.advancedCustomFunctionNames.sort((a,b) => b.length - a.length);
           }
       } catch (e) {
           console.error(`编译加载的高级函数 ${entry.name} 时出错:`, e);
           entry.compilationError = e.message;
       }
   }
} else if (entry.type === 'point_list') {

        const parsed = this.parsePointList(entry.expr);
        Object.assign(entry, parsed);

        entry.color = loadedEntry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
        entry.visible = loadedEntry.visible !== undefined ? loadedEntry.visible : true;
        entry.thickness = loadedEntry.thickness || 3;
        entry.displayFrame = loadedEntry.displayFrame || 0;
    } else if (entry.type === 'text') {
    entry.name = entry.name || this.autonameText();
    entry.content = entry.content || "";
    entry.color = entry.color || { h: 0, s: 0, b: 60, a: 0 };
    entry.expanded = false;
}
return entry;
}

processImplicitBlocksOnGrid(cssWidth, cssHeight) {
if (this.isPanning && this.globalPlayState === 0 && !this.isSmoothPanningActive) return;
const { unitStep } = this.calculateGridStep(cssWidth, cssHeight);
if (!Number.isFinite(unitStep) || unitStep <= 0) return;
if (this.currentUnitStep === 0) this.currentUnitStep = unitStep;
const { x: offsetX, y: offsetY } = this.offset;
const keyPrecision = 6;
const minXMathVisible = (-offsetX) / this.scale; const maxXMathVisible = (cssWidth - offsetX) / this.scale;
const minYMathVisible = (offsetY - cssHeight) / this.scale; const maxYMathVisible = (offsetY) / this.scale;
const startCellX = Math.floor(minXMathVisible / unitStep) * unitStep;
const endCellXLoopLimit = Math.ceil(maxXMathVisible / unitStep) * unitStep;
const startCellY = Math.floor(minYMathVisible / unitStep) * unitStep;
const endCellYLoopLimit = Math.ceil(maxYMathVisible / unitStep) * unitStep;
for (let currentCellX = startCellX; currentCellX < endCellXLoopLimit; currentCellX += unitStep) {
for (let currentCellY = startCellY; currentCellY < endCellYLoopLimit; currentCellY += unitStep) {
   const centerXMath = currentCellX + unitStep / 2; const centerYMath = currentCellY + unitStep / 2;
   const coordKey = `${centerXMath.toFixed(keyPrecision)},${centerYMath.toFixed(keyPrecision)}`;
   if (!this.blocks01.has(coordKey)) {
       this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
       this.processSingleBlockForImplicit(centerXMath, centerYMath, unitStep);
       this.implictplotindex.push(this.implictplotdata.length);
   }
}
}
}

cleanupUnusedCache(cssWidth, cssHeight) {
if (!this.performanceModeEnabled || this.globalPlayState !== 0) return;
const { unitStep } = this.calculateGridStep(cssWidth, cssHeight);
if (!Number.isFinite(unitStep) || unitStep <= 0) return;
const { x: offsetX, y: offsetY } = this.offset;
const keyPrecision = 6; const bufferCells = 1;
const minXMathVisible = (-offsetX)/this.scale - bufferCells*unitStep; const maxXMathVisible = (cssWidth-offsetX)/this.scale + bufferCells*unitStep;
const minYMathVisible = (offsetY-cssHeight)/this.scale - bufferCells*unitStep; const maxYMathVisible = (offsetY)/this.scale + bufferCells*unitStep;
const visibleBlockKeys = new Set();
const startCellX = Math.floor(minXMathVisible/unitStep)*unitStep; const endCellXLoopLimit = Math.ceil(maxXMathVisible/unitStep)*unitStep;
const startCellY = Math.floor(minYMathVisible/unitStep)*unitStep; const endCellYLoopLimit = Math.ceil(maxYMathVisible/unitStep)*unitStep;
for (let cX = startCellX; cX < endCellXLoopLimit; cX += unitStep) {
for (let cY = startCellY; cY < endCellYLoopLimit; cY += unitStep) {
   const cXM = cX + unitStep/2; const cYM = cY + unitStep/2;
   visibleBlockKeys.add(`${cXM.toFixed(keyPrecision)},${cYM.toFixed(keyPrecision)}`);
}
}
const newOrdBlks = []; const newBlks01Set = new Set();
const newImpPlotData = []; const newImpPlotIdx = [0];
let blksRemoved = false; let curNewDataLen = 0;
for (let i=0; i < this.orderedBlocks01ForImplicitProcessing.length; i++) {
const curBlkKey = this.orderedBlocks01ForImplicitProcessing[i];
if (visibleBlockKeys.has(curBlkKey)) {
   newOrdBlks.push(curBlkKey); newBlks01Set.add(curBlkKey);
   const dataStartIdx = this.implictplotindex[i]; const dataEndIdx = this.implictplotindex[i+1];
   if (dataStartIdx !== undefined && dataEndIdx !== undefined && dataStartIdx < dataEndIdx) {
       const segment = this.implictplotdata.slice(dataStartIdx, dataEndIdx);
       newImpPlotData.push(...segment); curNewDataLen += segment.length;
   }
   newImpPlotIdx.push(curNewDataLen);
} else blksRemoved = true;
}
if (newImpPlotIdx.length === 1 && newOrdBlks.length > 0) {
if (newImpPlotIdx[0] !== newImpPlotData.length) { newImpPlotIdx[0] = 0; newImpPlotIdx[1] = newImpPlotData.length; }
}
if (blksRemoved) {
this.orderedBlocks01ForImplicitProcessing = newOrdBlks; this.blocks01 = newBlks01Set;
this.implictplotdata = newImpPlotData; this.implictplotindex = newImpPlotIdx;
}
}

drawDeveloperGridInfoGL(cssWidth, cssHeight) { }
drawBlocks01ListContentGL(cssWidth, cssHeight) { }


setUIMode(mode) {
        if (!mode) return;
        if (mode === 'file' || mode === 'settings' || mode === 'code') {
            this.stopTracing();
        }
          const sidebarBg = document.getElementById('sidebar-background');
        if (sidebarBg && !this.isPortraitMode && ['plot', 'geometry', 'code'].includes(this.currentUIMode) && !document.body.classList.contains('sidebar-hidden') && !sidebarBg.classList.contains('fullscreen')) {
             this.lastValidSidebarRight = sidebarBg.getBoundingClientRect().right;
        }

        if (this.selectedAnnotationIndex !== -1) {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        }

        const sidebar = document.getElementById('sidebar');

        const allPanels = {
            plot: document.getElementById('entry-list'),
            geometry: this.geometryPanel,
            code: this.codePanel,
            settings: document.getElementById('settings-panel'),
            file: document.getElementById('file-panel'),
            about: document.getElementById('about-panel'),
        };

        if (this.currentUIMode === mode && !document.body.classList.contains('sidebar-hidden')) {
            return;
        }
        
        document.body.classList.remove('sidebar-hidden');

        Object.values(allPanels).forEach(p => { if (p) p.style.display = 'none'; });

        if (allPanels[mode]) {
            allPanels[mode].style.display = (mode === 'geometry' || mode === 'code') ? 'flex' : 'block';
        } else {
            mode = 'plot';
            allPanels.plot.style.display = 'block';
        }
        
        this.currentUIMode = mode;
        
        const infoModes = ['settings', 'file', 'about', 'code'];
        if (this.isPortraitMode || infoModes.includes(mode)) {
            sidebar.classList.add('fullscreen');
            sidebarBg.classList.add('fullscreen');
        } else {
            sidebar.classList.remove('fullscreen');
            sidebarBg.classList.remove('fullscreen');
        }

        if (mode === 'geometry') {
            if (!this.geometryPanel.innerHTML) {
                this.populateGeometryPanel();
            }
            this.updateGeometryButtonColors();
       } else if (mode === 'code') {
            this.updateCodeList();
            this.hideCodeEditor();
            document.getElementById('global-script-view').style.display = 'none';
            const toggleBtn = document.getElementById('global-script-toggle-btn');
            toggleBtn.style.display = 'flex';
            toggleBtn.textContent = '全局脚本';
        } else {
            this.cancelGeometryInteraction();
        }
        
        this.updateLayout();
        
        setTimeout(() => {
            this.updateOverlayPositions();
            this.updateCanvasPosition();
            this.updateTopBarLayout(); 
        }, 250);

        if (typeof updateKeyboardToggleVisibility === 'function') {
            updateKeyboardToggleVisibility();
        }


        if (typeof window.updateInterfaceState === 'function') {
            window.updateInterfaceState();
        }
    }   
populateGeometryPanel() {
        this.geometryPanel.innerHTML = `
            <div id="geometry-interaction-prompt-container"></div>
            <div class="geo-category">
                <h3>点</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="point">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Im5vbmUiLz48cGF0aCBkPSJNMjMwLjA1LDE4OC44NDg0M2MzLjgsLTIuNSA5LjMsLTQuMyAxNS41LC00LjciIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjMyLjQ1LDE4NS42NDg0M2MwLC0yLjggMi4zLC01LjEgNS4xLC01LjFjMi44LDAgNS4xLDIuMyA1LjEsNS4xYzAsMi44IC0yLjMsNS4xIC01LjEsNS4xYy0yLjgsMC4xIC01LjEsLTIuMiAtNS4xLC01LjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDYuMDUsMTY5LjI0ODQzbDMuOSw5LjZoLTJsLTAuOCwtMi4yaC0zLjdsLTAuOCwyLjJoLTEuOWwzLjcsLTkuNnpNMjQ2LjQ1LDE3NS4wNDg0M2wtMS4zLC0zLjRsLTEuMiwzLjR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="点"></div>
                        <span class="geo-btn-text">点</span>
                    </div>
                    <div class="geo-btn" data-geo-type="intercept">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ2LjY1LDE3Mi43NWwtMTMuNSwxNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni44NSwxODcuMjVsLTEzLjIsLTE0LjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzQuNTUsMTgwLjI1YzAsLTIuOCAyLjMsLTUuMSA1LjEsLTUuMWMyLjgsMCA1LjEsMi4zIDUuMSw1LjFjMCwyLjggLTIuMyw1LjEgLTUuMSw1LjFjLTIuOCwwIC01LjEsLTIuMyAtNS4xLC01LjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="交点"></div>
                        <span class="geo-btn-text">交点</span>
                    </div>
                    <div class="geo-btn" data-geo-type="midpoint">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjMzLjE0NDY0LDE4Ny4ybDE0LjMsLTE0LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuMjgwMzUsMTczLjc1MzU4YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjUxOTY1LDE4Ni4yNDY0MmMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNi43MDg5OSwxNzkuOTEwNzJjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="中点"></div>
                        <span class="geo-btn-text">中点</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>线</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="segment">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ0LjEsMTc1LjhsLTguNiw5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQxLjQsMTc1LjJjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzIuNCwxODQuOGMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="线段"></div>
                        <span class="geo-btn-text">线段</span>
                    </div>
                    <div class="geo-btn" data-geo-type="ray">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ4LjE1LDE3MS41NWwtMTMuMiwxMy44IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjg1LDE3NS43NWMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjMgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMS44NSwxODUuMzVjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS4zIC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="射线"></div>
                        <span class="geo-btn-text">射线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="line">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjMzLDE4Ny4ybDE0LjMsLTE0LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuNCwxNzUuMmMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMi40LDE4NC44YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="直线"></div>
                        <span class="geo-btn-text">直线</span>
                    </div>
                </div>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="vector">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM1LjIxNzMyLDE4NS4zMTEwMmwxMS44NDEwOCwtMTIuMzM3OTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzIuODQ1NzUsMTg0LjE1NTU3YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQyLjI4NDAxLDE3Mi43NDQ0M2g0LjI3MDE0IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ3LjE1NDI1LDE3My4wNzM4OHY0LjQ4MzY1IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="向量"></div>
                        <span class="geo-btn-text">向量</span>
                    </div>
                    <div class="geo-btn" data-geo-type="parallelline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM2LjA1LDE5MC42NWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjI5LjY1LDE4NC4yNWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMwLjM0OTk5LDE3OS42NWMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="平行线"></div>
                        <span class="geo-btn-text">平行线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="perpendicularline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjM1LjQxMTY2LDE4MS40NDkzNmwyLjQ3OTA2LC0yLjMxMzc5IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjQxLjc1LDE4Ny45bC0xMS45LC0xMS4xIiBzdHJva2U9IiM3OTc5NzkiLz48cGF0aCBkPSJNMjM1Ljg1LDE4N2wxNC4zLC0xNC45IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjM4LjM4NjUzLDE3OC44MDUwMmwyLjY0NDMzLDIuNDc5MDYiIHN0cm9rZT0iIzAwMDAwMCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="垂线"></div>
                        <span class="geo-btn-text">垂线</span>
                    </div>
                </div>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="anglebisector">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjQ2LjM2MDU5LDE3My44NDEyMmwtMTEuNTU1MDMsMTIuMDM5ODUiIHN0cm9rZT0iIzAwMDAwMCIvPjxwYXRoIGQ9Ik0yMzMuODMwOTUsMTg2LjMwMTI2aDEyLjYxNzQyIiBzdHJva2U9IiM3OTc5NzkiLz48cGF0aCBkPSJNMjMzLjU1MTYzLDE4Ni4yMTE4OHYtMTIuNTEzMTUiIHN0cm9rZT0iIzc5Nzk3OSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="角平分线"></div>
                        <span class="geo-btn-text">角平分线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="tangent">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM1LjUzMzgsMTgyLjY1Mzg3YzAsLTMuODg5NzkgMy4xNTMzLC03LjA0MzA5IDcuMDQzMDksLTcuMDQzMDljMy44ODk3OSwwIDcuMDQzMDksMy4xNTMzIDcuMDQzMDksNy4wNDMwOWMwLDMuODg5NzkgLTMuMTUzMyw3LjA0MzA5IC03LjA0MzA5LDcuMDQzMDljLTMuODg5NzksMCAtNy4wNDMwOSwtMy4xNTMzIC03LjA0MzA5LC03LjA0MzA5eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjM4MDAzLDE4NS4yMDMwNWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM1LjE5MDIzLDE3Ny45Mjk4NGMwLC0xLjQ3MDUzIDEuMTkyMSwtMi42NjI2MyAyLjY2MjYzLC0yLjY2MjYzYzEuNDcwNTMsMCAyLjY2MjYzLDEuMTkyMSAyLjY2MjYzLDIuNjYyNjNjMCwxLjQ3MDUzIC0xLjE5MjEsMi42NjI2MyAtMi42NjI2MywyLjY2MjYzYy0xLjQ3MDUzLDAgLTIuNjYyNjMsLTEuMTkyMSAtMi42NjI2MywtMi42NjI2M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="切线"></div>
                        <span class="geo-btn-text">切线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="trace">
                        <div class="geo-btn-icon">
                         <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIyMy43MzM5NywxOTYuMjY2MDN2LTMyLjUzMjA2aDMyLjUzMjA2djMyLjUzMjA2eiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yNTAuNDY0MzYsMTcyLjU2NjA0YzAuMzAzMTcsMS4yMTI2OCAtMC45MDk1MSwxLjUxNTg1IC0wLjkwOTUxLDEuNTE1ODVsLTAuNTA2NDksMC4wNzg1Yy0xLjgxNTIzLDEuMDM3MjcgLTQuMTE4MDQsMi4zNzMyNiAtNi4yMDA5MSwzLjk2NjQzYzEuMzUyNywyLjIwNjY0IDIuMjg3NTIsNC42Nzk0OCAyLjY5ODU3LDcuMzE1MzdjMC43MDk3Nyw0LjU1MTQ0IC0wLjU2NTQsOC43OTQzNSAtNS43NTg4Niw4LjgzNjQ0Yy00LjEyODEzLC0xLjQyMDUyIC01Ljg2MDIsLTYuNTU0IC00LjQ4ODM0LC0xMC42Nzg4M2MwLjcyNjI5LC0yLjE4Mzc3IDIuMjk1MywtNC4xNTE2MiA0LjE5OTUsLTUuODg2ODljLTEuODQ1OTEsLTIuMzg0MjkgLTQuMjYxMDIsLTQuMjk2OCAtNy4yMDg4OSwtNS41NDc2MmMwLDAgLTEuMTQ4OTMsLTAuNDkyNCAtMC42NTY1MywtMS42NDEzM2MwLjQ5MjQsLTEuMTQ4OTMgMS42NDEzMywtMC42NTY1MyAxLjY0MTMzLC0wLjY1NjUzYzMuMjI4NjUsMS4zOTU2MiA2LjAyOTgyLDMuNTU0MjEgOC4xNTgwMiw2LjIzNjYzYzIuMTI4MzUsLTEuNjI5NTUgNC40MzgwNiwtMy4wMDcwMiA2LjM3NTc2LC00LjExNDI4bDEuMTQwNSwtMC4zMzMyNWMwLDAgMS4yMTI2OCwtMC4zMDMxNyAxLjUxNTg1LDAuOTA5NTF6TTI0MC44ODk1OSwxNzkuNzgwMDljLTEuNDY4MjcsMS4zODYyNyAtMi42NTUwNiwyLjkyNDAxIC0zLjIxMzMsNC41OTI4MmMtMC43ODUyNCwyLjM0NzQyIC0wLjEwNTY2LDYuNjI2OTcgMi41MTEzNCw3LjQzOGMzLjYxNjA2LDAuMDUzOTQgMy40Njk0MywtNC42NTQ4OSAyLjcxMzY2LC03LjI4MTE4Yy0wLjQ4Njc2LC0xLjY5MTQ4IC0xLjE1OTQyLC0zLjI4NTYyIC0yLjAxMTY5LC00Ljc0OTY0eiIgZmlsbD0iIzg0ODQ4NCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48cGF0aCBkPSJNMjM0LjA5NDczLDE3My4zMjg3M2MwLC0xLjQ3MDUzIDEuMTkyMSwtMi42NjI2MyAyLjY2MjYzLC0yLjY2MjYzYzEuNDcwNTMsMCAyLjY2MjYzLDEuMTkyMSAyLjY2MjYzLDIuNjYyNjNjMCwxLjQ3MDUzIC0xLjE5MjEsMi42NjI2MyAtMi42NjI2MywyLjY2MjYzYy0xLjQ3MDUzLDAgLTIuNjYyNjMsLTEuMTkyMSAtMi42NjI2MywtMi42NjI2M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAzOjE2LjI2NjAzLS0+">
                        </div>
                        <span class="geo-btn-text">轨迹</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>圆锥曲线</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="circle_pr">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzEuNDUsMTgwLjZjMCwtNC41IDMuNywtOC4yIDguMiwtOC4yYzQuNSwwIDguMiwzLjcgOC4yLDguMmMwLDQuNSAtMy43LDguMiAtOC4yLDguMmMtNC41LDAgLTguMiwtMy42IC04LjIsLTguMnoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjM2LjU1MDAxLDE4MC43YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDIuMzUwMDEsMTc0LjNjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆(圆心与一点)"></div>
                        <span class="geo-btn-text">圆(圆心与一点)</span>
                    </div>
                    <div class="geo-btn" data-geo-type="circle_cr">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM2LjU1MDAxLDE4MC43YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjgxMjY3LDE4MC43Njg3Mmg3LjE3NDk4IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMxLjQ1LDE4MC42YzAsLTQuNSAzLjcsLTguMiA4LjIsLTguMmM0LjUsMCA4LjIsMy43IDguMiw4LjJjMCw0LjUgLTMuNyw4LjIgLTguMiw4LjJjLTQuNSwwIC04LjIsLTMuNiAtOC4yLC04LjJ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆(圆心与半径)"></div>
                        <span class="geo-btn-text">圆(圆心与半径)</span>
                    </div>
                     <div class="geo-btn" data-geo-type="circulararc">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yMzEuNzU0NDMsMTgwLjI0ODUyYzAsLTQuNTA2NDYgMy42NTMyMSwtOC4xNTk2OCA4LjE1OTY4LC04LjE1OTY4YzQuNTA2NDYsMCA4LjE1OTY4LDMuNjUzMjEgOC4xNTk2OCw4LjE1OTY4YzAsNC41MDY0NiAtMy42NTMyMSw4LjE1OTY4IC04LjE1OTY4LDguMTU5NjhjLTQuNTA2NDYsMCAtOC4xNTk2OCwtMy42NTMyMSAtOC4xNTk2OCwtOC4xNTk2OHoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjQ0Ljk4MTcsMTgwLjU5MjA5YzAsLTEuNDcwNTMgMS4xOTIxLC0yLjY2MjYzIDIuNjYyNjMsLTIuNjYyNjNjMS40NzA1MywwIDIuNjYyNjMsMS4xOTIxIDIuNjYyNjMsMi42NjI2M2MwLDEuNDcwNTMgLTEuMTkyMSwyLjY2MjYzIC0yLjY2MjYzLDIuNjYyNjNjLTEuNDcwNTMsMCAtMi42NjI2MywtMS4xOTIxIC0yLjY2MjYzLC0yLjY2MjYzeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM1LjQwNTE0LDE3My40NzcyNmMxLjI5NTQsLTAuODY1NDkgMi44NTI0MSwtMS4zNzAxMSA0LjUyNzI3LC0xLjM3MDExYzQuNTA2NDYsMCA4LjE1OTY4LDMuNjUzMjEgOC4xNTk2OCw4LjE1OTY4YzAsMC4wNDQxOSAtMC4wMDAzNSwwLjA4ODMgLTAuMDAxMDUsMC4xMzIzMyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMzIuOTc1MjEsMTczLjU2NzNjMCwtMS40NzA1MyAxLjE5MjEsLTIuNjYyNjMgMi42NjI2MywtMi42NjI2M2MxLjQ3MDUzLDAgMi42NjI2MywxLjE5MjEgMi42NjI2MywyLjY2MjYzYzAsMS40NzA1MyAtMS4xOTIxLDIuNjYyNjMgLTIuNjYyNjMsMi42NjI2M2MtMS40NzA1MywwIC0yLjY2MjYzLC0xLjE5MjEgLTIuNjYyNjMsLTIuNjYyNjN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxwYXRoIGQ9Ik0yMzcuMTE2MywxODAuMTEzMzVjMCwtMS40NzA1MyAxLjE5MjEsLTIuNjYyNjMgMi42NjI2MywtMi42NjI2M2MxLjQ3MDUzLDAgMi42NjI2MywxLjE5MjEgMi42NjI2MywyLjY2MjYzYzAsMS40NzA1MyAtMS4xOTIxLDIuNjYyNjMgLTIuNjYyNjMsMi42NjI2M2MtMS40NzA1MywwIC0yLjY2MjYzLC0xLjE5MjEgLTIuNjYyNjMsLTIuNjYyNjN6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆弧"></div>
                        <span class="geo-btn-text">圆弧</span>
                    </div>
                </div>
                 <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="ellipse">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yNTEuNTIxMDksMTgwLjU3NTdjMCw0LjY5MTMxIC01LjE1ODE2LDguNDk0MzYgLTExLjUyMTA4LDguNDk0MzZjLTYuMzYyOTIsMCAtMTEuNTIxMDgsLTMuODAzMDYgLTExLjUyMTA4LC04LjQ5NDM2YzAsLTQuNjkxMyA1LjE1ODE2LC04LjQ5NDM2IDExLjUyMTA5LC04LjQ5NDM2YzYuMzYyOTIsMCAxMS41MjEwOSwzLjgwMzA2IDExLjUyMTA5LDguNDk0MzZ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMy42OTc0OCwxODAuNTMwNDhjMCwtMS4wMDM5NSAwLjgyNjc4LC0xLjgzMDczIDEuODMwNzMsLTEuODMwNzNjMS4wMDM5NSwwIDEuODMwNzMsMC44MjY3OCAxLjgzMDczLDEuODMwNzNjMCwxLjAwMzk1IC0wLjgyNjc3LDEuODMwNzMgLTEuODMwNzMsMS44MzA3M2MtMS4wMDM5NSwwIC0xLjgzMDczLC0wLjgyNjc3IC0xLjgzMDczLC0xLjgzMDczeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQyLjYwMjk0LDE4MC42NDg2NmMwLC0xLjAwMzk1IDAuODI2NzgsLTEuODMwNzMgMS44MzA3MywtMS44MzA3M2MxLjAwMzk1LDAgMS44MzA3MywwLjgyNjc4IDEuODMwNzMsMS44MzA3M2MwLDEuMDAzOTUgLTAuODI2NzcsMS44MzA3MyAtMS44MzA3MywxLjgzMDczYy0xLjAwMzk1LDAgLTEuODMwNzMsLTAuODI2NzcgLTEuODMwNzMsLTEuODMwNzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDQuMDg4MDMsMTczLjM0NjQ5YzAsLTEuMzI1MjEgMS4wOTEzNCwtMi40MTY1NSAyLjQxNjU0LC0yLjQxNjU1YzEuMzI1MjEsMCAyLjQxNjU1LDEuMDkxMzQgMi40MTY1NSwyLjQxNjU1YzAsMS4zMjUyMSAtMS4wOTEzNCwyLjQxNjU0IC0yLjQxNjU1LDIuNDE2NTRjLTEuMzI1MjEsMCAtMi40MTY1NCwtMS4wOTEzMyAtMi40MTY1NCwtMi40MTY1NHoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="椭圆"></div>
                        <span class="geo-btn-text">椭圆</span>
                    </div>
                    <div class="geo-btn" data-geo-type="hyperbola">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzEuODE1MTEsMTcyLjMwMTM0YzMuMjUyNTEsMS4wOTA0NCA1LjYyMTc0LDQuMTc5MTEgNS42MjE3NCw3Ljc4MDA1YzAsMy43Mjk2NSAtMi41NDE2Miw2LjkwOTc1IC01Ljk3MzgyLDcuODg5MjUiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjQ4Ljc2NTA5LDE4Ny42MjMyOGMtMy4xNzI3MywtMS4xMTI0OSAtNS40NjcxNywtNC4xMTQ3NiAtNS40NjcxNywtNy43MzcxNmMwLC0zLjY4OTM4IDIuNDg3MDUsLTYuODQxMDMgNS44NjI5OCwtNy44NTY3NiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMjkuNzEzNDYsMTgwLjM0NTMzYzAsLTEuMDAzOTUgMC44MjY3OCwtMS44MzA3MyAxLjgzMDczLC0xLjgzMDczYzEuMDAzOTUsMCAxLjgzMDczLDAuODI2NzggMS44MzA3MywxLjgzMDczYzAsMS4wMDM5NSAtMC44MjY3OCwxLjgzMDczIC0xLjgzMDczLDEuODMwNzNjLTEuMDAzOTUsMCAtMS44MzA3MywtMC44MjY3OCAtMS44MzA3MywtMS44MzA3M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTI0Ni42MjUwOSwxODAuMjY4MjRjMCwtMS4wMDM5NSAwLjgyNjc4LC0xLjgzMDczIDEuODMwNzMsLTEuODMwNzNjMS4wMDM5NSwwIDEuODMwNzMsMC44MjY3OCAxLjgzMDczLDEuODMwNzNjMCwxLjAwMzk1IC0wLjgyNjc4LDEuODMwNzMgLTEuODMwNzMsMS44MzA3M2MtMS4wMDM5NSwwIC0xLjgzMDczLC0wLjgyNjc4IC0xLjgzMDczLC0xLjgzMDczeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQzLjYxODkxLDE3NC4zMzI5N2MwLC0xLjExMTAzIDAuOTE0OTcsLTIuMDI2IDIuMDI2LC0yLjAyNmMxLjExMTAzLDAgMi4wMjYsMC45MTQ5NyAyLjAyNiwyLjAyNmMwLDEuMTExMDMgLTAuOTE0OTcsMi4wMjYgLTIuMDI2LDIuMDI2Yy0xLjExMTAzLDAgLTIuMDI2LC0wLjkxNDk3IC0yLjAyNiwtMi4wMjZ6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="双曲线"></div>
                        <span class="geo-btn-text">双曲线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="parabola">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ2LjI2OCwxODguMTk4NTFjLTQuMzk4MDEsLTAuMTE3MjcgLTcuOTc1NzMsLTMuNjczNjYgLTcuOTc1NzMsLTguMTk3MDFjMCwtNC41IDMuNywtOC4yIDguMiwtOC4yYzAuMDU1NTUsMCAwLjExMDk4LDAuMDAwNTcgMC4xNjYyOCwwLjAwMTY5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzMuMzQxNDYsMTcyLjExNDYxdjE2LjAxMjM2IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQxLjYzNDgzLDE4MC4xOTkxM2MwLC0xLjAwMzk1IDAuODI2NzgsLTEuODMwNzMgMS44MzA3MywtMS44MzA3M2MxLjAwMzk1LDAgMS44MzA3MywwLjgyNjc4IDEuODMwNzMsMS44MzA3M2MwLDEuMDAzOTUgLTAuODI2NzgsMS44MzA3MyAtMS44MzA3MywxLjgzMDczYy0xLjAwMzk1LDAgLTEuODMwNzMsLTAuODI2NzggLTEuODMwNzMsLTEuODMwNzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="抛物线"></div>
                        <span class="geo-btn-text">抛物线</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>度量</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="length">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjM2LjAwMDAxLDE4My44bDguNiwtOSIgc3Ryb2tlPSIjNzk3OTc5Ii8+PHBhdGggZD0iTTI0Mi4zLDE3Mi42bDUsNC43IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjM3LjcsMTg3LjRsLTUsLTQuNyIgc3Ryb2tlPSIjMDAwMDAwIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="长度"></div>
                        <span class="geo-btn-text">长度</span>
                    </div>
                    <div class="geo-btn" data-geo-type="angle">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ5LjAwMDYxLDE4My40NjE3N2wtMTQuMDk4ODYsMC4yNTE3N2wxMC44MjU5MSwtMTEuMzI5NDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzAuOTk5MzksMTgzLjcxMzU0YzAsLTIuMTQwMDEgMS43NjIzNiwtMy45MDIzNiAzLjkwMjM2LC0zLjkwMjM2YzIuMTQwMDEsMCAzLjkwMjM2LDEuNzYyMzYgMy45MDIzNiwzLjkwMjM2YzAsMi4xNDAwMSAtMS43NjIzNiwzLjkwMjM2IC0zLjkwMjM2LDMuOTAyMzZjLTIuMTQwMDEsMCAtMy45MDIzNiwtMS43NjIzNiAtMy45MDIzNiwtMy45MDIzNnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="角度"></div>
                        <span class="geo-btn-text">角度</span>
                    </div>
                    <div class="geo-btn" data-geo-type="area">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTIzMi43MDU5NywxODYuMzc2NDdoMTQuNDUzMzQiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0Ny4yOTQwMywxNzMuNjIzNTN2MTIuNzUyOTUiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMi43NjE4NCwxODYuNDAwODdsMTMuNjM4NjIsLTEyLjgwMTc0IiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMzcuNzcyNDMsMTgzLjA1ODExbDEuOTc4NzgsMi41MTg0NCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTI0MC42NTA2NSwxODAuMzU5NzhsMy4yMzgsNS4yMTY3NyIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTI0My4xNjkwOSwxNzYuNzYybDMuMjM3OTksNS4wMzY4OSIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="面积"></div>
                        <span class="geo-btn-text">面积</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>判定</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="isparallel">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzYuMjQ1NTMsMTkwLjA0NDNsMTMuNTkyMTgsLTE0LjE2MjQ4IiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMC4xNjIyOSwxODMuOTYxMDlsMTMuNTkyMTgsLTE0LjE2MjQ4IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0OS44Mzc3MSwxNzYuMDM4OTFsLTEzLjU5MjE4LDE0LjE2MjQ4IiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0My43NTQ1MSwxNjkuOTU1N2wtMTMuNTkyMTgsMTQuMTYyNDgiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjM2LjM5Mjc4LDE3My44OTMyN2gzLjExNjQ2IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0yMzkuNzA0MDIsMTc0LjQ3NzZ2Mi45MjE2OSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="平行"></div>
                        <span class="geo-btn-text">平行</span>
                    </div>
                    <div class="geo-btn" data-geo-type="isperpendicular">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIj48cGF0aCBkPSJNMjM4Ljg3NDIzLDE4MS4xOTMzbDEuODc4NzQsLTIuNDkyMzciLz48cGF0aCBkPSJNMjQxLjMzNzcxLDE3OC44OTc0MWwyLjMzNjYsMS43NjEzMiIvPjwvZz48cGF0aCBkPSJNMjQ1LjcyNTAyLDE4Ny41MTQ0bC0xNS44NzA3NywtMTEuNjAxODMiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjUwLjE0NTc1LDE3MS45MjIxN2wtMTEuMjAxNzMsMTYuMTU1NjYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="垂直"></div>
                        <span class="geo-btn-text">垂直</span>
                    </div>
                    <div class="geo-btn" data-geo-type="isconcyclic">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzIuMjg2NzMsMTc5LjY3ODg0YzAsLTQuNSAzLjcsLTguMiA4LjIsLTguMmM0LjUsMCA4LjIsMy43IDguMiw4LjJjMCw0LjUgLTMuNyw4LjIgLTguMiw4LjJjLTQuNSwwIC04LjIsLTMuNiAtOC4yLC04LjJ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0My45MzY2LDE3My43Mzk2NWMwLC0xLjExNjMyIDAuOTE5MzMsLTIuMDM1NjUgMi4wMzU2NiwtMi4wMzU2NWMxLjExNjMyLDAgMi4wMzU2NSwwLjkxOTMzIDIuMDM1NjUsMi4wMzU2NWMwLDEuMTE2MzIgLTAuOTE5MzMsMi4wMzU2NSAtMi4wMzU2NSwyLjAzNTY1Yy0xLjExNjMyLDAgLTIuMDM1NjYsLTAuOTE5MzMgLTIuMDM1NjYsLTIuMDM1NjV6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yMzEuMzEzMjcsMTc1Ljg3MDc0YzAsLTEuMTE2MzIgMC45MTkzMywtMi4wMzU2NSAyLjAzNTY2LC0yLjAzNTY1YzEuMTE2MzIsMCAyLjAzNTY1LDAuOTE5MzMgMi4wMzU2NSwyLjAzNTY1YzAsMS4xMTYzMiAtMC45MTkzMiwyLjAzNTY1IC0yLjAzNTY1LDIuMDM1NjVjLTEuMTE2MzIsMCAtMi4wMzU2NiwtMC45MTkzMyAtMi4wMzU2NiwtMi4wMzU2NXoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTIzMy42NDkyOCwxODYuMTk4NzJjMCwtMS4xMTYzMiAwLjkxOTMzLC0yLjAzNTY1IDIuMDM1NjUsLTIuMDM1NjVjMS4xMTYzMiwwIDIuMDM1NjUsMC45MTkzMiAyLjAzNTY1LDIuMDM1NjVjMCwxLjExNjMyIC0wLjkxOTMzLDIuMDM1NjUgLTIuMDM1NjUsMi4wMzU2NWMtMS4xMTYzMiwwIC0yLjAzNTY1LC0wLjkxOTMzIC0yLjAzNTY1LC0yLjAzNTY1eiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQzLjE1NzU3LDE4Ni40ODU1MWMwLC0xLjExNjMyIDAuOTE5MzMsLTIuMDM1NjUgMi4wMzU2NSwtMi4wMzU2NWMxLjExNjMyLDAgMi4wMzU2NSwwLjkxOTMzIDIuMDM1NjUsMi4wMzU2NWMwLDEuMTE2MzIgLTAuOTE5MzMsMi4wMzU2NSAtMi4wMzU2NSwyLjAzNTY1Yy0xLjExNjMyLDAgLTIuMDM1NjUsLTAuOTE5MzMgLTIuMDM1NjUsLTIuMDM1NjV6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="共圆"></div>
                        <span class="geo-btn-text">共圆</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>变换</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="rotate">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM2LjE1OTc1LDE4MS4yNTk0MmMxLjc0MDczLDEuMzgxMDcgMi44ODg0OSwzLjQ4MzQxIDIuOTc0NDcsNS44MzgyIiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzQuNTAzMjgsMTg3LjUyNzMxbDEzLjQ3ODAyLC0wLjE5NTMzIiBmaWxsPSJub25lIiBzdHJva2U9IiNhZmFmYWYiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjU4MTk2LDE3NC4wNDkyOGwtNi40NDYwMSwxMC45Mzg2OSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjYWZhZmFmIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC41MjYzOCwxODYuOTUzOThjMCwtMS42MjA0NSAxLjMzNDQ5LC0yLjk1NDk0IDIuOTU0OTQsLTIuOTU0OTRjMS42MjA0NSwwIDIuOTU0OTQsMS4zMzQ0OSAyLjk1NDk0LDIuOTU0OTRjMCwxLjYyMDQ1IC0xLjMzNDQ5LDIuOTU0OTQgLTIuOTU0OTQsMi45NTQ5NGMtMS42MjA0NSwwIC0yLjk1NDk0LC0xLjMzNDQ5IC0yLjk1NDk0LC0yLjk1NDk0eiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNi45ODY0LDE3Mi45Njc5OWMwLC0xLjYyMDQ1IDEuMzM0NDksLTIuOTU0OTQgMi45NTQ5NCwtMi45NTQ5NGMxLjYyMDQ1LDAgMi45NTQ5NCwxLjMzNDQ5IDIuOTU0OTQsMi45NTQ5NGMwLDEuNjIwNDUgLTEuMzM0NDksMi45NTQ5NCAtMi45NTQ5NCwyLjk1NDk0Yy0xLjYyMDQ1LDAgLTIuOTU0OTQsLTEuMzM0NDkgLTIuOTU0OTQsLTIuOTU0OTR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI5LjU2MzczLDE4Ny4wMzIwMWMwLC0xLjYyMDQ1IDEuMzM0NDksLTIuOTU0OTQgMi45NTQ5NCwtMi45NTQ5NGMxLjYyMDQ1LDAgMi45NTQ5NCwxLjMzNDQ5IDIuOTU0OTQsMi45NTQ5NGMwLDEuNjIwNDUgLTEuMzM0NDksMi45NTQ5NCAtMi45NTQ5NCwyLjk1NDk0Yy0xLjYyMDQ1LDAgLTIuOTU0OTQsLTEuMzM0NDkgLTIuOTU0OTQsLTIuOTU0OTR6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="旋转"></div>
                        <span class="geo-btn-text">旋转</span>
                    </div>
                    <div class="geo-btn" data-geo-type="reflect">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ1LjUyMzg5LDE4MC4wNTkwOGMwLC0xLjY1NTk4IDEuMzYzNzUsLTMuMDE5NzMgMy4wMTk3MywtMy4wMTk3M2MxLjY1NTk4LDAgMy4wMTk3MywxLjM2Mzc1IDMuMDE5NzMsMy4wMTk3M2MwLDEuNjU1OTggLTEuMzYzNzUsMy4wMTk3MyAtMy4wMTk3MywzLjAxOTczYy0xLjY1NTk4LDAgLTMuMDE5NzMsLTEuMzYzNzUgLTMuMDE5NzMsLTMuMDE5NzN6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI4LjQzNjY1LDE4MC4xMzg4MmMwLC0xLjY1NTk4IDEuMzYzNzUsLTMuMDE5NzMgMy4wMTk3MywtMy4wMTk3M2MxLjY1NTk4LDAgMy4wMTk3MywxLjM2Mzc1IDMuMDE5NzMsMy4wMTk3M2MwLDEuNjU1OTggLTEuMzYzNzUsMy4wMTk3MyAtMy4wMTk3MywzLjAxOTczYy0xLjY1NTk4LDAgLTMuMDE5NzMsLTEuMzYzNzUgLTMuMDE5NzMsLTMuMDE5NzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5Ljg3MjMzLDE3MS40MTY1MXYxNy4xNjY5OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="对称"></div>
                        <span class="geo-btn-text">对称</span>
                    </div>
                    <div class="geo-btn" data-geo-type="translate">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzQuMTM2MDYsMTg1LjYxNTM1bDExLjMyMTc2LC0xMS4xMTIxIi8+PHBhdGggZD0iTTI0MS44OTM1NiwxNzQuMjkzNTloMy43NzM5MiIvPjxwYXRoIGQ9Ik0yNDUuNjY3NDgsMTc0LjUwMzI1djQuMTkzMjQiLz48L2c+PHBhdGggZD0iTTI0NC4wNjA0MiwxNzMuODc3OTJjMCwtMS4zNzIxIDEuMTI5OTcsLTIuNTAyMDYgMi41MDIwNiwtMi41MDIwNmMxLjM3MjEsMCAyLjUwMjA2LDEuMTI5OTcgMi41MDIwNiwyLjUwMjA2YzAsMS4zNzIxIC0xLjEyOTk3LDIuNTAyMDYgLTIuNTAyMDYsMi41MDIwNmMtMS4zNzIxLDAgLTIuNTAyMDYsLTEuMTI5OTcgLTIuNTAyMDYsLTIuNTAyMDZ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjkzNTQ1LDE4Ni4xMjIwOGMwLC0xLjM3MjEgMS4xMjk5NywtMi41MDIwNiAyLjUwMjA2LC0yLjUwMjA2YzEuMzcyMSwwIDIuNTAyMDYsMS4xMjk5NyAyLjUwMjA2LDIuNTAyMDZjMCwxLjM3MjEgLTEuMTI5OTcsMi41MDIwNiAtMi41MDIwNiwyLjUwMjA2Yy0xLjM3MjEsMCAtMi41MDIwNiwtMS4xMjk5NyAtMi41MDIwNiwtMi41MDIwNnoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="平移"></div>
                        <span class="geo-btn-text">平移</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>其他</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="polygon">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ3LjU5Mzg4LDE3OS44NDczMWwtMy44OTM1Miw3LjM3NzIxbC0xMC4wNDEyLC0xLjIyOTUzbC0xLjIyOTUzLC05LjAxNjU4bDkuMDE2NTgsLTQuNzEzMjJsNS4zMjc5OCw1LjMyNzk5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM4Ljk4OTIyLDE3Mi4yMzM1NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ1LjIxODc2LDE3OC40NjMwOGMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQwLjk5NzI1LDE4Ny43NjY0NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMxLjI0Mjg0LDE4NS43OTkwOWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI5Ljg5MDI1LDE3Ni42NTk0NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="多边形"></div>
                        <span class="geo-btn-text">多边形</span>
                    </div>
                    <div class="geo-btn" data-geo-type="fitline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQwLjgzNTYyLDE3My44ODQyNmMwLC0wLjgzOTE2IDAuNjkxMDcsLTEuNTMwMjQgMS41MzAyNCwtMS41MzAyNGMwLjgzOTE2LDAgMS41MzAyNCwwLjY5MTA4IDEuNTMwMjQsMS41MzAyNGMwLDAuODM5MTYgLTAuNjkxMDgsMS41MzAyNCAtMS41MzAyNCwxLjUzMDI0Yy0wLjgzOTE2LDAgLTEuNTMwMjQsLTAuNjkxMDcgLTEuNTMwMjQsLTEuNTMwMjR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMzLjMwNDYyLDE4Ni40ODE4NWwxNS4yMjc4NCwtMTIuMTM4MTMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuMDIwODEsMTc3Ljk2MTQyYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzEuNDY3NTQsMTgxLjkwNzgyYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzcuODk4NDUsMTg2LjExNTc1YzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDMuODA2MzEsMTgxLjQzMTcxYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="拟合直线"></div>
                        <span class="geo-btn-text">拟合直线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="annotation">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI2MC4xNDc5MiIgaGVpZ2h0PSI2MC4xNDc5MiIgdmlld0JveD0iMCwwLDYwLjE0NzkyLDYwLjE0NzkyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjA5LjkyNjA0LC0xNDkuOTI2MDQpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMDkuOTI2MDQsMjEwLjA3Mzk2di02MC4xNDc5Mmg2MC4xNDc5MnY2MC4xNDc5MnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0My4wOTI5NywxNjQuNzMyMjljMC42NzI2NiwtMC4wODE4NiAxLjM1OTU3LC0wLjA0NjcxIDEuOTc2NTEsMC4xNDUzMmMwLjYxNjk3LDAuMTkyMDMgMS4yMTUzMywwLjQ3NTM4IDEuNzEwOTYsMC44ODk5NWMwLjQ5NTYzLDAuNDE0NTYgMC45MzYzNCwwLjg2NTUxIDEuMjc0MjgsMS40NDc2M2MwLjMzNzk3LDAuNTgyMTQgMC41MzMyMywxLjIxMTI5IDAuNjE1MDcsMS44ODM5NWMwLjA4MTg1LDAuNjcyNjYgMC4wNDMxNiwxLjMzMDMxIC0wLjE0ODksMS45NDcyOGMtMC4xOTIwNiwwLjYxNjk1IC0wLjQ3NTM4LDEuMjE1MzMgLTAuOTE1NjMsMS43NDM3NWwtMTMuMjQ3NjQsMTYuOTg1OTJjLTAuMzg1MzIsMC40OTIwOSAtMC44NDY5LDAuODQ1MDEgLTEuNDQzMjcsMS4wNjYwMWwtNi41NTMwNSwyLjQ4OTE0Yy0wLjA1ODUxLDAuMDA3MSAtMC4wODQxNywwLjAzOTk0IC0wLjExMzQzLDAuMDQzNDljLTAuMDI5MjUsMC4wMDM1NSAtMC4wODc3NSwwLjAxMDY5IC0wLjE0NjIyLDAuMDE3NzljLTAuMjkyNDUsMC4wMzU2IC0wLjU2OTk0LC0wLjA0OTM5IC0wLjc5OTU1LC0wLjIyOTE4Yy0wLjIyOTY1LC0wLjE3OTggLTAuMzc4NjQsLTAuNDI4ODEgLTAuNDE0MjMsLTAuNzIxMjZjLTAuMDA3MTQsLTAuMDU4NDcgLTAuMDE0MjQsLTAuMTE2OTggLTAuMDE3NzksLTAuMTQ2MjNjLTAuMDAzNTUsLTAuMDI5MjUgLTAuMDEwNjgsLTAuMDg3NzUgMC4wMTUwMywtMC4xMjA1M2wwLjkwNzAxLC02LjkzNjYzYzAuMDI2NDYsLTAuMjcwMzMgMC4xMDc4NiwtMC41NzcwMyAwLjIyMjA0LC0wLjg1ODAxYzAuMTE0MjIsLTAuMjgxMDEgMC4yNjEyMywtMC41MzYzMiAwLjQ0MTAzLC0wLjc2NTk2bDEzLjI0NzYzLC0xNi45ODU5MWMwLjQxMTAxLC0wLjUyNDg4IDAuODk0NzEsLTAuOTM5OSAxLjQ3Njg2LC0xLjI3Nzg3YzAuNTgyMTQsLTAuMzM3OTcgMS4yNjk4NCwtMC41NDAzMyAxLjkxMzI3LC0wLjYxODY2ek0yNDMuMzU5ODUsMTY2LjkyNTdjLTAuMzUwOTQsMC4wNDI3IC0wLjcyNDA1LDAuMTQ3NDggLTEuMDI3OTQsMC4zMzI4NWMtMC4zMDM5MiwwLjE4NTM3IC0wLjYwMDY5LDAuNDI5MjQgLTAuODMxOTEsMC43MjQ0OWwtMTMuMjQ0MDgsMTcuMDE1MTZjLTAuMTI4NDIsMC4xNjQwNCAtMC4xOTQ4MywwLjM1MDE1IC0wLjIzMTk0LDAuNTMyNzZsLTAuNjU2MTYsNS4wOTU2Nmw0Ljg1MTYzLC0xLjgzNjg5YzAuMTk3NiwtMC4wODMzOCAwLjMzMzE3LC0wLjE4ODk1IDAuNDkwODQsLTAuMzU2NTVsMTMuMjUxMTUsLTE2Ljk1NjY1YzAuMjMxMTgsLTAuMjk1MjMgMC40MDAzMiwtMC42MTI2MiAwLjUwMzg0LC0wLjk4MTM1YzAuMTAzNTIsLTAuMzY4NzMgMC4xMTkzLC0wLjcyNjg1IDAuMDc2NiwtMS4wNzc3N2MtMC4wNDYyOCwtMC4zODAyIC0wLjE0NzQ0LC0wLjcyNDAzIC0wLjMzNjQsLTEuMDU3MjJjLTAuMTg4OTUsLTAuMzMzMTcgLTAuNDI5MjQsLTAuNjAwNjkgLTAuNjkxNjgsLTAuODA2MjFjLTAuMjYyNDQsLTAuMjA1NTIgLTAuNjA5MDgsLTAuMzcxMDcgLTAuOTUyMTYsLTAuNTA3MzljLTAuMzQzMDUsLTAuMTM2MzIgLTAuODIxNjYsLTAuMTY3MTIgLTEuMjAxODcsLTAuMTIwODd6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQzLjMxNDQxLDE4NC44MDA3OWg3LjAwNTU0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni44MTcxOCwxODYuMzcwOTlsLTIuNDE1Nyw4LjY5NjUzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI1NS4xMzM1OSwxODkuNjg1NTFsLTQuOTUyMTksLTAuMTIwNzkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjUzLjMzOTU4LDE4Ni44NTQxM2wtMi4yOTQ5Miw4LjIxMzM5IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI1MS4xNjU0NSwxOTUuMzA5MWgzLjAxOTYzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MzAuMDczOTYxOTI2NjA3NjE6MzAuMDczOTYxOTI2NjA3NzIzLS0+" alt="批注"></div>
                        <span class="geo-btn-text">批注</span>
                    </div>
                </div>

                <div class="geo-btn-row">
<div class="geo-btn" data-geo-type="checkbox"> <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC43Njk0NSIgaGVpZ2h0PSIyMS4wODE3OCIgdmlld0JveD0iMCwwLDIwLjc2OTQ1LDIxLjA4MTc4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjYxNTI3LC0xNjkuNDU5MTEpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjkuNjE1MjcsMTkwLjU0MDg5di0yMS4wODE3OGgyMC43Njk0NXYyMS4wODE3OHoiIGZpbGwtb3BhY2l0eT0iMC4wMzEzNyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yNDcuNDIwNTgsMTgyLjc1NTQ0Yy0wLjE0OTcxLDEuOTg1MDUgLTEuODAwMzMsMy41Mjg4OCAtMy43ODE5NSwzLjQ4ODRjLTAuMDE2MjYsLTAuMDAwMzMgLTAuMDMyNDksLTAuMDAwNzcgLTAuMDQ4NzMsLTAuMDAxM2wtNy4yNzY0MiwwLjAwMTJjLTAuMDI1MTQsMC4wMDAxIC0wLjA1MDMxLC0wLjAwMDA1IC0wLjA3NTU1LC0wLjAwMDQ3Yy0yLjA1MzMyLC0wLjAzMzYzIC0zLjY5MTA2LC0xLjc1MzgzIC0zLjY1ODAyLC0zLjg0MjJjMC4wMDAyOCwtMC4wMTY1MyAwLjAwMDYzLC0wLjAzMzA1IDAuMDAxMSwtMC4wNDk1NmwwLjAwMDksLTAuMTIxNDdsMC4wNDcwNiwtNC4xNTYwNWwwLjAwNDI4LC0wLjU4MDU3YzAuMDAwMywtMC4wMjU1NSAwLjAwMDg1LC0wLjA1MTE2IDAuMDAxNjcsLTAuMDc2ODJjMC4wNjU1LC0yLjA4NzU4IDEuNzgyNTQsLTMuNzI1ODkgMy44MzUwOSwtMy42NTkyNGMwLjAxNjI2LDAuMDAwNTMgMC4wMzI0OSwwLjAwMTE3IDAuMDQ4NzIsMC4wMDE5bDcuMTA1MTUsLTAuMDAyNjJjMC4wMjUxNCwtMC4wMDA0MSAwLjA1MDMxLC0wLjAwMDU0IDAuMDc1NTUsLTAuMDAwNDZjMi4wNTM1NSwwLjAwODkzIDMuNzExMiwxLjcwOTMgMy43MDI0NiwzLjc5NzkxYy0wLjAwMDA2LDAuMDE2NTUgLTAuMDAwMjMsMC4wMzMwNiAtMC4wMDA1MywwLjA0OTU4bDAuMDAwMzMsMC4wNzYyNXoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzkyOTI5MiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48cGF0aCBkPSJNMjM3LjgzNzY2LDE4Mi4xODU2MWMtMC4wMTg4NCwwLjAwMDQzIC0wLjAzNzczLDAuMDAwNjUgLTAuMDU2NjgsMC4wMDA2NWMtMS4zNDIyNSwwIC0yLjQzMDM1LC0xLjA4ODExIC0yLjQzMDM1LC0yLjQzMDM2YzAsLTEuMzQyMjUgMS4wODgxLC0yLjQzMDM2IDIuNDMwMzUsLTIuNDMwMzZjMC4wMTg5NSwwIDAuMDM3ODQsMC4wMDAyMiAwLjA1NjY4LDAuMDAwNjVsNC4zNjEwNywwLjAwNzgyYzAuMDE4ODUsLTAuMDAwMDQgMC4wMzc3NCwwLjAwMDE1IDAuMDU2NjgsMC4wMDA1NWMxLjM0MTk1LDAuMDI4NDQgMi40MDY3NiwxLjEzOTM0IDIuMzc4MzIsMi40ODEyOWMtMC4wMjg0NCwxLjM0MTk1IC0xLjEzOTM0LDIuNDA2NzcgLTIuNDgxMjksMi4zNzgzM2MtMC4wMTg5NCwtMC4wMDA0IC0wLjAzNzgzLC0wLjAwMTAyIC0wLjA1NjY1LC0wLjAwMTg1eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjOTI5MjkyIiBzdHJva2Utd2lkdGg9IjEuMiIvPjxwYXRoIGQ9Ik0yNDAuNjYyNTYsMTc5Ljc1MjZjMCwtMC43MzQ0OSAwLjU5NTQyLC0xLjMyOTkxIDEuMzI5OTEsLTEuMzI5OTFjMC43MzQ0OSwwIDEuMzI5OTEsMC41OTU0MiAxLjMyOTkxLDEuMzI5OTFjMCwwLjczNDQ5IC0wLjU5NTQyLDEuMzI5OTEgLTEuMzI5OTEsMS4zMjk5MWMtMC43MzQ0OSwwIC0xLjMyOTkxLC0wLjU5NTQyIC0xLjMyOTkxLC0xLjMyOTkxeiIgZmlsbD0iIzkyOTI5MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxMC4zODQ3MjczMDg1MzgwMDQ6MTAuNTQwODg4NjIxNDQ4Mzc0LS0+" style="filter: var(--icon-filter);"></div> <span class="geo-btn-text">复选框</span> </div>

  </div>
            </div>
        `;
    }
    


updateGeometryButtonColors() {
        const buttons = this.geometryPanel.querySelectorAll('.geo-btn');
        const isDark = document.documentElement.hasAttribute('data-theme');
        const hue = this.preferredColorValue;
        
        buttons.forEach(button => {

            const textColor = isDark ? '#e0e0e0' : '#222';
            button.style.color = textColor;
        });
    }



    
cancelGeometryInteraction() {
    this.geometryInteractionState.active = false;
    this.geometryInteractionState.type = null;
    this.updateGeometryInteractionUI();
    const activeButton = this.geometryPanel.querySelector('.geo-btn.active');
    if (activeButton) activeButton.classList.remove('active');
    if (this.highlightedObject) {
        this.highlightedObject = null;
        this.requestDraw();
    }
    this.hideInfoMessage();
}

showInfoMessage(text, duration = null) {
    if (!this.infoDisplay) return;
    clearTimeout(this.infoDisplayTimeout);
    this.infoDisplay.textContent = text;
    this.infoDisplay.classList.add('show');
    if (duration) {
        this.infoDisplayTimeout = setTimeout(() => {
            this.hideInfoMessage();
        }, duration);
    }
}

hideInfoMessage() {
    if (!this.infoDisplay) return;
    clearTimeout(this.infoDisplayTimeout);
    this.infoDisplay.classList.remove('show');
}

    updateGeometryInteractionUI() {
        let promptElement = document.getElementById('geometry-interaction-prompt');

        if (!promptElement) {
            promptElement = document.createElement('div');
            promptElement.id = 'geometry-interaction-prompt';
            document.body.appendChild(promptElement);
        }

        if (this.geometryInteractionState.active) {
            promptElement.textContent = this.geometryInteractionState.prompt;
            setTimeout(() => promptElement.classList.add('show'), 10);
        } else {
            if (promptElement) {
                promptElement.classList.remove('show');
            }
        }
    }

    autonamePoint() {
        const existingNames = new Set(this.entries.map(e => e.name).filter(Boolean).map(n => n.toUpperCase()));
        for (let i = 0; i < 26; i++) {
            const name = String.fromCharCode(65 + i);
            if (!existingNames.has(name)) return name;
        }
        for (let j = 1; j < 100; j++) {
             for (let i = 0; i < 26; i++) {
                const name = String.fromCharCode(65 + i) + j;
                if (!existingNames.has(name)) return name;
            }
        }
        return 'P' + Date.now();
    }

    autonameMidpoint() {
        return this.autonameByPrefix('m');
    }

    autonameByPrefix(prefix) {
        const existingNames = new Set(this.entries.map(e => e.name).filter(Boolean).map(n => n.toLowerCase()));
        for (let i = 1; i < 1000; i++) {
            const name = prefix + i;
            if (!existingNames.has(name.toLowerCase())) {
                return name;
            }
        }
        return prefix + Date.now();
    }
    findObjectNearClick(coords, maxDist = 10) {
        let closestPoint = { object: null, dist: maxDist };
        let closestOther = { object: null, dist: maxDist };
        const mathX = (coords.x - this.offset.x) / this.scale;
        const mathY = (this.offset.y - coords.y) / this.scale;

this.entries.forEach(entry => {
        if (!entry.isMeaningful || !entry.visible || entry.type !== 'geometry') return;

        let dist = Infinity;
       const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

        if (['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(entry.geometryType)) {
            const screenX = this.offset.x + entry.x_val * this.scale;
            const screenY = this.offset.y - entry.y_val * this.scale;
            dist = Math.hypot(coords.x - screenX, coords.y - screenY);
            if (dist < closestPoint.dist) {
                closestPoint = { object: entry, dist };
            }
        } else if (lineLike.includes(entry.geometryType)) {                const { p1, p2 } = entry;
                if (!p1 || !p2) return;
                const { x_val: x1, y_val: y1 } = p1;
                const { x_val: x2, y_val: y2 } = p2;
                const dx = x2 - x1, dy = y2 - y1;
                const lenSq = dx*dx + dy*dy;
                let t = 0;
                if (lenSq > 1e-9) {
                    t = ((mathX - x1) * dx + (mathY - y1) * dy) / lenSq;
                }
                let onObject = true;
                if (entry.geometryType === 'segment' || entry.geometryType === 'vector') {
                    if (t < -1e-9 || t > 1 + 1e-9) onObject = false;
                } else if (entry.geometryType === 'ray') {
                    if (t < -1e-9) onObject = false;
                }
                if (onObject) {
                    const closestX = x1 + t * dx;
                    const closestY = y1 + t * dy;
                    dist = Math.hypot(mathX - closestX, mathY - closestY) * this.scale;
                }
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            } else if (entry.geometryType === 'circle') {
                const { center, radius } = entry;
                if (!center || !radius) return;
                const distToCenter = Math.hypot(mathX - center.x_val, mathY - center.y_val);
                dist = Math.abs(distToCenter - radius) * this.scale;
                if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
} else if (entry.geometryType === 'ellipse' || entry.geometryType === 'ellipse_ab') {
                const { center, a, b, rotation } = entry;
                if (!center || !a || !b) return;
                const relX = mathX - center.x;
                const relY = mathY - center.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = (localX / a)**2 + (localY / b)**2 - 1;
                const gradMag = 2 * Math.hypot(localX/(a*a), localY/(b*b));
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }            } else if (entry.geometryType === 'hyperbola') {
                const { center, a, b, rotation } = entry;
                if (!center || !a || !b) return;
                const relX = mathX - center.x;
                const relY = mathY - center.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = (localX / a)**2 - (localY / b)**2 - 1;
                const gradMag = 2 * Math.hypot(localX/(a*a), -localY/(b*b));
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            } else if (entry.geometryType === 'parabola') {
                const { vertex, p, rotation } = entry;
                if (!vertex || !p) return;
                const relX = mathX - vertex.x;
                const relY = mathY - vertex.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = localY**2 - 4 * p * localX;
                const gradMag = Math.hypot(-4*p, 2*localY);
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            }  else if (entry.geometryType === 'circulararc') {
                const { center, radius, startAngle, endAngle } = entry;
                if (!center || !radius) return;
                const distToCenter = Math.hypot(mathX - center.x_val, mathY - center.y_val);
                const dist = Math.abs(distToCenter - radius) * this.scale;
                
                if (dist < closestOther.dist) {
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    let sA = startAngle;
                    let eA = endAngle;
                    if (eA < sA) eA += 2 * Math.PI;
                    
                    let checkAngle = angle;
                    while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
                    while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;

                    if (checkAngle <= eA + 1e-9) {
                        closestOther = { object: entry, dist };
                    }
                  }
                }
        });
        
        if (closestPoint.object) {
            return closestPoint.object;
        }
        return closestOther.object;
    }
        updateCodeList() {
        const listContainer = document.getElementById('code-entry-list');
        if (!listContainer) return;

        const userDefinedFunctions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => !this.defaultAdvancedFunctionNames.has(def.name));

        listContainer.innerHTML = userDefinedFunctions.map((def, index) => {
            const originalIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(d => d.name === def.name);
            const truncatedParams = def.params.join(', ').length > 20 ? def.params.join(', ').substring(0, 17) + '...' : def.params.join(', ');
            
            return `
                <div class="entry-item advanced_custom_function_definition-item" data-index="${originalIndex}">
                    <div class="entry-main-row">
                        <div class="entry-text-area">
                            <div>${def.name}(${truncatedParams})</div>
                        </div>
                        <div class="entry-actions-new">
                            <span class="action-btn code-edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODIsMTc1LjgzNThjLTAuMTIwNTgsMC4wMTQ2NyAtMC4yNDg3NywwLjA1MDY3IC0wLjM1MzE4LDAuMTE0MzZjLTAuMTA0NDIsMC4wNjM2OSAtMC4yMDYzOSwwLjE0NzQ4IC0wLjI4NTgzLDAuMjQ4OTJsLTQuNTUwNDEsNS44NDYwOGMtMC4wNDQxMiwwLjA1NjM2IC0wLjA2Njk0LDAuMTIwMzEgLTAuMDc5NjksMC4xODMwNWwtMC4yMjU0NCwxLjc1MDc3bDEuNjY2OTMsLTAuNjMxMTJjMC4wNjc4OSwtMC4wMjg2NSAwLjExNDQ3LC0wLjA2NDkyIDAuMTY4NjQsLTAuMTIyNWw0LjU1Mjg0LC01LjgyNTk4YzAuMDc5NDMsLTAuMTAxNDQgMC4xMzc1NCwtMC4yMTA0OCAwLjE3MzExLC0wLjMzNzE3YzAuMDM1NTcsLTAuMTI2NjkgMC4wNDA5OSwtMC4yNDk3MyAwLjAyNjMyLC0wLjM3MDNjLTAuMDE1OSwtMC4xMzA2MyAtMC4wNTA2NiwtMC4yNDg3NiAtMC4xMTU1OCwtMC4zNjMyNGMtMC4wNjQ5MiwtMC4xMTQ0NyAtMC4xNDc0OCwtMC4yMDYzOSAtMC4yMzc2NSwtMC4yNzdjLTAuMDkwMTcsLTAuMDcwNjEgLTAuMjA5MjcsLTAuMTI3NDkgLTAuMzI3MTQsLTAuMTc0MzNjLTAuMTE3ODcsLTAuMDQ2ODQgLTAuMjgyMzEsLTAuMDU3NDIgLTAuNDEyOTQsLTAuMDQxNTN6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NC4zOTQ4Nzc5ODQ1NTI2MDg6NS4yMTU2MTA0MzU2MDg1OTYtLT4=" style="width:18px; height:18px;"></span>
                            <span class="action-btn code-download-btn" title="下载"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjEyODQ3IiBoZWlnaHQ9IjguOTk3OTciIHZpZXdCb3g9IjAsMCw3LjEyODQ3LDguOTk3OTciPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuNDM1NzYsLTE3NS41MDEwMSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjM1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTI0MC4wNTY2NSwxNzYuMTc2MDJ2NS4zODE5MSIvPjxwYXRoIGQ9Ik0yMzguMzU3MTEsMTc5Ljk3MTY4bDEuNTg2MjUsMi4xNTI3NiIvPjxwYXRoIGQ9Ik0yNDEuNjQyOTEsMTc5Ljk3MTY4bC0xLjU4NjI1LDIuMTUyNzYiLz48cGF0aCBkPSJNMjM3LjExMDc3LDE4My44MjM5OWg1Ljc3ODQ3Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjMuNTY0MjM0OTk5OTk5OTk2NTo0LjQ5ODk4NTAwMDAwMDAwNS0tPg==" style="width:18px; height:18px;"></span>
                            <span class="action-btn code-delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3NiwxNzYuODQxMDdoLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5OCwxODIuMjE0MjJ2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxMiwxNzYuMjA4NDVoMS43ODgyNGMtMC4wMzM3NCwtMC4wOTI3OCAtMC4wNzU5MiwtMC4xODU1NyAtMC4xMzQ5NiwtMC4yNjE0OWMtMC4wNTkwNCwtMC4wNzU5MSAtMC4xMjY1MiwtMC4xNDMzOSAtMC4yMTA4OCwtMC4yMDI0NGMtMC4wODQzNiwtMC4wNTkwNCAtMC4xNjg3LC0wLjEwMTIyIC0wLjI1MzA2LC0wLjEyNjUzYy0wLjA4NDM2LC0wLjAyNTMxIC0wLjE4NTU3LC0wLjA0MjE3IC0wLjI5NTIzLC0wLjA0MjE3Yy0wLjEwOTY1LDAgLTAuMjAyNDQsMC4wMTY4NyAtMC4yOTUyMywwLjA0MjE3Yy0wLjA5Mjc5LDAuMDI1MzEgLTAuMTc3MTMsMC4wNzU5MSAtMC4yNTMwNiwwLjEyNjUzYy0wLjA3NTkyLDAuMDUwNjEgLTAuMTUxODQsMC4xMjY1MiAtMC4yMTA4OCwwLjIwMjQ0Yy0wLjA1OTA0LDAuMDc1OTEgLTAuMTAxMjIsMC4xNjAyNyAtMC4xMzQ5NiwwLjI2MTQ5ek0yNDAuNjM2ODcsMTgyLjIxNDIydi0zLjE2MzE2YzAsLTAuMDg0MzUgMC4wMzM3NCwtMC4xNjAyNyAwLjA5Mjc5LC0wLjIxOTMxYzAuMDU5MDQsLTAuMDU5MDQgMC4xMzQ5NiwtMC4wOTI3OSAwLjIxOTMxLC0wLjA5Mjc5YzAuMDg0MzYsMCAwLjE2MDI3LDAuMDMzNzQgMC4yMTkzMSwwLjA5Mjc5YzAuMDU5MDQsMC4wNTkwNCAwLjA5Mjc5LDAuMTM0OTYgMC4wOTI3OSwwLjIxOTMxdjMuMTYzMTZjMCwwLjA4NDM1IC0wLjAzMzc1LDAuMTYwMjcgLTAuMDkyNzksMC4yMTkzMWMtMC4wNTkwNCwwLjA1OTA0IC0wLjEzNDk1LDAuMDkyNzkgLTAuMjE5MzEsMC4wOTI3OWMtMC4wODQzNiwwIC0wLjE2MDI3LC0wLjAzMzc1IC0wLjIxOTMxLC0wLjA5Mjc5Yy0wLjA1OTA0LC0wLjA1OTA0IC0wLjA5Mjc5LC0wLjEzNDk2IC0wLjA5Mjc5LC0wLjIxOTMxeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMDAzMTc5OTk5OTk5OTU4OjUuMzA2ODQwMDAwMDAwMDIyLS0+" style="width:18px; height:18px;"></span>
                        </div>
                    </div>
                </div>`;
        }).join('');
    }

    handleCodeListClick(e) {
        const item = e.target.closest('.entry-item');
        if (!item) return;
        const index = parseInt(item.dataset.index, 10);

        if (e.target.closest('.code-edit-btn')) {
            this.showCodeEditor(index);
        } else if (e.target.closest('.code-download-btn')) {
            this.downloadSingleOperator(index);
        } else if (e.target.closest('.code-delete-btn')) {
            this.deleteCustomOperator(index);
        }
    }

    showCodeEditor(index) {
        this.currentCodeEditIndex = index;
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        const nameInput = document.getElementById('code-editor-name');
        const paramsInput = document.getElementById('code-editor-params');
        const bodyTextarea = document.getElementById('code-editor-body');

        if (index === -1) {
            nameInput.value = '';
            paramsInput.value = '';
            bodyTextarea.value = 'return input;';
            document.getElementById('main-content-title').textContent = "新建";
        } else {
            const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
            nameInput.value = operator.name;
            paramsInput.value = operator.params.map(p => `'${p}'`).join(', ');
            bodyTextarea.value = operator.bodyJsString.trim();
            document.getElementById('main-content-title').textContent = "编辑";
        }

        listView.style.display = 'none';
        editorView.style.display = 'flex';
        document.getElementById('global-script-toggle-btn').style.display = 'none'; 
    }

    hideCodeEditor() {
        this.currentCodeEditIndex = -1;
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        listView.style.display = 'flex';
        editorView.style.display = 'none';
        document.getElementById('main-content-title').textContent = "代码";
        document.getElementById('global-script-toggle-btn').style.display = 'flex';
    }
    
    _formatOperatorToString(name, paramsStr, bodyStr) {
        const paramsArray = paramsStr.split(',').map(p => p.trim().replace(/['"]/g, '')).filter(p => p);
        const formattedParams = JSON.stringify(paramsArray);
        return `{
    name: '${name}',
    params: ${formattedParams},
    bodyJsString: \`
${bodyStr}
    \`
}`;
    }

saveCodeFromEditor() {
        let name = document.getElementById('code-editor-name').value.trim();
        const paramsStr = document.getElementById('code-editor-params').value;
        const bodyJsString = document.getElementById('code-editor-body').value;


        if (name) name = name.toLowerCase();

        if (!name || !/^[a-zA-Z_][\w]*$/.test(name)) {
            alert("名称无效。");
            return;
        }
        if (this.defaultAdvancedFunctionNames.has(name) && (this.currentCodeEditIndex === -1 || ADVANCED_FUNCTION_DEFINITIONS[this.currentCodeEditIndex].name !== name)) {
            alert(`名称 "${name}" 是一个内置函数，无法覆盖。`);
            return;
        }

        const params = paramsStr.split(',').map(p => p.trim().replace(/['"]/g, '')).filter(p => p);
        for(const param of params) {
            if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                alert(`变量名 "${param}" 无效。`);
                return;
            }
        }

        const newOperator = { name, params, bodyJsString };

        if (this.currentCodeEditIndex === -1) { 
            ADVANCED_FUNCTION_DEFINITIONS.push(newOperator);
        } else { 
            ADVANCED_FUNCTION_DEFINITIONS[this.currentCodeEditIndex] = newOperator;
        }

        this.initializeAdvancedCalcJSFunctions();
        this.recalculateAll();
        this.updateCodeList();
        this.hideCodeEditor();
    }
    downloadCodeFromEditor() {
        const name = document.getElementById('code-editor-name').value.trim();
        const paramsStr = document.getElementById('code-editor-params').value;
        const bodyStr = document.getElementById('code-editor-body').value;
        if (!name) {
            alert("名称不能为空。");
            return;
        }
        const fileContent = this._formatOperatorToString(name, paramsStr, bodyStr);
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const filename = `jscalc_${name}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }
    
    downloadSingleOperator(index) {
        const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
        const paramsStr = operator.params.map(p => `'${p}'`).join(', ');
        const fileContent = this._formatOperatorToString(operator.name, paramsStr, operator.bodyJsString);
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const filename = `jscalc_${operator.name}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }
_uint8ArrayToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        const CHUNK_SIZE = 32768; // 32KB 分块
        
        // 使用数组收集，避免频繁的字符串拼接导致的内存压力和性能问题
        const chunks = [];
        for (let i = 0; i < len; i += CHUNK_SIZE) {
            const chunk = bytes.subarray(i, Math.min(i + CHUNK_SIZE, len));
            chunks.push(String.fromCharCode.apply(null, chunk));
        }
        return window.btoa(chunks.join(''));
    }

   _base64ToUint8Array(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    }

_ensurePdfJsLoaded() {
        if (window.pdfjsLib) return Promise.resolve();
        if (this._pdfJsLoadingPromise) return this._pdfJsLoadingPromise;
        this._pdfJsLoadingPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
            script.onload = () => {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                resolve();
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
        return this._pdfJsLoadingPromise;
    }
    async _restorePdfAnnotation(anno) {
        try {
            await this._ensurePdfJsLoaded();
            anno.pdfDoc = await window.pdfjsLib.getDocument(anno.pdfData).promise;
            await this.renderPdfPage(anno);
        } catch (e) {
            console.error("PDF restore failed:", e);
        }
    }

stopAllAudio() {
        this.annotations.forEach(anno => {
            if (anno.type === 'audio' && anno.audioElem) {
                anno.audioElem.pause();
                anno.audioElem.currentTime = 0;
                anno.isPlaying = false;
            }
        });
    }

    async renderPdfPage(annotation) {
        if (!annotation.pdfDoc) return;
        try {
            const page = await annotation.pdfDoc.getPage(annotation.page);
            const viewport = page.getViewport({ scale: 2 }); 
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport: viewport }).promise;
            
            const img = new Image();
            img.onload = () => {
                annotation.img = img;
                this.requestDraw();
            };
            img.src = canvas.toDataURL();
        } catch (e) {
            console.error(e);
        }
    }
    deleteCustomOperator(index) {
        const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
        if (confirm(`确定要删除运算符 "${operator.name}" 吗？所有依赖于它的条目也将被删除。`)) {
            const operatorName = operator.name;
            ADVANCED_FUNCTION_DEFINITIONS.splice(index, 1);
            
            const indicesToDelete = new Set();
            this.entries.forEach((entry, i) => {
                if (entry.dependencies && entry.dependencies.includes(operatorName.toLowerCase())) {
                    indicesToDelete.add(i);
                }
            });

            const sortedIndices = Array.from(indicesToDelete).sort((a, b) => b - a);
            sortedIndices.forEach(idx => this.entries.splice(idx, 1));
            
            this.initializeAdvancedCalcJSFunctions();
            this.recalculateAll();
            this.updateCodeList();
        }
    }

        handleGeometryButtonClick(type) {
        if (this.geometryInteractionState.active && this.geometryInteractionState.type === type) {
            this.cancelGeometryInteraction();
            return;
        }

if (type === 'annotation') {
            this.enterAnnotationMode();
            return;
        }

if (type === 'checkbox') { this.showCheckboxSelectionModal(); return; }

        this.cancelGeometryInteraction();

const interactions = {
            'point': { clicks: 1, prompt: '在绘图区点击以添加一个点' },
            'intercept': { clicks: 2, prompt: '请选择第一个对象' },
            'midpoint': { clicks: 2, prompt: '请选择第一个点' },
            'segment': { clicks: 2, prompt: '请选择线段的第一个端点' },
            'ray': { clicks: 2, prompt: '请选择射线的起点' },
            'line': { clicks: 2, prompt: '请选择直线上的第一个点' },
            'vector': { clicks: 2, prompt: '请选择向量的起点' },
            'circle_pr': { clicks: 2, prompt: '请选择圆心' },
            'circle_cr': { clicks: 1, prompt: '请选择圆心' },
            'circulararc': { clicks: 3, prompt: '请选择圆心' },
            'parallelline': { clicks: 2, prompt: '请选择一条线' },
            'perpendicularline': { clicks: 2, prompt: '请选择一条线' },
            'anglebisector': { clicks: 3, prompt: '请选择第一个点 (边上)' },
            'ellipse': { clicks: 3, prompt: '请选择第一个焦点' },
            'hyperbola': { clicks: 3, prompt: '请选择第一个焦点' },
            'parabola': { clicks: 2, prompt: '请选择焦点' },
            'polygon': { clicks: Infinity, prompt: '请选择第一个顶点' },
            'length': { clicks: 2, prompt: '请选择第一个点' },
            'angle': { clicks: 3, prompt: '请选择第一个点 (边上)' },
            'area': { clicks: Infinity, prompt: '请选择第一个顶点' },
            'isparallel': { clicks: 2, prompt: '请选择第一条线' },
            'isperpendicular': { clicks: 2, prompt: '请选择第一条线' },
            'isconcyclic': { clicks: 4, prompt: '请选择第一个点' },
            'rotate': { clicks: 2, prompt: '请选择旋转中心' },
            'reflect': { clicks: 2, prompt: '请选择对称轴或对称中心' },
            'translate': { clicks: 2, prompt: '请选择一个向量或射线' },
            'fitline': { clicks: Infinity, prompt: '请选择第一个点' },
            'tangent': { clicks: 2, prompt: '请选择一个圆锥曲线' },
       'trace': { clicks: 1, prompt: '请选择要追踪轨迹的点' },
        };


        if (interactions[type] && interactions[type].clicks > 0) {
            this.geometryInteractionState = {
                active: true,
                type: type,
                prompt: interactions[type].prompt,
                clicksNeeded: interactions[type].clicks,
                pointsSelected: [],
                objectsSelected: [],
                dx_expr: null, 
                dy_expr: null,
            };
            this.updateGeometryInteractionUI();
            const button = this.geometryPanel.querySelector(`.geo-btn[data-geo-type="${type}"]`);
            if (button) button.classList.add('active');
        } else {
             alert('此功能尚未实现。');
        }
    }
    
       handleGeometryClick(e) {
    this.highlightedObject = null;
    this.hideInfoMessage();

    const coords = this.getEventCoordinates(e);
        const mathX = (coords.x - this.offset.x) / this.scale;
        const mathY = (this.offset.y - coords.y) / this.scale;

        const state = this.geometryInteractionState;


        const selectOrCreatePoint = () => {
            let selectedPointName = '';
            const clickedObject = this.findObjectNearClick(coords);
            
            if (clickedObject && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(clickedObject.geometryType)) {
                selectedPointName = clickedObject.name;
            } else {
                const newPointName = this.autonamePoint();
                let definition = '';
                 if (clickedObject && !['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    let param = 0;
                    const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

                    if (lineLike.includes(clickedObject.geometryType)) {
                        const { p1 } = clickedObject;
                        const dir_vec = clickedObject.dir_vec || clickedObject.dir;
                        const lenSq = dir_vec.x**2 + dir_vec.y**2;
                        if (lenSq > 1e-9) {
                            param = ((mathX - p1.x_val) * dir_vec.x + (mathY - p1.y_val) * dir_vec.y) / lenSq;
                        }
} else if (clickedObject.geometryType === 'circle') {
                    const { center } = clickedObject;
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'ellipse' || clickedObject.geometryType === 'ellipse_ab') {
                    const { center, a, b, rotation } = clickedObject;
                    const relX = mathX - center.x;
                    const relY = mathY - center.y;
                    const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                    const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                    let angle = Math.atan2(localY / b, localX / a);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'hyperbola') {                        const { center, b, rotation, f1, f2 } = clickedObject;
                        const d1 = Math.hypot(mathX - f1.x_val, mathY - f1.y_val);
                        const d2 = Math.hypot(mathX - f2.x_val, mathY - f2.y_val);
                        const branch_sign = Math.sign(d1 - d2) || 1;
                        const relY = mathY - center.y;
                        const localY = (mathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        let t = Math.asinh(localY / b);

                        const magic_offset = 100000;
                        let param_to_store = t;
                        if (branch_sign === -1) {
                           param_to_store = t - magic_offset;
                        }
                        param = param_to_store;
                    } else if (clickedObject.geometryType === 'parabola') {
                        const { vertex, rotation } = clickedObject;
                        const relX = mathX - vertex.x;
                        const relY = mathY - vertex.y;
                        const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        param = localY;
} else if (clickedObject.geometryType === 'circulararc') {
                        const { center } = clickedObject;
                        let click_angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                        let { startAngle, endAngle } = clickedObject;
                        
                        if (endAngle < startAngle) endAngle += 2 * Math.PI;
                        
                        let angleDiff = click_angle - startAngle;
                        while (angleDiff < -1e-9) angleDiff += 2 * Math.PI;
                        while (angleDiff >= 2 * Math.PI - 1e-9) angleDiff -= 2 * Math.PI;

                        const arcSpan = endAngle - startAngle;

                        if (angleDiff >= -1e-9 && angleDiff <= arcSpan + 1e-9) {
                            let param = angleDiff / arcSpan;
                            param = Math.max(0, Math.min(1, param)); 
                            definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                        } else {
                            definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                        }
                    }
                    definition = `point(${newPointName},${clickedObject.name},${param.toPrecision(8)})`;
                } else {
                    definition = `point(${newPointName},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                }
                this.addEntry(definition);
                selectedPointName = newPointName;
            }
            return selectedPointName;
        };

        switch (state.type) {
            case 'point': {
                const clickedObject = this.findObjectNearClick(coords);
                const name = this.autonamePoint();
                let definition = '';

                if (clickedObject && !['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    let param = 0;
                    const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

                    if (lineLike.includes(clickedObject.geometryType)) {
                        const { p1 } = clickedObject;
                        const dir_vec = clickedObject.dir_vec || clickedObject.dir;
                        const lenSq = dir_vec.x**2 + dir_vec.y**2;
                        if (lenSq > 1e-9) {
                            param = ((mathX - p1.x_val) * dir_vec.x + (mathY - p1.y_val) * dir_vec.y) / lenSq;
                        }
} else if (clickedObject.geometryType === 'circle') {
                    const { center } = clickedObject;
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'ellipse' || clickedObject.geometryType === 'ellipse_ab') {
                    const { center, a, b, rotation } = clickedObject;
                    const relX = mathX - center.x;
                    const relY = mathY - center.y;
                    const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                    const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                    let angle = Math.atan2(localY / b, localX / a);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'hyperbola') {                        const { center, b, rotation, f1, f2 } = clickedObject;
                        const d1 = Math.hypot(mathX - f1.x_val, mathY - f1.y_val);
                        const d2 = Math.hypot(mathX - f2.x_val, mathY - f2.y_val);
                        const branch_sign = Math.sign(d1 - d2) || 1;
                        
                        const relY = mathY - center.y;
                        const localY = (mathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        let t = Math.asinh(localY / b);
                        
                        const magic_offset = 100000;
                        let param_to_store = t;
                        if (branch_sign === -1) {
                            param_to_store = t - magic_offset;
                        }
                        param = param_to_store;

                    } else if (clickedObject.geometryType === 'parabola') {
                        const { vertex, rotation } = clickedObject;
                        const relX = mathX - vertex.x;
                        const relY = mathY - vertex.y;
                        const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        param = localY;
                    } else if (clickedObject.geometryType === 'circulararc') {
                        const { center } = clickedObject;
                        let click_angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                        let { startAngle, endAngle } = clickedObject;
                        
                        if (endAngle < startAngle) endAngle += 2 * Math.PI;
                        if (click_angle < startAngle) click_angle += 2 * Math.PI;

                        if (click_angle >= startAngle - 1e-9 && click_angle <= endAngle + 1e-9) {
                            let param = (click_angle - startAngle) / (endAngle - startAngle);
                            param = Math.max(0, Math.min(1, param)); 
                            definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                        } else {

                            definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                        }
                    }
                    
                    definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                } else {
                    definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                }
                
                if (definition) {
                    this.addEntry(definition);
                }
                this.cancelGeometryInteraction();
                break;
            }
case 'intercept': {
                const clickedObject = this.findObjectNearClick(coords);

                if (!clickedObject || ['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    alert('请选择一条线、圆或圆锥曲线。');
                    this.cancelGeometryInteraction();
                    return;
                }

                this.highlightedObject = clickedObject;
                this.showInfoMessage(`选中：${clickedObject.name}`);
                this.requestDraw();

                state.pointsSelected.push(clickedObject.name);
                state.clicksNeeded--;

                if (state.clicksNeeded > 0) {
                    state.prompt = `已选择 ${clickedObject.name}. 请选择第二个对象`;
                    this.updateGeometryInteractionUI();
                } else {
                    const obj1Name = state.pointsSelected[0];
                    const obj2Name = state.pointsSelected[1];

                    const obj1 = this.entries.find(e => e.name === obj1Name);
                    const obj2 = this.entries.find(e => e.name === obj2Name);

                    if (!obj1 || !obj2) {
                        alert('错误: 找不到所选对象。');
                        this.cancelGeometryInteraction();
                        return;
                    }
                    
                    const type1 = obj1.geometryType;
                    const type2 = obj2.geometryType;

                    const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);
                    const isCircle = (t) => ['circle', 'circulararc'].includes(t);
                    const isConic = (t) => ['ellipse', 'hyperbola', 'parabola', 'ellipse_ab'].includes(t);

                    const hasTwoSolutions = 
                        (isLineLike(type1) && isCircle(type2)) ||
                        (isCircle(type1) && isLineLike(type2)) ||
                        (isCircle(type1) && isCircle(type2)) ||
                        (isLineLike(type1) && isConic(type2)) ||
                        (isConic(type1) && isLineLike(type2));

                    if (hasTwoSolutions) {
                        const name1 = this.autonamePoint();
                        this.addEntry(`intercept(${name1},${obj1Name},${obj2Name},1)`);
                        const name2 = this.autonamePoint();
                        this.addEntry(`intercept(${name2},${obj1Name},${obj2Name},-1)`);
                    } else {
                        const name = this.autonamePoint();
                        this.addEntry(`intercept(${name},${obj1Name},${obj2Name})`);
                    }
                    this.cancelGeometryInteraction();
                }
                break;
                        }            case 'midpoint': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = '已选择 ' + selectedPointName + '. 请选择第二个点';
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameMidpoint();
                        this.addEntry(`midpoint(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'segment':
            case 'ray':
            case 'line':
            case 'vector': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        const prompts = { 'segment': '请选择线段的终点', 'ray': '请选择射线上的另一点', 'line': '请选择直线上的另一点', 'vector': '请选择向量的终点' };
                        state.prompt = `已选择 ${selectedPointName}. ${prompts[state.type]}`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type[0]);
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'perpendicularline':
            case 'parallelline': {
                if (state.objectsSelected.length === 0) {
                   const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
    this.highlightedObject = clickedObject;
    this.showInfoMessage(`选中：${clickedObject.name}`);
    this.requestDraw();
    state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择线 ${clickedObject.name}. 请选择一个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        alert('请先选择一条线。');
                        this.cancelGeometryInteraction();
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonameByPrefix(state.type[0]);
                        this.addEntry(`${state.type}(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'anglebisector': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择顶点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择顶点 ${selectedPointName}. 请选择第三个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('l');
                        this.addEntry(`anglebisector(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'circle_pr': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择圆心 ${selectedPointName}. 请选择圆上的一点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('c');
                        this.addEntry(`circle(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'circle_cr': {
                const centerName = selectOrCreatePoint();
                if (centerName) {
                    const radiusExpr = prompt("请输入圆的半径 (可以是表达式):");
                    if (radiusExpr !== null && radiusExpr.trim() !== "") {
                        const name = this.autonameByPrefix('c');
                        this.addEntry(`circle(${name},${centerName},${radiusExpr})`);
                    }
                }
                this.cancelGeometryInteraction();
                break;
            }
            case 'ellipse':
            case 'hyperbola': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    const typeName = state.type === 'ellipse' ? '椭圆' : '双曲线';
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择第一个焦点 ${selectedPointName}. 请选择第二个焦点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择第二个焦点 ${selectedPointName}. 请选择${typeName}上的一点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type[0].toUpperCase());
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'parabola': {
                if (state.pointsSelected.length === 0) {
                    const focusName = selectOrCreatePoint();
                    if (focusName) {
                        state.pointsSelected.push(focusName);
                        state.clicksNeeded--;
                        state.prompt = `已选择焦点 ${focusName}. 请选择准线`;
                        this.updateGeometryInteractionUI();
                    }
                } else { 
const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
    this.highlightedObject = clickedObject;
    this.showInfoMessage(`选中：${clickedObject.name}`);
    this.requestDraw();
    state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        const name = this.autonameByPrefix('P');
                        this.addEntry(`parabola(${name},${state.pointsSelected[0]},${state.objectsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    } else {
                        alert('请选择一条线作为准线。');
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'polygon': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 2 && selectedPointName === state.pointsSelected[0]) {
                     
                        const name = this.autonameByPrefix('p');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`polygon(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个顶点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            } 
                        case 'fitline': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 1 && selectedPointName === state.pointsSelected[0]) {
                        const name = this.autonameByPrefix('l');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`fitline(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            }
             case 'circulararc': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择圆心 ${selectedPointName}. 请选择圆弧起始点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择起始点 ${selectedPointName}. 请选择圆弧终点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('arc');
                        this.addEntry(`circulararc(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }

case 'tangent': {
if (state.objectsSelected.length === 0) {
const clickedObject = this.findObjectNearClick(coords);
const conicLike = ['circle', 'ellipse', 'hyperbola', 'parabola', 'circulararc', 'ellipse_ab'];
if (clickedObject && conicLike.includes(clickedObject.geometryType)) {
this.highlightedObject = clickedObject;
this.showInfoMessage(`选中：${clickedObject.name}`);
this.requestDraw();
state.objectsSelected.push(clickedObject.name);
state.clicksNeeded--;
state.prompt = `已选择 ${clickedObject.name}. 请选择一个点`;
this.updateGeometryInteractionUI();
} else {
alert('请选择一个圆锥曲线或圆弧。');
this.cancelGeometryInteraction();
}
} else {
const selectedPointName = selectOrCreatePoint();
if (selectedPointName) {
state.pointsSelected.push(selectedPointName);
state.clicksNeeded--;
const name1 = this.autonameByPrefix('t');
this.addEntry(`tangent(${name1},${state.objectsSelected[0]},${state.pointsSelected[0]},1)`);
const name2 = this.autonameByPrefix('t');
this.addEntry(`tangent(${name2},${state.objectsSelected[0]},${state.pointsSelected[0]},-1)`);
this.cancelGeometryInteraction();
}
}
break;
}
        
case 'trace': {
                const clickedObject = this.findObjectNearClick(coords);
                if (clickedObject && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(clickedObject.geometryType)) {
                    this.highlightedObject = clickedObject;
                    this.showInfoMessage(`开始录制轨迹：${clickedObject.name}`);
                    this.requestDraw();
                    
                    this.traceState.active = true;
                    this.traceState.targetName = clickedObject.name;
                    this.traceState.path = [{x: clickedObject.x_val, y: clickedObject.y_val}];
                    this.traceState.lastRecordTime = 0;
                    
                    document.getElementById('stop-trace-btn').style.display = 'flex';
                    this.cancelGeometryInteraction();
                } else {
                     alert('请选择一个点。');
                     this.cancelGeometryInteraction();
                }
                break;
            }

            case 'isparallel':
            case 'isperpendicular': {
                const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
                    this.highlightedObject = clickedObject;
                    this.showInfoMessage(`选中：${clickedObject.name}`);
                    this.requestDraw();

                    state.objectsSelected.push(clickedObject.name);
                    state.clicksNeeded--;

                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择线 ${clickedObject.name}. 请选择第二条线`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type);
                        this.addEntry(`${state.type}(${name},${state.objectsSelected[0]},${state.objectsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                } else {
                    alert('请选择一条线。');
                    this.cancelGeometryInteraction();
                }
                break;
            }
            case 'isconcyclic': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择 ${state.pointsSelected.length} 个点. 请选择下一个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('isconcyclic');
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]},${state.pointsSelected[3]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }case 'length': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择第二个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('l');
                        this.addEntry(`length(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'angle': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择顶点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择顶点 ${selectedPointName}. 请选择第三个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('a');
                        this.addEntry(`angle(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'area': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 2 && selectedPointName === state.pointsSelected[0]) {
                     
                        const name = this.autonameByPrefix('s');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`area(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个顶点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            }
            case 'rotate': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择旋转中心 ${selectedPointName}. 请选择要旋转的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const angleStr = prompt("请输入旋转角度(度):", "90");
                        const angle = parseFloat(angleStr);
                        if (angleStr !== null && Number.isFinite(angle)) {
                            const name = this.autonamePoint();
                            this.addEntry(`rotate(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${angleStr})`);
                        }
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'reflect': {
                if (state.objectsSelected.length === 0) {
                    const clickedObject = this.findObjectNearClick(coords);
                    if (clickedObject) {
                        this.highlightedObject = clickedObject;
                        this.showInfoMessage(`选中：${clickedObject.name}`);
                        this.requestDraw();
                        state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择 ${clickedObject.name}. 请选择要作用的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        alert('请选择一个点或一条线作为对称基准。');
                        this.cancelGeometryInteraction();
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonamePoint();
                        this.addEntry(`reflect(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'translate': {
                if (state.objectsSelected.length === 0 && state.dx_expr === null) {
                    const clickedObject = this.findObjectNearClick(coords);
                    const vectorLike = ['vector', 'ray'];
                    if (clickedObject && vectorLike.includes(clickedObject.geometryType)) {
                        this.highlightedObject = clickedObject;
                        this.showInfoMessage(`选中：${clickedObject.name}`);
                        this.requestDraw();
                        state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择向量 ${clickedObject.name}. 请选择要平移的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const dxStr = prompt("未选择向量。请输入平移的 dx 值:", "1");
                        if (dxStr !== null) {
                            const dyStr = prompt("请输入平移的 dy 值:", "1");
                            if (dyStr !== null) {
                                state.dx_expr = dxStr;
                                state.dy_expr = dyStr;
                                state.clicksNeeded--;
                                state.prompt = `平移量为 (${dxStr}, ${dyStr}). 请选择要平移的点`;
                                this.updateGeometryInteractionUI();
                            } else {
                                this.cancelGeometryInteraction();
                            }
                        } else {
                            this.cancelGeometryInteraction();
                        }
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonamePoint();
                        if (state.objectsSelected.length > 0) {
                            this.addEntry(`translate(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        } else {
                            this.addEntry(`translate(${name},${state.pointsSelected[0]},${state.dx_expr},${state.dy_expr})`);
                        }
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
        }
    }

}
let archInstance = null;

document.addEventListener('DOMContentLoaded', () => {
    const mainContentTitle = document.getElementById('main-content-title');
    const sidebarNavButtons = document.getElementById('sidebar-nav-buttons');
    const navBtnPlot = document.getElementById('nav-btn-plot');
    const navBtnGeometry = document.getElementById('nav-btn-geometry');
    const navBtnAbout = document.getElementById('nav-btn-about');
    const navBtnFile = document.getElementById('nav-btn-file');
    const navBtnSettings = document.getElementById('nav-btn-settings');
    const navBtnCollapse = document.getElementById('nav-btn-collapse');
    const showSidebarBtn = document.getElementById('show-sidebar-btn');
    const navBtnCode = document.getElementById('nav-btn-code');

    const keyboardToggleBtn = document.getElementById('keyboard-toggle-btn');
    const keyboardToggleContainer = document.getElementById('keyboard-toggle-container');
    const keyboard = document.getElementById('keyboard');
    const keyboardPageBtns = keyboard.querySelectorAll('.keyboard-page-btn');
    const keyboardContentPages = keyboard.querySelectorAll('.keyboard-page-content');
    const keyboardInputDisplay = document.getElementById('keyboard-input-display');
    const keyboardInputPromptBtn = document.getElementById('keyboard-input-prompt-btn');
    const keyboardCopyBtn = document.getElementById('keyboard-copy-btn');
    const keyboardPasteBtn = document.getElementById('keyboard-paste-btn');
    const kbdDynamicOps = keyboard.querySelectorAll('.kbd-dynamic-op');
    const allKeyboardKeys = keyboard.querySelectorAll('.keyboard-page-content .btn');

    const keyboardShiftBtn = document.getElementById('keyboard-shift-btn'); 
const kbdPage3SwitchKeys = keyboard.querySelectorAll('.kbd-p3-switch');

    const kbdCharKeys = keyboard.querySelectorAll('#keyboard-page-3 .kbd-char'); 
    const keyboardPage2ShiftBtn = document.getElementById('keyboard-page2-shift-btn'); 
    const kbdCharPage2Keys = keyboard.querySelectorAll('#keyboard-page-2 .kbd-char-page2'); 
    const newFileBtn = document.getElementById('new-file-btn');
    const loadFileBtnMenu = document.getElementById('load-file-btn'); 
    const saveFileBtnMenu = document.getElementById('save-file-btn'); 

    let isKeyboardOpen = false;
    let keyboardSubmitCallback = null;
    let currentKeyboardPage = 1;
    let keyboardBuffer = "";
    let cursorPosition = 0;
    let isShiftActive = false; 
    let isPage2ShiftActive = false; 
    let keyboardInputStringForarch = "";

    const page2ShiftMapping = {
        "sin(": { shiftedText: "max", shiftedKey: "max(" },
        "cos(": { shiftedText: "min", shiftedKey: "min(" },
        "tan(": { shiftedText: "root", shiftedKey: "root(" },
        "cot(": { shiftedText: "beta", shiftedKey: "beta(" },
        "sec(": { shiftedText: "zeta", shiftedKey: "zeta(" },
        "csc(": { shiftedText: "erf", shiftedKey: "erf(" },
        "asin(": { shiftedText: "erfc", shiftedKey: "erfc(" },
        "acos(": { shiftedText: "lambertw", shiftedKey: "lambertw(" },
        "atan(": { shiftedText: "sinintegral", shiftedKey: "sinintegral(" },
        "acot(": { shiftedText: "cosintegral", shiftedKey: "cosintegral(" },
        "asec(": { shiftedText: "expintegral", shiftedKey: "expintegral(" },
        "acsc(": { shiftedText: "li", shiftedKey: "li(" },
        "sinh(": { shiftedText: "psi", shiftedKey: "psi(" },
        "cosh(": { shiftedText: "fresnels", shiftedKey: "fresnels(" },
        "tanh(": { shiftedText: "fresnelc", shiftedKey: "fresnelc(" },
        "coth(": { shiftedText: "elliptick", shiftedKey: "elliptick(" },
        "sech(": { shiftedText: "elliptice", shiftedKey: "elliptice(" },
        "csch(": { shiftedText: "heaviside", shiftedKey: "heaviside(" },
        "asinh(": { shiftedText: "normdist", shiftedKey: "normdist(" },
        "acosh(": { shiftedText: "tdist", shiftedKey: "tdist(" },
        "atanh(": { shiftedText: "chisqdist", shiftedKey: "chisqdist(" },
        "acoth(": { shiftedText: "lognormdist", shiftedKey: "lognormdist(" },
        "asech(": { shiftedText: "gammadist", shiftedKey: "gammadist(" },
        "acsch(": { shiftedText: "diffat", shiftedKey: "diffat(" },
    };


    function updateShiftButtonVisual() { 
        if(!keyboardShiftBtn) return;
        if (isShiftActive) keyboardShiftBtn.classList.add('active-shift');
        else keyboardShiftBtn.classList.remove('active-shift');
    }

    function updateKeyboardCharKeysCase() { 
        kbdCharKeys.forEach(keyBtn => { 
            const baseChar = keyBtn.getAttribute('data-original-key') || keyBtn.dataset.key; 
            keyBtn.textContent = isShiftActive ? baseChar.toUpperCase() : baseChar.toLowerCase(); 
        });
    }

    function updatePage3ShiftVisual() {
        kbdPage3SwitchKeys.forEach(btn => {
            if (isShiftActive && currentKeyboardPage === 3) {
                btn.textContent = btn.dataset.shiftKey;
                btn.dataset.key = btn.dataset.shiftKey;
            } else {
                btn.textContent = btn.dataset.originalKey;
                btn.dataset.key = btn.dataset.originalKey;
            }
        });
    }

    function updatePage2ShiftButtonVisual() {
        if (!keyboardPage2ShiftBtn) return;
        if (isPage2ShiftActive) keyboardPage2ShiftBtn.classList.add('active-shift');
        else keyboardPage2ShiftBtn.classList.remove('active-shift');
    }

    function updateKeyboardPage2CharKeysAndDataKeys() {
        const isPortrait = document.body.classList.contains('portrait-mode');
        const portraitAbbreviations = {
            "lambertw": "ltw", "sinintegral": "si", "cosintegral": "ci",
            "expintegral": "ei", "fresnels": "sfn", "fresnelc": "cfn",
            "elliptick": "kint", "elliptice": "eint", "heaviside": "heav",
            "normdist": "norm", "chisqdist": "chisq", "lognormdist": "lognm",
            "gammadist": "gmdst"
        };

        kbdCharPage2Keys.forEach(keyBtn => {
            const originalKey = keyBtn.getAttribute('data-original-key');
            const originalText = keyBtn.getAttribute('data-original-text');
            if (isPage2ShiftActive && page2ShiftMapping[originalKey]) {
                const shiftedInfo = page2ShiftMapping[originalKey];
                keyBtn.dataset.key = shiftedInfo.shiftedKey;
                
                if (isPortrait && portraitAbbreviations[shiftedInfo.shiftedText]) {
                    keyBtn.textContent = portraitAbbreviations[shiftedInfo.shiftedText];
                } else {
                    keyBtn.textContent = shiftedInfo.shiftedText;
                }
            } else {
                keyBtn.textContent = originalText;
                keyBtn.dataset.key = originalKey;
            }
        });

        if (kbdDynamicOps.length >= 3) {
            if (isPage2ShiftActive) {
                kbdDynamicOps[0].textContent = "sum"; kbdDynamicOps[0].dataset.key = "sum(";
                kbdDynamicOps[1].textContent = "prod"; kbdDynamicOps[1].dataset.key = "prod(";
                kbdDynamicOps[2].textContent = "int"; kbdDynamicOps[2].dataset.key = "int(";
            } else {
                kbdDynamicOps[0].textContent = "range"; kbdDynamicOps[0].dataset.key = "range(";
                kbdDynamicOps[1].textContent = "llim"; kbdDynamicOps[1].dataset.key = "llim(";
                kbdDynamicOps[2].textContent = "ulim"; kbdDynamicOps[2].dataset.key = "ulim(";
            }
        }
    }
    
    function escapeHtml(unsafe) {
        return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function updateKeyboardInputDisplay() {
        let displayHTML = "";
        for (let i = 0; i < keyboardBuffer.length; i++) {
            if (i === cursorPosition) {
                displayHTML += '<span class="cursor"></span>';
            }
            displayHTML += `<span class="char-span" data-index="${i}">${escapeHtml(keyboardBuffer[i])}</span>`;
        }
        if (cursorPosition === keyboardBuffer.length) {
            displayHTML += '<span class="cursor"></span>';
        }
        keyboardInputDisplay.innerHTML = displayHTML || '<span class="cursor"></span>';
        const cursorEl = keyboardInputDisplay.querySelector('.cursor');
        if (cursorEl) {
            cursorEl.scrollIntoView({ behavior: 'smooth', inline: 'nearest', block: 'nearest' });
        }
    }

    function setActiveKeyboardPage(pageNumberStr) {
        currentKeyboardPage = parseInt(pageNumberStr);
        keyboardPageBtns.forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.kpage) === currentKeyboardPage) btn.classList.add('active');
        });
        keyboardContentPages.forEach(page => {
            page.classList.remove('active');
            if (page.id === `keyboard-page-${currentKeyboardPage}`) page.classList.add('active');
        });
        isShiftActive = false; updateShiftButtonVisual(); updateKeyboardCharKeysCase();updatePage3ShiftVisual();
        isPage2ShiftActive = false; updatePage2ShiftButtonVisual(); updateKeyboardPage2CharKeysAndDataKeys();
    }

    function updateKeyboardToggleVisibility() {
        if (!archInstance) return;
        
        const container = document.getElementById('keyboard-toggle-container');
        if (!container) return;

        // 条件 1: 必须处于“绘图”模式
        const isPlotMode = archInstance.currentUIMode === 'plot';
        
        // 条件 2: 侧栏必须是“展开”状态 (body 标签上没有 sidebar-hidden 类)
        const isSidebarExpanded = !document.body.classList.contains('sidebar-hidden');

        // 条件 3: 键盘必须是“关闭”状态
        // (虽然层级调整了，但在输入时隐藏新建按钮是标准交互体验，也能防止误触)
        const isKeyboardClosed = !isKeyboardOpen;

        // 综合判定：同时满足三个条件才显示
        if (isPlotMode && isSidebarExpanded && isKeyboardClosed) {
            // 强制使用 flex 布局以保持横向排列
            container.style.setProperty('display', 'flex', 'important');
        } else {
            // 强制隐藏
            container.style.setProperty('display', 'none', 'important');
        }
    }
    window.updateKeyboardToggleVisibility = updateKeyboardToggleVisibility;


    function openKeyboard(initialValue = "", callback = null) { 
        isKeyboardOpen = true;
        keyboard.classList.add('open');
        keyboardBuffer = String(initialValue); 
        keyboardSubmitCallback = callback; 
        cursorPosition = keyboardBuffer.length; 
        keyboardInputStringForarch = ""; 
        
        isShiftActive = false; updateShiftButtonVisual(); updateKeyboardCharKeysCase();updatePage3ShiftVisual();
        isPage2ShiftActive = false; updatePage2ShiftButtonVisual(); updateKeyboardPage2CharKeysAndDataKeys();
        setActiveKeyboardPage(1);
        updateKeyboardInputDisplay();
        updateKeyboardToggleVisibility();
    }

    function closeKeyboard(submit = false) {
        isKeyboardOpen = false;
        keyboard.classList.remove('open');

        if (submit) {
            if (keyboardSubmitCallback) {
                keyboardSubmitCallback(keyboardBuffer);
            } else if (archInstance && archInstance.editingEntryIndex !== -1) {
                archInstance.applyEditToEntry(keyboardBuffer);
            } else if (archInstance && keyboardBuffer.trim() !== "") {
                archInstance.addEntry(keyboardBuffer);
            }
        }
        
        keyboardSubmitCallback = null; 
        if (archInstance) archInstance.editingEntryIndex = -1;
        keyboardBuffer = "";
        keyboardInputStringForarch = "";

        isShiftActive = false;
        updatePage3ShiftVisual();
        isPage2ShiftActive = false;
        updateKeyboardToggleVisibility();
    }

    function toggleKeyboard() {
        if (isKeyboardOpen) closeKeyboard(false);
        else openKeyboard(); 
    }


    window.globalOpenKeyboardForEdit = function(initialValue) {
        openKeyboard(initialValue); 
    };
    window.globalOpenKeyboardForValue = function(initialValue, callback) {
        openKeyboard(initialValue, callback);
    };


    try {
        archInstance = new ArchEngine();
    } catch (error) {
        console.error("绘图程序初始化错误: ", error);
        alert("绘图程序初始化错误，请检查控制台");
    }

    class StageController {
        constructor(archEngine) {
            this.engine = archEngine;
            this.workspaces = [];
            this.activeWorkspaceId = null;
            this.container = document.getElementById('stage-manager-container');
            this.toggleBtn = document.getElementById('stage-mode-toggle-btn');
            this.addButton = null;
            this.domElements = new Map(); 
            

            this.scrollOffset = 0;
            this.maxScrollOffset = 0;
            

            this.touchStartY = 0;
            this.lastScrollOffset = 0;


            const initialId = 'ws-' + Date.now();
            this.workspaces.push({
                id: initialId,
                name: this.engine.filename,
                data: null, 
                image: null 
            });
            this.activeWorkspaceId = initialId;

            this.setupUI();
        }

        setupUI() {
          
            this.toggleBtn.innerHTML = '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC4wNDk0IiBoZWlnaHQ9IjIwLjA0OTQiIHZpZXdCb3g9IjAsMCwyMC4wNDk0LDIwLjA0OTQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMjkuOTc1MywtMTY5Ljk3NTMpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjkuOTc1MywxOTAuMDI0N3YtMjAuMDQ5NGgyMC4wNDk0djIwLjA0OTR6IiBmaWxsLW9wYWNpdHk9IjAuMDMxMzciIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PHBhdGggZD0iTTI0NC40NjA0MiwxODQuMTMxMTVjMS4wMzU0OSwtMC4zNTc4OSAxLjc4OTc2LC0xLjM0NDc4IDEuODEyOTgsLTIuNTIxMTRjMC4wMDAzNSwtMC4wMTg0NSAwLjAwMDU1LC0wLjAzNjg2IDAuMDAwNTUsLTAuMDU1MjRsLTAuMDIxNzksLTUuMDk5NDNjMC4wMDAyMSwtMC4wMTE4NyAwLjAwMDMzLC0wLjAyMzc1IDAuMDAwMzgsLTAuMDM1NjVjMC4wMDYyOSwtMS41MDE5NyAtMS4xODU3NywtMi43MjQ3NSAtMi42NjI1MywtMi43MzExN2MtMC4wMTgxNSwtMC4wMDAwNyAtMC4wMzYyNSwwLjAwMDAzIC0wLjA1NDMzLDAuMDAwMzJsLTUuMTA5NDgsMC4wMDE4NmMtMC4wMTE2NiwtMC4wMDA1MyAtMC4wMjMzMywtMC4wMDA5OSAtMC4wMzUwMywtMC4wMDEzN2MtMS4wMDYzOCwtMC4wMzI2NyAtMS45MDA2MSwwLjUwNDYxIC0yLjM4MjcxLDEuMzI1NjZsMC40NDQ2MSwwLjkyMjEiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48cGF0aCBkPSJNMjQxLjY2ODM3LDE3NS43MjU5YzAuMDE4MDgsLTAuMDAwMjkgMC4wMzYxOCwtMC4wMDAzOSAwLjA1NDMzLC0wLjAwMDMyYzEuNDc2NzYsMC4wMDY0MiAyLjY2ODgyLDEuMjI5MiAyLjY2MjUzLDIuNzMxMTdjLTAuMDAwMDUsMC4wMTE5IC0wLjAwMDE3LDAuMDIzNzggLTAuMDAwMzgsMC4wMzU2NWwwLjAyMTc5LDUuMDk5NDNjMCwwLjAxODM4IC0wLjAwMDIsMC4wMzY3OSAtMC4wMDA1NSwwLjA1NTI0Yy0wLjAyOTY0LDEuNTAxNjkgLTEuMjUwNiwyLjY5NDYxIC0yLjcyNzEsMi42NjQ0NWMtMC4wMTE3LC0wLjAwMDI0IC0wLjAyMzM3LC0wLjAwMDU1IC0wLjAzNTA0LC0wLjAwMDk0bC01LjIzMjY1LDAuMDAwODZjLTAuMDE4MDgsMC4wMDAwNyAtMC4wMzYxOCwtMC4wMDAwNCAtMC4wNTQzMywtMC4wMDAzNGMtMS40NzY1OSwtMC4wMjQxOSAtMi42NTQzNCwtMS4yNjEyMiAtMi42MzA1NywtMi43NjMwM2MwLjAwMDIsLTAuMDExODkgMC4wMDA0NSwtMC4wMjM3NyAwLjAwMDc5LC0wLjAzNTY0bDAuMDM3NTYsLTUuMDk5MzVjMC4wMDAyMiwtMC4wMTgzOCAwLjAwMDYxLC0wLjAzNjc5IDAuMDAxMiwtMC4wNTUyNGMwLjA0NzEsLTEuNTAxMjMgMS4yODE4NywtMi42NzkzNyAyLjc1NzkxLC0yLjYzMTQ1YzAuMDExNywwLjAwMDM4IDAuMDIzMzcsMC4wMDA4NCAwLjAzNTAzLDAuMDAxMzd6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTAuMDI0NzAwNDQ0Nzc2MTAxOjEwLjAyNDcwMDQ0NDc3NjEzLS0+" style="width:20px;height:20px;">';

this.toggleBtn.addEventListener('click', () => {
                if (this.engine.currentUIMode === 'annotation') {
                    this.engine.exitAnnotationMode();
                }
                
                if (this.engine.selectedAnnotationIndex !== -1) {
                    this.engine.selectedAnnotationIndex = -1;
                    this.engine.updateAnnotationEditMenu(); 
                    this.engine.requestDraw(); 
                }
                this.enterStageMode();
            });
            
            // 绑定鼠标滚轮事件
            this.container.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
            
            // 绑定触摸事件以支持手指滑动
            this.container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
            this.container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });

            this.addButton = document.createElement('div');
            this.addButton.className = 'sm-add-btn';
            this.addButton.innerHTML = '+';
            this.addButton.title = '新建绘图';
            this.addButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.addNewWorkspace();
            });
            this.container.appendChild(this.addButton);
            
            const hint = document.createElement('div');
            hint.className = 'sm-hint';
            hint.innerText = '点击右侧窗口返回全屏，点击左侧缩略图切换';
            this.container.appendChild(hint);
        }

        
        handleWheel(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            e.preventDefault();
            this.scrollOffset -= e.deltaY;
            this.applyScrollLimits();
            this.updateLayout();
        }

        handleTouchStart(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            if (e.touches.length > 0) {
                this.touchStartY = e.touches[0].clientY;
                this.lastScrollOffset = this.scrollOffset;
            }
        }

        handleTouchMove(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            e.preventDefault();
            if (e.touches.length > 0) {
                const currentY = e.touches[0].clientY;
                const deltaY = currentY - this.touchStartY;
                

                this.scrollOffset = this.lastScrollOffset + deltaY;
                this.applyScrollLimits();
                this.updateLayout();
            }
        }

        applyScrollLimits() {

            if (this.scrollOffset > 0) this.scrollOffset = 0;
            if (this.scrollOffset < this.maxScrollOffset) this.scrollOffset = this.maxScrollOffset;
        }

    saveCurrentState() {
            const currentWS = this.workspaces.find(w => w.id === this.activeWorkspaceId);
            if (currentWS) {
                currentWS.data = this.engine.exportStateObject();
                currentWS.name = this.engine.filename;
                currentWS.image = this.engine.getScreenshot();

                currentWS.mode3d = this.engine.is3DMode;
            }
        }
          enterStageMode() {
            this.engine.stopTracing();
            this.saveCurrentState();
            this.syncDomElements(); 
            

            const currentWS = this.workspaces.find(w => w.id === this.activeWorkspaceId);
            const activeEl = this.domElements.get(this.activeWorkspaceId);
            if (activeEl && currentWS && currentWS.image) {
                activeEl.style.backgroundImage = `url(${currentWS.image})`;
                activeEl.style.backgroundColor = '#333';

                const spans = activeEl.querySelectorAll('span:not(.sm-name-label)');
                spans.forEach(s => s.remove());
            }

            if (activeEl) {
                activeEl.style.transition = 'none';
                activeEl.style.transform = 'translate3d(0, 0, 0) rotateY(0deg) scale(1)';
                activeEl.style.width = '100%';
                activeEl.style.height = '100%';
                activeEl.style.left = '0';
                activeEl.style.top = '0';
                activeEl.style.opacity = '1';
                
                activeEl.offsetHeight;
                activeEl.style.transition = ''; 
            }

            document.body.classList.add('stage-mode-active');
            
            requestAnimationFrame(() => {
                this.updateLayout();
            });
        }

        exitStageMode(targetId) {
            const targetWS = this.workspaces.find(w => w.id === targetId);
            if (!targetWS) return;

            this.activeWorkspaceId = targetId;
            
            const activeEl = this.domElements.get(targetId);
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            if (activeEl) {
                activeEl.style.transform = `translate3d(0px, 0px, 0) rotateY(0deg) scale(1)`;
                activeEl.style.width = `${w}px`;
                activeEl.style.height = `${h}px`;
                activeEl.style.left = '0px';
                activeEl.style.top = '0px';
                activeEl.style.zIndex = 1000;
            }

            this.workspaces.forEach(ws => {
                if (ws.id !== targetId) {
                    const el = this.domElements.get(ws.id);
                    if (el) {
                        const currentY = el.dataset.targetY || 0;
                        el.style.transform = `translate3d(-300px, ${currentY}px, 0) rotateY(25deg) scale(0.8)`;
                        el.style.opacity = '0';
                    }
                }
            });

          setTimeout(() => {

                this.engine.is3DMode = !!targetWS.mode3d;
this.engine.stopAllAudio();


                if (targetWS.data) {
                    this.engine.importStateObject(targetWS.data);
                    this.engine.categoryFilterMode = 0;
                this.engine.updateCategoryButtonIcon();
                } else {
                    this.engine.clearAllEntries();
                    this.engine.filename = targetWS.name;
                    this.engine.scale = 50;
                    this.engine.centerCanvas(); 
                    if(this.engine.fileNameDisplay) this.engine.fileNameDisplay.textContent = this.engine.filename;
                    this.engine.recalculateAll();
                }


                const viewModeCircle = document.getElementById('view-mode-toggle-circle');
                if (viewModeCircle) {
                    viewModeCircle.textContent = this.engine.is3DMode ? "2D" : "3D";
                }

                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) {
                    navBtnGeometry.style.display = this.engine.is3DMode ? 'none' : 'flex';
                }

                
                if (this.engine.is3DMode && this.engine.currentUIMode === 'geometry') {
                    this.engine.setUIMode('plot');
                    const navBtnPlot = document.getElementById('nav-btn-plot');
                    if (navBtnPlot && navBtnGeometry) {
                        navBtnGeometry.classList.remove('selected');
                        navBtnPlot.classList.add('selected');
                    }
                }

                if (this.engine.is3DMode) {
                    this.engine.recalculate3D();
                }
                this.engine.requestDraw();

                document.body.classList.remove('stage-mode-active');
            }, 500);
        }
        
        addNewWorkspace() {
            const newId = 'ws-' + Date.now();
            const date = new Date();
            const name = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}-${this.workspaces.length + 1}`;
            
            this.workspaces.push({
                id: newId,
                name: name,
                data: null,
                image: NEW_WORKSPACE_THUMBNAIL_BASE64 || null 
            });
            
            this.syncDomElements();
            this.scrollOffset = 0;
            this.activeWorkspaceId = newId;
            
            const newEl = this.domElements.get(newId);
            if (newEl) {
                newEl.style.transition = 'none';
                newEl.style.transform = 'translate3d(100%, 0, 0) scale(0.8)';
                newEl.offsetHeight;
                newEl.style.transition = '';
            }

            this.updateLayout();
        }

        removeWorkspace(id) {
            if (this.workspaces.length <= 1) {
                alert("至少保留一个工作区");
                return;
            }

            const el = this.domElements.get(id);
            if (el) {
                el.style.transform = 'scale(0)';
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 300);
                this.domElements.delete(id);
            }

            const index = this.workspaces.findIndex(w => w.id === id);
            if (index !== -1) {
                this.workspaces.splice(index, 1);
            }

            if (this.activeWorkspaceId === id) {
                this.activeWorkspaceId = this.workspaces[this.workspaces.length - 1].id;
            }

            this.updateLayout();
        }

 syncDomElements() {
            this.workspaces.forEach(ws => {
                let el = this.domElements.get(ws.id);
                
                if (!el) {
                    el = document.createElement('div');
                    el.className = 'sm-window';
                    el.id = ws.id;

                    const closeBtn = document.createElement('div');
                    closeBtn.className = 'sm-close-btn';
                    closeBtn.title = '关闭';
                    closeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeWorkspace(ws.id);
                    });
                    el.appendChild(closeBtn);

                    const label = document.createElement('div');
                    label.className = 'sm-name-label';
                    el.appendChild(label);

                    el.addEventListener('click', () => {
                        if (this.activeWorkspaceId === ws.id) {
                            this.exitStageMode(ws.id);
                        } else {
                            this.activeWorkspaceId = ws.id;
                            this.updateLayout();
                        }
                    });
                    
                    el.style.width = '0px'; 
                    el.style.height = '0px';

                    this.container.appendChild(el);
                    this.domElements.set(ws.id, el);
                }

                const label = el.querySelector('.sm-name-label');
                if (label) label.innerText = ws.name;

              const bgImage = ws.image || NEW_WORKSPACE_THUMBNAIL_BASE64; 
        el.style.background = '';
        
        if (bgImage) {
            el.style.backgroundImage = `url(${bgImage})`;
            el.style.backgroundColor = '#333';
            
         
            el.style.backgroundSize = 'cover'; 
            
            el.style.backgroundPosition = 'center center';
            el.style.backgroundRepeat = 'no-repeat';
            
       
            const spans = el.querySelectorAll('span:not(.sm-name-label)');
            spans.forEach(s => s.remove());
        } else {
        
            el.style.background = 'linear-gradient(135deg, #2b2b2b 0%, #1a1a1a 100%)';
      
        
                }
            });
        }

        updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            const activeWidth = w * 0.65;
            const activeHeight = h * 0.65;
            const activeLeft = w * 0.28; 
            const activeTop = (h - activeHeight) / 2;

            const thumbDisplayWidth = 220;
            const thumbDisplayHeight = 160;
            const thumbLeft = 40;
            const thumbGap = 30;
            
            const thumbnails = this.workspaces.filter(ws => ws.id !== this.activeWorkspaceId);
            
            const availableHeight = h; 
            const totalContentHeight = thumbnails.length * (thumbDisplayHeight + thumbGap) + thumbGap + 100;
            
            if (totalContentHeight > availableHeight) {
                this.maxScrollOffset = -(totalContentHeight - availableHeight);
            } else {
                this.maxScrollOffset = 0;
                this.scrollOffset = 0;
            }
            
            let startThumbTop = (h - (thumbnails.length * (thumbDisplayHeight + thumbGap) - thumbGap)) / 2;
            if (this.maxScrollOffset < 0) {
                 startThumbTop = 100; 
            }

            this.workspaces.forEach((ws) => {
                const el = this.domElements.get(ws.id);
                if (!el) return;

                if (ws.id === this.activeWorkspaceId) {
                    el.className = 'sm-window stage-center';
                    el.style.width = `${activeWidth}px`;
                    el.style.height = `${activeHeight}px`;
                    el.style.transform = `translate3d(${activeLeft}px, ${activeTop}px, 0) rotateY(0deg) scale(1)`;
                    el.style.opacity = '1';
                    
                    el.dataset.targetX = activeLeft;
                    el.dataset.targetY = activeTop;
                } else {
                    el.className = 'sm-window stage-thumbnail';
                    
                    const index = thumbnails.findIndex(t => t.id === ws.id);
                    const targetTop = startThumbTop + index * (thumbDisplayHeight + thumbGap) + this.scrollOffset;
                    
                    el.style.width = `${thumbDisplayWidth}px`;
                    el.style.height = `${thumbDisplayHeight}px`;
                    
                    el.style.transform = `translate3d(${thumbLeft}px, ${targetTop}px, 0) rotateY(25deg) scale(0.9)`;
                    
                    if (targetTop < -200 || targetTop > h + 200) {
                        el.style.opacity = '0';
                        el.style.pointerEvents = 'none';
                    } else {
                        el.style.opacity = '1';
                        el.style.pointerEvents = 'auto';
                    }
                    
                    el.dataset.targetY = targetTop;
                }
            });
        }
    }

    const stageController = new StageController(archInstance);

    kbdCharPage2Keys.forEach(keyBtn => {
        keyBtn.setAttribute('data-original-key', keyBtn.dataset.key);
        keyBtn.setAttribute('data-original-text', keyBtn.textContent);
    });

    const portraitNavToggleBtn = document.getElementById('portrait-nav-toggle-btn');
    const portraitResizeHandle = document.getElementById('portrait-resize-handle');

    if (portraitResizeHandle && archInstance) {
        portraitResizeHandle.addEventListener('mousedown', e => archInstance.startSidebarResize(e));
        portraitResizeHandle.addEventListener('touchstart', e => archInstance.startSidebarResizeTouch(e), { passive: false });
    }
    
    if (portraitNavToggleBtn) {
        portraitNavToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sidebarNavButtons.classList.toggle('nav-visible');
            keyboardToggleContainer.classList.toggle('hidden-by-nav');
            portraitNavToggleBtn.classList.toggle('active');
            if (portraitNavToggleBtn.classList.contains('active')) {
                portraitNavToggleBtn.style.display = 'none';
            }
        });
    }

function updateInterfaceState() {
        if (!archInstance) return;
        window.updateInterfaceState = updateInterfaceState;

        sidebarNavButtons.querySelectorAll('.sidebar-nav-btn').forEach(btn => btn.classList.remove('selected'));
        
        let titleText = null;
        const mode = archInstance.currentUIMode;

        const modeToButtonMap = {
            plot: { btn: navBtnPlot, title: "绘图" },
            geometry: { btn: navBtnGeometry, title: "几何" },
            code: { btn: navBtnCode, title: "代码"},
            settings: { btn: navBtnSettings, title: "设置" },
            file: { btn: navBtnFile, title: "文件" },
            about: { btn: navBtnAbout, title: "关于" }
        };

        if (modeToButtonMap[mode]) {
            modeToButtonMap[mode].btn.classList.add('selected');
            titleText = modeToButtonMap[mode].title;
        }

        if (mainContentTitle) {
            if (titleText && !document.body.classList.contains('sidebar-hidden')) {
                mainContentTitle.textContent = titleText;
                mainContentTitle.style.display = 'block';
            } else {
                mainContentTitle.style.display = 'none';
            }
        }
        updateKeyboardToggleVisibility();
    }
    
function handleNavClick(mode) {
        if (archInstance && archInstance.currentUIMode === 'annotation') {
             archInstance.exitAnnotationMode();
        }

        if (isKeyboardOpen) closeKeyboard();
        archInstance.setUIMode(mode);
        updateInterfaceState();
        updateKeyboardToggleVisibility();

        if (archInstance && archInstance.isPortraitMode) {
            document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
            document.getElementById('keyboard-toggle-container').classList.remove('hidden-by-nav');
            const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
            portraitBtn.classList.remove('active');
            portraitBtn.style.display = 'flex';
        }
    }

    navBtnPlot.addEventListener('click', () => handleNavClick('plot'));
    navBtnGeometry.addEventListener('click', () => handleNavClick('geometry'));
    navBtnSettings.addEventListener('click', () => handleNavClick('settings'));
    navBtnFile.addEventListener('click', () => handleNavClick('file'));
    navBtnAbout.addEventListener('click', () => handleNavClick('about'));
    navBtnCode.addEventListener('click', () => handleNavClick('code'));

    navBtnCollapse.addEventListener('click', () => {
        if (isKeyboardOpen) closeKeyboard();
        document.body.classList.add('sidebar-hidden');
        archInstance.updateLayout(); 
        updateInterfaceState();
        if (archInstance && archInstance.isPortraitMode) {
            const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
            portraitBtn.style.display = 'flex';
            portraitBtn.classList.remove('active');
            document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
        }
    });

    showSidebarBtn.addEventListener('click', () => {
        document.body.classList.remove('sidebar-hidden');
        archInstance.updateLayout();
        updateInterfaceState();
    });

    keyboardToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleKeyboard(); });
    keyboardPageBtns.forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); setActiveKeyboardPage(btn.dataset.kpage); }); });
    keyboardInputPromptBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const userInput = prompt("请输入算式:", keyboardBuffer);
        if (userInput !== null) { 
            keyboardBuffer = userInput; 
            cursorPosition = keyboardBuffer.length; 
            updateKeyboardInputDisplay(); 
        }
    });

    keyboardInputDisplay.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = keyboardInputDisplay.getBoundingClientRect();
        const clickX = e.clientX - rect.left + keyboardInputDisplay.scrollLeft;
        const charSpans = Array.from(keyboardInputDisplay.querySelectorAll('.char-span'));
        let newCursorPos = keyboardBuffer.length;
        if (charSpans.length === 0) {
            newCursorPos = 0;
        } else {
             for (let i = 0; i < charSpans.length; i++) {
                const span = charSpans[i];
                const spanMidX = span.offsetLeft - keyboardInputDisplay.scrollLeft + span.offsetWidth / 2;
                 if (clickX < spanMidX) {
                    newCursorPos = i;
                    break;
                }
            }
        }
        cursorPosition = newCursorPos;
        updateKeyboardInputDisplay();
    });

    if (keyboardCopyBtn) {
        keyboardCopyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (navigator.clipboard) {
                navigator.clipboard.writeText(keyboardBuffer).then(() => {
                    const originalHTML = keyboardCopyBtn.innerHTML;
                    keyboardCopyBtn.textContent = "已复制";
                    setTimeout(() => keyboardCopyBtn.innerHTML = originalHTML, 1000);
                }).catch(err => {
                    console.error('Could not copy text: ', err);
                    alert("复制失败，请检查浏览器权限");
                });
            } else {
                alert("当前浏览器不支持剪贴板API");
            }
        });
    }

    if (keyboardPasteBtn) {
        keyboardPasteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (navigator.clipboard) {
                navigator.clipboard.readText().then(text => {
                    if (text) {
                        keyboardBuffer = text;
                        cursorPosition = keyboardBuffer.length;
                        updateKeyboardInputDisplay();
                    }
                }).catch(err => {
                    console.error('Failed to read clipboard contents: ', err);
                     alert("粘贴失败，请检查浏览器权限");
                });
            } else {
                 alert("当前浏览器不支持剪贴板API");
            }
        });
    }

    function handleVirtualKeyPress(keyBtn) {
        const keyValue = keyBtn.dataset.key; 
        if (keyValue === 'del') { 
            if (cursorPosition > 0) { 
               keyboardBuffer = keyboardBuffer.substring(0, cursorPosition - 1) + keyboardBuffer.substring(cursorPosition); 
               cursorPosition--; 
            }
        } else if (keyValue === 'enter') { 
            closeKeyboard(true); 
        } else if (keyValue === '←') { 
            if (cursorPosition > 0) cursorPosition--; 
        } else if (keyValue === '→') { 
            if (cursorPosition < keyboardBuffer.length) cursorPosition++; 
        } else if (keyValue === 'shift' && keyBtn.id === 'keyboard-shift-btn') { 
            isShiftActive = !isShiftActive; 
            updateShiftButtonVisual(); 
            updateKeyboardCharKeysCase(); 
             updatePage3ShiftVisual();
        } else if (keyValue === 'shift_page2' && keyBtn.id === 'keyboard-page2-shift-btn') { 
            isPage2ShiftActive = !isPage2ShiftActive;
            updatePage2ShiftButtonVisual();
            updateKeyboardPage2CharKeysAndDataKeys();
        } else {
            let charToInsert = keyValue;
            if (keyValue === '×') charToInsert = '*'; 
            if (keyValue === '÷') charToInsert = '/';
            if (keyBtn.classList.contains('kbd-char') && currentKeyboardPage === 3) {
                 const originalKeyForPage3 = keyBtn.getAttribute('data-original-key') || keyBtn.dataset.key;
                 charToInsert = isShiftActive ? originalKeyForPage3.toUpperCase() : originalKeyForPage3.toLowerCase();
            }
            keyboardBuffer = keyboardBuffer.substring(0, cursorPosition) + charToInsert + keyboardBuffer.substring(cursorPosition);
            cursorPosition += charToInsert.length;
        }
        updateKeyboardInputDisplay();
    }
    
    allKeyboardKeys.forEach(keyBtn => { keyBtn.addEventListener('click', (e) => { e.stopPropagation(); handleVirtualKeyPress(keyBtn); }); });

    document.addEventListener('keydown', (event) => {
        if (!isKeyboardOpen) return; 
        let handled = true; const key = event.key;
        if (key === 'Backspace') { 
            if (cursorPosition > 0) { 
               keyboardBuffer = keyboardBuffer.substring(0, cursorPosition - 1) + keyboardBuffer.substring(cursorPosition); 
               cursorPosition--; 
            }
        } else if (key === 'Enter') { 
            keyboardInputStringForarch = keyboardBuffer; 
            closeKeyboard(true); 
        } else if (key === 'ArrowLeft') { 
            if (cursorPosition > 0) cursorPosition--; 
        } else if (key === 'ArrowRight') { 
            if (cursorPosition < keyboardBuffer.length) cursorPosition++; 
        } else if (key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) { 
            keyboardBuffer = keyboardBuffer.substring(0, cursorPosition) + key + keyboardBuffer.substring(cursorPosition); 
            cursorPosition += key.length; 
        } else {
            handled = false;
        }
        if (handled) { 
            event.preventDefault(); 
            updateKeyboardInputDisplay(); 
        }
    });

document.addEventListener('keydown', (event) => {
        if (!archInstance || isKeyboardOpen) return;
        

        if (event.shiftKey && event.code === 'Space') {
            const isPlotMode = archInstance.currentUIMode === 'plot';
            const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
            if (isPlotMode && isSidebarVisible) {
                event.preventDefault(); // 防止页面滚动
                toggleKeyboard();
                return;
            }
        }
        if (event.shiftKey && (event.key === 'R' || event.key === 'r')) {
             if (archInstance.is3DMode) {
                archInstance.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
                archInstance.center3D = { x: 0, y: 0, z: 0 };
                archInstance.offset3D = { x: 0, y: 0 };
                archInstance.scale3D = 1.0;
                archInstance.bounds3D = 8;
                archInstance.recalculate3D();
            } else {
                archInstance.scale = 100; 
                archInstance.centerCanvas();
            }
            archInstance.clearPlotData();
            archInstance.requestDraw();
            event.preventDefault();
            return;
        }

        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

        const panAmount = 20;
        const zoomFactor = 1.1;
        let handled = false;


        if (archInstance.is3DMode) {
             const moveStep = panAmount / archInstance.scale3D; 
             switch (event.key) {
                case 's': archInstance.offset3D.y -= moveStep*0.04; handled = true; break;
                case 'w': archInstance.offset3D.y += moveStep*0.04; handled = true; break;
                case 'd': archInstance.offset3D.x += moveStep*0.04; handled = true; break;
                case 'a': archInstance.offset3D.x -= moveStep*0.04; handled = true; break;
                
                case 'ArrowUp': 
                    archInstance.scale3D *= zoomFactor;
                    if (archInstance.scale3D > 100.0) archInstance.scale3D = 100.0;
                    handled = true;
                    break;
                case 'ArrowDown': 
                    archInstance.scale3D /= zoomFactor;
                    if (archInstance.scale3D < 0.001) archInstance.scale3D = 0.001;
                    handled = true;
                    break;
            }
             if (handled) {
                event.preventDefault();
                archInstance.recalculate3D();
                archInstance.requestDraw();
            }
        } 

        else {
            switch (event.key) {
                case 's': archInstance.offset.y -= panAmount; handled = true; break;
                case 'w': archInstance.offset.y += panAmount; handled = true; break;
                case 'd': archInstance.offset.x -= panAmount; handled = true; break;
                case 'a': archInstance.offset.x += panAmount; handled = true; break;
                
                case 'ArrowUp': {
                    const cssWidth = archInstance.canvas.clientWidth;
                    const cssHeight = archInstance.canvas.clientHeight;
                    const centerX = cssWidth / 2; const centerY = cssHeight / 2;
                    const centerXMath = (centerX - archInstance.offset.x) / archInstance.scale;
                    const centerYMath = (archInstance.offset.y - centerY) / archInstance.scale;
                    let newScale = archInstance.scale * zoomFactor;
                    newScale = Math.min(archInstance.maxScale, Math.max(archInstance.minScale, newScale));
                    archInstance.offset.x = centerX - centerXMath * newScale;
                    archInstance.offset.y = centerY + centerYMath * newScale;
                    archInstance.scale = newScale;
                    handled = true;
                    break;
                }
                case 'ArrowDown': {
                    const cssWidth = archInstance.canvas.clientWidth;
                    const cssHeight = archInstance.canvas.clientHeight;
                    const centerX = cssWidth / 2; const centerY = cssHeight / 2;
                    const centerXMath = (centerX - archInstance.offset.x) / archInstance.scale;
                    const centerYMath = (archInstance.offset.y - centerY) / archInstance.scale;
                    let newScale = archInstance.scale / zoomFactor;
                    newScale = Math.min(archInstance.maxScale, Math.max(archInstance.minScale, newScale));
                    archInstance.offset.x = centerX - centerXMath * newScale;
                    archInstance.offset.y = centerY + centerYMath * newScale;
                    archInstance.scale = newScale;
                    handled = true;
                    break;
                }
            }
            if (handled) {
                event.preventDefault();
                archInstance.clearPlotData();
                archInstance.requestDraw();
            }
        }
    });


    document.addEventListener('click', (e) => {
        const isSidebarNav = e.target.closest('#sidebar-nav-buttons');
        const isKeyboardToggle = e.target.closest('#keyboard-toggle-container');
        const isEditEntryButton = e.target.closest('.edit-btn');

        const isValueTrigger = e.target.closest('.frame-current-value') || 
                               e.target.closest('.frame-total-value') || 
                               e.target.closest('.frame-fps-value') || 
                               e.target.closest('.display-frame-value') ||
                               e.target.closest('.slice-val-value') || 
                               e.target.closest('#explicit-precision-value') ||
                               e.target.closest('#implicit-precision-value') ||
                               e.target.closest('#integral-precision-value') ||
                               e.target.closest('#preferred-color-value') ||
                               e.target.closest('#tmin-value') ||
                               e.target.closest('#tmax-value') ||
                               e.target.closest('.slider-min-value') || 
                               e.target.closest('.slider-max-value') || 
                               e.target.closest('.slider-step-value');

        if (isSidebarNav || isKeyboardToggle || isEditEntryButton || isValueTrigger) {
            return;
        }
        
        const targetIsSidebarRelated = e.target.closest('#sidebar') || e.target.closest('#sidebar-background');
        const targetIsKeyboardRelated = keyboard.contains(e.target);

        if (isKeyboardOpen && !targetIsKeyboardRelated) {
            const isTapOnKeyboardInput = e.target === keyboardInputDisplay || keyboardInputDisplay.contains(e.target);
            if (!isTapOnKeyboardInput) {
                closeKeyboard(false); 
            }
        }
    });

if (newFileBtn && archInstance) {
        newFileBtn.addEventListener('click', () => {
            archInstance.entries = []; archInstance.variables.clear();

            archInstance.annotations = [];
            archInstance.calcJSUtils.customFunctions = {}; archInstance.calcJSUtils.calc3 = [];
            ADVANCED_FUNCTION_DEFINITIONS.length = 22; 
            archInstance.initializeAdvancedCalcJSFunctions();
            archInstance.initializeCalcJSBuiltinFunctions(); 
            archInstance.recalculateAll();
            handleNavClick('plot');
        });
    }

    if (loadFileBtnMenu && archInstance) {
        loadFileBtnMenu.addEventListener('click', () => { 
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = re => {
                        archInstance.loadState(re.target.result);
                        handleNavClick('plot');
                    };
                    reader.readAsText(file);
                }
            };
            fileInput.click();
        }); 
    }
    
    if (saveFileBtnMenu && archInstance) {
        saveFileBtnMenu.addEventListener('click', () => { 
            archInstance.saveState(); 
            handleNavClick(archInstance.currentUIMode);
        }); 
    }

    updateKeyboardInputDisplay();
    updateInterfaceState();
});

