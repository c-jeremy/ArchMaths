<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arch Maths</title>
    <style>

           :root {
            --bg-color: #ddd;
            --sidebar-bg-color: #f0f0f0;
            --sidebar-border-color: #ccc;
            --entry-item-bg-color: #f8f8f8; 
            --entry-item-hover-bg-color: rgba(255, 255, 255, 0);
            --entry-item-separator-color: #c3c3c3; 
            --controls-border-color: #eee;
            --add-btn-bg-color: #e0e0e0;
            --add-btn-text-color: #000000; 
            --text-color-default: #333;
            --text-color-subtle: #555;
            --text-color-error: #cc0000;
            --text-color-accent: #007bff; 
            --variable-indicator-dependent-color: #999999; 
            --variable-indicator-independent-paused-color: var(--text-color-accent); 
            --variable-indicator-independent-playing-color: orange; 
            --canvas-bg-color: rgb(255, 255, 255);
            --input-range-track-bg: #d3d3d3;
            --overlay-bg-color: rgba(255, 255, 255, 0.85);
            --overlay-text-color: #333;
            --switch-off-bg-color: #ccc;
            --switch-on-bg-color: var(--text-color-accent); 
            --axis-number-color: #333;
            --menu-bg-color: rgba(255, 255, 255, 0.95);
            --keyboard-bg-color: rgba(255, 255, 255, 0.95);
             --code-input-bg-color: rgba(255, 255, 255, 0.5);
        }

        :root[data-theme="dark"] {
            --bg-color: #2e2e2e;
            --sidebar-bg-color: #383838;
            --sidebar-border-color: #4a4a4a;
            --entry-item-bg-color: #3f3f3f;
            --entry-item-hover-bg-color: rgba(85, 85, 85, 0);
            --entry-item-separator-color: #505050;
            --controls-border-color: #4a4a4a;
            --add-btn-bg-color: #555555;
            --add-btn-text-color: #e0e0e0;
            --text-color-default: #e0e0e0;
            --text-color-subtle: #b0b0b0;
            --text-color-error: #ff6b6b;
            --text-color-accent: #36a2ff; 
            --variable-indicator-dependent-color: #888888; 
            --variable-indicator-independent-paused-color: var(--text-color-accent); 
            --variable-indicator-independent-playing-color: orange; 
            --canvas-bg-color: #1e1e1e;
            --input-range-track-bg: #555;
            --overlay-bg-color: rgba(40, 40, 40, 0.85);
            --overlay-text-color: #e0e0e0;
            --switch-off-bg-color: #555;
            --switch-on-bg-color: var(--text-color-accent); 
            --axis-number-color: #ffffff;
            --menu-bg-color: rgba(50, 50, 50, 0.95);
            --keyboard-bg-color: rgba(50, 50, 50, 0.95);
            --code-input-bg-color: rgba(0, 0, 0, 0.25);
        }
         :root[data-theme="dark"] .menu-nav-rect-btn {
            background-color: hsla(var(--preferred-hue, 0), 0%, 25%, 0.95);
        }
        :root[data-theme="dark"] #keyboard-input-display {
            background-color: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: var(--text-color-default);
        }
         :root[data-theme="dark"] #keyboard-input-display .cursor {
            background-color: var(--text-color-default);
        }

        :root[data-theme="dark"] #keyboard-input-display .cursor {
            background-color: var(--text-color-default);
        }
        :root[data-theme="dark"] #keyboard-copy-btn img,
        :root[data-theme="dark"] #keyboard-paste-btn img,
        :root[data-theme="dark"] #keyboard-input-prompt-btn img {
            filter: invert(1);
        }

#stop-trace-btn {
            position: absolute;
            top: 15px;
            right: 268px; 
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(255, 182, 193, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s, visibility 0.3s, right 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        :root[data-theme="dark"] #stop-trace-btn {
            background-color: rgba(60, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        :root[data-theme="dark"] #stop-trace-btn img {
            filter: invert(1);
        }
        #stop-trace-btn:active {
            transform: scale(0.95);
        }

 #stage-mode-toggle-btn {
            position: absolute;
            top: 15px;
            right: 207px; 
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(240, 240, 240, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s, visibility 0.3s;
        }

       :root[data-theme="dark"] #annotation-split-btn,
        :root[data-theme="dark"] #reset-view-btn,
        :root[data-theme="dark"] #view-mode-toggle-circle,
        :root[data-theme="dark"] #stage-mode-toggle-btn {
            background-color: rgba(60, 60, 60, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }



        :root[data-theme="dark"]
 #stage-mode-toggle-btn {
            background-color: rgba(60, 60, 60, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #stage-mode-toggle-btn:active {
            transform: scale(0.95);
        }

    #stage-manager-container {

            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            z-index: 2000;
            display: none;
            overflow: hidden;
font-family: 'HarmonyOS_SC', Arial, sans-serif;
            transition: background-color 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            perspective: 1200px;
        }

body.stage-mode-active #stage-manager-container {
            display: block;
            background-color: #222;
            pointer-events: auto;
        }


        body.stage-mode-active > *:not(#stage-manager-container) {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }

.sm-window {
            position: absolute;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1), 
                        width 0.6s cubic-bezier(0.16, 1, 0.3, 1), 
                        height 0.6s cubic-bezier(0.16, 1, 0.3, 1),
                        opacity 0.4s ease,
                        filter 0.2s ease,
                        border-color 0.2s ease;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: #333;
            background-position: center;
            background-repeat: no-repeat;
            transform-style: preserve-3d;
            transform-origin: center center;
            user-select: none;
            -webkit-user-select: none;
        }

      .sm-name-label {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            text-shadow: 0 1px 4px rgba(0,0,0,0.8), 0 0 2px rgba(0,0,0,1); 
            pointer-events: none;
            z-index: 20;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        .sm-window.stage-thumbnail {
            z-index: 10;
            filter: brightness(0.7);
        }
        
       .sm-window.stage-thumbnail:hover {
            filter: brightness(1);
            border-color: rgba(255, 255, 255, 0.5);
        }


        .sm-window.stage-center {
            cursor: default;
            z-index: 500; 
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
        }
 
          body.is-touch-device .sm-window .sm-close-btn {
            opacity: 1 !important;
        }

        :root[data-theme="dark"] #stage-mode-toggle-btn img {
            filter: invert(1);
        }

        .sm-close-btn {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 24px;
            height: 24px;
            background: rgba(80, 80, 80, 0.9);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .sm-window:hover .sm-close-btn {
            opacity: 1;
        }

        .sm-close-btn:hover {
            background: #ff453a;
            border-color: #ff453a;
        }

        .sm-close-btn::before {
            content: "×";
            position: relative;
            top: -1px;
        }

         .sm-add-btn {
            position: fixed;
            left: 30px;
            bottom: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(128, 128, 128, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-color-default);
            font-size: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 2000; 
            line-height: 1;
            opacity: 0;
            transform: translateY(20px);
            user-select: none;
            -webkit-user-select: none;
        }
        body.stage-mode-active .sm-add-btn {
            opacity: 1;
            transform: translateY(0);
        }

        .sm-add-btn:hover {
            background: rgba(160, 160, 160, 0.6);
            transform: scale(1.1);
        }
        
        .sm-hint {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: var(--text-color-subtle);
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s 0.2s;
        }
        
        body.stage-mode-active .sm-hint {
            opacity: 0.7;
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-family: 'HarmonyOS_SC', Arial, sans-serif; 
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color-default);
            flex-direction: row;
        }
        body.sidebar-resizing #main-button-container,
body.sidebar-resizing #keyboard-toggle-container,
body.sidebar-resizing #entry-list,
body.sidebar-resizing #geometry-panel {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s ease !important;
}

        body.portrait-mode {
            flex-direction: column;
        }

#sidebar-background {
            position: absolute;
            top: 10px;
            left: 10px;
            bottom: 10px;
            width: 420px;
            min-width: 400px;
            max-width: 80vw;
            z-index: 1;
            border-radius: 25px;
            background-color: rgba(240, 240, 240, 0.65);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, width 0.2s ease, height 0.2s ease;
        }
        #sidebar-background::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 48px;
            height: calc(100% - 16px);
            border-radius: 24px;
            background-color: rgba(250, 250, 250, 0.9);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 0;
        }

        :root[data-theme="dark"] #sidebar-background::before {
            background-color: rgba(255, 255, 255, 0.08); 
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        :root[data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) #sidebar-background::before {
            background-color: hsla(var(--preferred-hue, 0), 20%, 95%, 0.8);
        }

body.portrait-mode #sidebar-background {
            top: auto;
            left: 10px;
            right: 10px;
            bottom: 10px;
            width: auto;
            height: 250px;
            min-height: 150px;
            max-height: 60vh;
            min-width: auto;
        }
        body.portrait-mode #sidebar-background::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 6px;
            border-radius: 3px;
            background-color: black;
            cursor: row-resize;
            transition: all 0.2s ease-in-out;
        }
        body.portrait-mode #sidebar-background:hover::after {
            width: 50px;
            height: 10px;
            border-radius: 5px;
        }
        :root[data-theme="dark"] body.portrait-mode #sidebar-background::after {
            background-color: white;
        }

        :root[data-theme="dark"] #sidebar-background {
            background-color: rgba(56, 56, 56, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        :root[data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) #sidebar-background {
            background-color: hsla(var(--preferred-hue, 0), 25%, 90%, 0.7);
        }

        #sidebar {
            position: absolute;
            top: 15px;
            left: 15px;
            bottom: 15px;
            width: 420px;
            min-width: 400px;
            max-width: 80vw;
            height: auto;
            background: transparent;
            display: flex;
            flex-direction: column;
            z-index: 5;
            cursor: default;
            user-select: none;
            border: none;
            box-sizing: border-box;
            touch-action: none;
            flex-shrink: 0;
            pointer-events: none;
        }

        #sidebar > * {
            pointer-events: auto;
        }

        #sidebar::after, #sidebar::before {
            content: none;
        }

        .menu-nav-panel > .menu-nav-rect-btn {
            padding: 10px;
        }
        

       

        #main-content-title {
            position: absolute;
            top: 30px;
            left: 85px;
            z-index: 5;
            font-weight: bold;
            font-size: 24px;
            color: black;
            pointer-events: none;
            user-select: none;
            transition: opacity 0.2s ease, left 0.2s ease;
            display: none;
        }
        :root[data-theme="dark"] #main-content-title {
            color: white;
        }
        body.portrait-mode #main-content-title {
            display: none !important;
        }
#geometry-panel {
            padding: 70px 15px 90px 68px;            overflow-y: auto;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-sizing: border-box;
            -webkit-mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
            mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
        }

        .geo-btn-row {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
            margin-bottom: 10px;         }
        
.geo-btn {
            width: 95px;
            flex-shrink: 0;
            height: 95px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            user-select: none;
            position: relative;
            text-align: center;
            padding: calc(95px * 0.05) 5px calc(95px * 0.15) 5px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.5) !important;
            backdrop-filter: blur(15px) saturate(180%);
            -webkit-backdrop-filter: blur(15px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.4) !important;
            box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.05);
            color: #222 !important;
        }

        :root[data-theme="dark"] .geo-btn {
            background-color: rgba(60, 60, 60, 0.45) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 4px 15px 0 rgba(0, 0, 0, 0.3);
            color: #e0e0e0 !important;
        }

        .geo-btn-icon {
            height: 75%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
          
        }

        .geo-btn-icon img {
            width: 45px;
            height: 45px;
            outline-color: 1;
        }

:root[data-theme="dark"] .geo-btn-icon img {
            filter: invert(1);
        }

        .geo-btn-text {
            height: 20%;
            font-size: 0.8em;            display: flex;
            align-items: center;
            justify-content: center;

        }

        .geo-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
        }
.geo-btn:active, .geo-btn.active {
    filter: brightness(0.95);
    transform: translateY(0);
    box-shadow: none; }

.geo-btn.active::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 8px;     width: calc(100% - 16px);
    height: 8px;
    border-radius: 4px;
    background-color: var(--geo-btn-active-underline-color, #36a2ff);
}
        #geometry-interaction-prompt {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(-50%, -150%);
            opacity: 0;
            background-color: rgba(80, 80, 80, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.1em;
            font-weight: bold;
            z-index: 1003;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                        transition: transform 0.1s cubic-bezier(0.55, 0.055, 0.675, 0.19), opacity 0.1s ease-in;
        }
        #geometry-interaction-prompt.show {
            transform: translate(-50%, 0);
            opacity: 1;
                        transition: transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.1s ease-out;
        }

        body.portrait-mode #sidebar {
            top: auto;
            left: 15px;
            right: 15px;
            bottom: 15px;
            width: auto;
            height: 250px;
            min-height: 150px;
            max-height: 60vh;
            border: none;
            order: 2;
            min-width: auto;
        }
      
       

#entry-list {
            flex: 1;
            overflow-y: auto;
            padding: 70px 15px 90px 58px;
            min-height: 50px;
            position: relative; 
            z-index: 1;         
            -webkit-mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
            mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
        }

        body.portrait-mode #entry-list,
        body.portrait-mode #geometry-panel {
            padding: 20px 20px 100px 20px;
            -webkit-mask-image: linear-gradient(transparent, black 20px, black calc(100% - 120px), transparent);
            mask-image: linear-gradient(transparent, black 20px, black calc(100% - 120px), transparent);
        }
        
        .entry-item {
            padding: 10px 15px;
            margin: 0 0 10px 0;
            word-break: break-all;
            cursor: default;
            position: relative;
            border-radius: 20px;
            background-color: rgba(255, 255, 255, 0.13);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: none;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            font-size: 1.1em;
            box-sizing: border-box;
            transition: box-shadow 0.3s ease, background-color 0.3s ease, width 0.1s ease-out;
        }
        
        :root[data-theme="dark"] .entry-item {
            background-color: rgba(70, 70, 70, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .entry-item.expanded {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        :root[data-theme="dark"] .entry-item.expanded {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }

        .entry-item:not(:last-child) {
            border-bottom: none; 
        }

.entry-item:hover, .entry-item.expanded {
    background-color: var(--entry-item-hover-bg-color);
}

.entry-item:not(.variable-item):not(.constant-item):not(.custom-function-definition-item):not(.advanced_custom_function_definition-item)::before {
             content: '';
             position: absolute;
             left: 4.4px;
             top: 12px;
             width: 11.2px;
             height: 2em;
             background-color: var(--entry-color, transparent);
             border-radius: 8px;
             opacity: var(--entry-visible-opacity, 1);
             margin-top: 0;
             margin-bottom: 0;
             bottom: auto;
        }

        .entry-item.variable-item::before,
        .entry-item.constant-item::before,
        .entry-item.custom-function-definition-item::before,
        .entry-item.advanced_custom_function_definition-item::before {
            content: '';
            position: absolute;
            left: 4.4px;
            top: 28px;
            transform: translateY(-50%);
            width: 11.2px;
            height: 11.2px;
            border-radius: 50%;
            background-color: var(--variable-indicator-color, var(--variable-indicator-dependent-color));
            margin-top: 0;
            margin-bottom: 0;
            bottom: auto;
        }
.entry-item.expanded.variable-item::before,
.entry-item.expanded.constant-item::before,
.entry-item.expanded.custom-function-definition-item::before,
.entry-item.expanded.advanced_custom_function_definition-item::before {
    top: 28px;
    transform: translateY(-50%);
}
         .entry-item.custom-function-definition-item::before,
         .entry-item.advanced_custom_function_definition-item::before {
              background-color: var(--text-color-subtle); 
         }
         .entry-item.constant-item::before {
            background-color: var(--variable-indicator-dependent-color);
         }


        .entry-item.function-hidden .entry-text-area {
            opacity: 0.6;
        }
        

.entry-text-area {
    flex-grow: 1;
    padding: 5px 15px 5px 20px;
    box-sizing: border-box;
    cursor: pointer;
    user-select: none;
}

.entry-item .entry-text-area > div { white-space: normal; word-wrap: break-word;  display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis;max-height: 3.2em; }  .entry-item.expanded .entry-text-area > div { max-height: 3.2em !important; overflow: hidden !important; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }

.entry-main-row {
    display: flex;
    justify-content: space-between;
    align-items: center; 
    gap: 8px;
    position: relative; 
    min-height: 28px;
}

body.is-touch-device .entry-item.expanded .entry-main-row {
    flex-direction: column;
    align-items: flex-start;
}

.entry-actions-new {
    position: absolute;
    top: 2px;
    right: 10px;
    transform: none;
    display: flex;
    flex-shrink: 0;
    gap: 8px;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
    background-color: var(--entry-item-hover-bg-color);
    padding: 4px 8px;
    border-radius: 16px;
    box-shadow: none;
}

.entry-item:hover .entry-actions-new {
    opacity: 1;
    pointer-events: auto;
}
body.is-touch-device .entry-item:not(.advanced_custom_function_definition-item) .entry-actions-new {
    display: none; }

body.is-touch-device .entry-item.expanded .entry-actions-new {
    display: flex;
    position: static; 
    opacity: 1;
    pointer-events: auto;
    background-color: transparent;
    width: 100%;
    margin-top: 1px;
    padding: 0;
    justify-content: flex-end; 
    gap: 15px;
}

body.is-touch-device .entry-item .color-toggle-btn,
body.is-touch-device .entry-item .settings-toggle-btn {
    display: none !important;
}

.entry-actions-new .action-btn {
    cursor: pointer;
    font-size: 20px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-color-subtle);
    user-select: none;
}

body.is-touch-device .entry-actions-new .action-btn {
    background-color: var(--add-btn-bg-color);
    width: 44px;
    height: 32px;
    border-radius: 16px;
    color: var(--add-btn-text-color);
}
body.is-touch-device .entry-actions-new .action-btn.delete-btn {
    background-color: rgba(255, 50, 50, 0.15);
}

body.is-touch-device .entry-actions-new .action-btn img {
    opacity: 1;
    width: 18px;
    height: 18px;
}



.entry-actions-new .action-btn:hover {
    color: var(--text-color-default);
}



:root[data-theme="dark"] .entry-actions-new .action-btn {
    filter: invert(0.8);
}

:root[data-theme="dark"] .entry-actions-new .action-btn:hover {
    filter: invert(1);
}

.entry-expandable-content {
    overflow: hidden;
    max-height: 0;
    opacity: 0;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    padding: 0 10px;
}

.entry-item.expanded .entry-expandable-content {
    max-height: 500px;
    opacity: 1;
    padding-top: 12px;
    margin-top: 8px;
    border-top: 1px solid var(--controls-border-color);
}

.independent-variable-item .variable-slider-wrapper {
    padding: 5px 10px;
}

.entry-expandable-content .variable-controls,
.entry-expandable-content .function-controls {
    padding: 0;
    max-height: none;
    opacity: 1;
    margin: 0;
    border: none;
    pointer-events: auto;
}


         .entry-item.variable-item .entry-text-area,
         .entry-item.constant-item .entry-text-area,
         .entry-item.custom-function-definition-item .entry-text-area,
         .entry-item.advanced_custom_function_definition-item .entry-text-area {
              color: var(--text-color-subtle);
              cursor: default;
         }
          .entry-item.variable-item.independent-variable-item .entry-text-area {
               cursor: pointer;
          }
          .entry-item.variable-item.independent-variable-item .entry-text-area:hover {
               text-decoration: underline dotted #888;
          }
          .entry-item.constant-item .entry-text-area:hover { 
               text-decoration: none;
          }


         .entry-item .entry-value {
             font-size: 0.9em;
             color: var(--text-color-default);
             margin-left: 5px;
         }


         .entry-item.independent-variable-item .entry-value-editable {
              text-decoration: underline dotted #888;
              cursor: pointer;
         }



         .variable-controls .slider-value-display,
         .variable-controls .slider-props,
         .function-controls .slider-group {
             font-size: 0.9em;
             color: var(--text-color-subtle);
             margin-bottom: 8px;
             word-break: normal;
         }
         .variable-controls .slider-props span {
              cursor: pointer;
              text-decoration: underline dotted #888;
         }

         .function-controls .slider-group {
             display: flex;
             align-items: center;
             margin-bottom: 8px;
             gap: 5px;
         }
.function-controls .slider-group label {
             width: 60px;
             flex-shrink: 0;
             box-sizing: border-box;
         }

        .custom-slider-container {
            width: 100%;
            height: 24px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
.function-controls .slider-group .custom-slider-container {
            flex: 1;
            min-width: 50px;
        }
        .settings-slider {
            height: 24px;
            width: 100%;
            margin-top: 5px;
        }
        .variable-controls .custom-slider-container {
            margin: 5px 0;
        }


        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            overflow: hidden;
            touch-action: none;
        }

         body.portrait-mode #canvas-container {
             order: 1;
         }

        #plot-canvas {
            background: var(--canvas-bg-color);
            cursor: grab;
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        #axis-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

#plot-canvas:active {
            cursor: grabbing;
        }

        #fps-display {
             position: absolute;
             bottom: 10px;
             right: 10px;
             z-index: 10;
             background-color: var(--overlay-bg-color);
             padding: 3px 6px;
             border-radius: 4px;
             font-size: 0.9em;
             color: var(--overlay-text-color);
             pointer-events: none;
             user-select: none;
         }
         #info-display {
            position: absolute;
            top: 35px;
            left: 370px;
            z-index: 10;
            background-color: var(--overlay-bg-color);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--overlay-text-color);
            pointer-events: none;
            user-select: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, left 0.2s ease;
        }

        #info-display.show {
            opacity: 1;
        }

        #geometry-measurement-display {
            position: absolute;
            top: 60px;
            right: 15px;
            z-index: 10;
            background-color: var(--overlay-bg-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--overlay-text-color);
            pointer-events: none;
            user-select: none;
            text-align: right;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        #geometry-measurement-display div {
            white-space: nowrap;
        }
.settings-from-core-wrapper h3 {
            margin-top: 15px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--controls-border-color);
        }

.settings-nav-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            justify-content: flex-start;
        }
        .settings-nav-btn {
            width: 150px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0;
            border-radius: 18px;
            background-color: var(--add-btn-bg-color);
            color: var(--add-btn-text-color);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
.settings-nav-btn.active {
            background-color: rgba(255, 255, 255, 0.65) !important;
            backdrop-filter: blur(15px) saturate(180%);
            -webkit-backdrop-filter: blur(15px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.1);
            color: var(--text-color-accent) !important;
        }

        :root[data-theme="dark"] .settings-nav-btn.active {
            background-color: rgba(60, 60, 60, 0.6) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
            box-shadow: 0 4px 15px 0 rgba(0, 0, 0, 0.4);
            color: #ffffff !important;
        }

        .settings-nav-btn img {
            width: 20px;
            height: 20px;
            transition: all 0.2s ease;
        }

        /* 高亮状态下的图标颜色处理 */
        .settings-nav-btn.active img {
            /* 在浅色模式下，将图标滤镜设为蓝色（对应 accent color） */
            filter: invert(31%) sepia(94%) saturate(1185%) hue-rotate(189deg) brightness(95%) contrast(105%);
            opacity: 1;
        }

        :root[data-theme="dark"] .settings-nav-btn.active img {
            /* 在深色模式下，将图标滤镜设为纯白 */
            filter: brightness(0) invert(1);
        }
 :root[data-theme="dark"] .settings-nav-btn:not(.active) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="dark"] .settings-nav-btn:not(.active) img {
            filter: invert(1);
            opacity: 0.7;
        }
        .settings-panel-content .settings-item-row > label,
        .settings-panel-content .settings-item > label {
             display: flex;
             align-items: center;
             gap: 16px;
        }
        .settings-item-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        :root[data-theme="dark"] .settings-item-icon {
            filter: invert(1);
        }
        body.portrait-mode .settings-nav-btn span {
            display: none;
        }
        body.portrait-mode .settings-nav-btn {
            flex: 1;
            width: auto;
            min-width: 40px;
        }
        .settings-panel-content {
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        .settings-panel-content.active {
            display: flex;
        }
        .settings-from-core-wrapper .settings-item,
        .settings-panel-content .settings-item {
             display: flex;
             flex-wrap: wrap;
             justify-content: space-between;
             align-items: center;
        }
        .settings-from-core-wrapper .settings-item-row,
        .settings-panel-content .settings-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-grow: 1;
        }
        .settings-panel-content .settings-item-row label {
            font-size: 1em;
        }
        .settings-from-core-wrapper .settings-comment,
        .settings-panel-content .settings-comment {
            font-style: italic;
            color: var(--text-color-subtle);
            font-size: 0.9em;
            margin-top: 2px;
            flex-basis: 100%;
        }
         .settings-panel-content .precision-value {
              font-size: 0.9em;
              cursor: pointer;
              text-decoration: underline dotted #888;
         }
#grid-style-buttons {
            justify-content: flex-end;
            gap: 8px;
            display: flex;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        #grid-style-buttons button {
            flex: 0 1 120px;
            max-width: 120px;
            height: 30px;
            min-width: auto;
            border-radius: 15px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            background-color: var(--add-btn-bg-color);
            color: var(--add-btn-text-color);
            transition: all 0.2s ease;
            text-align: center;
        }
        .settings-from-core-wrapper .button-group button.active,
        .settings-panel-content .button-group button.active {
            background-color: var(--text-color-accent);
            color: white;
        }
                #settings-panel-coords .button-group {
            justify-content: flex-end;
        }
        #settings-panel-coords .button-group button {
             flex: 0 1 auto;
             min-width: auto;
             max-width: 75px;
             height: 24px;
             border-radius: 12px;
             font-size: 0.9em;
             padding: 0 10px;
         }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
font-family: 'HarmonyOS_SC', Arial, sans-serif;
        }

        body {
            position: relative; 
        }

        .btn {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
            border: none;
            box-shadow: none;
        }
        .btn:active {
            transform: scale(0.95);
        }

        .circle-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            font-size: 15px;
        }

        .small-circle-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 13px;
        }

        .menu-toggle-btn {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            font-size: 16px; 
        }

        .pill-btn {
            height: 50px;
            border-radius: 25px;
            padding: 0 20px;
            font-size: 16px;
            min-width: auto;
        }

        .menu-nav-rect-btn {
            border-radius: 25px;
            padding: 15px;
            background-color: #f2f2f2; 
            display: flex;
            flex-direction: column;
            border: none;
            box-shadow: none;
        }
        .menu-nav-rect-btn.compact-rows {
             line-height: 1.2;
             font-size: 16px;
             padding: 10px;
        }



        .main-ui-btn-color {
            background-color: var(--add-btn-bg-color); 
            color: var(--add-btn-text-color); 
        }
        .main-ui-btn-color:hover {
            filter: brightness(0.9); 
        }

        .keyboard-del-enter-color {
            background-color: #ff6347;
            color: white;
        }
        .keyboard-del-enter-color:hover {
            background-color: #e05030;
        }

        .keyboard-arrow-color {
            background-color: #1e90ff;
            color: white;
        }
        .keyboard-arrow-color:hover {
            background-color: #1070d0;
        }

        .keyboard-default-color {
            background-color: #f0f0f0;
            color: black;
        }
        .keyboard-default-color:hover {
            background-color: #e0e0e0;
        }
        .keyboard-default-color.active-shift {
            background-color: #c0c0c0;
        }
        :root[data-theme="dark"] .keyboard-del-enter-color {
    background-color: #8B3A3A; 
    color: var(--text-color-default);
}
:root[data-theme="dark"] .keyboard-del-enter-color:hover {
    background-color: #A54A4A;
}

:root[data-theme="dark"] .keyboard-arrow-color {
    background-color: #3675B8; 
    color: var(--text-color-default);
}
:root[data-theme="dark"] .keyboard-arrow-color:hover {
    background-color: #4A8CCF;
}


        :root[data-theme="dark"] .keyboard-default-color {
            background-color: rgba(80, 80, 80, 0.8); 
            color: #fff;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        :root[data-theme="dark"] .keyboard-default-color:hover {
            background-color: rgba(100, 100, 100, 0.9);
        }
:root[data-theme="dark"] .keyboard-default-color.active-shift {
    background-color: #5a5a5a; 
    color: var(--text-color-default);
}

        .blue-pill-btn {
            background-color: var(--text-color-accent); 
            color: white;
            font-weight: bold;
            height: 50px; 
            border-radius: 25px; 
            padding: 0 25px;
            font-size: 16px;
        }
        .blue-pill-btn:hover {
            filter: brightness(1.1);
        }


        #keyboard-toggle-btn { 
            height: 64px;
            border-radius: 32px;
            font-weight: bold;
            font-size: 18px;
            padding: 0 35px; 
        }
        #keyboard-copy-btn {
            height: 32px;
            border-radius: 16px;
            padding: 0 15px;
            font-size: 14px;
        }
                #keyboard-paste-btn {
            height: 32px;
            border-radius: 16px;
            padding: 0 15px;
            font-size: 14px;
        }
                #keyboard-input-prompt-btn {
            height: 32px;
            border-radius: 16px;
            padding: 0 15px;
            font-size: 14px;
        }

        .text-bold-title {
            font-weight: bold;
            font-size: 20px;
        }
        .text-bold-large {
            font-weight: bold;
            font-size: 24px;
        }
        .text-bold-black-xlarge {
            font-weight: 900;
            font-size: 32px;
        }
        .text-bold-italic-gray {
            font-weight: bold;
            font-style: italic;
            color: #888;
            font-size: 16px;
        }

        
               .sidebar-panel {
            display: none;
            overflow-y: auto;
            height: 100%;
            padding: 70px 15px 90px 68px;
            -ms-overflow-style: none;
            scrollbar-width: none;
            -webkit-mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
            mask-image: linear-gradient(transparent, black 80px, black calc(100% - 100px), transparent);
        }

        .sidebar-panel::-webkit-scrollbar {
            display: none;
        }

        #settings-panel .settings-from-core-wrapper,
        #file-panel .menu-file-page-buttons,
        #about-panel .menu-about-page-content {
            padding-left: 12px;
            padding-right: 15px;
        }

        #sidebar-background.fullscreen {
            width: calc(100vw - 20px);
            left: 10px;
            max-width: none;
        }
        #sidebar.fullscreen {
            width: calc(100vw - 30px);
            left: 15px;
            max-width: none;
        }
        
        body.portrait-mode #sidebar-background.fullscreen {
            width: auto;
            left: 10px;
            right: 10px;
            top: 10px;
            bottom: 10px;
            height: auto;
            max-height: none;
        }

.settings-from-core-wrapper {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px; 
            font-size: 1em; 
            color: var(--text-color-default);
            user-select: none;
        }
        .settings-from-core-wrapper > div {
            width: 100%;
        }
        .settings-from-core-wrapper label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 3px;
            color: var(--text-color-default);
        }
        .settings-from-core-wrapper .dev-mode-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            width: 100%;
        }
        .settings-from-core-wrapper .dev-mode-label input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            margin: 0;
        }
        .settings-from-core-wrapper .custom-switch {
            position: relative;
            display: inline-block;
            width: 40px; 
            height: 22px; 
            flex-shrink: 0;
        }
        .settings-from-core-wrapper .custom-switch-track,
        .settings-from-core-wrapper .custom-switch-handle {
            transition: .2s;
        }
        .settings-from-core-wrapper .custom-switch-track {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--switch-off-bg-color);
            border-radius: 22px;
        }
        .settings-from-core-wrapper .custom-switch-handle {
            position: absolute;
            content: "";
            height: 18px; 
            width: 18px;  
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
        }
        .settings-from-core-wrapper .dev-mode-label input[type="checkbox"]:checked + .custom-switch .custom-switch-track {
            background-color: var(--switch-on-bg-color);
        }
        .settings-from-core-wrapper .dev-mode-label input[type="checkbox"]:checked + .custom-switch .custom-switch-handle {
            transform: translateX(18px); 
        }
        .settings-from-core-wrapper .precision-value {
              font-size: 0.8em;
              cursor: pointer;
              text-decoration: underline dotted #888;
         }
        .settings-from-core-wrapper .button-group {
             display: flex;
             gap: 8px;
             flex-wrap: wrap;
        }
        .settings-from-core-wrapper .button-group button {
             flex: 1 1 auto;
             min-width: 40%;
         }
        .settings-from-core-wrapper button {
            padding: 8px 12px; 
            background: var(--add-btn-bg-color);
            color: var(--add-btn-text-color);
            border: none;
            cursor: pointer;
            border-radius: 20px; 
            font-weight: bold;
            text-align: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-sizing: border-box;
            user-select: none;
            font-size: 0.9em; 
            height: 36px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .settings-from-core-wrapper button.small-text {
             font-size: 0.9em;
         }
        .settings-from-core-wrapper button:hover {
            filter: brightness(1.1);
        }
        .settings-from-core-wrapper button:active {
            filter: brightness(0.9);
            transform: scale(0.98);
        }
        body.portrait-mode #sidebar-background.fullscreen {
            width: auto;
            left: 10px;
            right: 10px;
            top: 10px;
            bottom: 10px;
            height: auto;
            max-height: none;
        }

        body.portrait-mode #sidebar.fullscreen {
            width: auto;
            left: 15px;
            right: 15px;
            top: 15px;
            bottom: 15px;
            height: auto;
            max-height: none;
        }

        .menu-file-page-buttons {
            display: flex;
            flex-direction: row;
            gap: 30px;
            align-items: flex-start;
            padding-top: 20px;
        }

        .menu-file-page-buttons .pill-btn {
            width: 220px;
        }

.main-actions-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .example-actions-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
        }
        
        .example-actions-group .btn {
            background-color: #a0c4e4;
            color: #1f3c55;
            font-weight: bold;
            height: 44px;
            border-radius: 22px;
            padding: 0 5px;
            font-size: 15px;
            width: 100%;
            justify-content: center;
        }

        .example-actions-group .btn:hover {
            filter: brightness(1.1);
        }

        body.portrait-mode .menu-file-page-buttons {
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        body.portrait-mode .main-actions-group {
            width: 100%;
        }

        body.portrait-mode .example-actions-group {
            width: 100%;
            grid-template-columns: 1fr;
        }
        
        body.portrait-mode .main-actions-group .pill-btn {
            width: 100%;
        }

        .menu-about-page-content {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 30px;
            padding-top: 20px;
        }

        .about-icon-container {
            flex-shrink: 0;
        }

        .about-icon-container img {
            width: 200px;
            height: 200px;
        }

        .about-text-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menu-about-page-content .text-bold-black-xlarge {
            margin-bottom: 10px;
        }
        
        #keyboard-toggle-container {
    position: absolute;
    bottom: 30px;
    left: 75px;
    z-index: 900 !important; 
    transition: left 0.2s ease;
    
    /* --- 核心修复 --- */
    display: flex ;           /* 强制弹性布局 */
    flex-direction: row !important;     /* 强制横向排列 */
    align-items: center !important;     /* 垂直居中 */
    flex-wrap: nowrap !important;       /* 禁止换行 */
    width: auto !important;             /* 宽度自适应内容 */
    height: auto !important;
    pointer-events: none;               /* 容器本身透传点击 */
}

/* 让容器内的按钮恢复点击响应 */
#keyboard-toggle-container > * {
    pointer-events: auto;
}

        #keyboard {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: calc(100% - 10px);
            height: auto;
            max-height: calc(40vh + 15px);
            min-height: 215px;
            

            background-color: rgba(245, 245, 245, 0.75) !important;
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.1);
            
            display: flex;
            flex-direction: column;
            padding: 10px 10px 10px 10px;
            z-index: 1000;
            overflow: hidden;
            transform: translateY(calc(100% + 10px));
            opacity: 0;
            visibility: hidden;
            transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.35s ease-in-out;
            color: var(--text-color-default);
            border-radius: 20px;
        }


        :root[data-theme="dark"] #keyboard {
            background-color: rgba(45, 45, 45, 0.75) !important; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
        }
        #keyboard.open {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }

#keyboard-input-area-container {
            display: flex;
            align-items: center;
            padding: 0px 0;
            margin-bottom: 5px;
            gap: 10px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        @media (max-width: 600px) {
            #keyboard-input-display {
                order: 99;
                width: 100%;
                flex-basis: 100%;
                margin-top: 5px;
            }
            .keyboard-page-nav {
                margin-right: auto;
            }
        }

        .keyboard-page-nav {
            display: flex;
            gap: 5px;
        }
        .keyboard-page-nav .small-circle-btn.active {
            background-color: #c0c0c0;
            font-weight: bold;
        }

        #keyboard-input-display {
            flex-grow: 1;
            height: 36px;
            border-radius: 18px;
            background-color: white;
            border: 1px solid #ccc;
            padding: 0 15px;
            font-size: 18px;
            line-height: 34px;
            overflow-x: auto;
            white-space: nowrap;
            cursor: text;
            position: relative;
            color: var(--text-color-default);
        }
        #keyboard-input-display .char-span {
            display: inline-block;
        }
        #keyboard-input-display .cursor {
            display: inline-block;
            width: 1.5px;
            height: 70%;
            background-color: var(--text-color-default);
            animation: blink 1s step-end infinite;
            position: relative;
            top: 0.15em;
            margin: 0 -0.75px;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }


        .keyboard-buttons-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; 
            gap: 5px; 
            padding-bottom: 5px;
            overflow: hidden; 
        }
        .keyboard-page-content {
            display: none;
            flex-direction: column;
            gap: 5px; 
            width: 100%;
        }
        .keyboard-page-content.active {
            display: flex;
        }
        .keyboard-page-content .btn {
            font-weight: bold;
            flex-grow: 1; 
            flex-basis: 0; 
            min-width: 30px; 
            padding: 0 5px; 
            font-size: clamp(12px, 2.5vw, 15px); 
            height: 36px; 
            border-radius: 18px; 
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        .keyboard-page-content .circle-btn { 
            width: auto;
            aspect-ratio: 1 / 1;
            padding: 0; 
            height: clamp(32px, 7vh, 48px); 
            border-radius: 50%; 
        }


        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 5px; 
            width: 100%;
        }
        .key-group-separator {
            margin-left: 10px !important; 
        }
  #sidebar-nav-buttons {
            position: absolute;
            top: 10px;
            left: 20px;
            bottom: 10px;
            width: 48px;
            z-index: 6;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            pointer-events: none;
        }

        #sidebar-nav-buttons > div {
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: auto;
        }
        .sidebar-nav-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background-color: var(--add-btn-bg-color);
            color: var(--add-btn-text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sidebar-nav-btn:hover {
            transform: scale(1.1);
            filter: brightness(1.1);
        }

        .sidebar-nav-btn.selected {
            background-color: hsl(185, 49%, 91%);
            color: var(--text-color-accent);
            box-shadow: 0 0 6px 1px rgba(0, 123, 255, 0.3);
        }
        
        :root[data-theme="dark"] .sidebar-nav-btn.selected {
            background-color: #01102d;
            color: #ffffff;
            box-shadow: 0 0 6px 1px rgba(54, 162, 255, 0.3);
        }

        :root[data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) .sidebar-nav-btn.selected {
            background-color: hsl(var(--preferred-hue, 0), 30%, 97%);
            color: hsl(var(--preferred-hue, 0), 70%, 55%);
            box-shadow: 0 0 6px 1px hsla(var(--preferred-hue, 0), 70%, 55%, 0.3);
        }
        
        .sidebar-nav-btn img {
            width: 18px;
            height: 18px;
        }

        #show-sidebar-btn img {
            width: 24px;
            height: 24px;
        }

        :root[data-theme="dark"] .sidebar-nav-btn img,
        :root[data-theme="dark"] #show-sidebar-btn img {
            filter: invert(1);
        }
:root[data-transparency-enabled="false"] #sidebar-background {
            background-color: var(--sidebar-bg-color);
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        :root[data-transparency-enabled="false"] .geo-btn,
        :root[data-transparency-enabled="false"] .code-panel-actions .btn,
        :root[data-transparency-enabled="false"] #keyboard-toggle-btn,
        :root[data-transparency-enabled="false"] #global-script-toggle-btn,
        :root[data-transparency-enabled="false"] #global-script-actions .btn {
            background-color: var(--entry-item-bg-color) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        :root[data-transparency-enabled="false"][data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) #sidebar-background {
            background-color: var(--sidebar-bg-color);
        }


#show-sidebar-btn {
            position: fixed;
            bottom: 15px;
            left: 15px;
            z-index: 1001;
            display: none; 
            width: 60px;
            height: 60px;
            background-color: rgba(128, 128, 128, 0.5);
            color: white;
        }
        #show-sidebar-btn:hover {
            background-color: rgba(128, 128, 128, 0.7);
        }


body.sidebar-hidden #show-sidebar-btn {
            display: flex;         }


        body.sidebar-hidden #sidebar,
        body.sidebar-hidden #sidebar-background,
        body.sidebar-hidden #sidebar-nav-buttons {
            display: none;
        }

        
        body.sidebar-hidden #info-display {
            left: 10px;
        }

        body.sidebar-hidden #keyboard-toggle-container {
            display: none;
        }

        #keyboard-toggle-btn {
            height: 64px;
            border-radius: 32px;
            font-weight: bold;
            font-size: 18px;
            padding: 0 25px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;

            background-color: rgba(255, 255, 255, 0.65) !important; 
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);

            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            
            color: #222 !important;
            
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 10;
        }

        #keyboard-toggle-btn:hover {
            background-color: rgba(255, 255, 255, 0.85) !important;
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.25);
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.8);
        }

        #keyboard-toggle-btn:active {
            transform: scale(0.96) translateY(0);
            box-shadow: 0 4px 12px 0 rgba(31, 38, 135, 0.1);
            background-color: rgba(255, 255, 255, 0.9) !important;
        }

        :root[data-theme="dark"] #keyboard-toggle-btn {
            background-color: rgba(30, 30, 30, 0.6) !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0 !important;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
        }

        :root[data-theme="dark"] #keyboard-toggle-btn:hover {
            background-color: rgba(60, 60, 60, 0.75) !important;
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.6);
        }
        
        #keyboard-toggle-btn .keyboard-toggle-icon {
            filter: none;
        }
        
        :root[data-theme="dark"] #keyboard-toggle-btn .keyboard-toggle-icon {
            filter: invert(1);
            opacity: 1;
        }
.keyboard-toggle-icon {
    width: 20px;
    height: 20px;
}
.keyboard-toggle-text {
    font-size: 16px;
}
:root[data-theme="dark"] .keyboard-toggle-icon {
    filter: invert(1);
}
:root[data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) .keyboard-toggle-icon,
:root[data-theme-preferred-color-value]:not([data-theme-preferred-color-value="0"]) .code-panel-actions .btn img {
    filter: invert(1);
}
#keyboard-page-4 {
            flex-direction: row;
            height: 100%;
        }
        .keyboard-geo-grid {
            flex: 7;
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-right: 5px;
        }
        .keyboard-nav-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .keyboard-geo-grid .keyboard-row {
            flex: 1;
        }
        .keyboard-geo-grid .btn {
            font-size: 13px;
            padding: 0 2px;
        }

body.portrait-mode #sidebar-background::before {
    display: none;
}
body.portrait-mode #nav-btn-code {
    display: none;
}
body.portrait-mode #sidebar-nav-buttons {
    position: fixed;
    top: auto;
    left: 0;
    right: 0;
    bottom: 32px;
    width: 100%;
    height: auto;
    padding: 0;
    z-index: 1003;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    gap: 8px;
    pointer-events: none;
    opacity: 0;
    transform: translateY(20px);
    visibility: hidden;
    transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s 0.3s;
}
body.portrait-mode #sidebar-nav-buttons.nav-visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
    transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s 0s;
}
body.portrait-mode #sidebar-nav-buttons > div {
    display: flex;
    flex-direction: row;
    gap: 8px;
    pointer-events: auto;
}
#portrait-nav-toggle-btn {
    display: none;
    position: absolute;
    width: 52px;
    height: 52px;
    bottom: 20px;
    right: 20px;
    z-index: 1004;
    background-color: rgba(255, 255, 255, 0.65) !important;
    backdrop-filter: blur(20px) saturate(180%);
    -webkit-backdrop-filter: blur(20px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.6);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), background-color 0.2s;
}

:root[data-theme="dark"] #portrait-nav-toggle-btn {
    background-color: rgba(30, 30, 30, 0.6) !important;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

#portrait-nav-toggle-btn:active {
    transform: scale(0.95);
    background-color: rgba(255, 255, 255, 0.8) !important;
}

:root[data-theme="dark"] #portrait-nav-toggle-btn:active {
    background-color: rgba(60, 60, 60, 0.75) !important;
}
#portrait-nav-toggle-btn img {
    width: 24px;
    height: 24px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
#portrait-nav-toggle-btn.active img {
transform: rotate(0deg);
}
body.portrait-mode #portrait-nav-toggle-btn {
    display: flex;
}
:root[data-theme="dark"] #portrait-nav-toggle-btn img,
:root[data-theme="dark"] .code-panel-actions .btn img {
    filter: invert(1);
}
body.portrait-mode #keyboard-toggle-container {
    transition: opacity 0.2s, visibility 0s 0s, transform 0.2s;
}
body.portrait-mode #keyboard-toggle-container.hidden-by-nav {
    opacity: 0;
    visibility: hidden;
    transform: translateY(10px);
    pointer-events: none;
    transition: opacity 0.2s, visibility 0s 0.2s, transform 0.2s;
}
body.portrait-mode .sidebar-nav-btn {
    width: 52px;
    height: 52px;
}

body.portrait-mode #sidebar.fullscreen .sidebar-panel {
    padding: 20px 20px 20px 20px;
    -webkit-mask-image: linear-gradient(transparent, black 20px, black calc(100% - 90px), transparent);
    mask-image: linear-gradient(transparent, black 20px, black calc(100% - 90px), transparent);
}

#code-panel {
    display: none;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
}

#code-list-view, #code-editor-view {
    height: 100%;
    width: 100%;
    padding: 70px 20px 90px 68px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    position: relative;
    -ms-overflow-style: none;
    scrollbar-width: none;
    -webkit-mask-image: none;
    mask-image: none;
}
#code-list-view::-webkit-scrollbar, #code-editor-view::-webkit-scrollbar {
    display: none;
}
body.portrait-mode #code-list-view,
body.portrait-mode #code-editor-view {
    padding: 20px 20px 100px 20px;
    -webkit-mask-image: none;
    mask-image: none;
}
#code-entry-list {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 20px;
}

.code-panel-actions {
    position: absolute;
    bottom: 20px;
    left: 68px;
    right: 20px;
    display: flex;
    width: 320px;
    gap: 15px;
    justify-content: center;
}
body.portrait-mode .code-panel-actions {
    left: 20px;
    right: 20px;
}

#code-editor-exit-btn {
    position: absolute;
    top: 25px;
    right: 25px;
    z-index: 5;
}

.code-editor-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
    overflow-y: auto;
    padding-bottom: 15px;
}
.code-editor-input-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.code-editor-input-group-large {
    flex: 1;
    display: flex;
    flex-direction: column;
}
.code-editor-input-group label {
    font-weight: bold;
    color: var(--text-color-subtle);
}
.code-editor-input, .code-editor-textarea {
    width: 100%;
    padding: 10px 15px;
    border-radius: 15px;
    border: 1px solid rgba(128, 128, 128, 0.2);
    background-color: var(--code-input-bg-color);
    color: var(--text-color-default);
    font-family: monospace;
    font-size: 1em;
    outline: none;
    box-sizing: border-box;
}
.code-editor-textarea {
    flex: 1;
    resize: vertical;
    min-height: 150px;
}
.code-panel-actions {
    justify-content: space-between;
    padding: 0 20px;
    transform: translateY(-10px);
}

.code-panel-actions .btn {
    height: 62.5px;
    border-radius: 31.25px;
    font-weight: bold;
    flex-grow: 0;
    flex-basis: 48%;
    max-width: 48%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    background-color: rgba(255, 255, 255, 0.5) !important;
    backdrop-filter: blur(15px) saturate(180%);
    -webkit-backdrop-filter: blur(15px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 24px 0 rgba(0, 0, 0, 0.08);
    color: #222 !important;
}

:root[data-theme="dark"] .code-panel-actions .btn {
    background-color: rgba(60, 60, 60, 0.45) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
    color: #e0e0e0 !important;
}

.code-panel-actions .btn:hover, .geo-btn:hover {
    background-color: rgba(255, 255, 255, 0.7) !important;
    transform: translateY(-2px);
}

:root[data-theme="dark"] .code-panel-actions .btn:hover, :root[data-theme="dark"] .geo-btn:hover {
    background-color: rgba(80, 80, 80, 0.6) !important;
}
        body.portrait-mode .menu-about-page-content {
            flex-direction: column;
            text-align: center;
        }

 .settings-item-row .custom-switch-container,
        .settings-from-core-wrapper .custom-switch-container {
             position: relative;
             display: inline-block;
             width: 40px;
             height: 22px;
             flex-shrink: 0;
        }

        .settings-item-row .custom-switch-container input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            margin: 0;
        }

        .settings-item-row .custom-switch-container .custom-switch-track,
        .settings-item-row .custom-switch-container .custom-switch-handle {
            transition: .2s;
        }

        .settings-item-row .custom-switch-container .custom-switch-track {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--switch-off-bg-color);
            border-radius: 22px;
        }

        .settings-item-row .custom-switch-container .custom-switch-handle {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
        }

        .settings-item-row .custom-switch-container input[type="checkbox"]:checked + .custom-switch .custom-switch-track {
            background-color: var(--switch-on-bg-color);
        }

        .settings-item-row .custom-switch-container input[type="checkbox"]:checked + .custom-switch .custom-switch-handle {
            transform: translateX(18px);
        }

        #code-panel {
    position: relative;
}

#global-script-toggle-btn {
    position: absolute;
    top: 25px;
    right: 25px;
    z-index: 5;
    height: 40px;
    border-radius: 20px;
    padding: 0 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    background-color: rgba(255, 255, 255, 0.5) !important;
    backdrop-filter: blur(15px) saturate(180%);
    -webkit-backdrop-filter: blur(15px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.05);
    color: #222 !important;
    font-weight: bold;
    cursor: pointer;
}

:root[data-theme="dark"] #global-script-toggle-btn {
    background-color: rgba(60, 60, 60, 0.45) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
    color: #e0e0e0 !important;
}

#global-script-toggle-btn:hover {
    background-color: rgba(255, 255, 255, 0.7) !important;
    transform: translateY(-1px);
}

:root[data-theme="dark"] #global-script-toggle-btn:hover {
    background-color: rgba(80, 80, 80, 0.6) !important;
}


#global-script-view {
    height: 100%;
    width: 100%;
    padding: 70px 20px 90px 68px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    position: relative;
    -ms-overflow-style: none;
    scrollbar-width: none;
    -webkit-mask-image: none;
    mask-image: none;
}
#global-script-view::-webkit-scrollbar {
    display: none;
}
body.portrait-mode #global-script-view {
    padding: 20px 20px 100px 20px;
    -webkit-mask-image: none;
    mask-image: none;
}

#global-script-input {
    flex: 1;
    width: 100%;
    padding: 15px;
    border-radius: 15px;
    border: 1px solid rgba(128, 128, 128, 0.2);
    background-color: var(--code-input-bg-color);
    color: var(--text-color-default);
    font-family: monospace;
    font-size: 1em;
    outline: none;
    box-sizing: border-box;
    resize: vertical;
    margin-bottom: 15px;
}

#global-script-actions {
    position: absolute;
    bottom: 20px;
    left: 68px;
    right: 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
}
body.portrait-mode #global-script-actions {
    left: 20px;
    right: 20px;
}
#global-script-actions .btn {
    height: 62.5px;
    border-radius: 31.25px;
    font-weight: bold;
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    background-color: rgba(255, 255, 255, 0.5) !important;
    backdrop-filter: blur(15px) saturate(180%);
    -webkit-backdrop-filter: blur(15px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 24px 0 rgba(0, 0, 0, 0.08);
    color: #222 !important;
    cursor: pointer;
}

:root[data-theme="dark"] #global-script-actions .btn {
    background-color: rgba(60, 60, 60, 0.45) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
    color: #e0e0e0 !important;
}

#global-script-run-btn {
    background-color: rgba(0, 123, 255, 0.15) !important;
    border: 1px solid rgba(0, 123, 255, 0.3) !important;
    color: var(--text-color-accent) !important;
}

:root[data-theme="dark"] #global-script-run-btn {
    background-color: rgba(54, 162, 255, 0.2) !important;
    border: 1px solid rgba(54, 162, 255, 0.3) !important;
    color: var(--text-color-accent) !important;
}

#global-script-actions .btn:hover {
    background-color: rgba(255, 255, 255, 0.7) !important;
    transform: translateY(-2px);
}

:root[data-theme="dark"] #global-script-actions .btn:hover {
    background-color: rgba(80, 80, 80, 0.6) !important;
}

#global-script-actions .btn:active {
    transform: scale(0.96) translateY(0);
}

#annotation-menu {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.65);
    backdrop-filter: blur(20px) saturate(180%);
    -webkit-backdrop-filter: blur(20px) saturate(180%);
    border-radius: 25px;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 1010;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    overflow: hidden;
    /* 关键修复：设置固定宽度以防止 ResizeObserver 无限循环 */
    width: 400px;
    max-width: 95vw;
}

:root[data-theme="dark"] #annotation-menu {
    background-color: rgba(50, 50, 50, 0.65);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.annotation-header {
    height: 50px;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    box-sizing: border-box;
    flex-shrink: 0;
}

.annotation-sliders-container {
    width: 100%;
    height: 0;
    opacity: 0;
    overflow: hidden;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    background-color: rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    padding: 0 20px;
    box-sizing: border-box;
}

:root[data-theme="dark"] .annotation-sliders-container {
    background-color: rgba(255,255,255,0.05);
}

#annotation-menu.expanded .annotation-sliders-container {
    height: auto;
    opacity: 1;
    padding-top: 15px;
    padding-bottom: 15px;
}

.anno-btn-group {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0; /* 防止按钮被挤压 */
}

.anno-circle-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: none;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    background-color: transparent;
    transition: all 0.2s ease;
    padding: 0;
    flex-shrink: 0;
}

.anno-circle-btn img {
    width: 20px;
    height: 20px;
    opacity: 0.7;
    transition: filter 0.2s;
}

.anno-circle-btn:hover {
    background-color: rgba(128, 128, 128, 0.15);
}

.anno-circle-btn:hover img {
    opacity: 1;
}

.anno-circle-btn.active {
    background-color: var(--text-color-accent);
}

.anno-circle-btn.active img {
    opacity: 1;
    filter: brightness(0) invert(1);
}

.anno-circle-btn.close-btn {
    background-color: rgba(255, 59, 48, 0.15);
}
.anno-circle-btn.close-btn img {
    filter: invert(27%) sepia(51%) saturate(2878%) hue-rotate(346deg) brightness(104%) contrast(97%);
    opacity: 1;
}
.anno-circle-btn.close-btn:hover {
    background-color: rgba(255, 59, 48, 0.8);
}
.anno-circle-btn.close-btn:hover img {
    filter: brightness(0) invert(1);
}

:root[data-theme="dark"] .anno-circle-btn img {
    filter: invert(1);
}
:root[data-theme="dark"] .anno-circle-btn.active img {
    filter: none;
}
:root[data-theme="dark"] .anno-circle-btn.close-btn img {
    filter: invert(27%) sepia(51%) saturate(2878%) hue-rotate(346deg) brightness(104%) contrast(97%);
}
:root[data-theme="dark"] .anno-circle-btn.close-btn:hover img {
    filter: none;
}

.annotation-sliders-container .slider-group {
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    height: 28px;
    width: 100%;
}
.annotation-sliders-container .slider-group label {
    width: 40px;
    font-size: 13px;
    font-weight: bold;
    color: var(--text-color-subtle);
    flex-shrink: 0;
    white-space: nowrap;
}

/* 关键修复：覆盖全局样式，防止宽度 100% 撑开父容器 */
.annotation-sliders-container .slider-group .custom-slider-container {
    flex: 1;
    width: auto !important; 
    min-width: 0; /* 允许 Flex 子项缩小 */
}

.annotation-selection-box {
    position: absolute;
    border: 1px dashed #007bff;
    pointer-events: none;
    z-index: 1005;
}

.annotation-resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #007bff;
    border: 1px solid white;
    border-radius: 50%;
}
/* 在 #annotation-menu 样式块之后添加 */
.checkbox-modal-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 3000;
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px);
}
.checkbox-modal {
    background: var(--menu-bg-color);
    padding: 20px;
    border-radius: 15px;
    width: 300px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--sidebar-border-color);
    color: var(--text-color-default);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.checkbox-modal h3 { margin: 0 0 15px 0; font-size: 1.2em; text-align: center; }
.checkbox-list {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 15px;
    border: 1px solid var(--controls-border-color);
    border-radius: 8px;
    padding: 5px;
}
.checkbox-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    border-bottom: 1px solid var(--entry-item-separator-color);
}
.checkbox-list-item:last-child { border-bottom: none; }
.checkbox-modal-actions { display: flex; gap: 10px; justify-content: flex-end; }
.checkbox-modal-btn {
    padding: 8px 15px;
    border-radius: 18px;
    border: none;
    cursor: pointer;
    font-weight: bold;
}
.checkbox-confirm { background: var(--text-color-accent); color: white; }
.checkbox-cancel { background: var(--add-btn-bg-color); color: var(--text-color-default); }


#top-blur-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 140px;
            z-index: 4; 
            backdrop-filter: blur(140px); 
            -webkit-backdrop-filter: blur(140px);
            background: linear-gradient(to bottom, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 100%);
            -webkit-mask-image: linear-gradient(to top, transparent 0%, black 100%);
            mask-image: linear-gradient(to top, transparent 0%, black 100%);
            pointer-events: none;
            transition: opacity 0.2s ease; 
        }
  body.portrait-mode #top-blur-mask,
        body.sidebar-hidden #top-blur-mask {
            padding-left: 20px;
        }
        #top-blur-mask.hidden {
            opacity: 0;

        }
        :root[data-theme="dark"] #top-blur-mask {
            background: linear-gradient(to bottom, rgba(40,40,40,0.6) 0%, rgba(40,40,40,0) 100%);
        }
#file-name-display {
            position: absolute;
            top: 12px;
          
            left: 430px;
            z-index: 11;
            pointer-events: auto;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 8px;
            transition: background-color 0.2s, left 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            user-select: none;
            color: var(--text-color-default);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }
        #file-name-display:hover {
            background-color: var(--entry-item-hover-bg-color);
        }
#view-mode-toggle-circle {
            position: absolute;
            top: 15px;
            right: 161px; 
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(240, 240, 240, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            font-weight: 600;
            font-size: 14px;
            user-select: none;
            transition: transform 0.2s, background-color 0.2s;
            color: black;
            border: 1px solid rgba(255,255,255,0.3);
        }

        :root[data-theme="dark"] #view-mode-toggle-circle {
            background-color: rgba(60, 60, 60, 0.5);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        }

        #view-mode-toggle-circle:active {
            transform: scale(0.95);
        }

#annotation-split-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 100px; /* 加宽以优化点击区域和图标间距 */
            height: 36px;
            border-radius: 18px; 
            background-color: rgba(240, 240, 240, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: stretch; /* 关键：让子元素填满高度 */
            justify-content: center;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s, visibility 0.3s;
            overflow: hidden;
            user-select: none;
        }

        .anno-split-part {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 50%; 
            position: relative;
        }

        :root[data-theme="dark"] #annotation-split-btn {
            background-color: rgba(60, 60, 60, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    .anno-split-part:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .anno-split-part:active {
            background-color: rgba(0, 0, 0, 0.1);
        }

        :root[data-theme="dark"] .anno-split-part:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        :root[data-theme="dark"] .anno-split-part:active {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .anno-split-separator {
            width: 1px;
            height: 20px;
            background-color: rgba(128, 128, 128, 0.3);
            align-self: center; /* 垂直居中 */
        }
        
        :root[data-theme="dark"] .anno-split-separator {
            background-color: rgba(255, 255, 255, 0.3);
        }

        #annotation-split-btn img {
            width: 22px; /* 稍微调大图标 */
            height: 22px;
            pointer-events: none; /* 穿透点击 */
            display: block;
        }

        :root[data-theme="dark"] #annotation-split-btn img {
            filter: invert(1);
        }

        #annotation-edit-toggle-container {
            display: none !important;
        }

        #reset-view-btn {
            position: absolute;
            top: 15px;
            right: 115px; 
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(240, 240, 240, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.2s, background-color 0.2s;
        }

        #reset-view-btn:active {
            transform: scale(0.95);
        }
        
        :root[data-theme="dark"] #reset-view-btn {
            background-color: rgba(60, 60, 60, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        }
        
        :root[data-theme="dark"] #reset-view-btn img {
            filter: invert(1);
        }
 .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

.entry-text-area, .entry-value, #keyboard-input-display { font-family: 'HarmonyOS_Italic', 'HarmonyOS_SC', Arial, sans-serif !important; } 
#keyboard-input-display .char-span { font-family: inherit; }
#annotation-edit-toggle-container {
            position: absolute;
            bottom: 45px;
            right: 10px;
            z-index: 10;
            background-color: var(--overlay-bg-color);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9em;
            color: var(--overlay-text-color);
            pointer-events: auto;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            transition: opacity 0.2s ease-in-out;
        }
        body.sidebar-hidden #annotation-edit-toggle-container {
             bottom: 45px; 
        }

              #annotation-edit-toggle-container {
            display: none !important;
        }

 #reset-view-btn,
        #view-mode-toggle-circle,
        #stage-mode-toggle-btn {
            position: absolute;
            top: 15px;
          
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(240, 240, 240, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);

            transition: right 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.2s, background-color 0.2s, opacity 0.3s, visibility 0.3s;
        }

#category-filter-btn {
    /* 必须重置定位，使其听从 Flex 布局指挥 */
    position: static !important; 
    top: auto !important;
    left: auto !important;
    bottom: auto !important;
    transform: none !important; /* 禁止位移动画 */
    
    /* 核心：左侧边距固定为 20px */
    margin-left: 20px; 
    
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: rgba(240, 240, 240, 0.5);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    
    display: none; /* 默认隐藏，JS 会改为 flex */
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    
    /* 只保留颜色和透明度的动画，去除位置动画 */
    transition: background-color 0.2s, opacity 0.2s;
    
    /* 确保层级正确（在 Flex 容器内） */
    z-index: auto; 
}

:root[data-theme="dark"] #category-filter-btn {
    background-color: rgba(60, 60, 60, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

:root[data-theme="dark"] #category-filter-btn img {
    filter: invert(1);
}

#category-filter-btn:active {
    transform: scale(0.95);
}

body.portrait-mode #category-filter-btn {
    display: none !important;
}

body.sidebar-hidden #category-filter-btn {
    display: none !important;
}

    </style>
</head>
<body>
<div id="top-blur-mask"></div>
<span id="file-name-display">Arch Graph 1</span>
<div id="stop-trace-btn" title="停止录制">
    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjIzLjczMzk3LDE5Ni4yNjYwM3YtMzIuNTMyMDZoMzIuNTMyMDZ2MzIuNTMyMDZ6IiBmaWxsLW9wYWNpdHk9IjAuMDA3ODQiIGZpbGw9IiNmZmZmZmYiLz48cGF0aCBkPSJNMjI3LjE4MjYzLDE4MGMwLC03LjA3ODg0IDUuNzM4NTMsLTEyLjgxNzM3IDEyLjgxNzM3LC0xMi44MTczN2M3LjA3ODg0LDAgMTIuODE3MzcsNS43Mzg1MyAxMi44MTczNywxMi44MTczN2MwLDcuMDc4ODQgLTUuNzM4NTMsMTIuODE3MzcgLTEyLjgxNzM3LDEyLjgxNzM3Yy03LjA3ODg0LDAgLTEyLjgxNzM3LC01LjczODUzIC0xMi44MTczNywtMTIuODE3Mzd6IiBmaWxsPSIjMDAwMDAwIi8+PHBhdGggZD0iTTIzNS4wMTQ1MiwxODQuOTg1NDh2LTkuOTcwOTdoOS45NzA5N3Y5Ljk3MDk3eiIgZmlsbD0iI2ZmZmZmZiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAzOjE2LjI2NjAzLS0+">
</div>
<div id="stage-mode-toggle-btn" title="多存档调度"></div>
<div id="view-mode-toggle-circle">3D</div>
<div id="reset-view-btn" title="重置视角">

    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS4xMzk2OSIgaGVpZ2h0PSIxOS4xMzk2OSIgdmlld0JveD0iMCwwLDE5LjEzOTY5LDE5LjEzOTY5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjQzMDE1LC0xNzAuNDMwMTUpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuNDMwMTUsMTg5LjU2OTg1di0xOS4xMzk2OWgxOS4xMzk2OXYxOS4xMzk2OXoiIGZpbGwtb3BhY2l0eT0iMC4wMzEzNyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNi41ODAwNiwxODBjMCwtMS44ODg3OCAxLjUzMTE2LC0zLjQxOTk0IDMuNDE5OTQsLTMuNDE5OTRjMS44ODg3OCwwIDMuNDE5OTQsMS41MzExNiAzLjQxOTk0LDMuNDE5OTRjMCwxLjg4ODc4IC0xLjUzMTE2LDMuNDE5OTQgLTMuNDE5OTQsMy40MTk5NGMtMS44ODg3OCwwIC0zLjQxOTk0LC0xLjUzMTE2IC0zLjQxOTk0LC0zLjQxOTk0eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0MC4xNjQwMiwxNzMuOTc3MzV2Mi4yNTE3MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuNzEwNDksMTc5Ljk0NDQzaDIuMzY0MzIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5Ljk4NTA0LDE4My45MzExNXYyLjI1MTczIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC4wNzQyNiwxNzkuODc4MDRoMi4zNjQzMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuMDY5NTcsMTgwYzAsMC42MjE4IC0wLjQ3ODg2LDEuMTI1ODYgLTEuMDY5NTcsMS4xMjU4NmMtMC41OTA3MSwwIC0xLjA2OTU3LC0wLjUwNDA3IC0xLjA2OTU3LC0xLjEyNTg2YzAsLTAuNjIxOCAwLjQ3ODg2LC0xLjEyNTg2IDEuMDY5NTcsLTEuMTI1ODZjMC41OTA3MSwwIDEuMDY5NTcsMC41MDQwNyAxLjA2OTU3LDEuMTI1ODZ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5LjU2OTg0NjYzMzQ5MDY0MTo5LjU2OTg0NjYzMzQ5MDY0MS0tPg==" style="width: 20px; height: 20px;">
</div>
<div id="annotation-split-btn">
    <div id="anno-split-left" class="anno-split-part" title="开启/关闭编辑">

        <img id="icon-edit-on" src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4yMzk1IiBoZWlnaHQ9IjEyLjczNTY5IiB2aWV3Qm94PSIwLDAsMTIuMjM5NSwxMi43MzU2OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzMy44ODAyNSwtMTczLjYzMjE1KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODIsMTc1LjgzNThjLTAuMTIwNTgsMC4wMTQ2NyAtMC4yNDg3NywwLjA1MDY3IC0wLjM1MzE4LDAuMTE0MzZjLTAuMTA0NDIsMC4wNjM2OSAtMC4yMDYzOSwwLjE0NzQ4IC0wLjI4NTgzLDAuMjQ4OTJsLTQuNTUwNDEsNS44NDYwOGMtMC4wNDQxMiwwLjA1NjM2IC0wLjA2Njk0LDAuMTIwMzEgLTAuMDc5NjksMC4xODMwNWwtMC4yMjU0NCwxLjc1MDc3bDEuNjY2OTMsLTAuNjMxMTJjMC4wNjc4OSwtMC4wMjg2NSAwLjExNDQ3LC0wLjA2NDkyIDAuMTY4NjQsLTAuMTIyNWw0LjU1Mjg0LC01LjgyNTk4YzAuMDc5NDMsLTAuMTAxNDQgMC4xMzc1NCwtMC4yMTA0OCAwLjE3MzExLC0wLjMzNzE3YzAuMDM1NTcsLTAuMTI2NjkgMC4wNDA5OSwtMC4yNDk3MyAwLjAyNjMyLC0wLjM3MDNjLTAuMDE1OSwtMC4xMzA2MyAtMC4wNTA2NiwtMC4yNDg3NiAtMC4xMTU1OCwtMC4zNjMyNGMtMC4wNjQ5MiwtMC4xMTQ0NyAtMC4xNDc0OCwtMC4yMDYzOSAtMC4yMzc2NSwtMC4yNzdjLTAuMDkwMTcsLTAuMDcwNjEgLTAuMjA5MjcsLTAuMTI3NDkgLTAuMzI3MTQsLTAuMTc0MzNjLTAuMTE3ODcsLTAuMDQ2ODQgLTAuMjgyMzEsLTAuMDU3NDIgLTAuNDEyOTQsLTAuMDQxNTN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC42Ii8+PHBhdGggZD0iTTIzMy44ODAyNSwxODYuMzY3ODV2LTEyLjczNTY5aDEyLjIzOTV2MTIuNzM1Njl6IiBmaWxsLW9wYWNpdHk9IjAuMDA3ODQiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4xMTk3NTAwMDAwMDAwMTA1OjYuMzY3ODQ0OTk5OTk5OTg4LS0+" alt="Edit On" style="display: block;">

        <img id="icon-edit-off" src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4yMzk1IiBoZWlnaHQ9IjEyLjczNTY5IiB2aWV3Qm94PSIwLDAsMTIuMjM5NSwxMi43MzU2OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzMy44ODAyNSwtMTczLjYzMjE1KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODIsMTc1LjgzNThjLTAuMTIwNTgsMC4wMTQ2NyAtMC4yNDg3NywwLjA1MDY3IC0wLjM1MzE4LDAuMTE0MzZjLTAuMTA0NDIsMC4wNjM2OSAtMC4yMDYzOSwwLjE0NzQ4IC0wLjI4NTgzLDAuMjQ4OTJsLTQuNTUwNDEsNS44NDYwOGMtMC4wNDQxMiwwLjA1NjM2IC0wLjA2Njk0LDAuMTIwMzEgLTAuMDc5NjksMC4xODMwNWwtMC4yMjU0NCwxLjc1MDc3bDEuNjY2OTMsLTAuNjMxMTJjMC4wNjc4OSwtMC4wMjg2NSAwLjExNDQ3LC0wLjA2NDkyIDAuMTY4NjQsLTAuMTIyNWw0LjU1Mjg0LC01LjgyNTk4YzAuMDc5NDMsLTAuMTAxNDQgMC4xMzc1NCwtMC4yMTA0OCAwLjE3MzExLC0wLjMzNzE3YzAuMDM1NTcsLTAuMTI2NjkgMC4wNDA5OSwtMC4yNDk3MyAwLjAyNjMyLC0wLjM3MDNjLTAuMDE1OSwtMC4xMzA2MyAtMC4wNTA2NiwtMC4yNDg3NiAtMC4xMTU1OCwtMC4zNjMyNGMtMC4wNjQ5MiwtMC4xMTQ0NyAtMC4xNDc0OCwtMC4yMDYzOSAtMC4yMzc2NSwtMC4yNzdjLTAuMDkwMTcsLTAuMDcwNjEgLTAuMjA5MjcsLTAuMTI3NDkgLTAuMzI3MTQsLTAuMTc0MzNjLTAuMTE3ODcsLTAuMDQ2ODQgLTAuMjgyMzEsLTAuMDU3NDIgLTAuNDEyOTQsLTAuMDQxNTN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC42IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzMuODgwMjUsMTg2LjM2Nzg1di0xMi43MzU2OWgxMi4yMzk1djEyLjczNTY5eiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM2LjU5MzQ1LDE3Ni42NDE5M2w2Ljc4MTM0LDYuNDUwNTUiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjYuMTE5NzUwMDAwMDAwMDEwNTo2LjM2Nzg0NDk5OTk5OTk4OC0tPg==" alt="Edit Off" style="display: none;">
    </div>
    <div class="anno-split-separator"></div>
    <div id="anno-split-right" class="anno-split-part" title="进入批注模式">

        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4yMzk1IiBoZWlnaHQ9IjEyLjczNTY5IiB2aWV3Qm94PSIwLDAsMTIuMjM5NSwxMi43MzU2OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzMy44ODAyNSwtMTczLjYzMjE2KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQzLjkyMzg3LDE3Ni45MDA0N3YyLjgzNTc0YzAsMC4xOTc4NCAtMC4wNjU5NSwwLjM5NTY4IC0wLjEzMTg5LDAuNTI3NThjLTAuMDY1OTUsMC4xMzE4OSAtMC4xMzE4OSwwLjMyOTc0IC0wLjMyOTc0LDAuNDYxNjNjLTAuMTMxODksMC4xMzE4OSAtMC4zMjk3NCwwLjE5Nzg0IC0wLjQ2MTYzLDAuMzI5NzRjLTAuMTMxODksMC4wNjU5NSAtMC4zOTU2OCwwLjA2NTk1IC0wLjUyNzU4LDAuMDY1OTVoLTUuNDczNjNsMS43ODA1OCwxLjc4MDU4YzAuMDY1OTUsMC4wNjU5NSAwLjA2NTk1LDAuMTMxODkgMC4wNjU5NSwwLjE5Nzg0YzAsMC4wNjU5NSAwLDAuMTMxODkgLTAuMDY1OTUsMC4xOTc4NGMtMC4wNjU5NSwwLjA2NTk1IC0wLjEzMTg5LDAuMDY1OTUgLTAuMTk3ODQsMC4wNjU5NWMtMC4wNjU5NSwwIC0wLjEzMTg5LDAgLTAuMTk3ODQsLTAuMDY1OTVsLTIuMjQyMjEsLTIuMjQyMjFjLTAuMDY1OTUsLTAuMDY1OTUgLTAuMDY1OTUsLTAuMTMxODkgLTAuMDY1OTUsLTAuMTk3ODRjMCwtMC4wNjU5NSAwLC0wLjEzMTg5IDAuMDY1OTUsLTAuMTk3ODRsMi4yNDIyMSwtMi4yNDIyMWMwLjA2NTk1LC0wLjA2NTk1IDAuMTMxODksLTAuMDY1OTUgMC4xOTc4NCwtMC4wNjU5NWMwLjA2NTk1LDAgMC4xMzE4OSwwIDAuMTk3ODQsMC4wNjU5NWMwLjA2NTk1LDAuMDY1OTUgMC4wNjU5NSwwLjEzMTg5IDAuMDY1OTUsMC4xOTc4NGMwLDAuMDY1OTUgMCwwLjEzMTg5IC0wLjA2NTk1LDAuMTk3ODRsLTEuNzgwNTgsMS43ODA1OGg1LjQ3MzYzYzAuMTMxODksMCAwLjE5Nzg0LDAgMC4zMjk3NCwtMC4wNjU5NWMwLjA2NTk1LC0wLjA2NTk1IDAuMTk3ODQsLTAuMDY1OTUgMC4zMjk3NCwtMC4xMzE4OWMwLjA2NTk1LC0wLjA2NTk1IDAuMTMxODksLTAuMTMxODkgMC4xMzE4OSwtMC4zMjk3NGMwLC0wLjEzMTg5IDAuMDY1OTUsLTAuMTk3ODQgMC4wNjU5NSwtMC4zMjk3NHYtMi44MzU3NGMwLC0wLjA2NTk1IDAsLTAuMTMxODkgMC4wNjU5NSwtMC4xOTc4NGMwLjA2NTk1LC0wLjA2NTk1IDAuMTMxODksLTAuMDY1OTUgMC4xOTc4NCwtMC4wNjU5NWMwLjA2NTk1LDAgMC4xMzE4OSwwIDAuMTk3ODQsMC4wNjU5NWMwLjEzMTg5LDAuMTMxODkgMC4xMzE4OSwwLjEzMTg5IDAuMTMxODksMC4xOTc4NHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTIzMy44ODAyNSwxODYuMzY3ODZ2LTEyLjczNTY5aDEyLjIzOTV2MTIuNzM1Njl6IiBmaWxsLW9wYWNpdHk9IjAuMDA3ODQiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4xMTk3NTAwMDAwMDAwMTA1OjYuMzY3ODM1MDAwMDAwMDE0LS0+" alt="Enter">
    </div>
</div>


<div id="sidebar-nav-buttons">
    <div class="nav-group-top">
        <div id="nav-btn-plot" class="btn sidebar-nav-btn" title="绘图">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNC43NjE1NSIgaGVpZ2h0PSIxMi4zMTY4NiIgdmlld0JveD0iMCwwLDE0Ljc2MTU1LDEyLjMxNjg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjYxOTIyLC0xNzMuODQxNTcpIj48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnPjxwYXRoIGQ9Ik0yMzUuMDAzNTksMTc3LjE2NjQxYy0wLjAwMzM2LC0wLjA1MjI2IC0wLjAwNTA5LC0wLjEwNDk4IC0wLjAwNTA5LC0wLjE1ODA4YzAsLTEuMzM0NzUgMS4wODIwMSwtMi40MTY3NiAyLjQxNjc2LC0yLjQxNjc2YzAuMjEzMzMsMCAwLjQyMDE5LDAuMDI3NjQgMC42MTcyMSwwLjA3OTU0IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzcuOTMxMjEsMTc0LjY0NTg1bDAuNDg4NzgsMC4xNjI5MiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC45OTg1LDE3Ny4xNDQxMnY4LjI1NTAxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMzLjM2OTIzLDE3OC43MTkwN2gzLjM2NzE5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ1LjcyOTE4LDE4MC4zODc1MmMwLjU2LDAuNjEzMDggMC45MDE2LDEuNDI5MDggMC45MDE2LDIuMzI0ODZjMCwwLjkxNjA3IC0wLjM1NzI0LDEuNzQ4NzMgLTAuOTQsMi4zNjYyNCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjM5NjY1LDE4NC45NTQwM2MtMC41NDAyOCwtMC42MDg3NSAtMC44Njg0MSwtMS40MTAwNCAtMC44Njg0MSwtMi4yODhjMCwtMC44NTY2OSAwLjMxMjQsLTEuNjQwNCAwLjgyOTQ5LC0yLjI0MzQyIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzkuNzA1OTQsMTg1LjMxNTY4bC0wLjM3MTExLC0wLjQxNzUxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjY1OTUyLDE4MC4wMjcyOWwtMC4zNzExMSwwLjQ2MzkiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDUuNDExOCwxNzkuOTgwODlsMC4zMjQ3MSwwLjM3MTEzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ1LjgyOTMsMTg0Ljg5ODE1bC0wLjUxMDI4LDAuNTEwMjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuMzgwMDUsMTgxLjIwOTAzbDIuNjg4OTMsMi44MjU2NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4zMzQ0NiwxODQuMDM0NjNsMi41OTc4LC0yLjY4ODkzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ny4zODA3NzU6Ni4xNTg0MzAwMDAwMDAwMS0tPg==>
        </div>
        <div id="nav-btn-geometry" class="btn sidebar-nav-btn" title="几何">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi40NTAxOSIgaGVpZ2h0PSIxMy4wNTI5OCIgdmlld0JveD0iMCwwLDEyLjQ1MDE5LDEzLjA1Mjk4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjc3NDkxLC0xNzMuNDczNTEpIj48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzQuNTI0OTEsMTg1Ljc3NjQ5di03LjEzMjY5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQxLjU1NzEzLDE4NS4xNzM2OWwtNi43MzA4MywtNi41Mjk5MiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC42MjUzNCwxODUuNzc2NDloNy4zMzM1OSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOS43NDg4NywxNzcuMDg2NjNjMCwtMS41ODEyNiAxLjI4MTg2LC0yLjg2MzExIDIuODYzMTEsLTIuODYzMTFjMS41ODEyNiwwIDIuODYzMTEsMS4yODE4NyAyLjg2MzExLDIuODYzMTFjMCwxLjU4MTI2IC0xLjI4MTg3LDIuODYzMTEgLTIuODYzMTEsMi44NjMxMWMtMS41ODEyNiwwIC0yLjg2MzExLC0xLjI4MTg3IC0yLjg2MzExLC0yLjg2MzExeiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjIyNTA5MzEzMjI3MjQ2MjU6Ni41MjY0ODc3OTI4NDgyODYtLT4=>
        </div>
        <div id="nav-btn-code" class="btn sidebar-nav-btn" title="代码">
            <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4yMTk4NCIgaGVpZ2h0PSIxMS4zNjI0NiIgdmlld0JveD0iMCwwLDEzLjIxOTg0LDExLjM2MjQ2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjM5MDEzLC0xNzQuMzE4NzcpIj48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTI0NS44NTk4NywxODIuMTc1OWMtMC4xMTgyMiwxLjU2NzU1IC0xLjQyMTY4LDIuNzg2NjggLTIuOTg2NTIsMi43NTQ3MWMtMC4wMTI4NCwtMC4wMDAyNiAtMC4wMjU2NiwtMC4wMDA2MSAtMC4wMzg0OCwtMC4wMDEwM2wtNS43NDYwMywwLjAwMDk1Yy0wLjAxOTg1LDAuMDAwMDggLTAuMDM5NzMsLTAuMDAwMDQgLTAuMDU5NjYsLTAuMDAwMzdjLTEuNjIxNDYsLTAuMDI2NTYgLTIuOTE0NzUsLTEuMzg0OTYgLTIuODg4NjYsLTMuMDM0MWMwLjAwMDIyLC0wLjAxMzA1IDAuMDAwNSwtMC4wMjYxIDAuMDAwODcsLTAuMDM5MTRsMC4wMDA3MSwtMC4wOTU5MmwwLjAzNzE2LC0zLjI4MTk0bDAuMDAzMzgsLTAuNDU4NDZjMC4wMDAyNCwtMC4wMjAxOCAwLjAwMDY3LC0wLjA0MDQgMC4wMDEzMiwtMC4wNjA2NmMwLjA1MTcyLC0xLjY0ODUyIDEuNDA3NjMsLTIuOTQyMjUgMy4wMjg0OSwtMi44ODk2MmMwLjAxMjg0LDAuMDAwNDIgMC4wMjU2NiwwLjAwMDkyIDAuMDM4NDcsMC4wMDE1bDUuNjEwNzgsLTAuMDAyMDdjMC4wMTk4NSwtMC4wMDAzMiAwLjAzOTczLC0wLjAwMDQzIDAuMDU5NjYsLTAuMDAwMzZjMS42MjE2NCwwLjAwNzA1IDIuOTMwNjUsMS4zNDk4IDIuOTIzNzUsMi45OTkxM2MtMC4wMDAwNSwwLjAxMzA3IC0wLjAwMDE4LDAuMDI2MTEgLTAuMDAwNDIsMC4wMzkxNWwwLjAwMDI2LDAuMDYwMjF6IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM0LjYzNDM4LDE3OC4xNzk1MWwxMC41ODkxLDAuMDUzNDgiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM2LjU5MTc2LDE4MC4xNTgyOGwxLjE1NTE3LDAuODk4NDciIHN0cm9rZS13aWR0aD0iMS4yIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM2LjUwNjE5LDE4Mi4xMjYzNmwxLjI0MDc0LC0wLjk4NDA0IiBzdHJva2Utd2lkdGg9IjEuMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOS4wNzMyNCwxODIuMjk3NDloMS40OTc0NSIgc3Ryb2tlLXdpZHRoPSIxLjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjYwOTg2ODk0OTg4NjI3Nzo1LjY4MTIyNzU0NjU5NjU0Ni0tPg==" alt="code" style="width: 20px; height: 20px;">
        </div>
    </div>
    <div class="nav-group-bottom">
        <div id="nav-btn-about" class="btn sidebar-nav-btn" title="关于">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNS4wMTEzMSIgaGVpZ2h0PSIxNS4wMzExMyIgdmlld0JveD0iMCwwLDE1LjAxMTMxLDE1LjAzMTEzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjQ5NDM1LC0xNzIuNDg0NDQpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnPjxwYXRoIGQ9Ik0yMzYuMTExOSwxODYuNzY1NTZjLTAuMTQ5MzcsLTAuMDAwNjQgLTAuMjk2LC0wLjAxMjg5IC0wLjQzOTAyLC0wLjAzNTg5Yy0wLjA3OTMzLC0wLjAyMTA0IC0wLjE2OTYxLC0wLjA0NzgyIC0wLjI0OTQ3LC0wLjA1MTgxYy0wLjAxNTg2LC0wLjAwNDA1IC0wLjAzMTY3LC0wLjAwODI0IC0wLjA0NzQyLC0wLjAxMjU3Yy0wLjA0MDgsLTAuMDE1MyAtMC4wNzk5NCwtMC4wMjk3OSAtMC4xMTU1NCwtMC4wNDA0N2MtMC4wMTcwNSwtMC4wMDUxMSAtMC4wMzQwMywtMC4wMTA0NSAtMC4wNTA5MSwtMC4wMTYwN2wtMC4wMDgxNCwtMC4wMDI3MWMwLDAgLTAuMDA3MjgsLTAuMDAyNDMgLTAuMDE0NjMsLTAuMDAwMDZjLTAuMDAzNDEsLTAuMDAyNDkgLTAuMDA3NTYsLTAuMDA0MDEgLTAuMDEyMDcsLTAuMDA0MTZjLTAuMDA3OTcsLTAuMDAyODUgLTAuMDE1OTQsLTAuMDA1NzQgLTAuMDIzODgsLTAuMDA4NjVsLTAuMDA0ODUsLTAuMDAyNDJjLTAuMTAwNTgsLTAuMDQ0NjcgLTAuMjEyODcsLTAuMTAwNzggLTAuMzE3MTQsLTAuMTM5NDhjLTAuMDExMTcsLTAuMDA1NzggLTAuMDIyMjksLTAuMDExNjQgLTAuMDMzMzgsLTAuMDE3NTZjLTAuMDAyMDIsLTAuMDA0NDQgLTAuMDA0ODQsLTAuMDA3MjcgLTAuMDA0ODQsLTAuMDA3MjdsLTAuMDE1NTEsLTAuMDExMTNjLTAuMDQ4OSwtMC4wMTIxNCAtMC4wNzQ4MiwtMC4wNDQwMyAtMC4xMTY1NSwtMC4wNjgzMWMwLDAgLTAuMDA4NjEsLTAuMDA0OTIgLTAuMDE3NTEsLTAuMDAyMjljLTAuMTAyODYsLTAuMDYzNyAtMC4yMDEzMiwtMC4xMzM4MiAtMC4yOTQ4MiwtMC4yMDk4MmMwLjAwMTQ0LC0wLjAxMjc5IC0wLjAxMDg5LC0wLjAyMDIgLTAuMDEwODksLTAuMDIwMmMtMC4wMzI1MSwtMC4wMTk1IC0wLjA2MDcsLTAuMDQzOTQgLTAuMDkwNDQsLTAuMDY2MmMtMC4wMDk2OCwtMC4wMDg4IC0wLjAxOTM3LC0wLjAxNzU3IC0wLjAyOTA4LC0wLjAyNjM1Yy0wLjAxNzY0LC0wLjAxNjIyIC0wLjAzNTA4LC0wLjAzMjY1IC0wLjA1MjMsLTAuMDQ5M2MwLjAwMTAyLC0wLjAwOTk5IC0wLjAwNjczLC0wLjAxNzczIC0wLjAwNjczLC0wLjAxNzczbC0wLjAxNTg5LC0wLjAxNTg5Yy0wLjAyODU5LC0wLjAyNzk4IC0wLjA1NjM1LC0wLjA1NzEyIC0wLjA4NDE0LC0wLjA4NjM5Yy0wLjAwMDMyLC0wLjAwMDgzIC0wLjAwMDU1LC0wLjAwMTI5IC0wLjAwMDU1LC0wLjAwMTI5bC0wLjAxMjAxLC0wLjAyMTUyYy0wLjA0OTY1LC0wLjA0ODU5IC0wLjExMjcxLC0wLjE0NDcxIC0wLjE3MjI2LC0wLjE4NjU3Yy0wLjAwNzE2LC0wLjAwOTQ4IC0wLjAxNDI3LC0wLjAxOTAyIC0wLjAyMTMyLC0wLjAyODU5Yy0wLjA0MDk2LC0wLjA2ODAzIC0wLjA4NzczLC0wLjE0NDYxIC0wLjEzODg3LC0wLjIwNzMzYy0wLjA3MTkyLC0wLjExODM4IC0wLjEzNTM3LC0wLjI0MjQ2IC0wLjE4OTUyLC0wLjM3MTQyYy0wLjAzNDc3LC0wLjEwNTY1IC0wLjA2MjE4LC0wLjIxMzgzIC0wLjExMDU3LC0wLjMxNDY3Yy0wLjAwMDIzLC0wLjAwMDgxIC0wLjAwMDQ3LC0wLjAwMTY0IC0wLjAwMDcsLTAuMDAyNDVjLTAuMDAwNjEsLTAuMDAzODcgLTAuMDAxMTksLTAuMDA3NzQgLTAuMDAxNzUsLTAuMDExNjFjMCwwIC0wLjAwMDgyLC0wLjAwNTY5IC0wLjAwNDUzLC0wLjAxMDhjLTAuMDA0MDUsLTAuMDE0NjggLTAuMDA3OTgsLTAuMDI5NCAtMC4wMTE3OSwtMC4wNDQxN2MwLC0wLjAwMDE3IDAuMDAwMDEsLTAuMDAwMzUgMC4wMDAwMSwtMC4wMDA1MmMwLDAgMCwtMC4wMDU5NCAtMC4wMDMxMSwtMC4wMTE2MWMtMC4wMDI1MywtMC4wMSAtMC4wMDUwMiwtMC4wMjAwMyAtMC4wMDc0NSwtMC4wMzAwN2MtMC4wMDI3MiwtMC4wMiAtMC4wMDUxMywtMC4wMzk3NCAtMC4wMDcyNywtMC4wNTkwM2MtMC4wMDkxMywtMC4wMzIwOCAtMC4wMTc3OSwtMC4wNjQ0NCAtMC4wMjU3OSwtMC4wOTcwMWMtMC4wMTcwMiwtMC4wOTMzNiAtMC4wMjk0NSwtMC4xODgzMiAtMC4wMzcwNCwtMC4yODQ2NGMtMC4wMDAyNCwtMC4wMjEgLTAuMDAwMzIsLTAuMDQyIC0wLjAwMDMyLC0wLjA2Mjk5YzAsMCAwLC0wLjAwNzgzIC0wLjAwNDcxLC0wLjAxNDA5Yy0wLjAwMDg1LC0wLjAxNjQyIC0wLjAwMTU2LC0wLjAzMjg5IC0wLjAwMjEyLC0wLjA0OTM4YzAsLTAuMTUyNDYgMCwtMC4zMDQ5MSAwLC0wLjQ1NzM3YzAsLTAuMTQ0MzIgMCwtMC4yODg2MyAwLC0wLjQzMjk1YzAsMCAwLC0wLjAxMDY4IC0wLjAwNzQ5LC0wLjAxNzA1bC0wLjAwMDgyLC0wLjEwOTIxYzAuMDAwMjIsLTAuMDEwODggMC4wMDAzNCwtMC4wMjE3NSAwLjAwMDM3LC0wLjAzMjYyYzAsMCAwLC0wLjAwMjA5IC0wLjAwMDY1LC0wLjAwNDk4bC0wLjA1MjA5LC02LjkyNjA0YzAuMDA0LC0wLjE4NjczIDAuMDI2MDUsLTAuMzY4ODYgMC4wNjQ0OCwtMC41NDQ3NGMwLjAyMDM4LC0wLjA2NTMgMC4wMzc0LC0wLjEzMTE2IDAuMDUwMjcsLTAuMTk1OTRjMC4wMjk1NCwtMC4wOTk5OCAwLjA2NDQ1LC0wLjE5NzYgMC4xMDQzOSwtMC4yOTI1NWMwLjA0MjQzLC0wLjA3MzM4IDAuMDgwOTMsLTAuMTQ3MzQgMC4xMDczMywtMC4yMjYyOWMwLjQ4MDkzLC0wLjkwNzEzIDEuNDQxMzYsLTEuNTE3OTggMi41Mzc1NCwtMS41MDEyaDAuMDQxNjZsNy43MjQxNCwtMC4wNjc3YzEuNTUwODksLTAuMDAxNDcgMi44MTE4NSwxLjI0OTggMi44MjIzNSwyLjgwMDY1djAuMDQyNTNsMC4wNTkwMiw3LjkxODU1Yy0wLjAyNTY5LDAuOTQ0MzQgLTAuNTEzMDEsMS43NjgxNyAtMS4yNDA1OSwyLjI2MDM3Yy0wLjI0Njc2LDAuMDkxOTMgLTAuNzcxNzEsMC4yNjY5OCAtMC45MjU1OSwwLjM2NzFjLTAuMDExNzYsMC4wMDc2NiAtMC4wMjUwNywwLjAxOTYgLTAuMDM5NTMsMC4wMzUwNGMtMC4wMTQzNCwwLjAwNzIyIC0wLjAyODQ1LDAuMDE0ODQgLTAuMDQyMzEsMC4wMjI4MmMtMC4yMDIyNCwwLjA0MTYgLTAuNDEyMiwwLjA2MTQ5IC0wLjYyNzI3LDAuMDU3MTdoLTAuMDQxNjZ6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzUuMzExMDMsMTg2LjY4NzI1YzAuMDAwNzgsMC4wMDAyNyAwLjAwMTU2LDAuMDAwNTUgMC4wMDIzNCwwLjAwMDgyYy0wLjAwMDIzLDAuMDAwMjYgLTAuMDAwNDUsMC4wMDA1MyAtMC4wMDA2NywwLjAwMDhjLTAuMDAwNTQsLTAuMDAwNTQgLTAuMDAxMSwtMC4wMDEwOCAtMC4wMDE2NiwtMC4wMDE2MnoiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDQuMzY2MDIsMTgzLjY1MzkxbC04LjEyOTA0LDAuMDQwMzQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzkuOTMwODUsMTc1LjQ2MTcxbC0zLjgxOTk0LDguMDEyMTYiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzMuNTA1OTUsMTc1LjY0ODI1YzUuMzI4MTIsMC44OTYxMSA5LjQzNjI5LDUuMzg2OTYgOS43NDQ3LDEwLjg5MjciIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjcuNTA1NjQ2NDg4OTIyMTE6Ny41MTU1NjI5ODc4MDU0MjQtLT4=>
        </div>
        <div id="nav-btn-file" class="btn sidebar-nav-btn" title="文件">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNS45MTI0MSIgaGVpZ2h0PSIxMy45MjQ1NSIgdmlld0JveD0iMCwwLDE1LjkxMjQxLDEzLjkyNDU1Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjA0Mzc5LC0xNzMuMDM3NzIpIj48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnPjxwYXRoIGQ9Ik0yNDcuMjA2MTgsMTgzLjE0NDY5bC0wLjAwMzY4LDAuNTUyMTFjLTAuMDAwMTgsMC4wMTcxNCAtMC4wMDA1NSwwLjAzNDMzIC0wLjAwMTA3LDAuMDUxNTNjLTAuMDQyOTcsMS40MDA1NyAtMS4xOTQxNCwyLjUwMDQ5IC0yLjU3MTIxLDIuNDU2NzJjLTAuMDEwOSwtMC4wMDAzNSAtMC4wMjE4MSwtMC4wMDA3NyAtMC4wMzI2OCwtMC4wMDEyNWwtMi4wNjYwOSwwLjAwMjE5bC01Ljg5ODA0LDAuMDA0NjJsLTEuMjYyODQsMC4wMDEzM2MtMC4wMTY4NSwwLjAwMDI3IC0wLjAzMzc1LDAuMDAwMzkgLTAuMDUwNjgsMC4wMDAzNGMtMS4zNzc3MywtMC4wMDUwMiAtMi40OTA2MywtMS4xNDUwMiAtMi40ODU3MSwtMi41NDYyNmMwLjAwMDA0LC0wLjAxMTEgMC4wMDAxNiwtMC4wMjIxOCAwLjAwMDM0LC0wLjAzMzI3bC0wLjAwMTY2LC0wLjMzMTg3bC0wLjAzOTAzLC0zLjc4NTEybDAuMDA0MDcsLTAuNTUyMTFjMC4wMDAyLC0wLjAxNzE0IDAuMDAwNTcsLTAuMDM0MzMgMC4wMDExMSwtMC4wNTE1M2MwLjA0Mzk1LC0xLjQwMDUyIDEuMTk1ODgsLTIuNDk5NjUgMi41NzI5MSwtMi40NTQ5NGMwLjAxMDksMC4wMDAzNSAwLjAyMTgxLDAuMDAwNzggMC4wMzI2OCwwLjAwMTI4bDIuMDY2MDksLTAuMDAwNzZsNS44OTgwNiwtMC4wMDA1M2wxLjI2Mjg0LC0wLjAwMDQ2YzAuMDE2ODUsLTAuMDAwMjcgMC4wMzM3NSwtMC4wMDAzNyAwLjA1MDY4LC0wLjAwMDNjMS4zNzc3MSwwLjAwNTk5IDIuNDg5ODIsMS4xNDY3NCAyLjQ4Mzk1LDIuNTQ3OTdjLTAuMDAwMDQsMC4wMTExIC0wLjAwMDE2LDAuMDIyMTggLTAuMDAwMzUsMC4wMzMyN2wwLjAwMTQxLDAuMzMxODd6IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzIuODIwNjcsMTc5Ljg3ODE0bDAuMDI5NTcsLTMuMjIzMTdsMC4wMDMyNiwtMC41MTczNWMwLjAwMDE2LC0wLjAxNjA3IDAuMDAwNDYsLTAuMDMyMTYgMC4wMDA5LC0wLjA0ODI5YzAuMDM1MjgsLTEuMzEyMzYgMC45NTk4MiwtMi4zNDIyOCAyLjA2NTAyLC0yLjMwMDM3YzAuMDA4NzUsMC4wMDAzNCAwLjAxNzUsMC4wMDA3MyAwLjAyNjIzLDAuMDAxMmwzLjgyNTc3LC0wLjAwMTYzYzAuMDEzNTIsLTAuMDAwMjUgMC4wMjcwOSwtMC4wMDAzNCAwLjA0MDY4LC0wLjAwMDI3YzEuMTA1NzUsMC4wMDU2MSAxLjk5ODMxLDEuMDc0NTQgMS45OTM1OSwyLjM4NzU2Yy0wLjAwMDA0LDAuMDEwNDIgLTAuMDAwMTMsMC4wMjA3OSAtMC4wMDAyOSwwLjAzMTE3bDAuMDAxMTMsMC4zMTA5OCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQyLjE0MTExLDE4Mi42MjU1NWgtMy44MzczIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ny45NTYyMDgwMDY3NTUzODk6Ni45NjIyODE3NzI4Nzg5NTMtLT4=>
        </div>
        <div id="nav-btn-settings" class="btn sidebar-nav-btn" title="设置">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNC40Njg2NiIgaGVpZ2h0PSIxMy41NzgwOSIgdmlld0JveD0iMCwwLDE0LjQ2ODY2LDEzLjU3ODA5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjc2NjExLC0xNzMuMjIxNTgpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC42MjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzOS41OTUyNSwxODUuMDEyMjZjLTAuMTM5MzksMC4wODExMSAtMC4yNTE0NiwwLjE4NjMxIC0wLjM1MTk0LDAuMzExNDNjLTAuMTAwNDksMC4xMjUxMSAtMC4xOTUxNSwwLjI2MDE3IC0wLjMwNTU5LDAuMzkxMDljLTAuMTEwNDQsMC4xMzA4OSAtMC4xOTUxNSwwLjI2MDE3IC0wLjMwNTU5LDAuMzkxMDljLTAuMTEwNDQsMC4xMzA4OSAtMC4yMjI0OSwwLjIzNjA5IC0wLjM1MTk0LDAuMzExNDNjLTAuMTE5NDksMC4wNjk1MyAtMC4yMzA2NCwwLjEwNzU1IC0wLjM1OTIsMC4xMTU3Yy0wLjEyODU1LDAuMDA4MTYgLTAuMjU4NzIsLTAuMDA5NCAtMC4zODA1NiwtMC4wNTg0N2MtMC4wODQ1NCwtMC4wMzA3OCAtMC4xOTA2NSwtMC4wNzU2NiAtMC4zMTI1LC0wLjEyNDcyYy0wLjEyMTg1LC0wLjA0OTA2IC0wLjI2MTA4LC0wLjEyOCAtMC4zOTQ1MSwtMC4xOTY5NmMtMC4xMzM0NCwtMC4wNjg5OCAtMC4yODg0LC0wLjE1MjA2IC0wLjQzMzQ0LC0wLjI0MDk3Yy0wLjE0NTA0LC0wLjA4ODg5IC0wLjI5MDAzLC0wLjE3Nzc3IC0wLjQxOTMyLC0wLjI2MjVjLTAuMTI5MjYsLTAuMDg0NzMgLTAuMjM4NjMsLTAuMTgxMDMgLTAuMzQyMTksLTAuMjY3MzljLTAuMTAzNTgsLTAuMDg2MzUgLTAuMTY1NjYsLTAuMTcwMTggLTAuMjEyMDIsLTAuMjQ5ODVjLTAuMDgxMTEsLTAuMTM5MzkgLTAuMTE2NTksLTAuMjkyMDIgLTAuMTEwNjQsLTAuNDQyMTJjMC4wMDU5NywtMC4xNTAwOSAwLjAzNzY1LC0wLjMwMTgxIDAuMDg1MDcsLTAuNDQ5MzdjMC4wNDc0MywtMC4xNDc1NiAwLjExNDc3LC0wLjMwNjcgMC4xODc5MSwtMC40NTU4OGMwLjA3MzEzLC0wLjE0OTE5IDAuMTQwNDksLTAuMzA4MzIgMC4xODc5MSwtMC40NTU4OGMwLjA0NzQzLC0wLjE0NzU2IDAuMDc5MTEsLTAuMjk5MjggMC4wOTA4NywtMC40Mzk0MWMwLjAxMTc3LC0wLjE0MDEzIC0wLjAxNzkzLC0wLjI4MjggLTAuMDk5MDQsLTAuNDIyMTljLTAuMDc1MzMsLTAuMTI5NDUgLTAuMTg0NjksLTAuMjI1NzcgLTAuMzE4MTEsLTAuMjk0NzNjLTAuMTMzNDQsLTAuMDY4OTggLTAuMjc1MiwtMC4xMDY0NCAtMC40MzI3LC0wLjE0ODA5Yy0wLjE1NzUxLC0wLjA0MTY0IC0wLjMyMzM2LC0wLjA1MTc3IC0wLjQ5NDk4LC0wLjA3MTg1Yy0wLjE3MTY0LC0wLjAyMDA5IC0wLjMzMzMyLC0wLjA0NTk4IC0wLjQ5NDk4LC0wLjA3MTg1Yy0wLjE2MTY4LC0wLjAyNTg5IC0wLjMwNTA3LC0wLjA4OTA2IC0wLjQzODQ5LC0wLjE1ODA1Yy0wLjEzMzQ0LC0wLjA2ODk4IC0wLjI0Mjc5LC0wLjE2NTI4IC0wLjMyOTcsLTAuMzE0NjZjLTAuMDQwNTYsLTAuMDY5NyAtMC4wNzI4LC0wLjE3MDkxIC0wLjA5NjcsLTAuMzAzNjFjLTAuMDIzOSwtMC4xMzI3MSAtMC4wNTM2LC0wLjI3NTM4IC0wLjA2MzM5LC0wLjQyOTYyYy0wLjAwOTc5LC0wLjE1NDI0IC0wLjAxNTQsLTAuMzI0MjggLTAuMDIxMDIsLTAuNDk0MjdjLTAuMDA1NjIsLTAuMTcwMDIgLTAuMDAxMjksLTAuMzQ1NzkgMC4wMDg4NSwtMC41MTE2NWMwLjAxMDE0LC0wLjE2NTg0IDAuMDE2MDksLTAuMzE1OTIgMC4wMjc4NiwtMC40NTYwNWMwLjAxMTc3LC0wLjE0MDEzIDAuMDMwOTcsLTAuMjQ0NiAwLjA0NTk4LC0wLjMzMzMyYzAuMDI3NTIsLTAuMTM1OTcgMC4wODIzNiwtMC4yNDc4NSAwLjE1Mjk3LC0wLjM1NTU5YzAuMDcwNjEsLTAuMTA3NzMgMC4xNjg1NCwtMC4xOTEzNyAwLjI3ODA4LC0wLjI1NTExYzAuMTM5MzksLTAuMDgxMTEgMC4yODYyMywtMC4xMjY1NiAwLjQ0NDY2LC0wLjE1MjA5YzAuMTU4NDIsLTAuMDI1NTQgMC4zMjI2MiwtMC4wNDExIDAuNDg2ODMsLTAuMDU2NjljMC4xNjQyMSwtMC4wMTU1OSAwLjMyODQxLC0wLjAzMTE1IDAuNDg2ODMsLTAuMDU2NjljMC4xNTg0MiwtMC4wMjU1NCAwLjMwNTI0LC0wLjA3MDk4IDAuNDQ0NjYsLTAuMTUyMDljMC4xNzkyNCwtMC4xMDQyOSAwLjI5OTYzLC0wLjI0MDk4IDAuMzU1MzgsLTAuNDIwMDRjMC4wNTU3NiwtMC4xNzkwNiAwLjA2NDI1LC0wLjM3MDYxIC0wLjAwNDM3LC0wLjU1NzI2Yy0wLjA3MDI1LC0wLjIxMjM3IC0wLjE1MDQ2LC0wLjQxODk1IC0wLjIyMDczLC0wLjYzMTMxYy0wLjA3MDI1LC0wLjIxMjM3IC0wLjE1MDQ2LC0wLjQxODk1IC0wLjIyMDczLC0wLjYzMTMxYy0wLjA2Mjg0LC0wLjE3NjcgLTAuMDc0MjQsLTAuMzU2NjcgLTAuMDIyNjUsLTAuNTE5OThjMC4wNTE2LC0wLjE2MzMxIDAuMTUwNDUsLTAuMzE0MTMgMC4yODY1OCwtMC40NDY2NmMwLjE0MTk0LC0wLjEyMjU3IDAuMjc5NzIsLTAuMjI5NCAwLjQzMzI1LC0wLjMzMjA2YzAuMTUzNTMsLTAuMTAyNjYgMC4zMTI4NCwtMC4xOTUzNiAwLjQ2MjIyLC0wLjI4MjI4YzAuMTU5MzIsLTAuMDkyNyAwLjMzNDM4LC0wLjE4MTI0IDAuNDk5NSwtMC4yNjM5OWMwLjE2NTEyLC0wLjA4Mjc0IDAuMzQ1OTcsLTAuMTYxMzQgMC41MjI2OCwtMC4yMjQxNmMwLjE3NjcsLTAuMDYyODQgMC4zNTY2NywtMC4wNzQyNCAwLjUxOTk4LC0wLjAyMjY1YzAuMTYzMzEsMC4wNTE2IDAuMzA4MzIsMC4xNDA0OSAwLjQ0MDg2LDAuMjc2NjJjMC4xNDk5MywwLjE2NjAxIDAuMjg5ODgsMC4zMzc4MiAwLjQyOTgyLDAuNTA5NjRjMC4xMzk5NiwwLjE3MTgxIDAuMjc5OTEsMC4zNDM2MyAwLjQyOTgyLDAuNTA5NjRjMC4xMjgzNywwLjE1MTg5IDAuMjg5MTQsMC4yNDQ5NCAwLjQ4MjMyLDAuMjc5MTZjMC4xOTMyLDAuMDM0MiAwLjM3MTUyLC0wLjAwMjkgMC41NDA3OCwtMC4xMDE0YzAuMTM5MzksLTAuMDgxMTEgMC4yNTE0NiwtMC4xODYzMSAwLjM1MTk0LC0wLjMxMTQzYzAuMTAwNDksLTAuMTI1MTEgMC4xOTUxNSwtMC4yNjAxNyAwLjMwNTU5LC0wLjM5MTA5YzAuMTEwNDQsLTAuMTMwODkgMC4xOTUxNSwtMC4yNjAxNyAwLjMwNTU5LC0wLjM5MTA5YzAuMTEwNDQsLTAuMTMwODkgMC4yMjI0OSwtMC4yMzYwOSAwLjM1MTk0LC0wLjMxMTQzYzAuMTE5NDksLTAuMDY5NTMgMC4yNDA2LC0wLjExMzM0IDAuMzY5MTYsLTAuMTIxNDljMC4xMjg1NSwtMC4wMDgxNiAwLjI0ODc2LDAuMDE1MTkgMC4zODA1NiwwLjA1ODQ3YzAuMDg0NTQsMC4wMzA3OCAwLjE5MDY1LDAuMDc1NjYgMC4zMTI1LDAuMTI0NzJjMC4xMjE4NSwwLjA0OTA2IDAuMjYxMDgsMC4xMjggMC4zOTQ1MSwwLjE5Njk2YzAuMTMzNDQsMC4wNjg5OCAwLjI4ODQsMC4xNTIwNiAwLjQzMzQ0LDAuMjQwOTdjMC4xNDUwNCwwLjA4ODg5IDAuMjkwMDMsMC4xNzc3NyAwLjQxOTMyLDAuMjYyNWMwLjEyOTI2LDAuMDg0NzMgMC4yMzg2MywwLjE4MTAzIDAuMzQyMTksMC4yNjczOWMwLjEwMzU4LDAuMDg2MzUgMC4xNjU2NiwwLjE3MDE4IDAuMjEyMDIsMC4yNDk4NWMwLjA4MTExLDAuMTM5MzkgMC4xMTY1OSwwLjI5MjAyIDAuMTEwNjQsMC40NDIxMmMtMC4wMDU5NywwLjE1MDA5IC0wLjAzNzY1LDAuMzAxODEgLTAuMDg1MDcsMC40NDkzN2MtMC4wNDc0MywwLjE0NzU2IC0wLjExNDc3LDAuMzA2NyAtMC4xODc5MSwwLjQ1NTg4Yy0wLjA3MzEzLDAuMTQ5MTkgLTAuMTQwNDksMC4zMDgzMiAtMC4xODc5MSwwLjQ1NTg4Yy0wLjA0NzQzLDAuMTQ3NTYgLTAuMDc5MTEsMC4yOTkyOCAtMC4wOTA4NywwLjQzOTQxYy0wLjAxMTc3LDAuMTQwMTMgMC4wMTc5MywwLjI4MjggMC4wOTkwNCwwLjQyMjE5YzAuMDc1MzMsMC4xMjk0NSAwLjE4NDY5LDAuMjI1NzcgMC4zMTgxMSwwLjI5NDczYzAuMTMzNDQsMC4wNjg5OCAwLjI3NTIsMC4xMDY0NCAwLjQzMjcsMC4xNDgwOWMwLjE1NzUxLDAuMDQxNjQgMC4zMjMzNiwwLjA1MTc3IDAuNDk0OTgsMC4wNzE4NWMwLjE3MTY0LDAuMDIwMDkgMC4zMzMzMiwwLjA0NTk4IDAuNDk0OTgsMC4wNzE4NWMwLjE2MTY4LDAuMDI1ODkgMC4zMDUwNywwLjA4OTA2IDAuNDM4NDksMC4xNTgwNWMwLjEzMzQ0LDAuMDY4OTggMC4yNDI3OSwwLjE2NTI4IDAuMzI5NywwLjMxNDY2YzAuMDQ2MzUsMC4wNzk2NiAwLjA3ODU4LDAuMTgwODUgMC4xMDI0OSwwLjMxMzU4YzAuMDIzOSwwLjEzMjcxIDAuMDQ3OCwwLjI2NTQyIDAuMDYzMzksMC40Mjk2MmMwLjAxNTU5LDAuMTY0MjEgMC4wMTU0LDAuMzI0MjggMC4wMjEwMiwwLjQ5NDI3YzAuMDA1NjIsMC4xNzAwMiAtMC4wMDQ1MSwwLjMzNTg1IC0wLjAxNDY0LDAuNTAxNjljLTAuMDEwMTQsMC4xNjU4NCAtMC4wMjE4OSwwLjMwNTk2IC0wLjAzMzY1LDAuNDQ2MTFjLTAuMDExNzcsMC4xNDAxMyAtMC4wMjUxNiwwLjI1NDU2IC0wLjA0NTk4LDAuMzMzMzJjLTAuMDI3NTIsMC4xMzU5NyAtMC4wODIzNiwwLjI0Nzg1IC0wLjE0MzAxLDAuMzQ5NzljLTAuMDYwNjUsMC4xMDE5MyAtMC4xNTg2LDAuMTg1NTggLTAuMjY4MTIsMC4yNDkzMWMtMC4xMjk0NSwwLjA3NTMzIC0wLjI3NjI3LDAuMTIwNzcgLTAuNDQ0NjYsMC4xNTIwOWMtMC4xNjgzNiwwLjAzMTMyIC0wLjMzMjU4LDAuMDQ2OSAtMC40OTY3OSwwLjA2MjQ5Yy0wLjE2NDIxLDAuMDE1NTkgLTAuMzM4MzcsMC4wMzY5NCAtMC40OTY3OSwwLjA2MjQ5Yy0wLjE1ODQyLDAuMDI1NTQgLTAuMzA1MjQsMC4wNzA5OCAtMC40MzQ3LDAuMTQ2M2MtMC4xNjkyNywwLjA5ODQ5IC0wLjI3NTU0LDAuMjEzNjYgLTAuMzM0NTYsMC4zNDEyOWMtMC4wNTkwMiwwLjEyNzY0IC0wLjA3NjU3LDAuMjU3ODIgLTAuMDYyNjQsMC4zOTYzMWMwLjAxMzk2LDAuMTM4NSAwLjA0MzY0LDAuMjgxMTcgMC4xMDQ4NSwwLjQzMjE3YzAuMDYxMiwwLjE1MDk4IDAuMTEwODEsMC4yODIwNiAwLjE1NjI1LDAuNDI4OTFjMC4wMzgwMiwwLjExMTE2IDAuMDc2MDUsMC4yMjIzMyAwLjExNDA4LDAuMzMzNDhjMC4wMzgwMiwwLjExMTE2IDAuMDcwMjUsMC4yMTIzNyAwLjExNDA4LDAuMzMzNDhjMC4wNjg2MiwwLjE4NjY1IDAuMDc0MjQsMC4zNTY2NyAwLjAyODQ1LDAuNTI5OTNjLTAuMDQ1OCwwLjE3MzI3IC0wLjE1MDQ1LDAuMzE0MTMgLTAuMzAyMzMsMC40NDI0OWMtMC4xNDE5NCwwLjEyMjU3IC0wLjI3OTcyLDAuMjI5NCAtMC40MzMyNSwwLjMzMjA2Yy0wLjE1MzUzLDAuMTAyNjYgLTAuMzEyODQsMC4xOTUzNiAtMC40NzIxNiwwLjI4ODA2Yy0wLjE1OTMyLDAuMDkyNyAtMC4zMzQzOCwwLjE4MTI0IC0wLjQ5OTUsMC4yNjM5OWMtMC4xNjUxMiwwLjA4Mjc0IC0wLjM0NTk3LDAuMTYxMzQgLTAuNTIyNjgsMC4yMjQxNmMtMC4xNzY3LDAuMDYyODQgLTAuMzU2NjcsMC4wNzQyNCAtMC41MTk5OCwwLjAyMjY1Yy0wLjE2MzMxLC0wLjA1MTYgLTAuMzA4MzIsLTAuMTQwNDkgLTAuNDQ2NjYsLTAuMjg2NThjLTAuMTQ5OTMsLTAuMTY2MDEgLTAuMjg5ODgsLTAuMzM3ODIgLTAuNDI5ODIsLTAuNTA5NjRjLTAuMTM5OTYsLTAuMTcxODEgLTAuMjc5OTEsLTAuMzQzNjMgLTAuNDI5ODIsLTAuNTA5NjRjLTAuMTI4MzcsLTAuMTUxODkgLTAuMjg5MTQsLTAuMjQ0OTQgLTAuNDgyMzIsLTAuMjc5MTZjLTAuMTkzMiwtMC4wMzQyIC0wLjM2MTU0LC0wLjAwMjg5IC0wLjUzMDgzLDAuMDk1NnpNMjQzLjgxODIsMTg0LjY4NzY2Yy0wLjAzMjIzLC0wLjEwMTIxIC0wLjA4MDIyLC0wLjIwNjU4IC0wLjEzNTYzLC0wLjM0NzZjLTAuMDU1NDIsLTAuMTQxMDQgLTAuMTEwODEsLTAuMjgyMDYgLTAuMTY2MjMsLTAuNDIzMWMtMC4wNTU0MiwtMC4xNDEwNCAtMC4xMDA4NSwtMC4yODc4NiAtMC4xNDA1LC0wLjQyNDc0Yy0wLjAzOTY1LC0wLjEzNjg3IC0wLjA3NzY5LC0wLjI0ODAyIC0wLjA4ODM2LC0wLjMzNTEyYy0wLjA1ODUsLTAuMzUyNSAtMC4wMTgzMSwtMC42OTU3NiAwLjEyMjE2LC0xLjAwNDExYzAuMTQwNDksLTAuMzA4MzIgMC4zNjcxNSwtMC41NjAxOCAwLjY4NTc5LC0wLjc0NTU4YzAuMTA5NTMsLTAuMDYzNzMgMC4yNDA2LC0wLjExMzM0IDAuNDAzMiwtMC4xNTQ2NGMwLjE2MjU4LC0wLjA0MTI3IDAuMzI1MTcsLTAuMDgyNTcgMC41MDM1LC0wLjExOTY4YzAuMTc4MzIsLTAuMDM3MTIgMC4zNDY3MSwtMC4wNjg0NiAwLjUxMDkyLC0wLjA4NDAyYzAuMTY0MjEsLTAuMDE1NTkgMC4zMTY4MiwtMC4wNTEwNiAwLjQzOTU4LC0wLjA2OTE4YzAuMDUxNzcsLTAuMzIzMzYgMC4wODc3OCwtMC42NTA4NyAwLjA4ODE0LC0wLjk3MDk2YzAuMDAwMzQsLTAuMzIwMDggLTAuMDMwOCwtMC42NDg1MSAtMC4wNzE5MSwtMC45NzExNGwtMC4wMDU3OSwtMC4wMDk5NmwtMS4zMzY1MSwtMC4yMzUzYy0wLjI0MDQ0LC0wLjA0NjY5IC0wLjQ2MjU5LC0wLjEzMDcgLTAuNjY4MDgsLTAuMjc3NzFjLTAuMjA1NSwtMC4xNDcwMSAtMC4zNjEyMiwtMC4zMjI5NyAtMC40ODI4OSwtMC41MzIwOWMtMC4xMjE2NywtMC4yMDkxMSAtMC4xOTM1NywtMC40NDcxOCAtMC4yMTk4MiwtMC42OTg0OGMtMC4wMjYyNiwtMC4yNTEzIDAuMDEwNDgsLTAuNDg1OTMgMC4wODg2OSwtMC43MTgwNWwwLjQ0NzUxLC0xLjI0NjcxbC0wLjAwNTc5LC0wLjAwOTk2YzAsMCAtMC4wMjczNCwtMC4wMjQwOCAtMC4wNjA0NywtMC4wNTgxMmMtMC4wMzMxMywtMC4wMzQwNSAtMC4wNjQ2MiwtMC4wNDIzNiAtMC4wNzA0MywtMC4wNTIzMmMtMC4yMjg2NywtMC4xODY4MyAtMC40ODE0MiwtMC4zNDYzMyAtMC43MzgzMywtMC40OTAwNmMtMC4yNTY5MywtMC4xNDM3NCAtMC41Mjc5NSwtMC4yNjU5NCAtMC44MDg5NCwtMC4zODIzNWwtMC4wMDk5NiwwLjAwNTc5bC0wLjg2MzU1LDEuMDM1NjNjLTAuMTMwMzUsMC4xNDI0OSAtMC4yNzIyOCwwLjI2NTA2IC0wLjQzMTU5LDAuMzU3NzZjLTAuMjY4ODQsMC4xNTY0MyAtMC41NDI1OCwwLjIzNTc1IC0wLjgzNjk4LDAuMjMzNzdjLTAuMjUyOTMsMC4wMDA1NSAtMC40ODM0MSwtMC4wNTE5NSAtMC43MTEzNSwtMC4xNDU5Yy0wLjIyNzk0LC0wLjA5Mzk1IC0wLjQxMzUyLC0wLjI1MjU2IC0wLjU3NTAzLC0wLjQzODQ4bC0wLjg1OTY2LC0xLjAxOTI3Yy0wLjMwNzc4LDAuMTEyNDUgLTAuNTk4MTksMC4yNTQ3NiAtMC44ODY5NSwwLjQyMjc4Yy0wLjEzOTM5LDAuMDgxMTEgLTAuMjc4ODIsMC4xNjIyMyAtMC40MTI0MiwwLjI1MzNjLTAuMTMzNjEsMC4wOTEwNyAtMC4yNjcyMywwLjE4MjE0IC0wLjM5NTAzLDAuMjgzMThjMC4wNzYwNSwwLjIyMjMzIDAuMTU2MjUsMC40Mjg5MSAwLjIzNjQ4LDAuNjM1NDhjMC4wODAyMiwwLjIwNjU4IDAuMTUwNDYsMC40MTg5NSAwLjIyMDczLDAuNjMxMzFjMC4wNTg2NSwwLjE5MjQ2IDAuMDkxNjIsMC4zODY1MyAwLjA5ODg2LDAuNTgyMjRjMC4wMDcyNSwwLjE5NTcyIC0wLjAyNjk2LDAuMzg4OSAtMC4wODI3MiwwLjU2Nzk2Yy0wLjA1NTc2LDAuMTc5MDYgLTAuMTU4NzYsMC4zNDU2MyAtMC4yNzMzNiwwLjQ5MjNjLTAuMTE0NiwwLjE0NjY0IC0wLjI2NjQ5LDAuMjc1MDIgLTAuNDQ1NzMsMC4zNzkzMmMtMC4xNzkyNCwwLjEwNDI5IC0wLjM1NTkzLDAuMTY3MTIgLTAuNTUwMDMsMC4yMDAwOWwtMC4wMDk5NiwwLjAwNTc5bC0xLjMwNzE1LDAuMjI3NDRsLTAuMDA5OTYsMC4wMDU3OWMtMC4wNTE3NywwLjMyMzM2IC0wLjA3NzgzLDAuNjQ1MDcgLTAuMDg4MTQsMC45NzA5NmMtMC4wMTAzLDAuMzI1ODggMC4wMTUwNywwLjY0NDM1IDAuMDcxOTEsMC45NzExNGwwLjAwNTc5LDAuMDA5OTZsMS4zMzY1MSwwLjIzNTNjMC4yNDA0NCwwLjA0NjY5IDAuNDYyNTksMC4xMzA3IDAuNjY4MDgsMC4yNzc3MWMwLjIwNTUsMC4xNDcwMSAwLjM2MTIyLDAuMzIyOTcgMC40ODI4OSwwLjUzMjA5YzAuMTIxNjcsMC4yMDkxMSAwLjIxMzQ4LDAuNDM1NTkgMC4yMzM5NCwwLjY3NjkzYzAuMDIwNDYsMC4yNDEzNCAtMC4wMTA0OCwwLjQ4NTkzIC0wLjA4ODY5LDAuNzE4MDVsLTAuNDQ3NTEsMS4yNDY3MWwwLjAwNTc5LDAuMDA5OTZjMCwwIDAuMDI3MzQsMC4wMjQwOCAwLjA2MDQ3LDAuMDU4MTJjMC4wMzMxMywwLjAzNDA1IDAuMDY0NjIsMC4wNDIzNiAwLjA3MDQzLDAuMDUyMzJjMC4yMjg2NywwLjE4NjgzIDAuNDgxNDIsMC4zNDYzMyAwLjczODMzLDAuNDkwMDZjMC4yNTY5MywwLjE0Mzc0IDAuNTI3OTUsMC4yNjU5NCAwLjgwODk0LDAuMzgyMzVsMC4wMDk5NiwtMC4wMDU3OWwwLjg2MzU1LC0xLjAzNTYzYzAuMTMwMzUsLTAuMTQyNDkgMC4yNzIyOCwtMC4yNjUwNiAwLjQzMTU5LC0wLjM1Nzc2YzAuMjY4ODQsLTAuMTU2NDMgMC41NDI1OCwtMC4yMzU3NSAwLjgzNjk4LC0wLjIzMzc3YzAuMjUyOTMsLTAuMDAwNTUgMC40ODM0MSwwLjA1MTk1IDAuNzExMzUsMC4xNDU5YzAuMjI3OTQsMC4wOTM5NSAwLjQxMzUyLDAuMjUyNTYgMC41NzUwMywwLjQzODQ4bDAuODU5NjYsMS4wMTkyN2MwLjMwNzc4LC0wLjExMjQ1IDAuNTk4MTksLTAuMjU0NzYgMC44ODY5NSwtMC40MjI3OGMwLjEzOTM5LC0wLjA4MTExIDAuMjc4ODIsLTAuMTYyMjMgMC40MTI0MiwtMC4yNTMzYzAuMTMzNjEsLTAuMDkxMDcgMC4yNTE0NiwtMC4xODYzMSAwLjM2OTM0LC0wLjI4MTU0ek0yMzcuNzQ0MjYsMTgxLjMwNDI4Yy0wLjE3OTYxLC0wLjMwODY5IC0wLjI5MzY5LC0wLjY0MjE3IC0wLjMzMDYzLC0wLjk4MDU0Yy0wLjAzNjk0LC0wLjMzODM3IC0wLjAxNjY3LC0wLjY3MDA1IDAuMDY2NTgsLTAuOTg1MDhjMC4wODMyOCwtMC4zMTUwMyAwLjIyOTU1LC0wLjYxMzM5IDAuNDI4ODgsLTAuODg5MzJjMC4xOTkzMiwtMC4yNzU5MiAwLjQ2MzI3LC0wLjUwOTQ5IDAuNzcxOTYsLTAuNjg5MTFjMC4zMDg2OSwtMC4xNzk2MSAwLjY0MjE3LC0wLjI5MzY5IDAuOTgwNTQsLTAuMzMwNjNjMC4zMzgzNywtMC4wMzY5NCAwLjY3MDA1LC0wLjAxNjY3IDAuOTg1MDgsMC4wNjY1OGMwLjMxNTAzLDAuMDgzMjggMC42MTMzOSwwLjIyOTU1IDAuODg5MzIsMC40Mjg4OGMwLjI3NTkyLDAuMTk5MzIgMC41MDk0OSwwLjQ2MzI3IDAuNjg5MTEsMC43NzE5NmMwLjE3OTYxLDAuMzA4NjkgMC4yOTM2OSwwLjY0MjE3IDAuMzMwNjMsMC45ODA1NGMwLjAzNjk0LDAuMzM4MzcgMC4wMTY2NywwLjY3MDA1IC0wLjA2NjU4LDAuOTg1MDhjLTAuMDgzMjgsMC4zMTUwMyAtMC4yMjk1NSwwLjYxMzM5IC0wLjQyODg4LDAuODg5MzJjLTAuMTk5MzIsMC4yNzU5MiAtMC40NjMyNywwLjUwOTQ5IC0wLjc3MTk2LDAuNjg5MTFjLTAuMzA4NjksMC4xNzk2MSAtMC42NDIxNywwLjI5MzY5IC0wLjk4MDU0LDAuMzMwNjNjLTAuMzM4MzcsMC4wMzY5NCAtMC42NzAwNSwwLjAxNjY3IC0wLjk4NTA4LC0wLjA2NjU4Yy0wLjMxNTAzLC0wLjA4MzI4IC0wLjYxMzM5LC0wLjIyOTU1IC0wLjg4OTMyLC0wLjQyODg4Yy0wLjI3NTkyLC0wLjE5OTMyIC0wLjUwOTQ5LC0wLjQ2MzI3IC0wLjY4OTExLC0wLjc3MTk2ek0yNDEuNDc4MzEsMTc5LjEzMTU2Yy0wLjEyMTY3LC0wLjIwOTExIC0wLjI3MTYsLTAuMzc1MTIgLTAuNDU1NTMsLTAuNTA4MDFjLTAuMTgzOTUsLTAuMTMyODkgLTAuMzg2MTksLTAuMjI4NDcgLTAuNTk2NzUsLTAuMjkyNTRjLTAuMjEwNTYsLTAuMDY0MDcgLTAuNDM3NzgsLTAuMDY1MTYgLTAuNjYzMzYsLTAuMDQwNTNjLTAuMjI1NTksMC4wMjQ2MyAtMC40NDc5MiwwLjEwMDY5IC0wLjY0NzA2LDAuMjE2NTZjLTAuMTk5MTUsMC4xMTU4OCAtMC4zNzUxMiwwLjI3MTYgLTAuNTA4MDEsMC40NTU1M2MtMC4xMzI4OSwwLjE4Mzk1IC0wLjIyODQ3LDAuMzg2MTkgLTAuMjkyNTQsMC41OTY3NWMtMC4wNjQwNywwLjIxMDU2IC0wLjA2NTE2LDAuNDM3NzggLTAuMDQwNTMsMC42NjMzNmMwLjAyNDYzLDAuMjI1NTkgMC4xMDA2OSwwLjQ0NzkyIDAuMjE2NTYsMC42NDcwNmMwLjExNTg4LDAuMTk5MTUgMC4yNzE2LDAuMzc1MTIgMC40NTU1MywwLjUwODAxYzAuMTgzOTUsMC4xMzI4OSAwLjM4NjE5LDAuMjI4NDcgMC41OTY3NSwwLjI5MjU0YzAuMjEwNTYsMC4wNjQwNyAwLjQzNzc4LDAuMDY1MTYgMC42NjMzNiwwLjA0MDUzYzAuMjI1NTksLTAuMDI0NjMgMC40NDc5MiwtMC4xMDA2OSAwLjY0NzA2LC0wLjIxNjU2YzAuMTk5MTUsLTAuMTE1ODggMC4zNzUxMiwtMC4yNzE2IDAuNTA4MDEsLTAuNDU1NTNjMC4xMzI4OSwtMC4xODM5NSAwLjIyODQ3LC0wLjM4NjE5IDAuMjkyNTQsLTAuNTk2NzVjMC4wNjQwNywtMC4yMTA1NiAwLjA2NTE2LC0wLjQzNzc4IDAuMDQwNTMsLTAuNjYzMzZjLTAuMDI0NjMsLTAuMjI1NTkgLTAuMTAwNjksLTAuNDQ3OTIgLTAuMjE2NTYsLTAuNjQ3MDZ6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ny4yMzM4OTEzMTM3OTYxMDc6Ni43Nzg0MjE4MzI5NDk1NjItLT4=>
        </div>
        <div id="nav-btn-collapse" class="btn sidebar-nav-btn" title="收起侧栏">
            <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4xNTg0NyIgaGVpZ2h0PSI5LjM0OTkiIHZpZXdCb3g9IjAsMCwxMi4xNTg0Nyw5LjM0OTkiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzMuOTIwNzcsLTE3NS4zNTg1MykiPjxnIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjI1IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuMDg2ODUsMTg0LjU4MzM3YzAuMjQ3NDIsMC4wMDIwMSAwLjQ3NTQ2LC0wLjA0Njc1IDAuNjkzOTgsLTAuMTQ2MjFjMC4yMTg1MiwtMC4wOTk0NiAwLjQxNzQ3LC0wLjIyOTQ0IDAuNTc3MTgsLTAuNDAwMjJjMC4xNTk2OSwtMC4xNzA4IDAuMjk5NzQsLTAuMzYxOTggMC40MDA0MywtMC41ODM4OWMwLjEwMDY5LC0wLjIyMTg4IDAuMTUyMDcsLTAuNDY0NDIgMC4xNTM5NSwtMC43MDczNWwwLjA0MTg1LC01LjM5NTEzYzAuMDAxOTYsLTAuMjUzMDUgLTAuMDQ1NzMsLTAuNDg2MjcgLTAuMTQyOTYsLTAuNzA5NzZjLTAuMDk3MjQsLTAuMjIzNDkgLTAuMjI0MzQsLTAuNDI2OTcgLTAuMzkxMzIsLTAuNTkwMjljLTAuMTY3LC0wLjE2MzMyIC0wLjM1MzkzLC0wLjMwNjU1IC0wLjU3MDksLTAuNDA5NTVjLTAuMjE2OTUsLTAuMTAyOTkgLTAuNDU0MDksLTAuMTU1NTMgLTAuNjkxNjIsLTAuMTU3NDVsLTguMjQ0MjgsLTAuMDY2ODljLTAuMjQ3NDIsLTAuMDAyMDEgLTAuNDc1NDYsMC4wNDY3NSAtMC42OTM5OCwwLjE0NjIxYy0wLjIxODUyLDAuMDk5NDYgLTAuNDE3NDksMC4yMjk0NSAtMC41NzcxOCwwLjQwMDIzYy0wLjE1OTY5LDAuMTcwOCAtMC4yOTk3NCwwLjM2MTk4IC0wLjQwMDQzLDAuNTgzODZjLTAuMTAwNywwLjIyMTg4IC0wLjE1MjA3LDAuNDY0NDIgLTAuMTUzOTUsMC43MDczNWwtMC4wNDE4NSw1LjM5NTEzYy0wLjAwMTk2LDAuMjUzMDUgMC4wNDU3MSwwLjQ4NjI3IDAuMTQyOTYsMC43MDk3NmMwLjA5NzI1LDAuMjIzNDkgMC4yMjQzNCwwLjQyNjk5IDAuMzkxMzIsMC41OTAzMWMwLjE2NywwLjE2MzMyIDAuMzUzOTMsMC4zMDY1NSAwLjU3MDksMC40MDk1NGMwLjIxNjk1LDAuMTAyOTkgMC40NTQwOSwwLjE1NTUzIDAuNjkxNjIsMC4xNTc0NXpNMjM4LjQ4MTA4LDE4My43Nzg2OGwwLjA1ODg5LC03LjU5MTYzbDUuNTYyMTYsMC4wNDUxM2MwLjE0ODQ2LDAuMDAxMiAwLjI5NjY3LDAuMDMyNzcgMC40MjQ4NiwwLjA5NDU2YzAuMTI4MTksMC4wNjE3OCAwLjI1NjIzLDAuMTQzOCAwLjM1NDQyLDAuMjQ1ODJjMC4wOTgxOSwwLjEwMjAzIDAuMTc2NDIsMC4yMjQxMyAwLjIzNDcsMC4zNjYzMmMwLjA1ODI5LDAuMTQyMiAwLjA4Njg3LDAuMjg0MTUgMC4wODU2OSwwLjQzNTk4bC0wLjA0MTIyLDUuMzE0MTRjLTAuMDAxMTgsMC4xNTE4MyAtMC4wMzIwNCwwLjMwMzQxIC0wLjA5MjQ0LDAuNDM0NTJjLTAuMDYwNDEsMC4xMzExMSAtMC4xNDA2MSwwLjI2MjA2IC0wLjI0MDM1LDAuMzYyNDljLTAuMDk5NzYsMC4xMDA0MiAtMC4yMTkxNSwwLjE4MDQzIC0wLjM1ODE5LDAuMjQwMDNjLTAuMTM5MDQsMC4wNTk2MSAtMC4yNzc4MiwwLjA4ODg1IC0wLjQyNjI3LDAuMDg3NjVsLTUuNTYyMTYsLTAuMDQ1MTN6TTI0MS40NzA4NiwxODEuMTQwNjNjMC4wMDA3OSwtMC4xMDEyMyAtMC4wMzgxLC0wLjE5MjY0IC0wLjEwNjg0LC0wLjI2NDA2bC0wLjg0NDM5LC0wLjg3NzQxbDMuNTYyOTYsMC4wMjg5MWMwLjA5ODk3LDAuMDAwOCAwLjE4ODM2LC0wLjAzODk3IDAuMjU4MiwtMC4xMDkyNmMwLjA2OTgzLC0wLjA3MDI5IDAuMTEwMTEsLTAuMTYxMDcgMC4xMTA5LC0wLjI2MjI5YzAuMDAwNzksLTAuMTAxMjMgLTAuMDM4MSwtMC4xOTI2NCAtMC4xMDY4MiwtMC4yNjQwNmMtMC4wNjg3NCwtMC4wNzE0MiAtMC4xNTc0OSwtMC4xMTI2NCAtMC4yNTY0NywtMC4xMTM0NGwtMy41NjI5NiwtMC4wMjg5MWwwLjg1NzksLTAuODYzNTljMC4wNjk4MywtMC4wNzAyOSAwLjExMDEzLC0wLjE2MTA3IDAuMTEwOTIsLTAuMjYyM2MwLjAwMDc5LC0wLjEwMTIzIC0wLjAzODEsLTAuMTkyNjMgLTAuMTA2ODQsLTAuMjY0MDZjLTAuMDY4NzMsLTAuMDcxNDIgLTAuMTU3NDksLTAuMTEyNjQgLTAuMjU2NDcsLTAuMTEzNDRjLTAuMDk4OTgsLTAuMDAwOCAtMC4xODgzNiwwLjAzODk3IC0wLjI1ODIsMC4xMDkyNmwtMS40OTYzNCwxLjUwNjI3Yy0wLjA2OTgzLDAuMDcwMjkgLTAuMTEwMTMsMC4xNjEwNyAtMC4xMTA5MiwwLjI2MjNjLTAuMDAwNzksMC4xMDEyMyAwLjAzODEsMC4xOTI2NCAwLjEwNjg0LDAuMjY0MDdsMS40NzI3OSwxLjUzMDM3YzAuMDY4NzMsMC4wNzE0MiAwLjE1NzQ5LDAuMTEyNjQgMC4yNTY0NywwLjExMzQ0YzAuMDk4OTgsMC4wMDA4IDAuMTg4MzYsLTAuMDM4OTYgMC4yNTgyLC0wLjEwOTI2YzAuMDY5ODMsLTAuMDcwMjkgMC4xMTAyOSwtMC4xODEzMSAwLjExMTA4LC0wLjI4MjU0ek0yMzUuODg4MDUsMTgzLjc1NzY0Yy0wLjE0ODQ2LC0wLjAwMTIgLTAuMjk2NjgsLTAuMDMyNzcgLTAuNDI0ODcsLTAuMDk0NTZjLTAuMTI4MTksLTAuMDYxNzggLTAuMjU2MjMsLTAuMTQzNzggLTAuMzU0NCwtMC4yNDU4MmMtMC4wOTgxOSwtMC4xMDIwMyAtMC4xNzY0MiwtMC4yMjQxMyAtMC4yMzQ3LC0wLjM2NjMyYy0wLjA1ODI5LC0wLjE0MjIgLTAuMDg2ODcsLTAuMjg0MTUgLTAuMDg1NjksLTAuNDM1OThsMC4wNDEyMiwtNS4zMTQxNGMwLjAwMTE4LC0wLjE1MTgzIDAuMDMyMDQsLTAuMzAzNDIgMC4wOTI0NCwtMC40MzQ1M2MwLjA2MDQxLC0wLjEzMTExIDAuMTQwNjEsLTAuMjYyMDUgMC4yNDAzNSwtMC4zNjI0NmMwLjA5OTc2LC0wLjEwMDQyIDAuMjE5MTUsLTAuMTgwNDMgMC4zNTgxNywtMC4yNDAwM2MwLjEzOTA0LC0wLjA1OTYxIDAuMjc3ODMsLTAuMDg4ODQgMC40MjYyOCwtMC4wODc2NGwxLjg2MDY1LDAuMDE1MWwtMC4wNTg4OSw3LjU5MTYzbC0xLjg2MDY1LC0wLjAxNTF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4wNzkyMzQ0MjEyMDAxMTM6NC42NDE0NzE2NTQ1NTk3OC0tPg==>
        </div>
    </div>
</div>
<div id="show-sidebar-btn" class="btn circle-btn" title="展开侧栏">
    <img src=data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4zODk2MyIgaGVpZ2h0PSI5LjQwMjIyIiB2aWV3Qm94PSIwLDAsMTIuMzg5NjMsOS40MDIyMiI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzMy44MDUxOCwtMTc1LjI5ODg5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuMjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTIzNS43NDE0MSwxODQuNTc2MTFjLTAuMjQ3NDMsMCAtMC40NzUwOCwtMC4wNDk0OCAtMC42OTI4MiwtMC4xNDg0NmMtMC4yMTc3NCwtMC4wOTg5OCAtMC40MTU3LC0wLjIyNzY0IC0wLjU3NDA2LC0wLjM5NTg5Yy0wLjE1ODM2LC0wLjE2ODI2IC0wLjI5NjkyLC0wLjM1NjMgLTAuMzk1ODksLTAuNTc0MDZjLTAuMDk4OTgsLTAuMjE3NzQgLTAuMTQ4NDYsLTAuNDU1MjggLTAuMTQ4NDYsLTAuNjkyODJ2LTUuMjc1MzJjMCwtMC4yNDc0MyAwLjA0OTQ4LC0wLjQ3NTA4IDAuMTQ4NDYsLTAuNjkyODJjMC4wOTg5OCwtMC4yMTc3NCAwLjIyNzY0LC0wLjQxNTcgMC4zOTU4OSwtMC41NzQwNmMwLjE2ODI2LC0wLjE1ODM2IDAuMzU2MywtMC4yOTY5MiAwLjU3NDA2LC0wLjM5NTg5YzAuMjE3NzQsLTAuMDk4OTggMC40NTUyOCwtMC4xNDg0NiAwLjY5MjgyLC0wLjE0ODQ2aDguMjQ0NTRjMC4yNDc0MywwIDAuNDc1MDgsMC4wNDk0OCAwLjY5MjgyLDAuMTQ4NDZjMC4yMTc3NCwwLjA5ODk4IDAuNDE1NywwLjIyNzY0IDAuNTc0MDYsMC4zOTU4OWMwLjE1ODM2LDAuMTY4MjYgMC4yOTY5MiwwLjM1NjMgMC4zOTU4OSwwLjU3NDA2YzAuMDk4OTgsMC4yMTc3NCAwLjE0ODQ2LDAuNDU1MjggMC4xNDg0NiwwLjY5MjgydjUuMjc1MzJjMCwwLjI0NzQzIC0wLjA0OTQ4LDAuNDc1MDggLTAuMTQ4NDYsMC42OTI4MmMtMC4wOTg5OCwwLjIxNzc0IC0wLjIyNzY0LDAuNDE1NyAtMC4zOTU4OSwwLjU3NDA2Yy0wLjE2ODI2LDAuMTU4MzYgLTAuMzU2MywwLjI5NjkyIC0wLjU3NDA2LDAuMzk1ODljLTAuMjE3NzQsMC4wOTg5OCAtMC40NTUyOCwwLjE0ODQ2IC0wLjY5MjgyLDAuMTQ4NDZ6TTI0MS4zNTMyNCwxODMuODMzODF2LTcuNDIzMDVoLTUuNTYyMzRjLTAuMTQ4NDYsMCAtMC4yOTY5MiwwLjAyOTY5IC0wLjQyNTU5LDAuMDg5MDhjLTAuMTI4NjcsMC4wNTkzOCAtMC4yNTczMywwLjEzODU3IC0wLjM1NjMsMC4yMzc1M2MtMC4wOTg5OCwwLjA5ODk4IC0wLjE3ODE1LDAuMjE3NzQgLTAuMjM3NTMsMC4zNTYzYy0wLjA1OTM4LDAuMTM4NTcgLTAuMDg5MDgsMC4yNzcxMyAtMC4wODkwOCwwLjQyNTU5djUuMTk2MTNjMCwwLjE0ODQ2IDAuMDI5NjksMC4yOTY5MiAwLjA4OTA4LDAuNDI1NTljMC4wNTkzOCwwLjEyODY3IDAuMTM4NTcsMC4yNTczMyAwLjIzNzUzLDAuMzU2M2MwLjA5ODk4LDAuMDk4OTggMC4yMTc3NCwwLjE3ODE1IDAuMzU2MywwLjIzNzUzYzAuMTM4NTcsMC4wNTkzOCAwLjI3NzEzLDAuMDg5MDggMC40MjU1OSwwLjA4OTA4aDUuNTYyMzR6TTIzOC4zODQwMiwxODEuMjMwNzljMCwtMC4wOTg5OCAwLjAzOTU5LC0wLjE4ODA1IDAuMTA4ODgsLTAuMjU3MzNsMC44NTExNywtMC44NTExN2gtMy41NjMwNmMtMC4wOTg5OCwwIC0wLjE4ODA1LC0wLjAzOTU5IC0wLjI1NzMzLC0wLjEwODg4Yy0wLjA2OTI4LC0wLjA2OTI4IC0wLjEwODg4LC0wLjE1ODM2IC0wLjEwODg4LC0wLjI1NzMzYzAsLTAuMDk4OTggMC4wMzk1OSwtMC4xODgwNSAwLjEwODg4LC0wLjI1NzMzYzAuMDY5MjgsLTAuMDY5MjggMC4xNTgzNiwtMC4xMDg4OCAwLjI1NzMzLC0wLjEwODg4aDMuNTYzMDZsLTAuODUxMTcsLTAuODUxMTdjLTAuMDY5MjgsLTAuMDY5MjggLTAuMTA4ODgsLTAuMTU4MzYgLTAuMTA4ODgsLTAuMjU3MzNjMCwtMC4wOTg5OCAwLjAzOTU5LC0wLjE4ODA1IDAuMTA4ODgsLTAuMjU3MzNjMC4wNjkyOCwtMC4wNjkyOCAwLjE1ODM2LC0wLjEwODg4IDAuMjU3MzMsLTAuMTA4ODhjMC4wOTg5OCwwIDAuMTg4MDUsMC4wMzk1OSAwLjI1NzMzLDAuMTA4ODhsMS40ODQ2MSwxLjQ4NDYxYzAuMDY5MjgsMC4wNjkyOCAwLjEwODg4LDAuMTU4MzYgMC4xMDg4OCwwLjI1NzMzYzAsMC4wOTg5OCAtMC4wMzk1OSwwLjE4ODA1IC0wLjEwODg4LDAuMjU3MzNsLTEuNDg0NjEsMS40ODQ2MWMtMC4wNjkyOCwwLjA2OTI4IC0wLjE1ODM2LDAuMTA4ODggLTAuMjU3MzMsMC4xMDg4OGMtMC4wOTg5OCwwIC0wLjE4ODA1LC0wLjAzOTU5IC0wLjI1NzMzLC0wLjEwODg4Yy0wLjA2OTI4LC0wLjA2OTI4IC0wLjEwODg4LC0wLjE3ODE1IC0wLjEwODg4LC0wLjI3NzEzek0yNDMuOTQ2MzUsMTgzLjgzMzgxYzAuMTQ4NDYsMCAwLjI5NjkyLC0wLjAyOTY5IDAuNDI1NTksLTAuMDg5MDhjMC4xMjg2NywtMC4wNTkzOCAwLjI1NzMzLC0wLjEzODU3IDAuMzU2MywtMC4yMzc1M2MwLjA5ODk4LC0wLjA5ODk4IDAuMTc4MTUsLTAuMjE3NzQgMC4yMzc1MywtMC4zNTYzYzAuMDU5MzgsLTAuMTM4NTcgMC4wODkwOCwtMC4yNzcxMyAwLjA4OTA4LC0wLjQyNTU5di01LjE5NjEzYzAsLTAuMTQ4NDYgLTAuMDI5NjksLTAuMjk2OTIgLTAuMDg5MDgsLTAuNDI1NTljLTAuMDU5MzgsLTAuMTI4NjcgLTAuMTM4NTcsLTAuMjU3MzMgLTAuMjM3NTMsLTAuMzU2M2MtMC4wOTg5OCwtMC4wOTg5OCAtMC4yMTc3NCwtMC4xNzgxNSAtMC4zNTYzLC0wLjIzNzUzYy0wLjEzODU3LC0wLjA1OTM4IC0wLjI3NzEzLC0wLjA4OTA4IC0wLjQyNTU5LC0wLjA4OTA4aC0xLjg2MDcxdjcuNDIzMDVoMS44NjA3MXoiLz48cGF0aCBkPSJNMjM1Ljg3NzczLDE4NC4zMjE2NWMtMC4yNDc0NCwwIC0wLjQ3NTA4LC0wLjA0OTQ4IC0wLjY5MjgyLC0wLjE0ODQ2Yy0wLjIxNzc0LC0wLjA5ODk4IC0wLjQxNTcsLTAuMjI3NjQgLTAuNTc0MDYsLTAuMzk1ODljLTAuMTU4MzYsLTAuMTY4MjYgLTAuMjk2OTIsLTAuMzU2MyAtMC4zOTU5LC0wLjU3NDA2Yy0wLjA5ODk3LC0wLjIxNzc0IC0wLjE0ODQ2LC0wLjQ1NTI4IC0wLjE0ODQ2LC0wLjY5Mjgydi01LjI3NTMyYzAsLTAuMjQ3NDMgMC4wNDk0OCwtMC40NzUwOCAwLjE0ODQ2LC0wLjY5MjgyYzAuMDk4OTgsLTAuMjE3NzQgMC4yMjc2NSwtMC40MTU3IDAuMzk1OSwtMC41NzQwNmMwLjE2ODI2LC0wLjE1ODM2IDAuMzU2MywtMC4yOTY5MiAwLjU3NDA2LC0wLjM5NTg5YzAuMjE3NzQsLTAuMDk4OTggMC40NTUyNywtMC4xNDg0NiAwLjY5MjgyLC0wLjE0ODQ2aDguMjQ0NTRjMC4yNDc0MywwIDAuNDc1MDgsMC4wNDk0OCAwLjY5MjgyLDAuMTQ4NDZjMC4yMTc3NCwwLjA5ODk4IDAuNDE1NywwLjIyNzY0IDAuNTc0MDYsMC4zOTU4OWMwLjE1ODM2LDAuMTY4MjYgMC4yOTY5MiwwLjM1NjMgMC4zOTU4OSwwLjU3NDA2YzAuMDk4OTgsMC4yMTc3NCAwLjE0ODQ2LDAuNDU1MjggMC4xNDg0NiwwLjY5MjgydjUuMjc1MzJjMCwwLjI0NzQzIC0wLjA0OTQ4LDAuNDc1MDggLTAuMTQ4NDYsMC42OTI4MmMtMC4wOTg5OCwwLjIxNzc0IC0wLjIyNzY0LDAuNDE1NyAtMC4zOTU4OSwwLjU3NDA2Yy0wLjE2ODI2LDAuMTU4MzYgLTAuMzU2MywwLjI5NjkyIC0wLjU3NDA2LDAuMzk1ODljLTAuMjE3NzQsMC4wOTg5OCAtMC40NTUyOCwwLjE0ODQ2IC0wLjY5MjgyLDAuMTQ4NDZ6TTI0MS40ODk1NiwxODMuNTc5MzV2LTcuNDIzMDVoLTUuNTYyMzNjLTAuMTQ4NDYsMCAtMC4yOTY5MiwwLjAyOTY5IC0wLjQyNTU5LDAuMDg5MDdjLTAuMTI4NjcsMC4wNTkzOSAtMC4yNTczNCwwLjEzODU3IC0wLjM1NjMsMC4yMzc1M2MtMC4wOTg5OCwwLjA5ODk4IC0wLjE3ODE1LDAuMjE3NzQgLTAuMjM3NTQsMC4zNTYzYy0wLjA1OTM4LDAuMTM4NTcgLTAuMDg5MDcsMC4yNzcxMyAtMC4wODkwNywwLjQyNTU5djUuMTk2MTNjMCwwLjE0ODQ2IDAuMDI5NjksMC4yOTY5MiAwLjA4OTA3LDAuNDI1NTljMC4wNTkzOSwwLjEyODY3IDAuMTM4NTcsMC4yNTczNCAwLjIzNzU0LDAuMzU2M2MwLjA5ODk3LDAuMDk4OTggMC4yMTc3NCwwLjE3ODE1IDAuMzU2MywwLjIzNzUzYzAuMTM4NTcsMC4wNTkzOSAwLjI3NzEzLDAuMDg5MDggMC40MjU1OSwwLjA4OTA4aDUuNTYyMzN6TTIzOC41MjAzNCwxODAuOTc2MzNjMCwtMC4wOTg5OCAwLjAzOTU5LC0wLjE4ODA0IDAuMTA4ODgsLTAuMjU3MzNsMC44NTExNywtMC44NTExN2gtMy41NjMwNmMtMC4wOTg5OCwwIC0wLjE4ODA1LC0wLjAzOTYgLTAuMjU3MzQsLTAuMTA4ODhjLTAuMDY5MjgsLTAuMDY5MjggLTAuMTA4ODgsLTAuMTU4MzYgLTAuMTA4ODgsLTAuMjU3MzRjMCwtMC4wOTg5OCAwLjAzOTU5LC0wLjE4ODA1IDAuMTA4ODgsLTAuMjU3MzNjMC4wNjkyOCwtMC4wNjkyOCAwLjE1ODM2LC0wLjEwODg4IDAuMjU3MzQsLTAuMTA4ODhoMy41NjMwNmwtMC44NTExNywtMC44NTExN2MtMC4wNjkyOCwtMC4wNjkyOCAtMC4xMDg4OCwtMC4xNTgzNiAtMC4xMDg4OCwtMC4yNTczNGMwLC0wLjA5ODk4IDAuMDM5NTksLTAuMTg4MDUgMC4xMDg4OCwtMC4yNTczM2MwLjA2OTI4LC0wLjA2OTI4IDAuMTU4MzYsLTAuMTA4ODggMC4yNTczNCwtMC4xMDg4OGMwLjA5ODk4LDAgMC4xODgwNSwwLjAzOTYgMC4yNTczNCwwLjEwODg4bDEuNDg0NjEsMS40ODQ2MWMwLjA2OTI4LDAuMDY5MjggMC4xMDg4OCwwLjE1ODM2IDAuMTA4ODgsMC4yNTczNGMwLDAuMDk4OTggLTAuMDM5NTksMC4xODgwNSAtMC4xMDg4OCwwLjI1NzM0bC0xLjQ4NDYxLDEuNDg0NjFjLTAuMDY5MjgsMC4wNjkyOCAtMC4xNTgzNiwwLjEwODg4IC0wLjI1NzM0LDAuMTA4ODhjLTAuMDk4OTgsMCAtMC4xODgwNSwtMC4wMzk1OSAtMC4yNTczNCwtMC4xMDg4OGMtMC4wNjkyOCwtMC4wNjkyOCAtMC4xMDg4OCwtMC4xNzgxNSAtMC4xMDg4OCwtMC4yNzcxM3pNMjQ0LjA4MjY3LDE4My41NzkzNWMwLjE0ODQ2LDAgMC4yOTY5MSwtMC4wMjk2OSAwLjQyNTU4LC0wLjA4OTA4YzAuMTI4NjcsLTAuMDU5MzkgMC4yNTczNCwtMC4xMzg1NSAwLjM1NjMyLC0wLjIzNzUzYzAuMDk4OTgsLTAuMDk4OTggMC4xNzgxNSwtMC4yMTc3NSAwLjIzNzUzLC0wLjM1NjMyYzAuMDU5MzksLTAuMTM4NTcgMC4wODkwNywtMC4yNzcxMyAwLjA4OTA3LC0wLjQyNTU5di01LjE5NjEzYzAsLTAuMTQ4NDYgLTAuMDI5NjksLTAuMjk2OTIgLTAuMDg5MDcsLTAuNDI1NTljLTAuMDU5MzksLTAuMTI4NjcgLTAuMTM4NTcsLTAuMjU3MzMgLTAuMjM3NTMsLTAuMzU2M2MtMC4wOTg5OCwtMC4wOTg5OCAtMC4yMTc3NSwtMC4xNzgxNSAtMC4zNTYzMiwtMC4yMzc1M2MtMC4xMzg1NywtMC4wNTkzOSAtMC4yNzcxMiwtMC4wODkwOCAtMC40MjU1OCwtMC4wODkwOGgtMS44NjA3MXY3LjQyMzA1aDEuODYwNzF6Ii8+PHBhdGggZD0iTTIzNi4wMTQwNSwxODQuNDU3OThjLTAuMjQ3NDMsMCAtMC40NzUwOCwtMC4wNDk0OCAtMC42OTI4MiwtMC4xNDg0NmMtMC4yMTc3NCwtMC4wOTg5OCAtMC40MTU2OCwtMC4yMjc2NCAtMC41NzQwNiwtMC4zOTU4OWMtMC4xNTgzNiwtMC4xNjgyNiAtMC4yOTY5MiwtMC4zNTYzIC0wLjM5NTg5LC0wLjU3NDA2Yy0wLjA5ODk3LC0wLjIxNzc0IC0wLjE0ODQ2LC0wLjQ1NTI4IC0wLjE0ODQ2LC0wLjY5Mjgydi01LjI3NTMyYzAsLTAuMjQ3NDMgMC4wNDk1LC0wLjQ3NTA4IDAuMTQ4NDYsLTAuNjkyODJjMC4wOTg5NywtMC4yMTc3NCAwLjIyNzY0LC0wLjQxNTY4IDAuMzk1ODksLTAuNTc0MDRjMC4xNjgyNiwtMC4xNTgzNiAwLjM1NjMsLTAuMjk2OTIgMC41NzQwNiwtMC4zOTU5YzAuMjE3NzQsLTAuMDk4OTggMC40NTUyOCwtMC4xNDg0NiAwLjY5MjgyLC0wLjE0ODQ2aDguMjQ0NTRjMC4yNDc0MywwIDAuNDc1MDgsMC4wNDk0OCAwLjY5MjgyLDAuMTQ4NDZjMC4yMTc3NCwwLjA5ODk4IDAuNDE1NywwLjIyNzY1IDAuNTc0MDYsMC4zOTU5YzAuMTU4MzYsMC4xNjgyNiAwLjI5NjkyLDAuMzU2MyAwLjM5NTg5LDAuNTc0MDRjMC4wOTg5OCwwLjIxNzc0IDAuMTQ4NDYsMC40NTUyOCAwLjE0ODQ2LDAuNjkyODJ2NS4yNzUzMmMwLDAuMjQ3NDMgLTAuMDQ5NDgsMC40NzUwOCAtMC4xNDg0NiwwLjY5MjgyYy0wLjA5ODk4LDAuMjE3NzQgLTAuMjI3NjQsMC40MTU3IC0wLjM5NTg5LDAuNTc0MDZjLTAuMTY4MjYsMC4xNTgzNiAtMC4zNTYzLDAuMjk2OTIgLTAuNTc0MDYsMC4zOTU4OWMtMC4yMTc3NCwwLjA5ODk4IC0wLjQ1NTI4LDAuMTQ4NDYgLTAuNjkyODIsMC4xNDg0NnpNMjQxLjYyNTg4LDE4My43MTU2OHYtNy40MjMwNWgtNS41NjIzNGMtMC4xNDg0NiwwIC0wLjI5NjkxLDAuMDI5NjkgLTAuNDI1NTgsMC4wODkwOGMtMC4xMjg2NywwLjA1OTM5IC0wLjI1NzM0LDAuMTM4NTcgLTAuMzU2MzIsMC4yMzc1M2MtMC4wOTg5OCwwLjA5ODk4IC0wLjE3ODE1LDAuMjE3NzQgLTAuMjM3NTMsMC4zNTYzYy0wLjA1OTM5LDAuMTM4NTcgLTAuMDg5MDcsMC4yNzcxMyAtMC4wODkwNywwLjQyNTU5djUuMTk2MTNjMCwwLjE0ODQ2IDAuMDI5NjksMC4yOTY5MSAwLjA4OTA3LDAuNDI1NThjMC4wNTkzOSwwLjEyODY3IDAuMTM4NTcsMC4yNTczNCAwLjIzNzUzLDAuMzU2MzJjMC4wOTg5OCwwLjA5ODk4IDAuMjE3NzQsMC4xNzgxNSAwLjM1NjMyLDAuMjM3NTNjMC4xMzg1NywwLjA1OTM5IDAuMjc3MTIsMC4wODkwOCAwLjQyNTU4LDAuMDg5MDhoNS41NjIzNHpNMjM4LjY1NjY2LDE4MS4xMTI2NmMwLC0wLjA5ODk4IDAuMDM5NTksLTAuMTg4MDUgMC4xMDg4OCwtMC4yNTczM2wwLjg1MTE3LC0wLjg1MTE3aC0zLjU2MzA3Yy0wLjA5ODk3LDAgLTAuMTg4MDUsLTAuMDM5NiAtMC4yNTczNCwtMC4xMDg4OGMtMC4wNjkyOCwtMC4wNjkyOCAtMC4xMDg4NiwtMC4xNTgzNiAtMC4xMDg4NiwtMC4yNTczM2MwLC0wLjA5ODk4IDAuMDM5NTksLTAuMTg4MDUgMC4xMDg4NiwtMC4yNTczM2MwLjA2OTI5LC0wLjA2OTI4IDAuMTU4MzYsLTAuMTA4ODggMC4yNTczNCwtMC4xMDg4OGgzLjU2MzA3bC0wLjg1MTE3LC0wLjg1MTE3Yy0wLjA2OTI4LC0wLjA2OTI4IC0wLjEwODg4LC0wLjE1ODM2IC0wLjEwODg4LC0wLjI1NzM0YzAsLTAuMDk4OTggMC4wMzk1OSwtMC4xODgwNCAwLjEwODg4LC0wLjI1NzMzYzAuMDY5MjgsLTAuMDY5MjggMC4xNTgzNiwtMC4xMDg4OCAwLjI1NzM0LC0wLjEwODg4YzAuMDk4OTgsMCAwLjE4ODA1LDAuMDM5NiAwLjI1NzM0LDAuMTA4ODhsMS40ODQ2MSwxLjQ4NDZjMC4wNjkyOCwwLjA2OTI4IDAuMTA4ODgsMC4xNTgzNiAwLjEwODg4LDAuMjU3MzRjMCwwLjA5ODk4IC0wLjAzOTU5LDAuMTg4MDUgLTAuMTA4ODgsMC4yNTczNGwtMS40ODQ2MSwxLjQ4NDYxYy0wLjA2OTI4LDAuMDY5MjggLTAuMTU4MzYsMC4xMDg4OCAtMC4yNTczNCwwLjEwODg4Yy0wLjA5ODk4LDAgLTAuMTg4MDUsLTAuMDM5NTkgLTAuMjU3MzQsLTAuMTA4ODhjLTAuMDY5MjgsLTAuMDY5MjggLTAuMTA4ODgsLTAuMTc4MTUgLTAuMTA4ODgsLTAuMjc3MTN6TTI0NC4yMTg5OSwxODMuNzE1NjhjMC4xNDg0NiwwIDAuMjk2OTIsLTAuMDI5NjkgMC40MjU1OSwtMC4wODkwOGMwLjEyODY3LC0wLjA1OTM5IDAuMjU3MzQsLTAuMTM4NTUgMC4zNTYzLC0wLjIzNzUzYzAuMDk4OTgsLTAuMDk4OTggMC4xNzgxNSwtMC4yMTc3NCAwLjIzNzUzLC0wLjM1NjNjMC4wNTkzOSwtMC4xMzg1NyAwLjA4OTA3LC0wLjI3NzEzIDAuMDg5MDcsLTAuNDI1NTl2LTUuMTk2MTNjMCwtMC4xNDg0NiAtMC4wMjk2OSwtMC4yOTY5MiAtMC4wODkwNywtMC40MjU1OWMtMC4wNTkzOSwtMC4xMjg2NyAtMC4xMzg1NywtMC4yNTczMyAtMC4yMzc1MywtMC4zNTYzYy0wLjA5ODk4LC0wLjA5ODk4IC0wLjIxNzc0LC0wLjE3ODE1IC0wLjM1NjMsLTAuMjM3NTNjLTAuMTM4NTcsLTAuMDU5MzkgLTAuMjc3MTMsLTAuMDg5MDcgLTAuNDI1NTksLTAuMDg5MDdoLTEuODYwNzF2Ny40MjMwNWgxLjg2MDcxeiIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjE5NDgxNTc0NDE5NzU5ODo0LjcwMTExMjM0ODMyMjczOC0tPg==>
</div>

<div id="keyboard-toggle-container">
    <div id="keyboard-toggle-btn" class="btn pill-btn main-ui-btn-color">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi40IiBoZWlnaHQ9IjEwLjMiIHZpZXdCb3g9IjAsMCwxMi40LDEwLjMiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzMuOCwtMTc0Ljg1KSI+PGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM1Ljk1LDE3Ny43di0wLjFjMCwtMS4xIDAuOSwtMiAyLC0yYzAuMiwwIDAuMywwIDAuNSwwLjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOC43NSwxNzUuN2wtMC40LC0wLjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzUuOTUsMTc3LjZ2Ni44IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM0LjU1LDE3OC45aDIuOCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC43NSwxODAuM2MwLjUsMC41IDAuNywxLjIgMC43LDEuOWMwLDAuOCAtMC4zLDEuNCAtMC44LDEuOSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjU1LDE4NC4xYy0wLjQsLTAuNSAtMC43LC0xLjIgLTAuNywtMS45YzAsLTAuNyAwLjMsLTEuMyAwLjcsLTEuOCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5Ljg1LDE4NC40bC0wLjMsLTAuMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOS40NSwxODAuNGwwLjMsLTAuNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC40NSwxODBsMC4zLDAuMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC44NSwxODRsLTAuNCwwLjQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuMzUsMTgzLjNsLTIuMiwtMi4zIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQzLjI1LDE4MS4xbC0yLjEsMi4yIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4yMDAwMDAwMDAwMDAwMTc6NS4xNTAwMDAwMDAwMDAwMDYtLT4=" alt="add" class="keyboard-toggle-icon">
        <span class="keyboard-toggle-text">输入表达式</span>
    </div>
<div id="category-filter-btn" class="btn circle-btn" title="分类筛选">
        <img id="category-filter-icon" src="" style="width: 20px; height: 20px;">
    </div>
</div>


<div id="keyboard">
<div id="keyboard-input-area-container">
<div class="keyboard-page-nav">
        <div class="btn small-circle-btn keyboard-default-color keyboard-page-btn active" data-kpage="1">1</div>
        <div class="btn small-circle-btn keyboard-default-color keyboard-page-btn" data-kpage="2">2</div>
        <div class="btn small-circle-btn keyboard-default-color keyboard-page-btn" data-kpage="3">3</div>
        <div class="btn small-circle-btn keyboard-default-color keyboard-page-btn" data-kpage="4">4</div>
    </div>
<div id="keyboard-input-display"></div>
    <div id="keyboard-copy-btn" class="btn pill-btn keyboard-default-color">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMTMuMjYxNiIgaGVpZ2h0PSIxMTEuMTY0MTUiIHZpZXdCb3g9IjAsMCwxMTMuMjYxNiwxMTEuMTY0MTUiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xODMuMzY5MiwtMTI0LjE2OTc2KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMTgzLjM2OTIsMjM1LjMzMzkxdi0xMTAuNjY3ODJoMTEzLjI2MTZ2MTEwLjY2NzgyeiIgZmlsbC1vcGFjaXR5PSIwLjA2Mjc1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxMCI+PHBhdGggZD0iTTI2My42OTIzNCwxOTguNjIzMDNjMC4wNjU3MSwzLjkyMDExIC0xLjE4MjQyLDcuODg1MzQgLTMuODIzMSwxMS4xODYwMmMtMy40MTU3Nyw0LjI2OTQ4IC04LjQyNzksNi41MDk3NCAtMTMuNTAwMTIsNi41NTAwOGwtMjYuNTU0NzYsLTAuMTE4MjhjLTMuOTIwMjYsMC4wNTUgLTcuODgyMTUsLTEuMjAzOTIgLTExLjE3NTU0LC0zLjg1MzY0Yy00LjI2MDE0LC0zLjQyNzQ3IC02LjQ4NjY0LC04LjQ0NTc1IC02LjUxMzE2LC0xMy41MTgwNGwtMC42Mjc3OSwtNTIuMzA2NDFjMC4wMTExNywtMy45MjA2NCAxLjMzNjcxLC03Ljg2MDczIDQuMDQxNTgsLTExLjEwODk5YzMuNDk4OCwtNC4yMDE3MiA4LjU1Mzg1LC02LjM0MzM3IDEzLjYyNTg0LC02LjI4NDM0bDI2LjU0NzMyLDAuNjM4NThjMy45MjA2NCwwLjAyMTg4IDcuODU3MDEsMS4zNTgyMSAxMS4wOTc5LDQuMDcxODljNC4xOTIxNSwzLjUxMDI3IDYuMzE5OTcsOC41NzExNyA2LjI0NzA0LDEzLjY0MzAxeiIvPjxwYXRoIGQ9Ik0yNzcuOTM3MzEsMTMzLjkwNzM5bDAuNTY0ODEsNzguMDI4NzNjLTAuMDQ0MTQsNC4yOTA4MyAtMS41MjY5Myw4LjU5MjIxIC00LjUxMzY0LDEyLjEyNTI3Yy0zLjg2MzQ0LDQuNTcwMDggLTkuNDEzNDEsNi44NzI3OCAtMTQuOTYzOTIsNi43NjY4OGwtNTAuODUyMjUsLTAuNTc4NjQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NTYuNjMwNzk5OTk5OTk5OTk0OjU1LjgzMDI0MDE2MjY0NzgtLT4=" style="width: 20px; height: 20px;">
    </div>
    <div id="keyboard-paste-btn" class="btn pill-btn keyboard-default-color">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMTMuMjYxNiIgaGVpZ2h0PSIxMTEuNjk3NjYiIHZpZXdCb3g9IjAsMCwxMTMuMjYxNiwxMTEuNjk3NjYiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xODMuMzY5MiwtMTI0LjE1MjA4KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMTgzLjM2OTIsMjM1LjMzMzkxdi0xMTAuNjY3ODJoMTEzLjI2MTZ2MTEwLjY2NzgyeiIgZmlsbC1vcGFjaXR5PSIwLjA2Mjc1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjc2LjI3MDMxLDIxMC4xNjIyNmMwLjA3NjY1LDQuNTcyNCAtMS4zNzkxNiw5LjE5NzQyIC00LjQ1OTI5LDEzLjA0NzM2Yy0zLjk4NDEyLDQuOTc5ODkgLTkuODMwMyw3LjU5MjkzIC0xNS43NDY1MSw3LjY0MDAybC0zMC45NzMzOCwtMC4xMzc5N2MtNC41NzI2MSwwLjA2NDE1IC05LjE5Mzc2LC0xLjQwNDIzIC0xMy4wMzUxNCwtNC40OTQ4NWMtNC45Njg5OCwtMy45OTc3OSAtNy41NjU5OSwtOS44NTEwOSAtNy41OTY5MywtMTUuNzY3NDNsLTAuNzMyMjYsLTYxLjAxMDFjMC4wMTMwNSwtNC41NzMwMiAxLjU1OTEyLC05LjE2ODc2IDQuNzE0MSwtMTIuOTU3NTJjNC4wODEsLTQuOTAwODkgOS45NzcxOCwtNy4zOTg4OCAxNS44OTMxOCwtNy4zMzAwM2wzMC45NjQ3NSwwLjc0NDgzYzQuNTczMDIsMC4wMjU1NSA5LjE2NDQxLDEuNTg0MTkgMTIuOTQ0NTQsNC43NDk0NWM0Ljg4OTcsNC4wOTQ0IDcuMzcxNjEsOS45OTc0MiA3LjI4NjUzLDE1LjkxMzIxeiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMjcuOTM4OTYsMTQ1LjExMzAxaDIzLjAxMjExIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuMzM0NzksMjA0LjEyNzc3bDYuNzkxNDgsNi43OTE0OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjY0Ljg4ODU2LDE5NS43NjkwMmwtMTUuMTUwMjIsMTcuMjM5ODkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NTYuNjMwNzk5OTk5OTk5OTk0OjU1Ljg0NzkyMjYwOTIxNDc1LS0+" style="width: 20px; height: 20px;">
    </div>
    <div id="keyboard-input-prompt-btn" class="btn pill-btn keyboard-default-color">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMTMuMjYxNiIgaGVpZ2h0PSIxMTAuNjY3ODIiIHZpZXdCb3g9IjAsMCwxMTMuMjYxNiwxMTAuNjY3ODIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xODMuMzY5MiwtMTI0LjY2NjA5KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMTgzLjM2OTIsMjM1LjMzMzkxdi0xMTAuNjY3ODJoMTEzLjI2MTZ2MTEwLjY2NzgyeiIgZmlsbC1vcGFjaXR5PSIwLjA2Mjc1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxwYXRoIGQ9Ik0yMDMuNDkwODYsMjEzLjI0NTAyYy0xLjU3MTYsMCAtMy4wNjI1NywtMC4zMjIzOSAtNC41MTMyNSwtMC45NjcxYy0xLjQ1MDY5LC0wLjY0NDcxIC0yLjY5OTksLTEuNTMxMzIgLTMuNzg3OTEsLTIuNTc4OThjLTEuMDg4MDEsLTEuMDQ3NzQgLTEuOTM0MjcsLTIuMzM3MjMgLTIuNTc4OTgsLTMuNzg3OTFjLTAuNjQ0NzEsLTEuNDUwNjkgLTAuOTY3MTgsLTIuOTQxNjUgLTAuOTY3MTgsLTQuNTEzMzN2LTQyLjc5NTRjMCwtMS41NzE2IDAuMzIyMzksLTMuMDYyNTcgMC45NjcxOCwtNC41MTMyNWMwLjY0NDcxLC0xLjQ1MDY5IDEuNTMxMzIsLTIuNjk5OSAyLjU3ODk4LC0zLjc4NzkxYzEuMDQ3NzQsLTEuMDg4MDEgMi4zMzcyMywtMS45MzQyNyAzLjc4NzkxLC0yLjU3ODk4YzEuNDUwNjksLTAuNjQ0NzEgMi45NDE2NSwtMC45NjcxOCA0LjUxMzI1LC0wLjk2NzE4aDczLjAxODIxYzEuNTcxNiwwIDMuMDYyNjUsMC4zMjIzOSA0LjUxMzMzLDAuOTY3MThjMS40NTA2OSwwLjY0NDcxIDIuNjk5OSwxLjUzMTMyIDMuNzg3OTEsMi41Nzg5OGMxLjA4ODAxLDEuMDQ3NzQgMS45MzQyNywyLjMzNzIzIDIuNTc4OTgsMy43ODc5MWMwLjY0NDcxLDEuNDUwNjkgMC45NjcxOCwyLjk0MTY1IDAuOTY3MTgsNC41MTMyNXY0Mi43OTU0YzAsMS41NzE2IC0wLjMyMjM5LDMuMDYyNjUgLTAuOTY3MTgsNC41MTMzM2MtMC42NDQ3MSwxLjQ1MDY5IC0xLjUzMTMyLDIuNjk5OSAtMi41Nzg5OCwzLjc4NzkxYy0xLjA0Nzc0LDEuMDg4MDEgLTIuMzM3MjMsMS45MzQyNyAtMy43ODc5MSwyLjU3ODk4Yy0xLjQ1MDY5LDAuNjQ0NzEgLTIuOTQxNjUsMC45NjcxIC00LjUxMzMzLDAuOTY3MXpNMjc2LjI2NzE2LDIwNy4yMDA0NGMwLjg0NjI2LDAgMS42NTIyNCwtMC4xNjEyIDIuMzc3NSwtMC40ODM1OWMwLjcyNTM0LC0wLjMyMjM5IDEuMzcwMDUsLTAuNzY1NjIgMS44OTM5OSwtMS4yODk0OWMwLjU2NDE1LC0wLjU2NDE1IDAuOTY3MSwtMS4xNjg2NSAxLjI4OTQ5LC0xLjg5Mzk5YzAuMzIyMzksLTAuNzI1MzQgMC40ODM1OSwtMS41MzEzMiAwLjQ4MzU5LC0yLjM3NzV2LTQyLjMxMTg5YzAsLTAuODA1OSAtMC4xNjEyLC0xLjYxMTg4IC0wLjQ4MzU5LC0yLjMzNzIzYy0wLjMyMjM5LC0wLjcyNTM0IC0wLjc2NTYyLC0xLjM3MDA1IC0xLjI4OTQ5LC0xLjkzNDJjLTAuNTY0MTUsLTAuNTY0MTUgLTEuMjA4OTMsLTAuOTY3MTggLTEuOTM0MjcsLTEuMjg5NTdjLTAuNzI1MzQsLTAuMzIyMzkgLTEuNTMxMzIsLTAuNDgzNTkgLTIuMzM3MjMsLTAuNDgzNTloLTcyLjUzNDYyYy0wLjg0NjI2LDAgLTEuNjUyMjQsMC4xNjEyIC0yLjM3NzU4LDAuNDgzNTljLTAuNzI1MzQsMC4zMjIzOSAtMS4zNzAwNSwwLjc2NTcgLTEuODkzOTIsMS4yODk1N2MtMC41NjQxNSwwLjU2NDE1IC0wLjk2NzEsMS4xNjg1NyAtMS4yODk0OSwxLjg5MzkyYy0wLjMyMjM5LDAuNzI1MzQgLTAuNDgzNTksMS41MzEzMiAtMC40ODM1OSwyLjM3NzV2NDIuMzExODljMCwwLjg0NjE4IDAuMTYxMiwxLjY1MjE2IDAuNDgzNTksMi4zNzc1YzAuMzIyMzksMC43MjUzNCAwLjcyNTM0LDEuMzcwMTMgMS4yODk0OSwxLjg5Mzk5YzAuNTIzODcsMC41MjM4NyAxLjE2ODU3LDAuOTY3MSAxLjg5MzkyLDEuMjg5NDljMC43MjUzNCwwLjMyMjM5IDEuNTMxMzIsMC40ODM1OSAyLjM3NzU4LDAuNDgzNTl6TTIwNi43NTQ5LDE2Ni40MTk4OGMwLC0xLjI0OTIxIDAuNDQzMzEsLTIuMzM3MjMgMS4zMjk4NSwtMy4yMjM3NmMwLjg4NjU0LC0wLjg4NjU0IDEuOTM0MjcsLTEuMzI5ODUgMy4yMjM3NiwtMS4zMjk4NWMxLjI0OTIxLDAgMi4zMzcyMywwLjQ0MzMxIDMuMjIzNzYsMS4zMjk4NWMwLjg4NjU0LDAuODg2NTQgMS4zMjk4NSwxLjkzNDI3IDEuMzI5ODUsMy4yMjM3NmMwLDEuMjQ5MjEgLTAuNDQzMzEsMi4zMzcyMyAtMS4zMjk4NSwzLjIyMzc2Yy0wLjg4NjU0LDAuODg2NTQgLTEuOTM0MjcsMS4zMjk3NyAtMy4yMjM3NiwxLjMyOTc3Yy0xLjI0OTIxLDAgLTIuMzM3MjMsLTAuNDQzMjMgLTMuMjIzNzYsLTEuMzI5NzdjLTAuODg2NTQsLTAuODg2NTQgLTEuMzI5ODUsLTEuOTc0NTUgLTEuMzI5ODUsLTMuMjIzNzZ6TTIxMi43OTk0OCwyMDEuMTU1OTRjLTAuODA1OSwwIC0xLjUzMTI1LC0wLjI4MjAzIC0yLjEzNTc1LC0wLjg4NjU0Yy0wLjYwNDUsLTAuNjA0NDMgLTAuODg2NTQsLTEuMjg5NTcgLTAuODg2NTQsLTIuMTM1NzVjMCwtMC44MDU5IDAuMjgyMDMsLTEuNTMxMzIgMC44ODY1NCwtMi4xMzU3NWMwLjYwNDUsLTAuNjA0NDMgMS4yODk0OSwtMC44ODY1NCAyLjEzNTc1LC0wLjg4NjU0aDU0LjQwMDk3YzAuODA1OSwwIDEuNTMxMjUsMC4yODIwMyAyLjEzNTc1LDAuODg2NTRjMC42MDQ1LDAuNjA0NDMgMC44ODY1NCwxLjI4OTU3IDAuODg2NTQsMi4xMzU3NWMwLDAuODA1OSAtMC4yODIwMywxLjUzMTMyIC0wLjg4NjU0LDIuMTM1NzVjLTAuNjA0NSwwLjYwNDQzIC0xLjI4OTQ5LDAuODg2NTQgLTIuMTM1NzUsMC44ODY1NHpNMjE4Ljg0NDA2LDE4NC41NTM1M2MwLC0xLjI0OTIxIDAuNDQzMjMsLTIuMzM3MjMgMS4zMjk3NywtMy4yMjM3NmMwLjg4NjU0LC0wLjg4NjU0IDEuOTM0MjcsLTEuMzI5ODUgMy4yMjM3NiwtMS4zMjk4NWMxLjI0OTIxLDAgMi4zMzcyMywwLjQ0MzMxIDMuMjIzNzYsMS4zMjk4NWMwLjg4NjU0LDAuODg2NTQgMS4zMjk3NywxLjkzNDI3IDEuMzI5NzcsMy4yMjM3NmMwLDEuMjQ5MjEgLTAuNDQzMjMsMi4zMzcyMyAtMS4zMjk3NywzLjIyMzc2Yy0wLjg4NjU0LDAuODg2NTQgLTEuOTM0MjcsMS4zMjk4NSAtMy4yMjM3NiwxLjMyOTg1Yy0xLjI0OTIxLDAgLTIuMzM3MjMsLTAuNDQzMzEgLTMuMjIzNzYsLTEuMzI5ODVjLTAuODg2NTQsLTAuODg2NTQgLTEuMzI5NzcsLTEuOTc0NTUgLTEuMzI5NzcsLTMuMjIzNzZ6TTIyNC44ODg1NiwxNjYuNDE5ODhjMCwtMS4yNDkyMSAwLjQ0MzMxLC0yLjMzNzIzIDEuMzI5ODUsLTMuMjIzNzZjMC44ODY1NCwtMC44ODY1NCAxLjkzNDI3LC0xLjMyOTg1IDMuMjIzNzYsLTEuMzI5ODVjMS4yNDkyMSwwIDIuMzM3MjMsMC40NDMzMSAzLjIyMzc2LDEuMzI5ODVjMC44ODY1NCwwLjg4NjU0IDEuMzI5ODUsMS45MzQyNyAxLjMyOTg1LDMuMjIzNzZjMCwxLjI0OTIxIC0wLjQ0MzMxLDIuMzM3MjMgLTEuMzI5ODUsMy4yMjM3NmMtMC44ODY1NCwwLjg4NjU0IC0xLjkzNDI3LDEuMzI5NzcgLTMuMjIzNzYsMS4zMjk3N2MtMS4yNDkyMSwwIC0yLjMzNzIzLC0wLjQ0MzIzIC0zLjIyMzc2LC0xLjMyOTc3Yy0wLjg4NjU0LC0wLjg4NjU0IC0xLjMyOTg1LC0xLjk3NDU1IC0xLjMyOTg1LC0zLjIyMzc2ek0yMzYuOTc3NjMsMTg0LjU1MzUzYzAsLTEuMjQ5MjEgMC40NDMzMSwtMi4zMzcyMyAxLjMyOTg1LC0zLjIyMzc2YzAuODg2NTQsLTAuODg2NTQgMS45MzQyNywtMS4zMjk4NSAzLjIyMzc2LC0xLjMyOTg1YzEuMjQ5MjEsMCAyLjMzNzIzLDAuNDQzMzEgMy4yMjM3NiwxLjMyOTg1YzAuODg2NTQsMC44ODY1NCAxLjMyOTc3LDEuOTM0MjcgMS4zMjk3NywzLjIyMzc2YzAsMS4yNDkyMSAtMC40NDMyMywyLjMzNzIzIC0xLjMyOTc3LDMuMjIzNzZjLTAuODg2NTQsMC44ODY1NCAtMS45MzQyNywxLjMyOTg1IC0zLjIyMzc2LDEuMzI5ODVjLTEuMjQ5MjEsMCAtMi4zMzcyMywtMC40NDMzMSAtMy4yMjM3NiwtMS4zMjk4NWMtMC44ODY1NCwtMC44ODY1NCAtMS4zMjk4NSwtMS45NzQ1NSAtMS4zMjk4NSwtMy4yMjM3NnpNMjQzLjAyMjI5LDE2Ni40MTk4OGMwLC0xLjI0OTIxIDAuNDQzMzEsLTIuMzM3MjMgMS4zMjk4NSwtMy4yMjM3NmMwLjg4NjU0LC0wLjg4NjU0IDEuOTM0MjcsLTEuMzI5ODUgMy4yMjM3NiwtMS4zMjk4NWMxLjI0OTIxLDAgMi4zMzcyMywwLjQ0MzMxIDMuMjIzNzYsMS4zMjk4NWMwLjg4NjU0LDAuODg2NTQgMS4zMjk4NSwxLjkzNDI3IDEuMzI5ODUsMy4yMjM3NmMwLDEuMjQ5MjEgLTAuNDQzMzEsMi4zMzcyMyAtMS4zMjk4NSwzLjIyMzc2Yy0wLjg4NjU0LDAuODg2NTQgLTEuOTM0MjcsMS4zMjk3NyAtMy4yMjM3NiwxLjMyOTc3Yy0xLjI0OTIxLDAgLTIuMzM3MjMsLTAuNDQzMjMgLTMuMjIzNzYsLTEuMzI5NzdjLTAuODg2NTQsLTAuODg2NTQgLTEuMzI5ODUsLTEuOTc0NTUgLTEuMzI5ODUsLTMuMjIzNzZ6TTI1NS4xMTEzNywxODQuNTUzNTNjMCwtMS4yNDkyMSAwLjQ0MzMxLC0yLjMzNzIzIDEuMzI5ODUsLTMuMjIzNzZjMC44ODY1NCwtMC44ODY1NCAxLjkzNDI3LC0xLjMyOTg1IDMuMjIzNzYsLTEuMzI5ODVjMS4yNDkyMSwwIDIuMzM3MjMsMC40NDMzMSAzLjIyMzc2LDEuMzI5ODVjMC44ODY1NCwwLjg4NjU0IDEuMzI5ODUsMS45MzQyNyAxLjMyOTg1LDMuMjIzNzZjMCwxLjI0OTIxIC0wLjQ0MzMxLDIuMzM3MjMgLTEuMzI5ODUsMy4yMjM3NmMtMC44ODY1NCwwLjg4NjU0IC0xLjkzNDI3LDEuMzI5ODUgLTMuMjIzNzYsMS4zMjk4NWMtMS4yNDkyMSwwIC0yLjMzNzIzLC0wLjQ0MzMxIC0zLjIyMzc2LC0xLjMyOTg1Yy0wLjg4NjU0LC0wLjg4NjU0IC0xLjMyOTg1LC0xLjk3NDU1IC0xLjMyOTg1LC0zLjIyMzc2ek0yNjEuMTU1OTQsMTY2LjQxOTg4YzAsLTEuMjQ5MjEgMC40NDMzMSwtMi4zMzcyMyAxLjMyOTg1LC0zLjIyMzc2YzAuODg2NTQsLTAuODg2NTQgMS45MzQyNywtMS4zMjk4NSAzLjIyMzc2LC0xLjMyOTg1YzEuMjQ5MjEsMCAyLjMzNzIzLDAuNDQzMzEgMy4yMjM3NiwxLjMyOTg1YzAuODg2NTQsMC44ODY1NCAxLjMyOTg1LDEuOTM0MjcgMS4zMjk4NSwzLjIyMzc2YzAsMS4yNDkyMSAtMC40NDMzMSwyLjMzNzIzIC0xLjMyOTg1LDMuMjIzNzZjLTAuODg2NTQsMC44ODY1NCAtMS45MzQyNywxLjMyOTc3IC0zLjIyMzc2LDEuMzI5NzdjLTEuMjQ5MjEsMCAtMi4zMzcyMywtMC40NDMyMyAtMy4yMjM3NiwtMS4zMjk3N2MtMC44ODY1NCwtMC44ODY1NCAtMS4zMjk4NSwtMS45NzQ1NSAtMS4zMjk4NSwtMy4yMjM3NnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjI1Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NTYuNjMwNzk5OTk5OTk5OTk0OjU1LjMzMzkwNjE2OTg4Mjk4LS0+" style="width: 20px; height: 20px;">
    </div>
        </div>

    <div class="keyboard-buttons-panel">
        <div id="keyboard-page-1" class="keyboard-page-content active">
            <div class="keyboard-row">
                <div class="btn keyboard-default-color" data-key="x">x</div>
                <div class="btn keyboard-default-color" data-key="y">y</div>
                <div class="btn keyboard-default-color" data-key="t">t</div>
                <div class="btn keyboard-default-color" data-key=",">,</div>
                <div class="btn keyboard-default-color key-group-separator" data-key="7">7</div>
                <div class="btn keyboard-default-color" data-key="8">8</div>
                <div class="btn keyboard-default-color" data-key="9">9</div>
                <div class="btn keyboard-default-color" data-key="÷">÷</div>
                <div class="btn keyboard-arrow-color key-group-separator" data-key="←">←</div>
            </div>
            <div class="keyboard-row">
                <div class="btn keyboard-default-color" data-key="(">(</div>
                <div class="btn keyboard-default-color" data-key=")">)</div>
                <div class="btn keyboard-default-color" data-key="<"><</div>
                <div class="btn keyboard-default-color" data-key=">">></div>
                <div class="btn keyboard-default-color key-group-separator" data-key="4">4</div>
                <div class="btn keyboard-default-color" data-key="5">5</div>
                <div class="btn keyboard-default-color" data-key="6">6</div>
                <div class="btn keyboard-default-color" data-key="×">×</div>
                <div class="btn keyboard-arrow-color key-group-separator" data-key="→">→</div>
            </div>
            <div class="keyboard-row">
                <div class="btn keyboard-default-color" data-key="abs(">abs</div>
                <div class="btn keyboard-default-color" data-key="exp(">exp</div>
                <div class="btn keyboard-default-color" data-key="sqrt(">sqrt</div>
                <div class="btn keyboard-default-color" data-key="z">z</div>
                <div class="btn keyboard-default-color key-group-separator" data-key="1">1</div>
                <div class="btn keyboard-default-color" data-key="2">2</div>
                <div class="btn keyboard-default-color" data-key="3">3</div>
                <div class="btn keyboard-default-color" data-key="-">-</div>
                <div class="btn keyboard-del-enter-color key-group-separator" data-key="del">del</div>
            </div>
            <div class="keyboard-row">
                <div class="btn keyboard-default-color" data-key="sgn(">sgn</div>
                <div class="btn keyboard-default-color" data-key="^">^</div>
                <div class="btn keyboard-default-color" data-key="log(">log</div>
                <div class="btn keyboard-default-color" data-key="ln(">ln</div>
                <div class="btn keyboard-default-color key-group-separator" data-key="0">0</div>
                <div class="btn keyboard-default-color" data-key=".">.</div>
                <div class="btn keyboard-default-color" data-key="=">=</div>
                <div class="btn keyboard-default-color" data-key="+">+</div>
                <div class="btn keyboard-del-enter-color key-group-separator" data-key="enter">enter</div>
            </div>
        </div>
  <div id="keyboard-page-2" class="keyboard-page-content">
            <div class="keyboard-row">
               <div class="btn keyboard-default-color kbd-char-page2" data-key="sin(">sin</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="cos(">cos</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="tan(">tan</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="cot(">cot</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="sec(">sec</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="csc(">csc</div>
               <div class="btn keyboard-default-color" data-key="round(">round</div>
               <div class="btn keyboard-default-color kbd-dynamic-op" data-key="range(">range</div>
               <div class="btn keyboard-arrow-color key-group-separator" data-key="←">←</div>
           </div>
           <div class="keyboard-row">
               <div class="btn keyboard-default-color kbd-char-page2" data-key="asin(">asin</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acos(">acos</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="atan(">atan</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acot(">acot</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="asec(">asec</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acsc(">acsc</div>
               <div class="btn keyboard-default-color" data-key="floor(">floor</div>
               <div class="btn keyboard-default-color kbd-dynamic-op" data-key="llim(">llim</div>
               <div class="btn keyboard-arrow-color key-group-separator" data-key="→">→</div>
           </div>
           <div class="keyboard-row">
               <div class="btn keyboard-default-color kbd-char-page2" data-key="sinh(">sinh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="cosh(">cosh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="tanh(">tanh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="coth(">coth</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="sech(">sech</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="csch(">csch</div>
               <div class="btn keyboard-default-color" data-key="ceil(">ceil</div>
               <div class="btn keyboard-default-color kbd-dynamic-op" data-key="ulim(">ulim</div>
               <div class="btn keyboard-del-enter-color key-group-separator" data-key="del">del</div>
           </div>
           <div class="keyboard-row">
               <div class="btn keyboard-default-color kbd-char-page2" data-key="asinh(">asinh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acosh(">acosh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="atanh(">atanh</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acoth(">acoth</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="asech(">asech</div>
               <div class="btn keyboard-default-color kbd-char-page2" data-key="acsch(">acsch</div>
               <div class="btn keyboard-default-color" data-key="gamma(">gamma</div>
               <div id="keyboard-page2-shift-btn" class="btn keyboard-default-color" data-key="shift_page2">shift</div>
               <div class="btn keyboard-del-enter-color key-group-separator" data-key="enter">enter</div>
           </div>
       </div>
   <div id="keyboard-page-3" class="keyboard-page-content">
            <div class="keyboard-row">
                <div class="btn keyboard-default-color kbd-char" data-key="q">q</div>
                <div class="btn keyboard-default-color kbd-char" data-key="w">w</div>
                <div class="btn keyboard-default-color kbd-char" data-key="e">e</div>
                <div class="btn keyboard-default-color kbd-char" data-key="r">r</div>
                <div class="btn keyboard-default-color kbd-char" data-key="t">t</div>
                <div class="btn keyboard-default-color kbd-char" data-key="y">y</div>
                <div class="btn keyboard-default-color kbd-char" data-key="u">u</div>
                <div class="btn keyboard-default-color kbd-char" data-key="i">i</div>
                <div class="btn keyboard-default-color kbd-char" data-key="o">o</div>
                <div class="btn keyboard-default-color kbd-char" data-key="p">p</div>
            </div>
            <div class="keyboard-row">
                <div class="btn keyboard-default-color kbd-char" data-key="a">a</div>
                <div class="btn keyboard-default-color kbd-char" data-key="s">s</div>
                <div class="btn keyboard-default-color kbd-char" data-key="d">d</div>
                <div class="btn keyboard-default-color kbd-char" data-key="f">f</div>
                <div class="btn keyboard-default-color kbd-char" data-key="g">g</div>
                <div class="btn keyboard-default-color kbd-char" data-key="h">h</div>
                <div class="btn keyboard-default-color kbd-char" data-key="j">j</div>
                <div class="btn keyboard-default-color kbd-char" data-key="k">k</div>
                <div class="btn keyboard-default-color kbd-char" data-key="l">l</div>
                <div class="btn keyboard-default-color" data-key="θ">θ</div>
            </div>
            <div class="keyboard-row">
                <div id="keyboard-shift-btn" class="btn keyboard-default-color" data-key="shift">shift</div>
                <div class="btn keyboard-default-color kbd-char" data-key="z">z</div>
                <div class="btn keyboard-default-color kbd-char" data-key="x">x</div>
                <div class="btn keyboard-default-color kbd-char" data-key="c">c</div>
                <div class="btn keyboard-default-color kbd-char" data-key="v">v</div>
                <div class="btn keyboard-default-color kbd-char" data-key="b">b</div>
                <div class="btn keyboard-default-color kbd-char" data-key="n">n</div>
                <div class="btn keyboard-default-color kbd-char" data-key="m">m</div>
                <div class="btn keyboard-arrow-color kbd-p3-switch" data-key="←" data-original-key="←" data-shift-key="9">←</div>
                <div class="btn keyboard-arrow-color kbd-p3-switch" data-key="→" data-original-key="→" data-shift-key="0">→</div>
            </div>
            <div class="keyboard-row">
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="+" data-original-key="+" data-shift-key="1">+</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="-" data-original-key="-" data-shift-key="2">-</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="×" data-original-key="×" data-shift-key="3">×</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="÷" data-original-key="÷" data-shift-key="4">÷</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="." data-original-key="." data-shift-key="5">.</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="(" data-original-key="(" data-shift-key="6">(</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key=")" data-original-key=")" data-shift-key="7">)</div>
                <div class="btn keyboard-default-color kbd-p3-switch" data-key="," data-original-key="," data-shift-key="8">,</div>
                <div class="btn keyboard-del-enter-color" data-key="del">del</div>
                <div class="btn keyboard-del-enter-color" data-key="enter">enter</div>
            </div>
        </div>
        <div id="keyboard-page-4" class="keyboard-page-content">
            <div class="keyboard-geo-grid">
                <div class="keyboard-row">
                    <div class="btn keyboard-default-color" data-key="point(">点</div>
                    <div class="btn keyboard-default-color" data-key="ray(">射线</div>
                    <div class="btn keyboard-default-color" data-key="perpendicularline(">垂线</div>
                    <div class="btn keyboard-default-color" data-key="circulararc(">圆弧</div>
                    <div class="btn keyboard-default-color" data-key="parabola(">抛物线</div>
                    <div class="btn keyboard-default-color" data-key="isparallel(">是否平行</div>
                    <div class="btn keyboard-default-color" data-key="reflect(">对称</div>
                </div>
                <div class="keyboard-row">
                    <div class="btn keyboard-default-color" data-key="intercept(">交点</div>
                    <div class="btn keyboard-default-color" data-key="line(">直线</div>
                    <div class="btn keyboard-default-color" data-key="anglebisector(">角平分线</div>
                    <div class="btn keyboard-default-color" data-key="ellipse(">椭圆</div>
                    <div class="btn keyboard-default-color" data-key="length(">长度</div>
                    <div class="btn keyboard-default-color" data-key="isperpendicular(">是否垂直</div>
                    <div class="btn keyboard-default-color" data-key="translate(">平移</div>
                </div>
                <div class="keyboard-row">
                    <div class="btn keyboard-default-color" data-key="midpoint(">中点</div>
                    <div class="btn keyboard-default-color" data-key="vector(">向量</div>
                    <div class="btn keyboard-default-color" data-key="tangent(">切线</div>
                    <div class="btn keyboard-default-color" data-key="ellipse(">标准椭圆</div>
                    <div class="btn keyboard-default-color" data-key="angle(">角度</div>
                    <div class="btn keyboard-default-color" data-key="isconcyclic(">是否共圆</div>
                    <div class="btn keyboard-default-color" data-key="polygon(">多边形</div>
                </div>
                <div class="keyboard-row">
                    <div class="btn keyboard-default-color" data-key="segment(">线段</div>
                    <div class="btn keyboard-default-color" data-key="parallelline(">平行线</div>
                    <div class="btn keyboard-default-color" data-key="circle(">圆</div>
                    <div class="btn keyboard-default-color" data-key="hyperbola(">双曲线</div>
                    <div class="btn keyboard-default-color" data-key="area(">面积</div>
                    <div class="btn keyboard-default-color" data-key="rotate(">旋转</div>
                    <div class="btn keyboard-default-color" data-key="fitline(">拟合直线</div>
                </div>
            </div>
            <div class="keyboard-nav-col">
                <div class="btn keyboard-arrow-color" data-key="←">←</div>
                <div class="btn keyboard-arrow-color" data-key="→">→</div>
                <div class="btn keyboard-del-enter-color" data-key="del">del</div>
                <div class="btn keyboard-del-enter-color" data-key="enter">enter</div>
            </div>
        </div>
    </div>
</div>

<div id="sidebar-background"><div id="portrait-resize-handle"></div></div>
<div id="category-filter-btn" class="btn circle-btn" title="分类筛选">
    <img id="category-filter-icon" src="" style="width: 20px; height: 20px;">
</div>
<div id="sidebar">
    <div id="entry-list"></div>
    <div id="geometry-panel" style="display: none;"></div>
<!-- 新版设置页面 -->
     <div id="settings-panel" class="sidebar-panel" style="display: none;">
        <div class="settings-from-core-wrapper">
            <div class="settings-nav-buttons">
                <div class="settings-nav-btn active" data-panel="appearance">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS44MDExNSIgaGVpZ2h0PSIxOS44NjcxMyIgdmlld0JveD0iMCwwLDE5LjgwMTE1LDE5Ljg2NzEzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjA5OTQyLC0xNzAuMDY2NDMpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzMC4xMTg2NSwxODkuODgxMzh2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM2LjM2OTc3LDE4MS43ODIxMWMtMC4yODA1MywwIC0wLjU0NDUzLDAuMDY2MDEgLTAuNzc1NTMsMC4xODE1MmMtMC4yMzEsMC4xMTU1MSAtMC40Nzg1MiwwLjI0NzUyIC0wLjcwOTU0LDAuMzc5NTNjLTAuMjMxLDAuMTMyIC0wLjQ3ODUyLDAuMjY0IC0wLjcwOTU0LDAuMzc5NTFjLTAuMjMxLDAuMTE1NTEgLTAuNTExNTEsMC4xODE1MSAtMC44MDg1NCwwLjE4MTUxYy0wLjQxMjUxLDAgLTAuNzkyMDYsLTAuMDk5IC0xLjEzODU4LC0wLjI5NzAzYy0wLjM0NjUxLC0wLjE5Nzk4IC0wLjY3NjUxLC0wLjQxMjU0IC0wLjk3MzU2LC0wLjY2MDAzYy0wLjM5NjAyLC0wLjM0NjUyIC0wLjY5MzAzLC0wLjcyNjA0IC0wLjg1ODAyLC0xLjE3MTU3Yy0wLjE2NTAyLC0wLjQ0NTUzIC0wLjI5NzAzLC0wLjkyNDAzIC0wLjI5NzAzLC0xLjQzNTU5YzAsLTAuNTExNTQgMC4wNjYwMSwtMS4wMzk1OSAwLjIxNDUzLC0xLjUzNDZjMC4xNDg1LC0wLjQ5NTA0IDAuMzEzNSwtMC45OTAwNSAwLjUyODAyLC0xLjQ2ODU3YzAuNDYyMDIsLTEuMDIzMDQgMS4wMzk1NiwtMS45NDcwOSAxLjc0OTExLC0yLjgwNTE0YzAuMzEzNSwtMC4zNzk1MyAwLjY0MzU1LC0wLjc1OTA0IDEuMDA2NTcsLTEuMTA1NTdjMC4zNjMwMywtMC4zNDY1MiAwLjc0MjU0LC0wLjY2MDAxIDEuMTcxNTcsLTAuOTI0MDVjMC43NDI1NCwtMC40Nzg1MiAxLjUxODA4LC0wLjgyNTAzIDIuMzI2NjIsLTEuMDcyNTVjMC44MDg1NCwtMC4yNDc1MiAxLjY1MDA5LC0wLjM2MzA0IDIuNTQxMTMsLTAuMzYzMDRjMC44MjUwNSwwIDEuNjMzNTgsMC4xMTU1MiAyLjQwOTE0LDAuMzMwMDVjMC43NzU1MiwwLjIxNDUxIDEuNTUxMDcsMC41MTE1NCAyLjI3NzE0LDAuOTA3NTZjMC44OTEwMywwLjQ3ODUyIDEuNjgzMDgsMS4wMzk1NiAyLjM3NjExLDEuNjgzMDhjMC42OTMwNSwwLjY0MzUyIDEuMjcwNTksMS4zNTMwOCAxLjc0OTExLDIuMTQ1MTNjMC40Nzg1MiwwLjc5MjA1IDAuODQxNTUsMS42MzM1OCAxLjA4OTA3LDIuNTQxMTNjMC4yNDc1MiwwLjkwNzU2IDAuMzYzMDMsMS44NjQ2IDAuMzYzMDMsMi44NzExNWMwLDAuNzQyNTQgLTAuMDY2LDEuNDg1MSAtMC4xOTgwMSwyLjI0NDEyYy0wLjEzMiwwLjc1OTAzIC0wLjM0NjUxLDEuNDg1MDYgLTAuNjI3MDIsMi4xOTQ2NGMtMC4yODA1MywwLjcwOTU3IC0wLjYyNzAzLDEuMzY5NTYgLTEuMDU2MDYsMi4wMTMxYy0wLjQyOTAxLDAuNjQzNTIgLTAuOTQwNTQsMS4xODgwNSAtMS41MTgwOCwxLjY1MDFjLTAuNDc4NTIsMC4zOTYwMiAtMS4wMDY1NywwLjcwOTU2IC0xLjU2NzU5LDAuOTQwNTZjLTAuNTYxMDIsMC4yMzEwMiAtMS4xNTUwNiwwLjM0NjUxIC0xLjc5ODYsMC4zNDY1MWMtMC41NjEwMiwwIC0xLjEzODU1LC0wLjA5ODk5IC0xLjY5OTU4LC0wLjI5NzAzYy0wLjU2MTAyLC0wLjE5Nzk4IC0xLjAzOTU2LC0wLjQ0NTUzIC0xLjQ1MjA4LC0wLjc0MjU0Yy0wLjQxMjUyLC0wLjI5NzAzIC0wLjc0MjU0LC0wLjY0MzUyIC0xLjAyMzA0LC0xLjAzOTU2Yy0wLjI4MDUzLC0wLjM5NjAyIC0wLjQ3ODUyLC0wLjg0MTU2IC0wLjYyNzAzLC0xLjMzNjU3Yy0wLjE0ODUsLTAuNDk1MDQgLTAuMjMxLC0xLjAyMzA0IC0wLjI2NDAyLC0xLjYwMDU4Yy0wLjAxNjQ5LC0wLjE5Nzk4IC0wLjAxNjUsLTAuMzk2MDMgLTAuMDMyOTksLTAuNTk0MDFjLTAuMDE2NDksLTAuMTk3OTggLTAuMDE2NTEsLTAuMzk2MDMgLTAuMDMzMDEsLTAuNTk0MDFjMCwtMC4xMTU1MSAtMC4wMTY0OSwtMC4yMzEgLTAuMDMyOTksLTAuMzc5NWMtMC4wMTY0OSwtMC4xNDg1IC0wLjAzMjk5LC0wLjI4MDUzIC0wLjA2NjAxLC0wLjQxMjU0Yy0wLjAzMjk5LC0wLjEzMiAtMC4wNjYsLTAuMjgwNDggLTAuMTE1NDksLTAuMzk1OTljLTAuMDQ5NTEsLTAuMTE1NTEgLTAuMDk5MDIsLTAuMjMxMDMgLTAuMTY1MDIsLTAuMzMwMDVjLTAuMDY2LC0wLjA4MjUgLTAuMTMyMDEsLTAuMTQ4NSAtMC4yNDc1MiwtMC4xOTgwMWMtMC4xMTU0OSwtMC4wNDk1MSAtMC4yMTQ1MSwtMC4wOTg5OSAtMC4zNDY0OSwtMC4xMzJjLTAuMTMyLC0wLjAzMjk5IC0wLjI0NzUyLC0wLjA0OTQ4IC0wLjM2MzAzLC0wLjA2NmMtMC4xMTU0OSwtMC4wMTY0OSAtMC4xOTgwMSwtMC4wMzI5OSAtMC4yOTcwMywtMC4wMzI5OXpNMjQwLjc3NTQ1LDE3NC43MDMyM2MwLC0wLjMxMzUgLTAuMDk5LC0wLjU2MTAyIC0wLjMxMzUsLTAuNzc1NTVjLTAuMjE0NTMsLTAuMjE0NTEgLTAuNDYyMDUsLTAuMzEzNTIgLTAuNzc1NTUsLTAuMzEzNTJjLTAuMTQ4NSwwIC0wLjI4MDUzLDAuMDMyOTkgLTAuNDEyNTIsMC4wODI1Yy0wLjEzMiwwLjA0OTUxIC0wLjI0NzUyLDAuMTMyMDEgLTAuMzQ2NTEsMC4yMzEwMmMtMC4wOTkwMiwwLjA5OSAtMC4xODE0OSwwLjIxNDUxIC0wLjIzMSwwLjM0NjUxYy0wLjA0OTUxLDAuMTMyIC0wLjA4MjUsMC4yODA1NCAtMC4wODI1LDAuNDEyNTRjMCwwLjEzMiAwLjAzMjk5LDAuMjgwNTEgMC4wODI1LDAuNDEyNTJjMC4wNDk1MSwwLjEzMiAwLjEzMjAxLDAuMjQ3NTIgMC4yMzEsMC4zNDY1MmMwLjA5OTAyLDAuMDk5IDAuMjE0NTMsMC4xODE1MSAwLjM0NjUxLDAuMjMxMDJjMC4xMzIsMC4wNDk1MSAwLjI4MDUzLDAuMDgyNSAwLjQxMjUyLDAuMDgyNWMwLjEzMiwwIDAuMjgwNTQsLTAuMDMyOTkgMC40MTI1NCwtMC4wODI1YzAuMTMyLC0wLjA0OTUxIDAuMjQ3NSwtMC4xMzIgMC4zNDY1MSwtMC4yMzEwMmMwLjA5OTAyLC0wLjA5OSAwLjE4MTQ5LC0wLjIxNDUxIDAuMjMxLC0wLjM0NjUyYzAuMDQ5NTEsLTAuMTMyIDAuMDk5MDIsLTAuMjQ3NDkgMC4wOTkwMiwtMC4zOTYwMnpNMjQ0LjE3NDYsMTg0LjkxNzI1YzAsLTAuMzEzNSAtMC4wOTksLTAuNTYxMDIgLTAuMzEzNSwtMC43NzU1NWMtMC4yMTQ1MywtMC4yMTQ1MSAtMC40NjIwNSwtMC4zMTM1IC0wLjc3NTU1LC0wLjMxMzVjLTAuMTQ4NSwwIC0wLjI4MDQ4LDAuMDMyOTkgLTAuNDEyNDksMC4wODI1Yy0wLjEzMiwwLjA0OTUxIC0wLjI0NzUyLDAuMTMyIC0wLjM0NjUyLDAuMjMxYy0wLjA5OTAyLDAuMDk5IC0wLjE4MTQ5LDAuMjE0NTEgLTAuMjMxLDAuMzQ2NTFjLTAuMDQ5NTEsMC4xMzIgLTAuMDgyNSwwLjI4MDU0IC0wLjA4MjUsMC40MTI1NGMwLDAuMTMyIDAuMDMyOTksMC4yODA1MSAwLjA4MjUsMC40MTI1MmMwLjA0OTUxLDAuMTMyIDAuMTMyLDAuMjQ3NTIgMC4yMzEsMC4zNDY1MWMwLjA5OTAyLDAuMDk5IDAuMjE0NTMsMC4xODE1MiAwLjM0NjUyLDAuMjMxMDNjMC4xMzIsMC4wNDk1MSAwLjI4MDQ4LDAuMDgyNSAwLjQxMjQ5LDAuMDgyNWMwLjEzMiwwIDAuMjgwNTQsLTAuMDMyOTkgMC40MTI1NCwtMC4wODI1YzAuMTMyLC0wLjA0OTUxIDAuMjQ3NDksLTAuMTMyMDEgMC4zNDY0OSwtMC4yMzEwM2MwLjA5OTAyLC0wLjA5OSAwLjE4MTUsLTAuMjE0NTEgMC4yMzEwMSwtMC4zNDY1MWMwLjA0OTUxLC0wLjEzMiAwLjA5OTAyLC0wLjI0NzUyIDAuMDk5MDIsLTAuMzk2MDJ6TTI0NC40ODgxNywxNzUuOTQwODVjMCwtMC4zMTM1IC0wLjA5OSwtMC41NjEwMiAtMC4zMTM1LC0wLjc3NTU1Yy0wLjIxNDUzLC0wLjIxNDUxIC0wLjQ2MjAzLC0wLjMxMzUyIC0wLjc3NTUzLC0wLjMxMzUyYy0wLjE0ODUsMCAtMC4yODA1MywwLjAzMjk5IC0wLjQxMjU0LDAuMDgyNWMtMC4xMzIsMC4wNDk1MSAtMC4yNDc1LDAuMTMyMDEgLTAuMzQ2NDksMC4yMzEwMmMtMC4wOTkwMiwwLjA5OSAtMC4xODE0OSwwLjIxNDUxIC0wLjIzMSwwLjM0NjUyYy0wLjA0OTUxLDAuMTMyIC0wLjA4MjUsMC4yODA1NCAtMC4wODI1LDAuNDEyNTRjMCwwLjEzMiAwLjAzMjk5LDAuMjgwNTEgMC4wODI1LDAuNDEyNTFjMC4wNDk1MSwwLjEzMiAwLjEzMiwwLjI0NzUyIDAuMjMxLDAuMzQ2NTJjMC4wOTkwMiwwLjA5OSAwLjIxNDUxLDAuMTgxNDkgMC4zNDY0OSwwLjIzMWMwLjEzMiwwLjA0OTUxIDAuMjgwNTMsMC4wODI1IDAuNDEyNTQsMC4wODI1YzAuMTMyLDAgMC4yODA1NCwtMC4wMzI5OSAwLjQxMjUyLC0wLjA4MjVjMC4xMzIsLTAuMDQ5NTEgMC4yNDc1MiwtMC4xMzIgMC4zNDY1MSwtMC4yMzFjMC4wOTkwMiwtMC4wOTkgMC4xODE0OSwtMC4yMTQ1MSAwLjIzMSwtMC4zNDY1MmMwLjA0OTUxLC0wLjEzMiAwLjA5OSwtMC4yNDc1MiAwLjA5OSwtMC4zOTYwMnpNMjQ2LjY0OTc1LDE3OC43Mjk0MmMwLC0wLjMxMzUgLTAuMDk5LC0wLjU2MTAyIC0wLjMxMzUyLC0wLjc3NTU1Yy0wLjIxNDUzLC0wLjIxNDUxIC0wLjQ2MjAyLC0wLjMxMzUgLTAuNzc1NTIsLTAuMzEzNWMtMC4xNDg1LDAgLTAuMjgwNTMsMC4wMzI5OCAtMC40MTI1MiwwLjA4MjQ5Yy0wLjEzMiwwLjA0OTUxIC0wLjI0NzUyLDAuMTMxOTggLTAuMzQ2NTIsMC4yMzA5OGMtMC4wOTkwMiwwLjA5OSAtMC4xODE0OSwwLjIxNDUxIC0wLjIzMSwwLjM0NjUyYy0wLjA0OTUxLDAuMTMyIC0wLjA4MjUsMC4yODA1NCAtMC4wODI1LDAuNDEyNTRjMCwwLjEzMiAwLjAzMjk5LDAuMjgwNTMgMC4wODI1LDAuNDEyNTRjMC4wNDk1MSwwLjEzMiAwLjEzMiwwLjI0NzUxIDAuMjMxLDAuMzQ2NTFjMC4wOTkwMiwwLjA5OSAwLjIxNDUzLDAuMTgxNSAwLjM0NjUyLDAuMjMxMDFjMC4xMzIsMC4wNDk1MSAwLjI4MDUzLDAuMDgyNDkgMC40MTI1MiwwLjA4MjQ5YzAuMTMyLDAgMC4yODA1MSwtMC4wMzI5OCAwLjQxMjUxLC0wLjA4MjQ5YzAuMTMyLC0wLjA0OTUxIDAuMjQ3NTIsLTAuMTMyMDEgMC4zNDY1MiwtMC4yMzEwMWMwLjA5OTAyLC0wLjA5OSAwLjE4MTQ5LC0wLjIxNDUxIDAuMjMxLC0wLjM0NjUxYzAuMDQ5NTEsLTAuMTMyIDAuMDk5LC0wLjI0NzUyIDAuMDk5LC0wLjM5NjAyek0yNDYuNjQ5NzUsMTgyLjQ0MjE5YzAsLTAuMzEzNSAtMC4wOTksLTAuNTYxMDIgLTAuMzEzNTIsLTAuNzc1NTVjLTAuMjE0NTMsLTAuMjE0NTEgLTAuNDYyMDIsLTAuMzEzNSAtMC43NzU1MiwtMC4zMTM1Yy0wLjE0ODUsMCAtMC4yODA1MywwLjAzMjk5IC0wLjQxMjUyLDAuMDgyNWMtMC4xMzIsMC4wNDk1MSAtMC4yNDc1MiwwLjEzMjAxIC0wLjM0NjUyLDAuMjMxMDJjLTAuMDk5MDIsMC4wOTkgLTAuMTgxNDksMC4yMTQ1MSAtMC4yMzEsMC4zNDY1MmMtMC4wNDk1MSwwLjEzMiAtMC4wODI1LDAuMjgwNTEgLTAuMDgyNSwwLjQxMjUxYzAsMC4xMzIgMC4wMzI5OSwwLjI4MDUxIDAuMDgyNSwwLjQxMjUyYzAuMDQ5NTEsMC4xMzIgMC4xMzIsMC4yNDc1MiAwLjIzMSwwLjM0NjUxYzAuMDk5MDIsMC4wOTkgMC4yMTQ1MywwLjE4MTQ5IDAuMzQ2NTIsMC4yMzFjMC4xMzIsMC4wNDk1MSAwLjI4MDUzLDAuMDgyNSAwLjQxMjUyLDAuMDgyNWMwLjEzMiwwIDAuMjgwNTEsLTAuMDMyOTkgMC40MTI1MSwtMC4wODI1YzAuMTMyLC0wLjA0OTUxIDAuMjQ3NTIsLTAuMTMyIDAuMzQ2NTIsLTAuMjMxYzAuMDk5MDIsLTAuMDk5IDAuMTgxNDksLTAuMjE0NTEgMC4yMzEsLTAuMzQ2NTFjMC4wNDk1MSwtMC4xMzIgMC4wOTksLTAuMjQ3NTIgMC4wOTksLTAuMzk2MDJ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5LjkwMDU3NTAwMDAwMDAwMzo5LjkzMzU2NDk5OTk5OTk4Ny0tPg==" alt="外观"><span class="settings-nav-text">外观</span>
                </div>
                <div class="settings-nav-btn" data-panel="performance">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC42MDQ4NyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDIwLjYwNDg3LDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjY5NzU2LC0xNzAuMTE4NjUpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjYsMTg5Ljg4MTM5di0xOS43NjI3M2gxOS43NjI3M3YxOS43NjI3M3oiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2MyZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM1LjAyMzg5LDE4MC4wMTY1MmMwLDAuMTY1NTkgLTAuMDY2MjUsMC4zMTQ2MyAtMC4xODIxNiwwLjQzMDU0Yy0wLjExNTkxLDAuMTE1OTEgLTAuMjY0OTUsMC4xODIxNiAtMC40MzA1NCwwLjE4MjE2Yy0wLjExNTkxLDAgLTAuMjE1MjgsLTAuMDMzMTMgLTAuMzMxMTksLTAuMDk5MzhsLTIuMjUyMTEsLTEuNDA3NTZjLTAuMTE1OTEsMC4xODIxNiAtMC4yMTUyOCwwLjM2NDMgLTAuMjk4MDcsMC41NDY0OGMtMC4wODI4MSwwLjE4MjE2IC0wLjE4MjE2LDAuMzY0MjkgLTAuMjY0OTUsMC41NjMwNGMtMC4wNDk2OSwwLjExNTkxIC0wLjEzMjQ3LDAuMjE1MjggLTAuMjE1MjgsMC4yODE1MWMtMC4wODI4MSwwLjA2NjI1IC0wLjIxNTI4LDAuMDk5MzcgLTAuMzQ3NzYsMC4wOTkzN2MtMC4xNjU1OSwwIC0wLjMxNDYzLC0wLjA2NjI1IC0wLjQ0NzEsLTAuMTgyMTZjLTAuMTMyNDcsLTAuMTE1OTEgLTAuMTgyMTYsLTAuMjY0OTUgLTAuMTgyMTYsLTAuNDMwNTRjMCwtMC4xMTU5MSAwLjAzMzEyLC0wLjI0ODQxIDAuMDk5MzcsLTAuNDMwNTRjMC4wNjYyNSwtMC4xODIxNiAwLjE2NTYsLTAuMzY0MjkgMC4yODE1MSwtMC41NjMwNGMwLjExNTkxLC0wLjE5ODcyIDAuMjMxODQsLTAuNDE0IDAuMzgwODgsLTAuNjEyN2MwLjE0OTAzLC0wLjE5ODcyIDAuMjgxNTEsLTAuNDE0IDAuNDE0MDEsLTAuNjEyN2MwLjEzMjQ3LC0wLjE5ODcyIDAuMjY0OTQsLTAuMzY0MyAwLjM4MDg4LC0wLjUyOTg5YzAuMTE1OTEsLTAuMTY1NTkgMC4yMTUyOSwtMC4yODE1MSAwLjI5ODA3LC0wLjM2NDI5YzAuNDYzNjYsLTAuNTQ2NDcgMC45NzcwMiwtMS4wNDMyNCAxLjU0MDAzLC0xLjQ3Mzc5YzAuNTYzMDQsLTAuNDMwNTQgMS4xNTkxNSwtMC44MTE0MiAxLjgwNSwtMS4xNTkxNWMwLjc0NTE3LC0wLjM4MDg4IDEuNTA2OTIsLTAuNjYyMzkgMi4zMDE3OCwtMC44NDQ1M2MwLjc5NDg2LC0wLjE4MjE2IDEuNjA2MjYsLTAuMjY0OTUgMi40MzQyNywtMC4yNjQ5NWMwLjU2MzA0LDAgMS4xMDk1LDAuMDMzMTMgMS42NTU5NywwLjExNTkxYzAuNTQ2NDcsMC4wODI4MSAxLjA5Mjk0LDAuMjE1MjggMS42MjI4MywwLjM4MDg4bC0wLjc5NDg2LDEuMDU5ODFjLTAuMjk4MDcsLTAuMDgyODEgLTAuNjEyNzEsLTAuMTQ5MDQgLTAuOTI3MzQsLTAuMTk4NzJjLTAuMzE0NjMsLTAuMDQ5NjkgLTAuNjI5MjcsLTAuMDgyODEgLTAuOTI3MzMsLTAuMDk5Mzd2My4wODAwN2MwLDAuMTY1NTkgLTAuMDY2MjUsMC4zMTQ2MyAtMC4xODIxNiwwLjQzMDU0Yy0wLjExNTkxLDAuMTE1OTEgLTAuMjY0OTUsMC4xODIxNiAtMC40MzA1NCwwLjE4MjE2Yy0wLjE2NTU5LDAgLTAuMzE0NjMsLTAuMDY2MjUgLTAuNDMwNTQsLTAuMTgyMTZjLTAuMTE1OTEsLTAuMTE1OTEgLTAuMTgyMTYsLTAuMjY0OTUgLTAuMTgyMTYsLTAuNDMwNTR2LTMuMDgwMDdjLTAuNjk1NTEsMC4wMzMxMyAtMS4zNTc4NywwLjE0OTAzIC0xLjk4NzE0LDAuMzQ3NzVjLTAuNjI5MjcsMC4xOTg3MiAtMS4yNDE5NywwLjQzMDU1IC0xLjgyMTU1LDAuNzQ1MThjLTAuNTc5NTgsMC4zMTQ2MyAtMS4xMDk1LDAuNjk1NTEgLTEuNjIyODMsMS4xMjYwNmMtMC41MTMzNSwwLjQzMDU0IC0wLjk3NzAyLDAuOTEwNzcgLTEuNDA3NTYsMS40NTcyM2wyLjIwMjQyLDEuMzc0NDRjMC4xNjU1OSwwLjE2NTU5IDAuMjQ4NDEsMC4zNDc3NSAwLjI0ODQxLDAuNTYzMDR6TTIzOS42OTM3MSwxODYuODU1NTljLTAuMjk4MDcsMCAtMC41Nzk1OCwtMC4wNDk2OCAtMC44NDQ1MywtMC4xNjU1OWMtMC4yNjQ5NSwtMC4xMTU5MSAtMC40OTY3OSwtMC4yNjQ5NSAtMC42OTU1MSwtMC40NjM2N2MtMC4xOTg3MiwtMC4xOTg3MiAtMC4zNDc3NiwtMC40MzA1NCAtMC40NjM2NywtMC42OTU1MWMtMC4xMTU5MSwtMC4yNjQ5NSAtMC4xNjU1OSwtMC41NDY0OCAtMC4xNjU1OSwtMC44NDQ1M2MwLC0wLjI2NDk1IDAuMDMzMTIsLTAuNDk2NzkgMC4xMTU5MSwtMC42OTU1MWMwLjA4MjgxLC0wLjE5ODcyIDAuMTk4NzIsLTAuNDE0MDEgMC4zNDc3NiwtMC42MjkyN2w2LjQ5MTM0LC04LjY2MDY1YzAuMTE1OTEsLTAuMTgyMTYgMC4yOTgwNywtMC4yNjQ5NCAwLjQ5Njc5LC0wLjI2NDk0YzAuMTY1NTksMCAwLjMxNDYzLDAuMDY2MjUgMC40MzA1NCwwLjE4MjE2YzAuMTE1OTEsMC4xMTU5MSAwLjE4MjE2LDAuMjY0OTUgMC4xODIxNiwwLjQzMDU1YzAsMC4wNjYyNSAtMC4wMTY1NiwwLjE0OTAzIC0wLjA0OTY5LDAuMjMxODRsLTMuNzU5MDMsOS45Njg4NWMtMC4wODI4MSwwLjI0ODQgLTAuMTgyMTYsMC40NjM2NyAtMC4yOTgwNywwLjYyOTI3Yy0wLjExNTkxLDAuMTY1NTkgLTAuMjY0OTUsMC4zNDc3NiAtMC40ODAyMywwLjUxMzM1Yy0wLjM4MDg4LDAuMzE0NjMgLTAuODExNDIsMC40NjM2NyAtMS4zMDgxOSwwLjQ2MzY3ek0yNDIuODU2NTUsMTc4LjkwNzA1bC0zLjg5MTQ5LDUuMTgzMTNjLTAuMTMyNDcsMC4xODIxNiAtMC4xOTg3MiwwLjM4MDg4IC0wLjE5ODcyLDAuNTc5NThjMCwwLjI2NDk1IDAuMDgyODEsMC40ODAyMyAwLjI2NDk1LDAuNjYyMzljMC4xODIxNiwwLjE4MjE2IDAuMzk3NDQsMC4yNjQ5NSAwLjY2MjM5LDAuMjY0OTVjMC4yNDg0LDAgMC40NDcxLC0wLjA2NjI1IDAuNTc5NTgsLTAuMjE1MjhjMC4xMzI0NywtMC4xNDkwMyAwLjI0ODQxLC0wLjMxNDYzIDAuMzMxMiwtMC41Mjk4OXpNMjQ5LjkyNzQ0LDE4MC4wMzMwNmMwLDAuMTgyMTYgLTAuMDY2MjQsMC4zMTQ2MyAtMC4xODIxNSwwLjQzMDU0Yy0wLjExNTkxLDAuMTE1OTEgLTAuMjgxNTEsMC4xODIxNiAtMC40NDcxMSwwLjE4MjE2Yy0wLjEzMjQ3LDAgLTAuMjQ4NDEsLTAuMDMzMTMgLTAuMzQ3NzYsLTAuMDk5MzhjLTAuMDk5MzcsLTAuMDY2MjUgLTAuMTY1NTksLTAuMTY1NTkgLTAuMjE1MjgsLTAuMjgxNTFjLTAuMDgyODEsLTAuMTk4NzIgLTAuMTY1NTksLTAuMzgwODggLTAuMjY0OTQsLTAuNTYzMDRjLTAuMDk5MzcsLTAuMTgyMTYgLTAuMTk4NzIsLTAuMzY0MyAtMC4zMTQ2NCwtMC41NDY0OGwtMi4yNTIxMSwxLjQwNzU2Yy0wLjExNTkxLDAuMDY2MjUgLTAuMjE1MjgsMC4wOTkzNyAtMC4zMzEyLDAuMDk5MzdjLTAuMTY1NTksMCAtMC4zMTQ2MywtMC4wNjYyNSAtMC40MzA1NCwtMC4xODIxNmMtMC4xMTU5MSwtMC4xMTU5MSAtMC4xODIxNSwtMC4yNjQ5NSAtMC4xODIxNSwtMC40MzA1NGMwLC0wLjIzMTg0IDAuMDk5MzcsLTAuMzk3NDQgMC4yOTgwNywtMC41Mjk4OWwyLjIwMjQzLC0xLjM3NDQ0Yy0wLjE0OTAzLC0wLjE4MjE2IC0wLjI5ODA4LC0wLjM0Nzc2IC0wLjQ2MzY3LC0wLjUyOTljLTAuMTY1NTksLTAuMTgyMTYgLTAuMzE0NjQsLTAuMzMxMiAtMC40ODAyMywtMC40OTY3OWwwLjQ2MzY3LC0xLjI0MTk2bDAuMDE2NTYsLTAuMDE2NTZjMC4yODE1MSwwLjI0ODQgMC41NjMwNCwwLjUyOTg5IDAuODQ0NTMsMC44Mjc5NmMwLjI4MTUxLDAuMjk4MDcgMC41NjMwMywwLjYyOTI3IDAuODI3OTYsMC45NzcwMmMwLjI2NDk1LDAuMzQ3NzYgMC40OTY3OSwwLjY5NTUxIDAuNzEyMDcsMS4wNTk4MWMwLjIxNTI4LDAuMzY0MjkgMC4zODA4OCwwLjcyODYxIDAuNTEzMzYsMS4wNzYzN2MwLjAxNjU2LDAuMDY2MjUgMC4wMzMxMiwwLjE0OTAzIDAuMDMzMTIsMC4yMzE4NHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjc1Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTAuMzAyNDM1MDAwMDAwMDAzOjkuODgxMzQ1MDAwMDAwMDEtLT4=" alt="性能"><span class="settings-nav-text">性能</span>
                </div>
                <div class="settings-nav-btn" data-panel="coords">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY2LC0xNzAuMTE4NjYpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTIzNC4zMzcyOSwxODguNTc0MjdsMC4xNzg2MywtMTYuNjEyNjUiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0yNDguMDg0MzQsMTg1LjU5Njk5bC0xNi42MTM1NSwwLjA0MzgxIiBzdHJva2Utd2lkdGg9IjIiLz48ZyBzdHJva2Utd2lkdGg9IjIiPjxwYXRoIGQ9Ik0yMzQuMzM3MjksMTcxLjQyNTczbC0xLjk2NDk0LDIuODU4MDkiLz48cGF0aCBkPSJNMjM2LjY1OTQ5LDE3NC40NjI0NWwtMi4xNDM1NywtMy4wMzY3MiIvPjwvZz48ZyBzdHJva2Utd2lkdGg9IjIiPjxwYXRoIGQ9Ik0yNDUuNTg2MTksMTgzLjM1MzA1bDIuOTM1NzUsMS44NDY5Ii8+PHBhdGggZD0iTTI0NS41ODIzMiwxODcuNjQzOTFsMi45NDY4OSwtMi4yNjU0NyIvPjwvZz48cGF0aCBkPSJNMjQ1Ljg0NTkyLDE3NC45MjIzOGMtMS4xNTMyMyw1LjkzMzg4IC0zLjIxMTc3LDEyLjcyODk3IC01Ljg0NDQ2LDUuNTAyMTZjLTIuNDYzODYsLTYuODU2NjkgLTQuMDE5OTksLTMuMDk2NTcgLTQuOTI3NzMsMC43NzQxNCIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzUwMDAwMDAwMDc6OS44ODEzMzUwMDAwMDAwMDctLT4=" alt="坐标系"><span class="settings-nav-text">坐标系</span>
                </div>
                <div class="settings-nav-btn" data-panel="features">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC41ODA2MSIgaGVpZ2h0PSIyMC4zODM0NSIgdmlld0JveD0iMCwwLDIwLjU4MDYxLDIwLjM4MzQ1Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjUyMjIsLTE2OS44MDgyNykiPjxnIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzMC4xMTg2OCwxODkuODgxNDF2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIGZpbGw9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yNDguOTE0MjIsMTc3LjI4MTkzbC0yLjcyNzQyLDIuNzI3NDJjMC4yNjE1MywwLjAxODcgMC41MjMwOCwwLjA5MzQxIDAuNzY1OTIsMC4yMDU0OWMwLjI0Mjg0LDAuMTEyMDggMC40NDgzMywwLjI2MTUyIDAuNjE2NDgsMC40NDgzM2MwLjE2ODExLDAuMTg2ODEgMC4zMTc1NywwLjQxMDk2IDAuNDEwOTYsMC42NTM4M2MwLjA5MzQxLDAuMjQyODQgMC4xNDk0NSwwLjUwNDM4IDAuMTQ5NDUsMC43ODQ2djUuNjA0MjRjMCwwLjI5ODg5IC0wLjA1NjAzLDAuNTYwNDEgLTAuMTY4MTEsMC44MjE5NmMtMC4xMTIwOCwwLjI2MTUzIC0wLjI2MTUzLDAuNDg1NjkgLTAuNDQ4MzQsMC42NzI0OGMtMC4xODY4MSwwLjE4NjgxIC0wLjQxMDk2LDAuMzM2MjYgLTAuNjcyNDgsMC40NDgzNGMtMC4yNjE1MywwLjExMjA4IC0wLjUyMzA3LDAuMTY4MTEgLTAuODIxOTYsMC4xNjgxMWgtMTQuMDEwNjJjLTAuMjk4ODksMCAtMC41NjA0MSwtMC4wNTYwMyAtMC44MjE5NSwtMC4xNjgxMWMtMC4yNjE1MywtMC4xMTIwOCAtMC40ODU3LC0wLjI2MTUzIC0wLjY3MjQ5LC0wLjQ0ODM0Yy0wLjE4NjgxLC0wLjE4NjgxIC0wLjMzNjI2LC0wLjQxMDk2IC0wLjQ0ODM0LC0wLjY3MjQ4Yy0wLjExMjA4LC0wLjI2MTUzIC0wLjE2ODEyLC0wLjUyMzA3IC0wLjE2ODEyLC0wLjgyMTk2di0xNC4wMTA2MmMwLC0wLjI5ODg5IDAuMDU2MDQsLTAuNTYwNDEgMC4xNjgxMiwtMC44MjE5NWMwLjExMjA4LC0wLjI2MTUzIDAuMjYxNTMsLTAuNDg1NyAwLjQ0ODM0LC0wLjY3MjQ5YzAuMTg2ODEsLTAuMTg2ODEgMC40MTA5NywtMC4zMzYyNiAwLjY3MjQ5LC0wLjQ0ODM0YzAuMjYxNTMsLTAuMTEyMDggMC41MjMwNywtMC4xNjgxMSAwLjgyMTk1LC0wLjE2ODExaDUuNjA0MjVjMC4yNjE1MywwIDAuNTIzMDcsMC4wNTYwNCAwLjc4NDU5LDAuMTQ5NDVjMC4yNjE1MywwLjA5MzQxIDAuNDY3MDQsMC4yNDI4NSAwLjY1MzgzLDAuNDEwOTZjMC4xODY4MSwwLjE2ODExIDAuMzM2MjYsMC4zNzM2IDAuNDQ4MzQsMC42MTY0OWMwLjExMjA4LDAuMjQyODQgMC4xODY4MSwwLjQ4NTY5IDAuMjA1NDksMC43NjU5MmwyLjcyNzQxLC0yLjcyNzQyYzAuMTg2ODEsLTAuMTg2ODEgMC40MTA5NiwtMC4zMzYyNiAwLjY3MjQ4LC0wLjQ0ODMzYzAuMjYxNTMsLTAuMTEyMDggMC41NDE3NSwtMC4xNjgxMiAwLjgwMzMsLTAuMTY4MTJjMC4yNjE1MywwIDAuNTQxNzUsMC4wNTYwNCAwLjgwMzI5LDAuMTY4MTJjMC4yNjE1MywwLjExMjA4IDAuNDg1NjksMC4yNjE1MiAwLjY3MjQ4LDAuNDQ4MzNsMy40NDU5MywzLjQ0NTkyYzAuMDA1MTMsMC45OTU2IDAuMDM5MTgsMS45MzEzNiAwLjIwNDMsMi44OTU2Yy0wLjAzNzk5LDAuMDQ3OTYgLTAuMDc3ODUsMC4wOTQ3OSAtMC4xMTk1NywwLjE0MDY4ek0yMzguMzIyMzIsMTg4LjM5Njk3di03LjAwNTI5aC03LjAwNTI5djYuMzE0MTFjMCwwLjE4NjgxIDAuMDc0NzMsMC4zNTQ5NCAwLjIwNTQ4LDAuNDg1NjljMC4xMzA3NywwLjEzMDc3IDAuMjk4ODgsMC4yMDU0OSAwLjQ4NTY5LDAuMjA1NDl6TTI0Ni43Mjg2OSwxODIuMDgyOTVjMCwtMC4xODY4MSAtMC4wNzQ3NCwtMC4zNTQ5NCAtMC4yMDU0OSwtMC40ODU3Yy0wLjEzMDc3LC0wLjEzMDc3IC0wLjI5ODg5LC0wLjIwNTQ5IC0wLjQ4NTcsLTAuMjA1NDloLTYuMzE0MXY3LjAwNTI5aDYuMzE0MWMwLjE4NjgxLDAgMC4zNTQ5NCwtMC4wNzQ3NCAwLjQ4NTcsLTAuMjA1NDljMC4xMzA3NywtMC4xMzA3NyAwLjIwNTQ5LC0wLjI5ODg4IDAuMjA1NDksLTAuNDg1Njl6TTIzOC4zMjIzMiwxNzkuOTkwNjh2LTYuMzE0MTFjMCwtMC4xODY4MSAtMC4wNzQ3NCwtMC4zNTQ5NCAtMC4yMDU0OSwtMC40ODU2OWMtMC4xMzA3NywtMC4xMzA3NyAtMC4yOTg4OCwtMC4yMDU0OSAtMC40ODU2OSwtMC4yMDU0OWgtNS42MDQyNGMtMC4xODY4MSwwIC0wLjM1NDk0LDAuMDc0NzMgLTAuNDg1NjksMC4yMDU0OWMtMC4xMzA3NywwLjEzMDc3IC0wLjIwNTQ5LDAuMjk4ODggLTAuMjA1NDksMC40ODU2OXY2LjMxNDExek0yNDguMTI5NzQsMTc1Ljc4NzQ1YzAsLTAuMTg2ODEgLTAuMDc0NzMsLTAuMzU0OTQgLTAuMjA1NDgsLTAuNDg1NjlsLTMuNTEyMDIsLTMuNTEyMDFjLTAuMTMwNzcsLTAuMTMwNzcgLTAuMjk4ODgsLTAuMjA1NDkgLTAuNDg1NjksLTAuMjA1NDljLTAuMTg2ODEsMCAtMC4zNTQ5NCwwLjA3NDc0IC0wLjQ4NTY5LDAuMjA1NDlsLTMuNTEyMDIsMy41MTIwMWMtMC4xMzA3NywwLjEzMDc3IC0wLjIwNTQ4LDAuMjk4ODggLTAuMjA1NDgsMC40ODU2OWMwLDAuMTg2ODEgMC4wNzQ3MywwLjM1NDk0IDAuMjA1NDgsMC40ODU3bDMuNTEyMDIsMy41MTIwMWMwLjEzMDc3LDAuMTMwNzcgMC4yOTg4OCwwLjIwNTQ5IDAuNDg1NjksMC4yMDU0OWMwLjE4NjgxLDAgMC4zNTQ5NCwtMC4wNzQ3NCAwLjQ4NTY5LC0wLjIwNTQ5bDMuNTEyMDIsLTMuNTEyMDFjMC4xMzA3NywtMC4xMzA3NyAwLjIwNTQ4LC0wLjI5ODg5IDAuMjA1NDgsLTAuNDg1N3pNMjQxLjY0NzQ4LDE3OS45OTA2OGwtMS45MjQxMiwtMS45MjQxMnYxLjkyNDEyeiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNzUiLz48cGF0aCBkPSJNMjQ4LjQ0MzE5LDE3NC4wODljMC45MTY1OCwwIDEuNjU5NjEsMC43NDMwMyAxLjY1OTYxLDEuNjU5NjFjMCwwLjkxNjU4IC0wLjc0MzAzLDEuNjU5NjIgLTEuNjU5NjEsMS42NTk2MmMtMC4zNzQxNSwwIC0wLjcxOTM4LC0wLjEyMzgxIC0wLjk5Njk2LC0wLjMzMjdjMCwtMC44ODQ2MSAwLC0xLjc2OTIyIDAsLTIuNjUzODNjMC4yNzc1OCwtMC4yMDg4OSAwLjYyMjgxLC0wLjMzMjcgMC45OTY5NiwtMC4zMzI3eiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTAuNDc3ODAyNDk5OTk5OTk2OjEwLjE5MTcyNDk5OTk5OTk5MS0tPg==" alt="功能"><span class="settings-nav-text">功能</span>
                </div>
            </div>

            <div id="settings-panel-appearance" class="settings-panel-content active">
                <div class="settings-item-row"><label for="dark-mode-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS44NSIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljg1Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY5LC0xNzAuMDc1KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjMwLjExODY5LDE4OS44ODE0MXYtMTkuNzYyNzNoMTkuNzYyNzN2MTkuNzYyNzN6IiBmaWxsLW9wYWNpdHk9IjAuMDA3ODQiIGZpbGw9IiNjMmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PHBhdGggZD0iTTIzMS4yLDE4NS4wNWMwLC0wLjIgMCwtMC4zIDAuMSwtMC40YzAuMSwtMC4xIDAuMiwtMC4yIDAuMywtMC4zYzAuMiwtMC4xIDAuNCwtMC4yIDAuNiwtMC4yYzAuMiwtMC4xIDAuNCwtMC4xIDAuNiwtMC4yYzAuNSwtMC4yIDEuMSwtMC41IDEuNiwtMC43YzAuNSwtMC4zIDEsLTAuNiAxLjUsLTAuOWMwLjYsLTAuNCAxLjEsLTAuOSAxLjUsLTEuNWMwLjQsLTAuNiAwLjgsLTEuMSAxLjEsLTEuOGMwLjMsLTAuNyAwLjUsLTEuMyAwLjcsLTJjMC4yLC0wLjcgMC4zLC0xLjQgMC4zLC0yLjJjMCwtMC42IDAsLTEuMiAtMC4xLC0xLjhjLTAuMiwtMC41IC0wLjMsLTEuMSAtMC40LC0xLjd2LTAuMXYtMC4xYzAsLTAuMiAwLjEsLTAuMyAwLjIsLTAuNWMwLjEsLTAuMSAwLjMsLTAuMiAwLjUsLTAuMmMwLjQsMCAwLjcsMCAxLjEsMC4xYzAuNCwwLjEgMC43LDAuMiAxLjEsMC4zYzAuNCwwLjEgMC43LDAuMiAxLjEsMC40YzAuNCwwLjIgMC43LDAuMyAxLDAuNWMwLjcsMC40IDEuNCwwLjkgMiwxLjVjMC42LDAuNiAxLjEsMS4zIDEuNSwyYzAuNCwwLjcgMC43LDEuNSAxLDIuM2MwLjIsMC44IDAuMywxLjYgMC4zLDIuNWMwLDAuOSAtMC4xLDEuNyAtMC4zLDIuNWMtMC4yLDAuOCAtMC42LDEuNiAtMSwyLjNjLTAuNCwwLjcgLTAuOSwxLjQgLTEuNSwxLjljLTAuNiwwLjUgLTEuMiwxLjEgLTEuOSwxLjVjLTAuNywwLjQgLTEuNSwwLjcgLTIuMywxYy0wLjgsMC4yIC0xLjcsMC4zIC0yLjUsMC4zYy0wLjgsMCAtMS41LC0wLjEgLTIuMywtMC4zYy0wLjgsLTAuMiAtMS42LC0wLjQgLTIuMiwtMC44Yy0wLjcsLTAuNCAtMS4zLC0wLjggLTEuOSwtMS4zYy0wLjYsLTAuNSAtMS4xLC0xLjEgLTEuNSwtMS43Yy0wLjEsLTAuMSAtMC4yLC0wLjMgLTAuMiwtMC40ek0yMzkuMiwxODguMzVjMC44LDAgMS41LC0wLjEgMi4yLC0wLjNjMC43LC0wLjIgMS40LC0wLjUgMiwtMC44YzAuNiwtMC4zIDEuMiwtMC44IDEuNywtMS4zYzAuNSwtMC41IDAuOSwtMS4xIDEuMywtMS43YzAuNCwtMC42IDAuNiwtMS4zIDAuOCwtMmMwLjIsLTAuNyAwLjMsLTEuNSAwLjMsLTIuMmMwLC0wLjcgLTAuMSwtMS40IC0wLjIsLTJjLTAuMiwtMC43IC0wLjQsLTEuMyAtMC43LC0xLjljLTAuMywtMC42IC0wLjcsLTEuMSAtMS4xLC0xLjZjLTAuNCwtMC41IC0wLjksLTAuOSAtMS41LC0xLjNjLTAuNSwtMC40IC0xLjEsLTAuNyAtMS44LC0xYy0wLjYsLTAuMiAtMS4zLC0wLjQgLTIsLTAuNWMwLjEsMC41IDAuMiwxIDAuMywxLjZjMC4xLDAuNSAwLjEsMSAwLjEsMS42YzAsMC45IC0wLjEsMS44IC0wLjMsMi43Yy0wLjIsMC45IC0wLjUsMS43IC0xLDIuNWMtMC40LDAuNyAtMC44LDEuMyAtMS4zLDEuOGMtMC41LDAuNSAtMSwxIC0xLjYsMS40Yy0wLjYsMC40IC0xLjIsMC44IC0xLjgsMS4xYy0wLjcsMC4zIC0xLjMsMC42IC0yLDAuOWMwLjQsMC41IDAuOCwwLjkgMS4zLDEuM2MwLjUsMC40IDEsMC43IDEuNiwxYzAuNywwLjIgMS4yLDAuNCAxLjgsMC41YzAuNywwLjIgMS4zLDAuMiAxLjksMC4yeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNzUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljg4MTMwNTAwMDAwMDAyNjo5LjkyNDk5OTk5OTk5OTk4My0tPg==" class="settings-item-icon" alt="">深色模式</label><label class="custom-switch-container"><input type="checkbox" id="dark-mode-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item"><div class="settings-item-row"><label for="window-transparency-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC43NjI3OSIgaGVpZ2h0PSIyMC41OTc0OCIgdmlld0JveD0iMCwwLDIwLjc2Mjc5LDIwLjU5NzQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjYxODYsLTE2OS43OTQxMykiPjxnIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzMC4xMTg2OSwxODkuODgxNDF2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ3LjQzMjQzLDE3MS43ODAwNGMxLjQ1MzAyLDEuMjQ1NDUgMS41MjgzMywzLjQxOTg0IDEuNTY1MzcsNS4yMjA5N2MwLjEzOTUzLDYuNzg1NzggMC4yNzAzMywxMy4wNDAwOCAtNy44MjM0OSwxMi43OTk3OWMtMC42NDI4OCwtMC4wMTkwOSAtMS43MzQzMiwtMC4yMjk0NCAtMi4yMDc2NCwtMC42MzUxNGMtMS42MjAzNCwtMS4zODg4NiAtMS43MzcyMiwtNC41NDgzNCAwLjI4MDM3LC01Ljc1ODljLTAuMDcxMzksLTAuMjMyNDEgLTAuMTA5ODIsLTAuNDc5MjYgLTAuMTA5ODIsLTAuNzM1MDhjMCwtMy4yODI5OSAzLjY5MDA2LC0xNC44Mzg5MSA4LjI5NTIxLC0xMC44OTE2NHoiIGZpbGwtb3BhY2l0eT0iMC40NTg4MiIgZmlsbD0iIzgyODI4MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMzLjI2NTE1LDE4OC41NDA1NWMtMS41MjEzMiwtMS4xNjEwMyAtMS43MTk4MywtMy4zMjc2NSAtMS44NTg5NywtNS4xMjM3OGMtMC41MjQxOCwtNi43NjY5NCAtMS4wMDk1LC0xMy4wMDM3NiA3LjA4NDkyLC0xMy4yMjI5MmMwLjY0MjkzLC0wLjAxNzQxIDEuNzQ0NTUsMC4xMzA3MSAyLjI0MDExLDAuNTA4OTFjMS42OTY1LDEuMjk0NzMgMS45OTI0LDQuNDQyNDkgMC4wNDY3Miw1Ljc2NTUzYzAuMDg0NDYsMC4yMjc5OSAwLjEzNjgyLDAuNDcyMjYgMC4xNTEzMywwLjcyNzY2YzAuMTg2MiwzLjI3NzcgLTIuODQyNDksMTUuMDI0MzIgLTcuNjY0MTEsMTEuMzQ0NnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0NC41NzEwNCwxNzAuNzk0NjljMC4wMzE3NiwtMC4wMDA1MSAwLjA2MzU2LC0wLjAwMDY5IDAuMDk1NDQsLTAuMDAwNTZjMi41OTQyNSwwLjAxMTI4IDQuNjg4MzYsMi4xNTkzNiA0LjY3NzMxLDQuNzk3ODljLTAuMDAwMDksMC4wMjA5IC0wLjAwMDMsMC4wNDE3NyAtMC4wMDA2NywwLjA2MjYzbDAuMDM4MjgsOC45NTgyNmMwLDAuMDMyMjkgLTAuMDAwMzUsMC4wNjQ2MyAtMC4wMDA5NywwLjA5NzA0Yy0wLjA1MjA3LDIuNjM4MDQgLTIuMTk2OTUsNC43MzM2NyAtNC43OTA3NCw0LjY4MDY4Yy0wLjAyMDU1LC0wLjAwMDQyIC0wLjA0MTA1LC0wLjAwMDk3IC0wLjA2MTU2LC0wLjAwMTY1bC05LjE5MjI5LDAuMDAxNTFjLTAuMDMxNzYsMC4wMDAxMiAtMC4wNjM1NiwtMC4wMDAwNyAtMC4wOTU0NCwtMC4wMDA2Yy0yLjU5Mzk1LC0wLjA0MjQ5IC00LjY2MjkyLC0yLjIxNTYxIC00LjYyMTE3LC00Ljg1Mzg2YzAuMDAwMzUsLTAuMDIwODkgMC4wMDA3OSwtMC4wNDE3NiAwLjAwMTM5LC0wLjA2MjYxbDAuMDY1OTgsLTguOTU4MTJjMC4wMDAzOSwtMC4wMzIyOSAwLjAwMTA3LC0wLjA2NDYzIDAuMDAyMTEsLTAuMDk3MDRjMC4wODI3NCwtMi42MzcyNCAyLjI1MTg4LC00LjcwNjg5IDQuODQ0ODcsLTQuNjIyNzFjMC4wMjA1NSwwLjAwMDY3IDAuMDQxMDUsMC4wMDE0OCAwLjA2MTU0LDAuMDAyNDF6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQyLjc5NDUsMTcxLjQ0NjA3bC01LjU1NDk0LDE3LjEyNzc0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzMy43Njc3MiwxNzQuOTE3OTFoNS4yMDc3NiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzMuNzY3NzIsMTc5LjE5OTg0aDEuMTU3MjgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMzLjc5NjY1LDE4My4yMjcxOGgyLjI1NjciIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTAuMzgxMzk1NDUxNjEyMzc3OjEwLjIwNTg2NTk1NDY0Njc1NC0tPg==" class="settings-item-icon" alt="">启用窗口透明度</label><label class="custom-switch-container"><input type="checkbox" id="window-transparency-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">可能会降低性能</p></div>
                <div class="settings-item-row"><label for="color-inversion-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC42MzQ3OCIgaGVpZ2h0PSIyMC42MzQ3NiIgdmlld0JveD0iMCwwLDIwLjYzNDc4LDIwLjYzNDc2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjY4MjYxLC0xNjkuNjgyNjIpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjksMTg5Ljg4MTQxdi0xOS43NjI3M2gxOS43NjI3M3YxOS43NjI3M3oiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2MyZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PGcgc3Ryb2tlPSIjMDAwMDAwIj48cGF0aCBkPSJNMjM0LjM2MDA4LDE4Ny40MTU5MWMtNC4wOTU2OSwtMy4xMTQ4NSAtNC44OTA4MywtOC45NjAxNCAtMS43NzU5OSwtMTMuMDU1ODNjMy4xMTQ4MywtNC4wOTU2NyA4Ljk2MDE0LC00Ljg5MDgzIDEzLjA1NTgzLC0xLjc3NTk5YzQuMDk1NjksMy4xMTQ4NSA0Ljg5MDgzLDguOTYwMTQgMS43NzU5OSwxMy4wNTU4M2MtMy4xMTQ4Myw0LjA5NTY3IC04Ljk2MDE0LDQuODkwODMgLTEzLjA1NTgzLDEuNzc1OTl6IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOS40NjIxLDE3MC45OTI3NmwwLjEwNjk1LDE3Ljg3ODQ4IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC4zODY0MywxODcuNDQyMjZjLTQuMDk1NjksLTMuMTE0ODUgLTQuODkwODMsLTguOTYwMTQgLTEuNzc1OTgsLTEzLjA1NTgzYzEuNjU2ODcsLTIuMTc4NjIgNC4wODYzNCwtMy40MjMzNSA2LjYxNDEsLTMuNjQyNDZjMCw2LjE4ODYzIDAsMTIuMzc3MjcgMCwxOC41NjU5Yy0xLjY5OTY5LC0wLjE0NTE4IC0zLjM3OTgxLC0wLjc1ODU0IC00LjgzODExLC0xLjg2NzYxeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjEwLjMxNzM4ODA2NzUyNDI2MzoxMC4zMTczODIwODgwOTQwMzUtLT4=" class="settings-item-icon" alt="">颜色反转</label><label class="custom-switch-container"><input type="checkbox" id="color-inversion-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item"><label for="preferred-color-slider"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS44MDExNSIgaGVpZ2h0PSIxOS44NjcxMyIgdmlld0JveD0iMCwwLDE5LjgwMTE1LDE5Ljg2NzEzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjA5OTQzLC0xNzAuMDY2NDMpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzMC4xMTg2NCwxODkuODgxMzd2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM2LjM2OTc3LDE4MS43ODIxYy0wLjI4MDUzLDAgLTAuNTQ0NTMsMC4wNjYwMSAtMC43NzU1MywwLjE4MTUyYy0wLjIzMSwwLjExNTUxIC0wLjQ3ODUyLDAuMjQ3NTIgLTAuNzA5NTQsMC4zNzk1M2MtMC4yMzEsMC4xMzIgLTAuNDc4NTIsMC4yNjQgLTAuNzA5NTQsMC4zNzk1MWMtMC4yMzEsMC4xMTU1MSAtMC41MTE1MSwwLjE4MTUxIC0wLjgwODU0LDAuMTgxNTFjLTAuNDEyNTEsMCAtMC43OTIwNiwtMC4wOTkgLTEuMTM4NTgsLTAuMjk3MDNjLTAuMzQ2NTEsLTAuMTk3OTggLTAuNjc2NTEsLTAuNDEyNTQgLTAuOTczNTYsLTAuNjYwMDNjLTAuMzk2MDIsLTAuMzQ2NTIgLTAuNjkzMDMsLTAuNzI2MDQgLTAuODU4MDIsLTEuMTcxNTdjLTAuMTY1MDIsLTAuNDQ1NTMgLTAuMjk3MDMsLTAuOTI0MDMgLTAuMjk3MDMsLTEuNDM1NTljMCwtMC41MTE1NCAwLjA2NjAxLC0xLjAzOTU5IDAuMjE0NTMsLTEuNTM0NmMwLjE0ODUsLTAuNDk1MDQgMC4zMTM1LC0wLjk5MDA1IDAuNTI4MDIsLTEuNDY4NTdjMC40NjIwMiwtMS4wMjMwNCAxLjAzOTU2LC0xLjk0NzA5IDEuNzQ5MTEsLTIuODA1MTRjMC4zMTM1LC0wLjM3OTUzIDAuNjQzNTUsLTAuNzU5MDQgMS4wMDY1NywtMS4xMDU1N2MwLjM2MzAzLC0wLjM0NjUyIDAuNzQyNTQsLTAuNjYwMDEgMS4xNzE1NywtMC45MjQwNWMwLjc0MjU0LC0wLjQ3ODUyIDEuNTE4MDgsLTAuODI1MDMgMi4zMjY2MiwtMS4wNzI1NWMwLjgwODU0LC0wLjI0NzUyIDEuNjUwMDksLTAuMzYzMDQgMi41NDExMywtMC4zNjMwNGMwLjgyNTA1LDAgMS42MzM1OCwwLjExNTUyIDIuNDA5MTQsMC4zMzAwNWMwLjc3NTUyLDAuMjE0NTEgMS41NTEwNywwLjUxMTU0IDIuMjc3MTQsMC45MDc1NmMwLjg5MTAzLDAuNDc4NTIgMS42ODMwOCwxLjAzOTU2IDIuMzc2MTEsMS42ODMwOGMwLjY5MzA1LDAuNjQzNTIgMS4yNzA1OSwxLjM1MzA4IDEuNzQ5MTEsMi4xNDUxM2MwLjQ3ODUyLDAuNzkyMDUgMC44NDE1NSwxLjYzMzU4IDEuMDg5MDcsMi41NDExM2MwLjI0NzUyLDAuOTA3NTYgMC4zNjMwMywxLjg2NDYgMC4zNjMwMywyLjg3MTE1YzAsMC43NDI1NCAtMC4wNjYsMS40ODUxIC0wLjE5ODAxLDIuMjQ0MTJjLTAuMTMyLDAuNzU5MDMgLTAuMzQ2NTEsMS40ODUwNiAtMC42MjcwMiwyLjE5NDY0Yy0wLjI4MDUzLDAuNzA5NTcgLTAuNjI3MDMsMS4zNjk1NiAtMS4wNTYwNiwyLjAxMzFjLTAuNDI5MDEsMC42NDM1MiAtMC45NDA1NCwxLjE4ODA1IC0xLjUxODA4LDEuNjUwMWMtMC40Nzg1MiwwLjM5NjAyIC0xLjAwNjU3LDAuNzA5NTYgLTEuNTY3NTksMC45NDA1NmMtMC41NjEwMiwwLjIzMTAyIC0xLjE1NTA2LDAuMzQ2NTEgLTEuNzk4NiwwLjM0NjUxYy0wLjU2MTAyLDAgLTEuMTM4NTUsLTAuMDk4OTkgLTEuNjk5NTgsLTAuMjk3MDNjLTAuNTYxMDIsLTAuMTk3OTggLTEuMDM5NTYsLTAuNDQ1NTMgLTEuNDUyMDgsLTAuNzQyNTRjLTAuNDEyNTIsLTAuMjk3MDMgLTAuNzQyNTQsLTAuNjQzNTIgLTEuMDIzMDQsLTEuMDM5NTZjLTAuMjgwNTMsLTAuMzk2MDIgLTAuNDc4NTIsLTAuODQxNTYgLTAuNjI3MDMsLTEuMzM2NTdjLTAuMTQ4NSwtMC40OTUwNCAtMC4yMzEsLTEuMDIzMDQgLTAuMjY0MDIsLTEuNjAwNThjLTAuMDE2NDksLTAuMTk3OTggLTAuMDE2NSwtMC4zOTYwMyAtMC4wMzI5OSwtMC41OTQwMWMtMC4wMTY0OSwtMC4xOTc5OCAtMC4wMTY1MSwtMC4zOTYwMyAtMC4wMzMwMSwtMC41OTQwMWMwLC0wLjExNTUxIC0wLjAxNjQ5LC0wLjIzMSAtMC4wMzI5OSwtMC4zNzk1Yy0wLjAxNjQ5LC0wLjE0ODUgLTAuMDMyOTksLTAuMjgwNTMgLTAuMDY2MDEsLTAuNDEyNTRjLTAuMDMyOTksLTAuMTMyIC0wLjA2NiwtMC4yODA0OCAtMC4xMTU0OSwtMC4zOTU5OWMtMC4wNDk1MSwtMC4xMTU1MSAtMC4wOTkwMiwtMC4yMzEwMyAtMC4xNjUwMiwtMC4zMzAwNWMtMC4wNjYsLTAuMDgyNSAtMC4xMzIwMSwtMC4xNDg1IC0wLjI0NzUyLC0wLjE5ODAxYy0wLjExNTQ5LC0wLjA0OTUxIC0wLjIxNDUxLC0wLjA5ODk5IC0wLjM0NjQ5LC0wLjEzMmMtMC4xMzIsLTAuMDMyOTkgLTAuMjQ3NTIsLTAuMDQ5NDggLTAuMzYzMDMsLTAuMDY2Yy0wLjExNTQ5LC0wLjAxNjQ5IC0wLjE5ODAxLC0wLjAzMjk5IC0wLjI5NzAzLC0wLjAzMjk5ek0yNDAuNzc1NDUsMTc0LjcwMzIyYzAsLTAuMzEzNSAtMC4wOTksLTAuNTYxMDIgLTAuMzEzNSwtMC43NzU1NWMtMC4yMTQ1MywtMC4yMTQ1MSAtMC40NjIwNSwtMC4zMTM1MiAtMC43NzU1NSwtMC4zMTM1MmMtMC4xNDg1LDAgLTAuMjgwNTMsMC4wMzI5OSAtMC40MTI1MiwwLjA4MjVjLTAuMTMyLDAuMDQ5NTEgLTAuMjQ3NTIsMC4xMzIwMSAtMC4zNDY1MSwwLjIzMTAyYy0wLjA5OTAyLDAuMDk5IC0wLjE4MTQ5LDAuMjE0NTEgLTAuMjMxLDAuMzQ2NTFjLTAuMDQ5NTEsMC4xMzIgLTAuMDgyNSwwLjI4MDU0IC0wLjA4MjUsMC40MTI1NGMwLDAuMTMyIDAuMDMyOTksMC4yODA1MSAwLjA4MjUsMC40MTI1MmMwLjA0OTUxLDAuMTMyIDAuMTMyMDEsMC4yNDc1MiAwLjIzMSwwLjM0NjUyYzAuMDk5MDIsMC4wOTkgMC4yMTQ1MywwLjE4MTUxIDAuMzQ2NTEsMC4yMzEwMmMwLjEzMiwwLjA0OTUxIDAuMjgwNTMsMC4wODI1IDAuNDEyNTIsMC4wODI1YzAuMTMyLDAgMC4yODA1NCwtMC4wMzI5OSAwLjQxMjU0LC0wLjA4MjVjMC4xMzIsLTAuMDQ5NTEgMC4yNDc1LC0wLjEzMiAwLjM0NjUxLC0wLjIzMTAyYzAuMDk5MDIsLTAuMDk5IDAuMTgxNDksLTAuMjE0NTEgMC4yMzEsLTAuMzQ2NTJjMC4wNDk1MSwtMC4xMzIgMC4wOTkwMiwtMC4yNDc0OSAwLjA5OTAyLC0wLjM5NjAyek0yNDQuMTc0NiwxODQuOTE3MjRjMCwtMC4zMTM1IC0wLjA5OSwtMC41NjEwMiAtMC4zMTM1LC0wLjc3NTU1Yy0wLjIxNDUzLC0wLjIxNDUxIC0wLjQ2MjA1LC0wLjMxMzUgLTAuNzc1NTUsLTAuMzEzNWMtMC4xNDg1LDAgLTAuMjgwNDgsMC4wMzI5OSAtMC40MTI0OSwwLjA4MjVjLTAuMTMyLDAuMDQ5NTEgLTAuMjQ3NTIsMC4xMzIgLTAuMzQ2NTIsMC4yMzFjLTAuMDk5MDIsMC4wOTkgLTAuMTgxNDksMC4yMTQ1MSAtMC4yMzEsMC4zNDY1MWMtMC4wNDk1MSwwLjEzMiAtMC4wODI1LDAuMjgwNTQgLTAuMDgyNSwwLjQxMjU0YzAsMC4xMzIgMC4wMzI5OSwwLjI4MDUxIDAuMDgyNSwwLjQxMjUyYzAuMDQ5NTEsMC4xMzIgMC4xMzIsMC4yNDc1MiAwLjIzMSwwLjM0NjUxYzAuMDk5MDIsMC4wOTkgMC4yMTQ1MywwLjE4MTUyIDAuMzQ2NTIsMC4yMzEwM2MwLjEzMiwwLjA0OTUxIDAuMjgwNDgsMC4wODI1IDAuNDEyNDksMC4wODI1YzAuMTMyLDAgMC4yODA1NCwtMC4wMzI5OSAwLjQxMjU0LC0wLjA4MjVjMC4xMzIsLTAuMDQ5NTEgMC4yNDc0OSwtMC4xMzIwMSAwLjM0NjQ5LC0wLjIzMTAzYzAuMDk5MDIsLTAuMDk5IDAuMTgxNSwtMC4yMTQ1MSAwLjIzMTAxLC0wLjM0NjUxYzAuMDQ5NTEsLTAuMTMyIDAuMDk5MDIsLTAuMjQ3NTIgMC4wOTkwMiwtMC4zOTYwMnpNMjQ0LjQ4ODE3LDE3NS45NDA4NGMwLC0wLjMxMzUgLTAuMDk5LC0wLjU2MTAyIC0wLjMxMzUsLTAuNzc1NTVjLTAuMjE0NTMsLTAuMjE0NTEgLTAuNDYyMDMsLTAuMzEzNTIgLTAuNzc1NTMsLTAuMzEzNTJjLTAuMTQ4NSwwIC0wLjI4MDUzLDAuMDMyOTkgLTAuNDEyNTQsMC4wODI1Yy0wLjEzMiwwLjA0OTUxIC0wLjI0NzUsMC4xMzIwMSAtMC4zNDY0OSwwLjIzMTAyYy0wLjA5OTAyLDAuMDk5IC0wLjE4MTQ5LDAuMjE0NTEgLTAuMjMxLDAuMzQ2NTJjLTAuMDQ5NTEsMC4xMzIgLTAuMDgyNSwwLjI4MDU0IC0wLjA4MjUsMC40MTI1NGMwLDAuMTMyIDAuMDMyOTksMC4yODA1MSAwLjA4MjUsMC40MTI1MWMwLjA0OTUxLDAuMTMyIDAuMTMyLDAuMjQ3NTIgMC4yMzEsMC4zNDY1MmMwLjA5OTAyLDAuMDk5IDAuMjE0NTEsMC4xODE0OSAwLjM0NjQ5LDAuMjMxYzAuMTMyLDAuMDQ5NTEgMC4yODA1MywwLjA4MjUgMC40MTI1NCwwLjA4MjVjMC4xMzIsMCAwLjI4MDU0LC0wLjAzMjk5IDAuNDEyNTIsLTAuMDgyNWMwLjEzMiwtMC4wNDk1MSAwLjI0NzUyLC0wLjEzMiAwLjM0NjUxLC0wLjIzMWMwLjA5OTAyLC0wLjA5OSAwLjE4MTQ5LC0wLjIxNDUxIDAuMjMxLC0wLjM0NjUyYzAuMDQ5NTEsLTAuMTMyIDAuMDk5LC0wLjI0NzUyIDAuMDk5LC0wLjM5NjAyek0yNDYuNjQ5NzUsMTc4LjcyOTQxYzAsLTAuMzEzNSAtMC4wOTksLTAuNTYxMDIgLTAuMzEzNTIsLTAuNzc1NTVjLTAuMjE0NTMsLTAuMjE0NTEgLTAuNDYyMDIsLTAuMzEzNSAtMC43NzU1MiwtMC4zMTM1Yy0wLjE0ODUsMCAtMC4yODA1MywwLjAzMjk4IC0wLjQxMjUyLDAuMDgyNDljLTAuMTMyLDAuMDQ5NTEgLTAuMjQ3NTIsMC4xMzE5OCAtMC4zNDY1MiwwLjIzMDk4Yy0wLjA5OTAyLDAuMDk5IC0wLjE4MTQ5LDAuMjE0NTEgLTAuMjMxLDAuMzQ2NTJjLTAuMDQ5NTEsMC4xMzIgLTAuMDgyNSwwLjI4MDU0IC0wLjA4MjUsMC40MTI1NGMwLDAuMTMyIDAuMDMyOTksMC4yODA1MyAwLjA4MjUsMC40MTI1NGMwLjA0OTUxLDAuMTMyIDAuMTMyLDAuMjQ3NTEgMC4yMzEsMC4zNDY1MWMwLjA5OTAyLDAuMDk5IDAuMjE0NTMsMC4xODE1IDAuMzQ2NTIsMC4yMzEwMWMwLjEzMiwwLjA0OTUxIDAuMjgwNTMsMC4wODI0OSAwLjQxMjUyLDAuMDgyNDljMC4xMzIsMCAwLjI4MDUxLC0wLjAzMjk4IDAuNDEyNTEsLTAuMDgyNDljMC4xMzIsLTAuMDQ5NTEgMC4yNDc1MiwtMC4xMzIwMSAwLjM0NjUyLC0wLjIzMTAxYzAuMDk5MDIsLTAuMDk5IDAuMTgxNDksLTAuMjE0NTEgMC4yMzEsLTAuMzQ2NTFjMC4wNDk1MSwtMC4xMzIgMC4wOTksLTAuMjQ3NTIgMC4wOTksLTAuMzk2MDJ6TTI0Ni42NDk3NSwxODIuNDQyMThjMCwtMC4zMTM1IC0wLjA5OSwtMC41NjEwMiAtMC4zMTM1MiwtMC43NzU1NWMtMC4yMTQ1MywtMC4yMTQ1MSAtMC40NjIwMiwtMC4zMTM1IC0wLjc3NTUyLC0wLjMxMzVjLTAuMTQ4NSwwIC0wLjI4MDUzLDAuMDMyOTkgLTAuNDEyNTIsMC4wODI1Yy0wLjEzMiwwLjA0OTUxIC0wLjI0NzUyLDAuMTMyMDEgLTAuMzQ2NTIsMC4yMzEwMmMtMC4wOTkwMiwwLjA5OSAtMC4xODE0OSwwLjIxNDUxIC0wLjIzMSwwLjM0NjUyYy0wLjA0OTUxLDAuMTMyIC0wLjA4MjUsMC4yODA1MSAtMC4wODI1LDAuNDEyNTFjMCwwLjEzMiAwLjAzMjk5LDAuMjgwNTEgMC4wODI1LDAuNDEyNTJjMC4wNDk1MSwwLjEzMiAwLjEzMiwwLjI0NzUyIDAuMjMxLDAuMzQ2NTFjMC4wOTkwMiwwLjA5OSAwLjIxNDUzLDAuMTgxNDkgMC4zNDY1MiwwLjIzMWMwLjEzMiwwLjA0OTUxIDAuMjgwNTMsMC4wODI1IDAuNDEyNTIsMC4wODI1YzAuMTMyLDAgMC4yODA1MSwtMC4wMzI5OSAwLjQxMjUxLC0wLjA4MjVjMC4xMzIsLTAuMDQ5NTEgMC4yNDc1MiwtMC4xMzIgMC4zNDY1MiwtMC4yMzFjMC4wOTkwMiwtMC4wOTkgMC4xODE0OSwtMC4yMTQ1MSAwLjIzMSwtMC4zNDY1MWMwLjA0OTUxLC0wLjEzMiAwLjA5OSwtMC4yNDc1MiAwLjA5OSwtMC4zOTYwMnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjkuOTAwNTc0OTk5OTk5OTc1OjkuOTMzNTY1MDAwMDAwMDE2LS0+" class="settings-item-icon" alt="">偏好颜色: <span id="preferred-color-value" class="precision-value">值: 0</span></label><div id="preferred-color-slider-container" class="custom-slider-container settings-slider"></div><p class="settings-comment">将会更改侧栏的颜色，适用于浅色模式</p></div>
            </div>

            <div id="settings-panel-performance" class="settings-panel-content">
                <div class="settings-item"><label><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY0LC0xNzAuMTE4NjQpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjUsMTg5Ljg4MTM4di0xOS43NjI3M2gxOS43NjI3M3YxOS43NjI3M3oiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2MyZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiPjxwYXRoIGQ9Ik0yMzMuNjgyNiwxNzYuNDE3MjVjLTAuMDA0MjcsLTAuMDY2MDkgLTAuMDA2NDUsLTAuMTMyNzEgLTAuMDA2NDUsLTAuMTk5ODVjMCwtMS42ODc2NiAxLjM2ODEzLC0zLjA1NTc2IDMuMDU1NzksLTMuMDU1NzZjMC4yNjk3MiwwIDAuNTMxMjYsMC4wMzQ5NSAwLjc4MDQxLDAuMTAwNTYiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNy4zODQyNywxNzMuMjMwMmwwLjYxODAyLDAuMjA1OTkiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzMuNjc2MTQsMTc2LjM4OTA1djEwLjQzNzY5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMxLjYxNjA0LDE3OC4zODAzNGg0LjI1NzQ3IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ3LjI0Mzk5LDE4MC40OTAxYzAuNzA4MDgsMC43NzUxOCAxLjEzOTk3LDEuODA2OTMgMS4xMzk5NywyLjkzOTU3YzAsMS4xNTgzIC0wLjQ1MTcsMi4yMTExMiAtMS4xODg1NCwyLjk5MTg3IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzkuMjM3MTgsMTg2LjI2Mzg2Yy0wLjY4MzE1LC0wLjc2OTY5IC0xLjA5ODAxLC0xLjc4Mjg3IC0xLjA5ODAxLC0yLjg5Mjk1YzAsLTEuMDgzMTggMC4zOTUwMywtMi4wNzQxMyAxLjA0ODg2LC0yLjgzNjU5IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzkuNjI4MTYsMTg2LjcyMTIybC0wLjQ2OTIyLC0wLjUyNzg5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjEwMDMsMTgwLjYyMTEybDAuNDY5MjIsLTAuNTg2NTUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDYuODQyNzcsMTc5Ljk3NTk2bDAuNDEwNiwwLjQ2OTI2IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ2LjcyNTQ0LDE4Ni44MzgzN2wwLjY0NTIsLTAuNjQ1MjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuNzQ0OTksMTgxLjUyODc2bDMuMzk5OTEsMy41NzI3OCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS42ODczNCwxODUuMTAxMzlsMy4yODQ2NiwtMy4zOTk5MSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjkuODgxMzU0OTk5OTk5OTg1OjkuODgxMzU0OTk5OTk5OTg1LS0+" class="settings-item-icon" alt="">显函数与参数方程精度: <span id="explicit-precision-value" class="precision-value">值: 2</span></label><div id="explicit-precision-slider-container" class="custom-slider-container settings-slider"></div></div>
                <div class="settings-item"><label><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY1LC0xNzAuMTE4NjUpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjYsMTg5Ljg4MTM5di0xOS43NjI3M2gxOS43NjI3M3YxOS43NjI3M3oiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2MyZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIuMjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTI0MS43NzA2NSwxNzcuNDE0ODVsLTguMzU3NDcsLTQuMTc4NzMiLz48cGF0aCBkPSJNMjQxLjkxMjMxLDE3Ny42OTgxNmwtOC4zNTc0NywzLjI1OCIvPjxwYXRoIGQ9Ik0yNDYuMzAzNTIsMTgwLjI0NzlsLTYuOTQwOTYsMy44MjQ2Ii8+PHBhdGggZD0iTTIzOS4zNjI1NywxODQuMjE0MTVsNy4yMjQyNiwyLjU0OTczIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjkuODgxMzQ0OTk5OTk5OTgyOjkuODgxMzQ0OTk5OTk5OTgyLS0+" class="settings-item-icon" alt="">隐函数与不等式精度: <span id="implicit-precision-value" class="precision-value">值: 5</span></label><div id="implicit-precision-slider-container" class="custom-slider-container settings-slider"></div></div>
                <div class="settings-item"><label><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiPjxnIHN0cm9rZS13aWR0aD0iMiI+PHBhdGggZD0iTTIzNy42MDY3LDE3NS4zOTA5NmMtMC4wMDM0OCwtMC4wNTM4NCAtMC4wMDUyNSwtMC4xMDgxMyAtMC4wMDUyNSwtMC4xNjI4M2MwLC0xLjM3NTAxIDEuMTE0NjgsLTIuNDg5NjcgMi40ODk2OSwtMi40ODk2N2MwLjIxOTc1LDAgMC40MzI4NCwwLjAyODQ4IDAuNjM1ODMsMC4wODE5NCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQwLjYyMjYyLDE3Mi43OTQzM2wwLjUwMzUzLDAuMTY3ODMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNjAxNDMsMTc1LjM2Nzk4djguNTA0MDYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNTU5MTEsMTgzLjg5NTE0YzAuMDAyNTgsMC4wNTM5IDAuMDAzNDQsMC4xMDgyIDAuMDAyNTIsMC4xNjI5Yy0wLjAyMzAxLDEuMzc0ODIgLTEuMTU2MTgsMi40NzA2NiAtMi41MzEsMi40NDc2NWMtMC4yMTk3MywtMC4wMDM2OCAtMC40MzIzMSwtMC4wMzU3MSAtMC42MzQzOCwtMC4wOTI1NiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM0LjA3ODE1LDE4Ni4zMTQ1OGwwLjUwMzUzLDAuMTY3ODMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48cGF0aCBkPSJNMjQzLjgyOTksMTc1LjQ0ODc4YzAsLTAuNTc3NjcgMC40NjgzLC0xLjA0NTk3IDEuMDQ1OTgsLTEuMDQ1OTdjMC41Nzc2NywwIDEuMDQ1OTcsMC40NjgzIDEuMDQ1OTcsMS4wNDU5N2MwLDAuNTc3NjcgLTAuNDY4MywxLjA0NTk4IC0xLjA0NTk3LDEuMDQ1OThjLTAuNTc3NjcsMCAtMS4wNDU5OCwtMC40NjgzMSAtMS4wNDU5OCwtMS4wNDU5OHoiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQzLjU4MjI4LDE3Ni4zNTE3NHYtMy40NTE3MyIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjA0NTMxLDE4Ni4xMTQxM2MwLC0wLjU0MjA0IDAuNDM5NDEsLTAuOTgxNDUgMC45ODE0NSwtMC45ODE0NWMwLjU0MjA0LDAgMC45ODE0NSwwLjQzOTQxIDAuOTgxNDUsMC45ODE0NWMwLDAuNTQyMDQgLTAuNDM5NDEsMC45ODE0NSAtMC45ODE0NSwwLjk4MTQ1Yy0wLjU0MjA0LDAgLTAuOTgxNDUsLTAuNDM5NDEgLTAuOTgxNDUsLTAuOTgxNDV6IiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0Mi4xMDQwNywxODQuOTQ4MTJ2Mi4zMTM0MSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">积分步数: <span id="integral-precision-value" class="precision-value">值: 50</span></label><div id="integral-precision-slider-container" class="custom-slider-container settings-slider"></div></div>
                <div class="settings-item"><label><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yMzIuOTI5MDksMTgzLjI2NTE4bDAuMDgxOTIsLTcuODY0MzgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC44ODU5OSwxODUuMjEyNzNjLTAuMDQzMDQsLTAuMDAwMTQgLTAuMDg2MzQsLTAuMDAxNjQgLTAuMTI5ODcsLTAuMDA0NTljLTEuMDIwNCwtMC4wNjkxMiAtMS44MDg0LC0wLjg5NzM2IC0xLjg1MDEzLC0xLjg5NjE0IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNC45MzU1MSwxODUuMjY2MzNsMC40MjMzMywtMC4wMDcyNiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMzLjA1MDQxLDE3NS41MjY3OGMwLjAwMDI1LC0wLjA0MzA0IDAuMDAxODgsLTAuMDg2MzMgMC4wMDQ5NiwtMC4xMjk4NmMwLjA3MTk1LC0xLjAyMDIxIDAuOTAyMzcsLTEuODA1OTEgMS45MDEyNywtMS44NDQ4NiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzUuMDU0NjUsMTczLjUzMDM5bDAuNDIzMzMsLTAuMDA3MjYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOC42MTQ5NiwxNzIuMzM0MTlsMy4xNTUwNiwzLjI2OTc5IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzguNTU3NiwxNzUuODMzNDNsMy4zMjcxNSwtMy40NDE4OCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM4LjY1ODI5LDE4Mi44NDcxOWwxLjU0ODg1LDEuOTUwNCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjUxODc2LDE4Ny42NjU4MmwyLjQ2NjY4LC00Ljc2MTI3IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxnIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yNDQuNDA4OCwxNzMuMDIyNTZoMi40NjY2OCIvPjxwYXRoIGQ9Ik0yNDYuOTM0NCwxNzQuOTE3MTVoLTIuNDY2NjgiLz48L2c+PGcgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTI0NC41Njg0MSwxODMuNzA5MjFoMi40NjY2OCIvPjxwYXRoIGQ9Ik0yNDQuNjI3MzMsMTg1LjYwMzhoMi40NjY2OCIvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">参数曲线区间: <span id="tmin-value" class="precision-value" title="点击修改t的最小值"></span> - <span id="tmax-value" class="precision-value" title="点击修改t的最大值"></span></label></div>
                <div class="settings-item"><div class="settings-item-row"><label for="performance-mode-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODYzLC0xNzAuMTE4NjMpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjQsMTg5Ljg4MTM3di0xOS43NjI3M2gxOS43NjI3M3YxOS43NjI3M3oiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2MyZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuMSI+PHBhdGggZD0iTTI0MC41NzM5LDE4MS41MjE2MXYwLjM2OTY5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ1LjI1ODAxLDE3OS45NTYyOXY2LjIxOTUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDUuMzE0NjMsMTc5Ljk0MzY2YzEuODM3MDIsMC4yNjk3MiAzLjIzMDI2LDEuNTczMTEgMy4yMzAyNiwzLjE0MDM0YzAsMS41NjcyMiAtMS4zOTMyNCwyLjg3MDYyIC0zLjIzMDI2LDMuMTQwMzEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0MC41NzQ4NSwxODEuNTk3MDljMC4wMjk4NiwtMC44OTI1NyAwLjc2MjgzLC0xLjYwNjk4IDEuNjYyNjcsLTEuNjA2OThjMC45MTg3OSwwIDEuNjYzNjIsMC43NDQ4MiAxLjY2MzYyLDEuNjYzNjJjMCwwLjAzODMxIC0wLjAwMTI5LDAuMDc2MzMgLTAuMDAzODQsMC4xMTM5OWwtMy4yMzgwNyw0LjEzNzQ3IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDAuNjMwNzgsMTg1Ljg0ODNoMy4zNTU2NiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIj48cGF0aCBkPSJNMjM0LjUxODM0LDE3My40MzAyM2gtMi4xODE1MyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNC45MjczNiwxNzMuNTY2NTdsLTIuMTEzMzYsMS45NzcwMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzMi45NzE1MSwxNzUuNjEyM2MwLjAxNTYzLC0wLjAwMDM3IDAuMDMxMywtMC4wMDA2IDAuMDQ3MDEsLTAuMDAwNmMxLjA1NDIzLDAgMS45MDg4MywwLjg1NDYxIDEuOTA4ODMsMS45MDg4NWMwLDEuMDQzNzQgLTAuODM3NjcsMS44OTE4MiAtMS44Nzc0MSwxLjkwODU5IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzIuMjY4NjUsMTc5LjA4ODU3bDAuNjEzNTQsMC4yNzI2OCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNi42ODcxOSwxNzkuMzcyNDN2LTYuMTM1NTUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuOTIwOTYsMTczLjE1MTgyYzEuODQ0MjcsMC4yNzA3OSAzLjI0MywxLjU3OTMyIDMuMjQzLDMuMTUyNzNjMCwxLjU3MzQxIC0xLjM5ODc1LDIuODgxOTUgLTMuMjQzLDMuMTUyNzEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjxwYXRoIGQ9Ik0yMzguNjEyNzksMTc0LjM2NDI2YzAuNDQ0NDksLTAuMTA5MDQgMC45MDkxLC0wLjE2Njg2IDEuMzg3MjEsLTAuMTY2ODZjMy4yMDQ2OSwwIDUuODAyNiwyLjU5NzkxIDUuODAyNiw1LjgwMjZjMCwwLjUyMjY1IC0wLjA2OTEsMS4wMjkxNiAtMC4xOTg2NiwxLjUxMDkiIGZpbGw9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIwLjQ1MDk4IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDEuMzYzNDQsMTg1LjY0MTUyYy0wLjQzNzI4LDAuMTA1MyAtMC44OTM4NSwwLjE2MTA5IC0xLjM2MzQ0LDAuMTYxMDljLTMuMjA0NjksMCAtNS44MDI2LC0yLjU5NzkxIC01LjgwMjYsLTUuODAyNmMwLC0wLjA1Mzk4IDAuMDAwNzQsLTAuMTA3NzkgMC4wMDIyLC0wLjE2MTQxIiBmaWxsPSJub25lIiBzdHJva2Utb3BhY2l0eT0iMC40NTA5OCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljg4MTM2NDk5OTk5OTk4ODo5Ljg4MTM2NDk5OTk5OTk4OC0tPg==" class="settings-item-icon" alt="">2D/3D叠加绘图</label><label class="custom-switch-container"><input type="checkbox" id="overlay-drawing-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">在3d模式绘制2d对象，在2d模式绘制3d对象</p></div>
                <div class="settings-item"><div class="settings-item-row"><label for="performance-mode-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC40NTIxNSIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDIwLjQ1MjE1LDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIHN0cm9rZT0iIzAwMDAwMCI+PHBhdGggZD0iTTI0OS41Njg1MiwxODEuNzA5NDJsMC4wMDIzLDAuNTM3MThjMCwwLjAzNTUgLTAuMDAwMzgsMC4wNzEwNSAtMC4wMDEwNiwwLjEwNjY4Yy0wLjA1NjQ1LDIuODYwMjYgLTIuMzUwNyw1LjE0MDUyIC01LjE0OTIsNS4xNDcwNCIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTIzNC4xMTQ2NywxNzcuMzA2NzRsMC4wMDI1LC0wLjM0MDMyYzAuMDAwNDMsLTAuMDM1NSAwLjAwMTE4LC0wLjA3MTA1IDAuMDAyMzIsLTAuMTA2NjhjMC4wOTA5NywtMi44OTkzOSAyLjQ3NTc0LC01LjE3NDc5IDUuMzI2NDgsLTUuMDgyMjRjMC4wMjI1OSwwLjAwMDczIDAuMDQ1MTMsMC4wMDE2MiAwLjA2NzY1LDAuMDAyNjVsMC4wNTQ3NSwtMC4wMDAwMiIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTIzMy41NjkxMywxODMuODg4MTRjMCwwLjEwNTAxIC0wLjA0MjAxLDAuMTk5NTIgLTAuMTE1NTIsMC4yNzMwM2MtMC4wNzM1MSwwLjA3MzUxIC0wLjE2ODAyLDAuMTE1NTIgLTAuMjczMDMsMC4xMTU1MmMtMC4wNzM1MSwwIC0wLjEzNjUyLC0wLjAyMTAxIC0wLjIxMDAzLC0wLjA2MzAybC0xLjQyODIsLTAuODkyNjJjLTAuMDczNTEsMC4xMTU1MiAtMC4xMzY1MywwLjIzMTAzIC0wLjE4OTAzLDAuMzQ2NTZjLTAuMDUyNTEsMC4xMTU1MiAtMC4xMTU1MiwwLjIzMTAyIC0wLjE2ODAyLDAuMzU3MDZjLTAuMDMxNTEsMC4wNzM1MSAtMC4wODQwMSwwLjEzNjUzIC0wLjEzNjUzLDAuMTc4NTNjLTAuMDUyNTEsMC4wNDIwMSAtMC4xMzY1MiwwLjA2MzAyIC0wLjIyMDU0LDAuMDYzMDJjLTAuMTA1MDEsMCAtMC4xOTk1MiwtMC4wNDIwMSAtMC4yODM1NCwtMC4xMTU1MmMtMC4wODQwMSwtMC4wNzM1MSAtMC4xMTU1MiwtMC4xNjgwMyAtMC4xMTU1MiwtMC4yNzMwM2MwLC0wLjA3MzUxIDAuMDIxMDEsLTAuMTU3NTMgMC4wNjMwMiwtMC4yNzMwM2MwLjA0MjAxLC0wLjExNTUyIDAuMTA1MDEsLTAuMjMxMDIgMC4xNzg1MiwtMC4zNTcwNmMwLjA3MzUxLC0wLjEyNjAyIDAuMTQ3MDIsLTAuMjYyNTQgMC4yNDE1NCwtMC4zODg1NWMwLjA5NDUxLC0wLjEyNjAyIDAuMTc4NTMsLTAuMjYyNTQgMC4yNjI1NSwtMC4zODg1NWMwLjA4NDAxLC0wLjEyNjAyIDAuMTY4MDIsLTAuMjMxMDMgMC4yNDE1NCwtMC4zMzYwNGMwLjA3MzUxLC0wLjEwNTAxIDAuMTM2NTMsLTAuMTc4NTMgMC4xODkwMiwtMC4yMzEwMmMwLjI5NDA0LC0wLjM0NjU1IDAuNjE5NTksLTAuNjYxNTggMC45NzY2MywtMC45MzQ2MmMwLjM1NzA2LC0wLjI3MzAzIDAuNzM1MDksLTAuNTE0NTcgMS4xNDQ2NywtMC43MzUwOWMwLjQ3MjU2LC0wLjI0MTU0IDAuOTU1NjMsLTAuNDIwMDYgMS40NTk3LC0wLjUzNTU3YzAuNTA0MDcsLTAuMTE1NTIgMS4wMTg2MywtMC4xNjgwMiAxLjU0MzcyLC0wLjE2ODAyYzAuMzU3MDYsMCAwLjcwMzYxLDAuMDIxMDEgMS4wNTAxNiwwLjA3MzUxYzAuMzQ2NTUsMC4wNTI1MSAwLjY5MzEsMC4xMzY1MiAxLjAyOTEzLDAuMjQxNTRsLTAuNTA0MDcsMC42NzIwOWMtMC4xODkwMiwtMC4wNTI1MSAtMC4zODg1NSwtMC4wOTQ1MSAtMC41ODgwOCwtMC4xMjYwMmMtMC4xOTk1MiwtMC4wMzE1MSAtMC4zOTkwNiwtMC4wNTI1MSAtMC41ODgwOCwtMC4wNjMwMnYxLjk1MzI3YzAsMC4xMDUwMSAtMC4wNDIwMSwwLjE5OTUyIC0wLjExNTUyLDAuMjczMDNjLTAuMDczNTEsMC4wNzM1MSAtMC4xNjgwMiwwLjExNTUyIC0wLjI3MzAzLDAuMTE1NTJjLTAuMTA1MDEsMCAtMC4xOTk1MywtMC4wNDIwMSAtMC4yNzMwMywtMC4xMTU1MmMtMC4wNzM1MSwtMC4wNzM1MSAtMC4xMTU1MiwtMC4xNjgwMiAtMC4xMTU1MiwtMC4yNzMwM3YtMS45NTMyN2MtMC40NDEwNywwLjAyMTAxIC0wLjg2MTExLDAuMDk0NTEgLTEuMjYwMTcsMC4yMjA1M2MtMC4zOTkwNiwwLjEyNjAyIC0wLjc4NzYsMC4yNzMwNCAtMS4xNTUxNSwwLjQ3MjU3Yy0wLjM2NzU1LDAuMTk5NTIgLTAuNzAzNjEsMC40NDEwNyAtMS4wMjkxNCwwLjcxNDExYy0wLjMyNTU1LDAuMjczMDMgLTAuNjE5NTksMC41Nzc1NyAtMC44OTI2MiwwLjkyNDEybDEuMzk2NjksMC44NzE2MmMwLjEwNTAxLDAuMTA1MDEgMC4xNTc1MywwLjIyMDUzIDAuMTU3NTMsMC4zNTcwNnpNMjM2LjUzMDU2LDE4OC4yMjUyMmMtMC4xODkwMiwwIC0wLjM2NzU1LC0wLjAzMTUgLTAuNTM1NTcsLTAuMTA1MDFjLTAuMTY4MDIsLTAuMDczNTEgLTAuMzE1MDQsLTAuMTY4MDIgLTAuNDQxMDYsLTAuMjk0MDRjLTAuMTI2MDIsLTAuMTI2MDIgLTAuMjIwNTQsLTAuMjczMDMgLTAuMjk0MDUsLTAuNDQxMDdjLTAuMDczNTEsLTAuMTY4MDIgLTAuMTA1MDEsLTAuMzQ2NTYgLTAuMTA1MDEsLTAuNTM1NTdjMCwtMC4xNjgwMiAwLjAyMTAxLC0wLjMxNTA1IDAuMDczNTEsLTAuNDQxMDdjMC4wNTI1MSwtMC4xMjYwMiAwLjEyNjAyLC0wLjI2MjU1IDAuMjIwNTQsLTAuMzk5MDZsNC4xMTY1NiwtNS40OTIyNmMwLjA3MzUxLC0wLjExNTUyIDAuMTg5MDIsLTAuMTY4MDEgMC4zMTUwNCwtMC4xNjgwMWMwLjEwNTAxLDAgMC4xOTk1MiwwLjA0MjAxIDAuMjczMDMsMC4xMTU1MmMwLjA3MzUxLDAuMDczNTEgMC4xMTU1MiwwLjE2ODAzIDAuMTE1NTIsMC4yNzMwNGMwLDAuMDQyMDEgLTAuMDEwNSwwLjA5NDUxIC0wLjAzMTUxLDAuMTQ3MDJsLTIuMzgzODQsNi4zMjE4N2MtMC4wNTI1MSwwLjE1NzUyIC0wLjExNTUyLDAuMjk0MDQgLTAuMTg5MDMsMC4zOTkwNmMtMC4wNzM1MSwwLjEwNTAxIC0wLjE2ODAxLDAuMjIwNTQgLTAuMzA0NTQsMC4zMjU1NWMtMC4yNDE1NCwwLjE5OTUyIC0wLjUxNDU3LDAuMjk0MDQgLTAuODI5NiwwLjI5NDA0ek0yMzguNTM2MzEsMTgzLjE4NDU1bC0yLjQ2Nzg0LDMuMjg2OTVjLTAuMDg0MDEsMC4xMTU1MiAtMC4xMjYwMiwwLjI0MTUzIC0wLjEyNjAyLDAuMzY3NTVjMCwwLjE2ODAyIDAuMDUyNTEsMC4zMDQ1NCAwLjE2ODAyLDAuNDIwMDZjMC4xMTU1MiwwLjExNTUyIDAuMjUyMDQsMC4xNjgwMiAwLjQyMDA2LDAuMTY4MDJjMC4xNTc1MiwwIDAuMjgzNTQsLTAuMDQyMDEgMC4zNjc1NSwtMC4xMzY1MmMwLjA4NDAxLC0wLjA5NDUxIDAuMTU3NTMsLTAuMTk5NTMgMC4yMTAwMywtMC4zMzYwNHpNMjQzLjAyMDQxLDE4My44OTg2M2MwLDAuMTE1NTIgLTAuMDQyMDEsMC4xOTk1MiAtMC4xMTU1MiwwLjI3MzAzYy0wLjA3MzUxLDAuMDczNTEgLTAuMTc4NTIsMC4xMTU1MiAtMC4yODM1NCwwLjExNTUyYy0wLjA4NDAxLDAgLTAuMTU3NTMsLTAuMDIxMDEgLTAuMjIwNTQsLTAuMDYzMDJjLTAuMDYzMDIsLTAuMDQyMDEgLTAuMTA1MDIsLTAuMTA1MDEgLTAuMTM2NTMsLTAuMTc4NTJjLTAuMDUyNTEsLTAuMTI2MDIgLTAuMTA1MDEsLTAuMjQxNTQgLTAuMTY4MDEsLTAuMzU3MDZjLTAuMDYzMDIsLTAuMTE1NTIgLTAuMTI2MDIsLTAuMjMxMDIgLTAuMTk5NTMsLTAuMzQ2NTVsLTEuNDI4MjEsMC44OTI2MmMtMC4wNzM1MSwwLjA0MjAxIC0wLjEzNjUzLDAuMDYzMDIgLTAuMjEwMDQsMC4wNjMwMmMtMC4xMDUwMSwwIC0wLjE5OTUzLC0wLjA0MjAxIC0wLjI3MzAzLC0wLjExNTUyYy0wLjA3MzUxLC0wLjA3MzUxIC0wLjExNTUxLC0wLjE2ODAzIC0wLjExNTUxLC0wLjI3MzAzYzAsLTAuMTQ3MDMgMC4wNjMwMiwtMC4yNTIwNCAwLjE4OTAzLC0wLjMzNjA0bDEuMzk2NywtMC44NzE2MmMtMC4wOTQ1MSwtMC4xMTU1MiAtMC4xODkwMywtMC4yMjA1MyAtMC4yOTQwNCwtMC4zMzYwNGMtMC4xMDUwMSwtMC4xMTU1MiAtMC4xOTk1NCwtMC4yMTAwNCAtMC4zMDQ1NSwtMC4zMTUwNWwwLjI5NDA1LC0wLjc4NzZsMC4wMTA1LC0wLjAxMDVjMC4xNzg1MywwLjE1NzUyIDAuMzU3MDYsMC4zMzYwNCAwLjUzNTU3LDAuNTI1MDZjMC4xNzg1MywwLjE4OTAyIDAuMzU3MDUsMC4zOTkwNiAwLjUyNTA2LDAuNjE5NTljMC4xNjgwMiwwLjIyMDU0IDAuMzE1MDQsMC40NDEwNyAwLjQ1MTU3LDAuNjcyMWMwLjEzNjUzLDAuMjMxMDIgMC4yNDE1NCwwLjQ2MjA1IDAuMzI1NTUsMC42ODI1OWMwLjAxMDUsMC4wNDIwMSAwLjAyMSwwLjA5NDUxIDAuMDIxLDAuMTQ3MDJ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuMjUiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">高性能缩放</label><label class="custom-switch-container"><input type="checkbox" id="performance-mode-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">以图片缓存显示坐标系，缩放更流畅</p></div>
                <div class="settings-item"><div class="settings-item-row"><label for="high-performance-plotting-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC40MzczMSIgaGVpZ2h0PSIyMC4zMTkzMiIgdmlld0JveD0iMCwwLDIwLjQzNzMxLDIwLjMxOTMyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5Ljk3NTg4LC0xNjkuODAxNjgpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIHN0cm9rZT0iIzAwMDAwMCI+PHBhdGggZD0iTTIzMC45NzU4NSwxNzguNTg0MTlsMC4wMjMwMywtMy4xMzEyN2MwLjAwMDMyLC0wLjAzMTgxIDAuMDAxMDUsLTAuMDYzNzcgMC4wMDIxLC0wLjA5NTVjMC4wODE1MywtMi41OTc3MyAyLjIxODE2LC00LjYzNjE5IDQuNzcyMTMsLTQuNTUzMjljMC4wMjAyNiwwLjAwMDczIDAuMDQwNDQsMC4wMDEzNyAwLjA2MDcxLDAuMDAyMzRsOC44NDEzMSwtMC4wMDM0N2MwLjAzMTI0LC0wLjAwMDQ4IDAuMDYyNjQsLTAuMDAwNzMgMC4wOTM5NiwtMC4wMDA0OGMyLjU1NTM1LDAuMDExMTQgNC42MTgwMywyLjEyNjk0IDQuNjA3MTMsNC43MjU5NmMtMC4wMDAwOCwwLjAyMDUgLTAuMDAwMzIsMC4wNDExNyAtMC4wMDA3MywwLjA2MTY3bDAuMDM3Nyw4LjgyMzc5YzAsMC4wMzE4MSAtMC4wMDAzMiwwLjA2Mzc3IC0wLjAwMDg5LDAuMDk1NThjLTAuMDUxMzQsMi41OTg0NSAtMi4xNjQwNyw0LjY2MjU5IC00LjcxODc3LDQuNjEwNTJjLTAuMDIwMjYsLTAuMDAwNCAtMC4wNDA0NCwtMC4wMDA4OSAtMC4wNjA3MSwtMC4wMDE3bC0yLjMwNDEsMC4wMDAzNyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTIzMy43MjY3NywxODQuODYxMjNjMCwwLjEwNTAxIC0wLjA0MjAxLDAuMTk5NTIgLTAuMTE1NTIsMC4yNzMwM2MtMC4wNzM1MSwwLjA3MzUxIC0wLjE2ODAyLDAuMTE1NTIgLTAuMjczMDMsMC4xMTU1MmMtMC4wNzM1MSwwIC0wLjEzNjUyLC0wLjAyMTAxIC0wLjIxMDAzLC0wLjA2MzAybC0xLjQyODIsLTAuODkyNjJjLTAuMDczNTEsMC4xMTU1MiAtMC4xMzY1MywwLjIzMTAzIC0wLjE4OTAzLDAuMzQ2NTZjLTAuMDUyNTEsMC4xMTU1MiAtMC4xMTU1MiwwLjIzMTAyIC0wLjE2ODAyLDAuMzU3MDZjLTAuMDMxNTEsMC4wNzM1MSAtMC4wODQwMSwwLjEzNjUzIC0wLjEzNjUzLDAuMTc4NTNjLTAuMDUyNTEsMC4wNDIwMSAtMC4xMzY1MiwwLjA2MzAyIC0wLjIyMDU0LDAuMDYzMDJjLTAuMTA1MDEsMCAtMC4xOTk1MiwtMC4wNDIwMSAtMC4yODM1NCwtMC4xMTU1MmMtMC4wODQwMSwtMC4wNzM1MSAtMC4xMTU1MiwtMC4xNjgwMyAtMC4xMTU1MiwtMC4yNzMwM2MwLC0wLjA3MzUxIDAuMDIxMDEsLTAuMTU3NTMgMC4wNjMwMiwtMC4yNzMwM2MwLjA0MjAxLC0wLjExNTUyIDAuMTA1MDEsLTAuMjMxMDIgMC4xNzg1MiwtMC4zNTcwNmMwLjA3MzUxLC0wLjEyNjAyIDAuMTQ3MDIsLTAuMjYyNTQgMC4yNDE1NCwtMC4zODg1NWMwLjA5NDUxLC0wLjEyNjAyIDAuMTc4NTMsLTAuMjYyNTQgMC4yNjI1NSwtMC4zODg1NWMwLjA4NDAxLC0wLjEyNjAyIDAuMTY4MDIsLTAuMjMxMDMgMC4yNDE1NCwtMC4zMzYwNGMwLjA3MzUxLC0wLjEwNTAxIDAuMTM2NTMsLTAuMTc4NTMgMC4xODkwMiwtMC4yMzEwMmMwLjI5NDA0LC0wLjM0NjU1IDAuNjE5NTksLTAuNjYxNTggMC45NzY2MywtMC45MzQ2MmMwLjM1NzA2LC0wLjI3MzAzIDAuNzM1MDksLTAuNTE0NTcgMS4xNDQ2NywtMC43MzUwOWMwLjQ3MjU2LC0wLjI0MTU0IDAuOTU1NjMsLTAuNDIwMDYgMS40NTk3LC0wLjUzNTU3YzAuNTA0MDcsLTAuMTE1NTIgMS4wMTg2MywtMC4xNjgwMiAxLjU0MzcyLC0wLjE2ODAyYzAuMzU3MDYsMCAwLjcwMzYxLDAuMDIxMDEgMS4wNTAxNiwwLjA3MzUxYzAuMzQ2NTUsMC4wNTI1MSAwLjY5MzEsMC4xMzY1MiAxLjAyOTEzLDAuMjQxNTRsLTAuNTA0MDcsMC42NzIwOWMtMC4xODkwMiwtMC4wNTI1MSAtMC4zODg1NSwtMC4wOTQ1MSAtMC41ODgwOCwtMC4xMjYwMmMtMC4xOTk1MiwtMC4wMzE1MSAtMC4zOTkwNiwtMC4wNTI1MSAtMC41ODgwOCwtMC4wNjMwMnYxLjk1MzI3YzAsMC4xMDUwMSAtMC4wNDIwMSwwLjE5OTUyIC0wLjExNTUyLDAuMjczMDNjLTAuMDczNTEsMC4wNzM1MSAtMC4xNjgwMiwwLjExNTUyIC0wLjI3MzAzLDAuMTE1NTJjLTAuMTA1MDEsMCAtMC4xOTk1MywtMC4wNDIwMSAtMC4yNzMwMywtMC4xMTU1MmMtMC4wNzM1MSwtMC4wNzM1MSAtMC4xMTU1MiwtMC4xNjgwMiAtMC4xMTU1MiwtMC4yNzMwM3YtMS45NTMyN2MtMC40NDEwNywwLjAyMTAxIC0wLjg2MTExLDAuMDk0NTEgLTEuMjYwMTcsMC4yMjA1M2MtMC4zOTkwNiwwLjEyNjAyIC0wLjc4NzYsMC4yNzMwNCAtMS4xNTUxNSwwLjQ3MjU3Yy0wLjM2NzU1LDAuMTk5NTIgLTAuNzAzNjEsMC40NDEwNyAtMS4wMjkxNCwwLjcxNDExYy0wLjMyNTU1LDAuMjczMDMgLTAuNjE5NTksMC41Nzc1NyAtMC44OTI2MiwwLjkyNDEybDEuMzk2NjksMC44NzE2MmMwLjEwNTAxLDAuMTA1MDEgMC4xNTc1MywwLjIyMDUzIDAuMTU3NTMsMC4zNTcwNnpNMjM2LjY4ODIsMTg5LjE5ODMxYy0wLjE4OTAyLDAgLTAuMzY3NTUsLTAuMDMxNSAtMC41MzU1NywtMC4xMDUwMWMtMC4xNjgwMiwtMC4wNzM1MSAtMC4zMTUwNCwtMC4xNjgwMiAtMC40NDEwNiwtMC4yOTQwNGMtMC4xMjYwMiwtMC4xMjYwMiAtMC4yMjA1NCwtMC4yNzMwMyAtMC4yOTQwNSwtMC40NDEwN2MtMC4wNzM1MSwtMC4xNjgwMiAtMC4xMDUwMSwtMC4zNDY1NiAtMC4xMDUwMSwtMC41MzU1N2MwLC0wLjE2ODAyIDAuMDIxMDEsLTAuMzE1MDUgMC4wNzM1MSwtMC40NDEwN2MwLjA1MjUxLC0wLjEyNjAyIDAuMTI2MDIsLTAuMjYyNTUgMC4yMjA1NCwtMC4zOTkwNmw0LjExNjU2LC01LjQ5MjI2YzAuMDczNTEsLTAuMTE1NTIgMC4xODkwMiwtMC4xNjgwMSAwLjMxNTA0LC0wLjE2ODAxYzAuMTA1MDEsMCAwLjE5OTUyLDAuMDQyMDEgMC4yNzMwMywwLjExNTUyYzAuMDczNTEsMC4wNzM1MSAwLjExNTUyLDAuMTY4MDMgMC4xMTU1MiwwLjI3MzA0YzAsMC4wNDIwMSAtMC4wMTA1LDAuMDk0NTEgLTAuMDMxNTEsMC4xNDcwMmwtMi4zODM4NCw2LjMyMTg3Yy0wLjA1MjUxLDAuMTU3NTIgLTAuMTE1NTIsMC4yOTQwNCAtMC4xODkwMywwLjM5OTA2Yy0wLjA3MzUxLDAuMTA1MDEgLTAuMTY4MDEsMC4yMjA1NCAtMC4zMDQ1NCwwLjMyNTU1Yy0wLjI0MTU0LDAuMTk5NTIgLTAuNTE0NTcsMC4yOTQwNCAtMC44Mjk2LDAuMjk0MDR6TTIzOC42OTM5NSwxODQuMTU3NjRsLTIuNDY3ODQsMy4yODY5NWMtMC4wODQwMSwwLjExNTUyIC0wLjEyNjAyLDAuMjQxNTMgLTAuMTI2MDIsMC4zNjc1NWMwLDAuMTY4MDIgMC4wNTI1MSwwLjMwNDU0IDAuMTY4MDIsMC40MjAwNmMwLjExNTUyLDAuMTE1NTIgMC4yNTIwNCwwLjE2ODAyIDAuNDIwMDYsMC4xNjgwMmMwLjE1NzUyLDAgMC4yODM1NCwtMC4wNDIwMSAwLjM2NzU1LC0wLjEzNjUyYzAuMDg0MDEsLTAuMDk0NTEgMC4xNTc1MywtMC4xOTk1MyAwLjIxMDAzLC0wLjMzNjA0ek0yNDMuMTc4MDUsMTg0Ljg3MTcyYzAsMC4xMTU1MiAtMC4wNDIwMSwwLjE5OTUyIC0wLjExNTUyLDAuMjczMDNjLTAuMDczNTEsMC4wNzM1MSAtMC4xNzg1MiwwLjExNTUyIC0wLjI4MzU0LDAuMTE1NTJjLTAuMDg0MDEsMCAtMC4xNTc1MywtMC4wMjEwMSAtMC4yMjA1NCwtMC4wNjMwMmMtMC4wNjMwMiwtMC4wNDIwMSAtMC4xMDUwMiwtMC4xMDUwMSAtMC4xMzY1MywtMC4xNzg1MmMtMC4wNTI1MSwtMC4xMjYwMiAtMC4xMDUwMSwtMC4yNDE1NCAtMC4xNjgwMSwtMC4zNTcwNmMtMC4wNjMwMiwtMC4xMTU1MiAtMC4xMjYwMiwtMC4yMzEwMiAtMC4xOTk1MywtMC4zNDY1NWwtMS40MjgyMSwwLjg5MjYyYy0wLjA3MzUxLDAuMDQyMDEgLTAuMTM2NTMsMC4wNjMwMiAtMC4yMTAwNCwwLjA2MzAyYy0wLjEwNTAxLDAgLTAuMTk5NTMsLTAuMDQyMDEgLTAuMjczMDMsLTAuMTE1NTJjLTAuMDczNTEsLTAuMDczNTEgLTAuMTE1NTEsLTAuMTY4MDMgLTAuMTE1NTEsLTAuMjczMDNjMCwtMC4xNDcwMyAwLjA2MzAyLC0wLjI1MjA0IDAuMTg5MDMsLTAuMzM2MDRsMS4zOTY3LC0wLjg3MTYyYy0wLjA5NDUxLC0wLjExNTUyIC0wLjE4OTAzLC0wLjIyMDUzIC0wLjI5NDA0LC0wLjMzNjA0Yy0wLjEwNTAxLC0wLjExNTUyIC0wLjE5OTU0LC0wLjIxMDA0IC0wLjMwNDU1LC0wLjMxNTA1bDAuMjk0MDUsLTAuNzg3NmwwLjAxMDUsLTAuMDEwNWMwLjE3ODUzLDAuMTU3NTIgMC4zNTcwNiwwLjMzNjA0IDAuNTM1NTcsMC41MjUwNmMwLjE3ODUzLDAuMTg5MDIgMC4zNTcwNSwwLjM5OTA2IDAuNTI1MDYsMC42MTk1OWMwLjE2ODAyLDAuMjIwNTQgMC4zMTUwNCwwLjQ0MTA3IDAuNDUxNTcsMC42NzIxYzAuMTM2NTMsMC4yMzEwMiAwLjI0MTU0LDAuNDYyMDUgMC4zMjU1NSwwLjY4MjU5YzAuMDEwNSwwLjA0MjAxIDAuMDIxLDAuMDk0NTEgMC4wMjEsMC4xNDcwMnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC4yNSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxMC4wMjQxMjI5NTQyMzc2Njk6MTAuMTk4MzE1NzQ5NDk1MjM3LS0+" class="settings-item-icon" alt="">高性能绘图</label><label class="custom-switch-container"><input type="checkbox" id="high-performance-plotting-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">对于线条密集的图像，通过绘制细线条，提升绘图性能和清晰度</p></div>
                <div class="settings-item"><div class="settings-item-row"><label for="low-precision-buffer-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43OTY1NyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc5NjU3LDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCI+PHBhdGggZD0iTTIzNi42NjYwNCwxNzcuMjExMTZjMCwwLjE0MzA0IC0wLjA1NzIzLDAuMjcxNzkgLTAuMTU3MzYsMC4zNzE5MmMtMC4xMDAxMywwLjEwMDEzIC0wLjIyODg3LDAuMTU3MzYgLTAuMzcxOTIsMC4xNTczNmMtMC4xMDAxMywwIC0wLjE4NTk3LC0wLjAyODYyIC0wLjI4NjA5LC0wLjA4NTg1bC0xLjk0NTQ1LC0xLjIxNTljLTAuMTAwMTMsMC4xNTczNiAtMC4xODU5NywwLjMxNDcgLTAuMjU3NDgsMC40NzIwN2MtMC4wNzE1MywwLjE1NzM2IC0wLjE1NzM2LDAuMzE0NjkgLTAuMjI4ODcsMC40ODYzN2MtMC4wNDI5MiwwLjEwMDEzIC0wLjExNDQzLDAuMTg1OTcgLTAuMTg1OTcsMC4yNDMxOGMtMC4wNzE1MywwLjA1NzIzIC0wLjE4NTk3LDAuMDg1ODQgLTAuMzAwNDEsMC4wODU4NGMtMC4xNDMwNCwwIC0wLjI3MTc5LC0wLjA1NzIzIC0wLjM4NjIyLC0wLjE1NzM2Yy0wLjExNDQzLC0wLjEwMDEzIC0wLjE1NzM2LC0wLjIyODg3IC0wLjE1NzM2LC0wLjM3MTkyYzAsLTAuMTAwMTMgMC4wMjg2MSwtMC4yMTQ1OSAwLjA4NTg0LC0wLjM3MTkyYzAuMDU3MjMsLTAuMTU3MzYgMC4xNDMwNSwtMC4zMTQ2OSAwLjI0MzE4LC0wLjQ4NjM3YzAuMTAwMTMsLTAuMTcxNjYgMC4yMDAyNywtMC4zNTc2MyAwLjMyOTAyLC0wLjUyOTI3YzAuMTI4NzQsLTAuMTcxNjYgMC4yNDMxOCwtMC4zNTc2MyAwLjM1NzY0LC0wLjUyOTI3YzAuMTE0NDMsLTAuMTcxNjYgMC4yMjg4NiwtMC4zMTQ3IDAuMzI5MDIsLTAuNDU3NzRjMC4xMDAxMywtMC4xNDMwNCAwLjE4NTk4LC0wLjI0MzE4IDAuMjU3NDgsLTAuMzE0NjljMC40MDA1MywtMC40NzIwNiAwLjg0Mzk4LC0wLjkwMTE5IDEuMzMwMzMsLTEuMjczMTFjMC40ODYzNywtMC4zNzE5MiAxLjAwMTMxLC0wLjcwMDkzIDEuNTU5MjIsLTEuMDAxMzFjMC42NDM3LC0wLjMyOTAyIDEuMzAxNzMsLTAuNTcyMiAxLjk4ODM2LC0wLjcyOTUzYzAuNjg2NjMsLTAuMTU3MzYgMS4zODc1NCwtMC4yMjg4NyAyLjEwMjgxLC0wLjIyODg3YzAuNDg2MzcsMCAwLjk1ODQyLDAuMDI4NjIgMS40MzA0OCwwLjEwMDEzYzAuNDcyMDYsMC4wNzE1MyAwLjk0NDEyLDAuMTg1OTcgMS40MDE4NiwwLjMyOTAybC0wLjY4NjYzLDAuOTE1NWMtMC4yNTc0OCwtMC4wNzE1MyAtMC41MjkyOCwtMC4xMjg3NSAtMC44MDEwNywtMC4xNzE2NmMtMC4yNzE3OSwtMC4wNDI5MiAtMC41NDM1OSwtMC4wNzE1MyAtMC44MDEwNiwtMC4wODU4NHYyLjY2MDY3YzAsMC4xNDMwNCAtMC4wNTcyMywwLjI3MTc5IC0wLjE1NzM2LDAuMzcxOTJjLTAuMTAwMTMsMC4xMDAxMyAtMC4yMjg4NywwLjE1NzM2IC0wLjM3MTkyLDAuMTU3MzZjLTAuMTQzMDQsMCAtMC4yNzE3OSwtMC4wNTcyMyAtMC4zNzE5MiwtMC4xNTczNmMtMC4xMDAxMywtMC4xMDAxMyAtMC4xNTczNiwtMC4yMjg4NyAtMC4xNTczNiwtMC4zNzE5MnYtMi42NjA2N2MtMC42MDA4MSwwLjAyODYyIC0xLjE3Mjk4LDAuMTI4NzQgLTEuNzE2NTYsMC4zMDA0Yy0wLjU0MzU5LDAuMTcxNjYgLTEuMDcyODYsMC4zNzE5MiAtMS41NzM1MiwwLjY0MzcxYy0wLjUwMDY2LDAuMjcxNzkgLTAuOTU4NDIsMC42MDA4MSAtMS40MDE4NiwwLjk3MjczYy0wLjQ0MzQ1LDAuMzcxOTIgLTAuODQzOTgsMC43ODY3NSAtMS4yMTU5LDEuMjU4ODFsMS45MDI1MywxLjE4NzI5YzAuMTQzMDQsMC4xNDMwNCAwLjIxNDU5LDAuMzAwNCAwLjIxNDU5LDAuNDg2Mzd6TTI0MC42OTk5OSwxODMuMTE4OTdjLTAuMjU3NDgsMCAtMC41MDA2NiwtMC4wNDI5MiAtMC43Mjk1MywtMC4xNDMwNGMtMC4yMjg4NywtMC4xMDAxMyAtMC40MjkxNCwtMC4yMjg4NyAtMC42MDA4MSwtMC40MDA1M2MtMC4xNzE2NiwtMC4xNzE2NiAtMC4zMDA0MSwtMC4zNzE5MiAtMC40MDA1MywtMC42MDA4MWMtMC4xMDAxMywtMC4yMjg4NyAtMC4xNDMwNCwtMC40NzIwNyAtMC4xNDMwNCwtMC43Mjk1M2MwLC0wLjIyODg3IDAuMDI4NjEsLTAuNDI5MTQgMC4xMDAxMywtMC42MDA4MWMwLjA3MTUzLC0wLjE3MTY2IDAuMTcxNjYsLTAuMzU3NjQgMC4zMDA0MSwtMC41NDM1OWw1LjYwNzQ1LC03LjQ4MTM3YzAuMTAwMTMsLTAuMTU3MzYgMC4yNTc0OCwtMC4yMjg4NiAwLjQyOTE0LC0wLjIyODg2YzAuMTQzMDQsMCAwLjI3MTc5LDAuMDU3MjMgMC4zNzE5MiwwLjE1NzM2YzAuMTAwMTMsMC4xMDAxMyAwLjE1NzM2LDAuMjI4ODcgMC4xNTczNiwwLjM3MTkyYzAsMC4wNTcyMyAtMC4wMTQzMSwwLjEyODc0IC0wLjA0MjkyLDAuMjAwMjdsLTMuMjQ3MTgsOC42MTE0NGMtMC4wNzE1MywwLjIxNDU4IC0wLjE1NzM2LDAuNDAwNTMgLTAuMjU3NDgsMC41NDM1OWMtMC4xMDAxMywwLjE0MzA0IC0wLjIyODg3LDAuMzAwNDEgLTAuNDE0ODQsMC40NDM0NWMtMC4zMjkwMiwwLjI3MTc5IC0wLjcwMDkzLDAuNDAwNTMgLTEuMTMwMDYsMC40MDA1M3pNMjQzLjQzMjE2LDE3Ni4yNTI3NWwtMy4zNjE2LDQuNDc3MzdjLTAuMTE0NDMsMC4xNTczNiAtMC4xNzE2NiwwLjMyOTAyIC0wLjE3MTY2LDAuNTAwNjZjMCwwLjIyODg3IDAuMDcxNTMsMC40MTQ4NCAwLjIyODg3LDAuNTcyMmMwLjE1NzM2LDAuMTU3MzYgMC4zNDMzMiwwLjIyODg3IDAuNTcyMiwwLjIyODg3YzAuMjE0NTgsMCAwLjM4NjIyLC0wLjA1NzIzIDAuNTAwNjYsLTAuMTg1OTdjMC4xMTQ0MywtMC4xMjg3NCAwLjIxNDU5LC0wLjI3MTc5IDAuMjg2MSwtMC40NTc3NHpNMjQ5LjU0MDI0LDE3Ny4yMjU0NGMwLDAuMTU3MzYgLTAuMDU3MjIsMC4yNzE3OSAtMC4xNTczNSwwLjM3MTkyYy0wLjEwMDEzLDAuMTAwMTMgLTAuMjQzMTgsMC4xNTczNiAtMC4zODYyMywwLjE1NzM2Yy0wLjExNDQzLDAgLTAuMjE0NTksLTAuMDI4NjIgLTAuMzAwNDEsLTAuMDg1ODVjLTAuMDg1ODQsLTAuMDU3MjMgLTAuMTQzMDQsLTAuMTQzMDQgLTAuMTg1OTcsLTAuMjQzMThjLTAuMDcxNTMsLTAuMTcxNjYgLTAuMTQzMDQsLTAuMzI5MDIgLTAuMjI4ODYsLTAuNDg2MzdjLTAuMDg1ODQsLTAuMTU3MzYgLTAuMTcxNjYsLTAuMzE0NyAtMC4yNzE4LC0wLjQ3MjA3bC0xLjk0NTQ1LDEuMjE1OWMtMC4xMDAxMywwLjA1NzIzIC0wLjE4NTk3LDAuMDg1ODQgLTAuMjg2MSwwLjA4NTg0Yy0wLjE0MzA0LDAgLTAuMjcxNzksLTAuMDU3MjMgLTAuMzcxOTIsLTAuMTU3MzZjLTAuMTAwMTMsLTAuMTAwMTMgLTAuMTU3MzUsLTAuMjI4ODcgLTAuMTU3MzUsLTAuMzcxOTJjMCwtMC4yMDAyNyAwLjA4NTg0LC0wLjM0MzMyIDAuMjU3NDgsLTAuNDU3NzRsMS45MDI1NCwtMS4xODcyOWMtMC4xMjg3NCwtMC4xNTczNiAtMC4yNTc0OSwtMC4zMDA0MSAtMC40MDA1MywtMC40NTc3NWMtMC4xNDMwNCwtMC4xNTczNiAtMC4yNzE4LC0wLjI4NjEgLTAuNDE0ODQsLTAuNDI5MTRsMC40MDA1MywtMS4wNzI4NWwwLjAxNDMxLC0wLjAxNDMxYzAuMjQzMTgsMC4yMTQ1OCAwLjQ4NjM3LDAuNDU3NzQgMC43Mjk1MywwLjcxNTIyYzAuMjQzMTgsMC4yNTc0OCAwLjQ4NjM2LDAuNTQzNTkgMC43MTUyMiwwLjg0Mzk4YzAuMjI4ODcsMC4zMDA0MSAwLjQyOTE0LDAuNjAwODEgMC42MTUxMSwwLjkxNTVjMC4xODU5NywwLjMxNDY5IDAuMzI5MDIsMC42Mjk0IDAuNDQzNDYsMC45Mjk4MWMwLjAxNDMxLDAuMDU3MjMgMC4wMjg2MSwwLjEyODc0IDAuMDI4NjEsMC4yMDAyN3oiIHN0cm9rZS13aWR0aD0iMC43NSIvPjxwYXRoIGQ9Ik0yMzAuNDU5NzgsMTgzLjE3MjU5YzAsLTAuMTMxNDMgMC4wNDEwNywtMC4yNTQ2NCAwLjExNSwtMC4zNjk2M2MwLjA3MzkzLC0wLjExNSAwLjE4MDcxLC0wLjE4ODkzIDAuMzEyMTMsLTAuMjI5OTlsMC44NTQyNSwtMC4yNzkyOGMwLjA5ODU2LC0wLjAzMjg1IDAuMTk3MTQsLTAuMDgyMTQgMC4yOTU3LC0wLjE0Nzg1YzAuMDk4NTYsLTAuMDY1NzEgMC4xNzI1LC0wLjEzMTQzIDAuMjQ2NDIsLTAuMjA1MzRjMC4xNjQyOCwtMC4xNjQyOCAwLjI3MTA3LC0wLjM0NDk4IDAuMzQ0OTksLTAuNTUwMzNsMC4yNzkyNywtMC44NjI0N2MwLjA0MTA3LC0wLjEzMTQyIDAuMTIzMjEsLTAuMjI5OTkgMC4yMjk5OSwtMC4zMTIxM2MwLjEwNjc4LC0wLjA4MjE0IDAuMjM4MiwtMC4xMjMyMSAwLjM2OTYzLC0wLjEyMzIxYzAuMTMxNDMsMCAwLjI2Mjg0LDAuMDQxMDcgMC4zNjk2MywwLjExNWMwLjEwNjc4LDAuMDczOTIgMC4xOTcxNCwwLjE4MDcxIDAuMjM4MiwwLjMxMjEzbDAuMjc5MjgsMC44NTQyNWMwLjA2NTcxLDAuMjEzNTYgMC4xODA3LDAuNDAyNDggMC4zNDQ5OSwwLjU2Njc2YzAuMTU2MDYsMC4xNjQyOCAwLjM0NDk5LDAuMjc5MjggMC41NjY3NywwLjM0NDk5bDAuODQ2MDMsMC4yNzkyOGMwLjEzOTY0LDAuMDQxMDcgMC4yNDY0MiwwLjEyMzIxIDAuMzI4NTUsMC4yMjk5OWMwLjA4MjE0LDAuMTA2NzggMC4xMjMyMSwwLjIzODIgMC4xMjMyMSwwLjM4NjA2YzAsMC4xMzE0MyAtMC4wNDEwNywwLjI1NDY0IC0wLjEyMzIxLDAuMzY5NjNjLTAuMDgyMTQsMC4xMTUgLTAuMTgwNywwLjE4ODkzIC0wLjMxMjEzLDAuMjI5OTlsLTAuODU0MjUsMC4yNzkyOGMtMC4yMTM1NiwwLjA2NTcxIC0wLjQwMjQ5LDAuMTgwNyAtMC41NjY3NywwLjM0NDk5Yy0wLjA5ODU2LDAuMDk4NTYgLTAuMTg4OTMsMC4yMjE3NyAtMC4yNDY0MiwwLjM1MzJjLTAuMDU3NSwwLjEzMTQzIC0wLjExNSwwLjI2Mjg0IC0wLjE1NjA2LDAuNDAyNDljLTAuMDQxMDcsMC4xMzk2NCAtMC4wODIxNCwwLjI3MTA2IC0wLjEyMzIxLDAuNDAyNDljLTAuMDQxMDcsMC4xMzE0MiAtMC4wOTAzNSwwLjI0NjQyIC0wLjE0Nzg1LDAuMzQ0OTljLTAuMDU3NSwwLjA5ODU2IC0wLjEzMTQzLDAuMTg4OTMgLTAuMjEzNTYsMC4yNDY0M2MtMC4wODIxNCwwLjA1NzUgLTAuMTk3MTQsMC4wOTAzNSAtMC4zNDQ5OSwwLjA5MDM1Yy0wLjEzMTQzLDAgLTAuMjYyODQsLTAuMDQxMDcgLTAuMzY5NjMsLTAuMTE1Yy0wLjEwNjc4LC0wLjA3MzkyIC0wLjE4ODkzLC0wLjE4MDcgLTAuMjI5OTksLTAuMzEyMTNsLTAuMjc5MjgsLTAuODU0MjVjLTAuMDI0NjUsLTAuMDgyMTQgLTAuMDU3NSwtMC4xNTYwNiAtMC4wOTAzNSwtMC4yMjk5OWMtMC4wMzI4NSwtMC4wNzM5MyAtMC4wODIxNCwtMC4xMzk2NCAtMC4xMzE0MywtMC4yMDUzNGMtMC4xMDY3OCwtMC4xMzk2NCAtMC4yMjk5OSwtMC4yNDY0MyAtMC4zNjk2MywtMC4zMjg1NmMtMC4xMzk2NCwtMC4wODIxNCAtMC4yNzkyOCwtMC4xNDc4NSAtMC40MjcxMywtMC4xOTcxNGMtMC4xNDc4NSwtMC4wNDkyOCAtMC4yODc0OSwtMC4wOTg1NiAtMC40MjcxMywtMC4xMzE0MmMtMC4xMzk2NCwtMC4wMzI4NiAtMC4yNjI4NCwtMC4wODIxNCAtMC4zNzc4NCwtMC4xMzk2NGMtMC4xMTUsLTAuMDU3NSAtMC4xOTcxNCwtMC4xMzE0MyAtMC4yNjI4NCwtMC4yMTM1NmMtMC4wNjU3MSwtMC4wODIxNCAtMC4wOTAzNSwtMC4xOTcxNCAtMC4wOTAzNSwtMC4zNDQ5OHpNMjM1Ljk4Nzc3LDE4My4yMDU0NmMtMC4yNDY0MywtMC4wOTAzNSAtMC40NzY0MiwtMC4xODA3MSAtMC42OTgxOSwtMC4yNTQ2NGMtMC4yMjE3OCwtMC4wNzM5MiAtMC40MjcxMywtMC4xNzI0OSAtMC42MTYwNCwtMC4yODc0OWMtMC4xODg5MiwtMC4xMTUgLTAuMzUzMjEsLTAuMjU0NjQgLTAuNTAxMDUsLTAuNDI3MTNjLTAuMTQ3ODUsLTAuMTcyNDkgLTAuMjYyODQsLTAuMzg2MDYgLTAuMzQ0OTksLTAuNjY1MzNsLTAuMjcxMDYsLTAuODQ2MDNsLTAuMzIwMzQsMC44NDYwM2MtMC4wNTc1LDAuMTU2MDYgLTAuMTIzMjEsMC4yOTU3MSAtMC4yMDUzNCwwLjQyNzEzYy0wLjA4MjE0LDAuMTMxNDIgLTAuMTcyNSwwLjI1NDY0IC0wLjI4NzQ5LDAuMzc3ODRjLTAuMTA2NzgsMC4xMDY3OCAtMC4yMjk5OSwwLjIwNTM0IC0wLjM2OTYzLDAuMjk1N2MtMC4xMzk2NCwwLjA5MDM1IC0wLjI3OTI3LDAuMTU2MDYgLTAuNDI3MTMsMC4yMDUzNGwtMC44NTQyNSwwLjI3MTA2YzAuMjM4MiwwLjA5MDM1IDAuNDY4MiwwLjE4MDcxIDAuNjg5OTcsMC4yNTQ2NGMwLjIyMTc3LDAuMDczOTMgMC40MjcxMywwLjE3MjUgMC42MDc4MywwLjI4NzQ5YzAuMTgwNzEsMC4xMTUgMC4zNTMyMSwwLjI1NDY0IDAuNTAxMDUsMC40MjcxM2MwLjE0Nzg1LDAuMTcyNSAwLjI2Mjg0LDAuMzg2MDYgMC4zNDQ5OSwwLjY1NzEybDAuMjcxMDYsMC44NDYwNGwwLjMyMDM0LC0wLjg0NjA0YzAuMTE1LC0wLjMxMjEzIDAuMjg3NDksLTAuNTgzMTkgMC41MDEwNCwtMC44MDQ5N2MwLjIxMzU2LC0wLjIyMTc3IDAuNDg0NjMsLTAuMzk0MjYgMC44MDQ5NywtMC40OTI4M3pNMjM1LjM4ODE4LDE4Ni44NTI0NWMwLC0wLjA5ODU2IDAuMDMyODUsLTAuMTg4OTMgMC4wOTg1NiwtMC4yNzEwNmMwLjA2NTcxLC0wLjA4MjE0IDAuMTM5NjQsLTAuMTM5NjQgMC4yMzgyMSwtMC4xNzI1bDAuNDc2NDIsLTAuMTU2MDZjMC4xMDY3OCwtMC4wMzI4NSAwLjE5NzE0LC0wLjA5MDM1IDAuMjU0NjQsLTAuMTY0MjhjMC4wNTc1LC0wLjA3MzkyIDAuMTA2NzksLTAuMTU2MDYgMC4xNDc4NSwtMC4yNDY0MmMwLjA0MTA3LC0wLjA5MDM1IDAuMDY1NzEsLTAuMTg4OTMgMC4wOTAzNSwtMC4yNzkyOGMwLjAyNDY1LC0wLjA5MDM1IDAuMDU3NSwtMC4xODA3IDAuMDk4NTYsLTAuMjYyODRjMC4wNDEwNywtMC4wODIxNCAwLjA5MDM1LC0wLjEzOTY0IDAuMTU2MDYsLTAuMTk3MTRjMC4wNjU3MSwtMC4wNTc1IDAuMTU2MDYsLTAuMDczOTMgMC4yNzkyOCwtMC4wNzM5M2MwLjA5ODU2LDAgMC4xOTcxNCwwLjAzMjg2IDAuMjg3NDgsMC4wOTAzNWMwLjA5MDM1LDAuMDU3NSAwLjE0Nzg1LDAuMTM5NjQgMC4xODA3MSwwLjIzODJjMC4wMTY0MywwLjA2NTcxIDAuMDQxMDcsMC4xMzE0MyAwLjA1NzQ5LDAuMTk3MTRjMC4wMTY0MywwLjA2NTcxIDAuMDQxMDcsMC4xMzE0MiAwLjA1NzUsMC4xODg5M2MwLjAxNjQzLDAuMDU3NSAwLjA0OTI4LDAuMTIzMjEgMC4wODIxNCwwLjE4MDdjMC4wMzI4NiwwLjA1NzUgMC4wNzM5MiwwLjExNSAwLjEyMzIxLDAuMTY0MjhjMC4wNDkyOCwwLjA1NzUgMC4xMTUsMC4wOTg1NiAwLjE4ODkyLDAuMTMxNDNjMC4wNzM5MywwLjAzMjg2IDAuMTQ3ODUsMC4wNTc1IDAuMjI5OTksMC4wODIxNGMwLjA4MjE0LDAuMDI0NjUgMC4xNTYwNiwwLjA0OTI4IDAuMjM4MiwwLjA3MzkzYzAuMDgyMTQsMC4wMjQ2NCAwLjE0Nzg1LDAuMDU3NSAwLjIwNTM0LDAuMDk4NTZjMC4wNTc1LDAuMDQxMDcgMC4xMDY3OSwwLjA5MDM1IDAuMTQ3ODUsMC4xNTYwNmMwLjA0MTA3LDAuMDY1NzEgMC4wNTc1LDAuMTM5NjQgMC4wNTc1LDAuMjM4MmMwLDAuMTA2NzggLTAuMDMyODYsMC4yMDUzNCAtMC4wOTAzNSwwLjI4NzQ5Yy0wLjA1NzUsMC4wODIxNCAtMC4xMzk2NCwwLjE0Nzg1IC0wLjI0NjQyLDAuMTgwN2MtMC4wNTc1LDAuMDE2NDMgLTAuMTIzMjEsMC4wNDEwNyAtMC4xODg5MywwLjA1NzVjLTAuMDY1NzEsMC4wMTY0MyAtMC4xMzE0MiwwLjA0MTA3IC0wLjE5NzE0LDAuMDU3NWMtMC4wNjU3MSwwLjAxNjQzIC0wLjEzMTQzLDAuMDQ5MjggLTAuMTg4OTMsMC4wODIxNGMtMC4wNTc1LDAuMDMyODYgLTAuMTE0OTksMC4wNzM5MyAtMC4xNjQyOCwwLjEyMzIxYy0wLjA3MzkyLDAuMDgyMTQgLTAuMTMxNDMsMC4xODA3MSAtMC4xNzI1LDAuMzAzOTJjLTAuMDQxMDcsMC4xMjMyMSAtMC4wNzM5MywwLjIzODIxIC0wLjExNSwwLjM1MzIxYy0wLjA0MTA3LDAuMTE1IC0wLjA5ODU2LDAuMjEzNTYgLTAuMTY0MjcsMC4yODc0OGMtMC4wNjU3MSwwLjA3MzkzIC0wLjE4MDcxLDAuMTIzMjEgLTAuMzI4NTYsMC4xMjMyMWMtMC4wOTg1NiwwIC0wLjE5NzE0LC0wLjAzMjg2IC0wLjI4NzQ4LC0wLjA5MDM1Yy0wLjA5MDM1LC0wLjA1NzUgLTAuMTQ3ODUsLTAuMTM5NjQgLTAuMTgwNywtMC4yMzgyYy0wLjAxNjQzLC0wLjA1NzUgLTAuMDQxMDcsLTAuMTIzMjEgLTAuMDU3NSwtMC4xODg5M2MtMC4wMTY0MywtMC4wNjU3MSAtMC4wNDEwNywtMC4xMzE0MiAtMC4wNTc1LC0wLjE5NzE0Yy0wLjAxNjQzLC0wLjA2NTcxIC0wLjA0OTI4LC0wLjEzMTQzIC0wLjA4MjE0LC0wLjE4ODkzYy0wLjAzMjg1LC0wLjA1NzUgLTAuMDczOTMsLTAuMTE1IC0wLjExNSwtMC4xNTYwNmMtMC4wNTc1LC0wLjA1NzUgLTAuMTIzMjEsLTAuMDk4NTYgLTAuMTk3MTQsLTAuMTMxNDJjLTAuMDczOTIsLTAuMDMyODYgLTAuMTQ3ODUsLTAuMDU3NSAtMC4yMjk5OSwtMC4wODIxNGMtMC4wODIxNCwtMC4wMjQ2NCAtMC4xNTYwNiwtMC4wNDkyOCAtMC4yMjk5OSwtMC4wNzM5MmMtMC4wNzM5MiwtMC4wMjQ2NSAtMC4xNDc4NSwtMC4wNTc1IC0wLjIwNTM0LC0wLjA5ODU2Yy0wLjA1NzUsLTAuMDQxMDcgLTAuMTA2NzgsLTAuMDkwMzUgLTAuMTQ3ODUsLTAuMTU2MDZjLTAuMDQxMDcsLTAuMDY1NzEgLTAuMDQ5MjgsLTAuMTY0MjggLTAuMDQ5MjgsLTAuMjcxMDZ6TTIzOC4xODkxMSwxODYuODc3MDhjLTAuMTM5NjQsLTAuMDQxMDcgLTAuMjU0NjQsLTAuMDkwMzUgLTAuMzYxNDIsLTAuMTQ3ODVjLTAuMTA2NzgsLTAuMDU3NSAtMC4xODg5MywtMC4xMjMyMSAtMC4yNjI4NCwtMC4xOTcxNGMtMC4wNzM5MywtMC4wNzM5MyAtMC4xMzk2NCwtMC4xNjQyOCAtMC4xODg5MywtMC4yNjI4NGMtMC4wNDkyOCwtMC4wOTg1NiAtMC4xMDY3OCwtMC4yMjE3NyAtMC4xNTYwNiwtMC4zNTMyMWMtMC4wNDEwNywwLjEzMTQzIC0wLjA4MjE0LDAuMjQ2NDIgLTAuMTM5NjQsMC4zNDQ5OWMtMC4wNTc1LDAuMDk4NTYgLTAuMTIzMjEsMC4xODg5MyAtMC4xOTcxNCwwLjI2Mjg0Yy0wLjA3MzkyLDAuMDczOTIgLTAuMTY0MjcsMC4xNDc4NSAtMC4yNjI4NCwwLjIwNTM0Yy0wLjA5ODU2LDAuMDU3NSAtMC4yMTM1NiwwLjEwNjc4IC0wLjM0NDk5LDAuMTQ3ODVjMC4yNjI4NCwwLjA3MzkyIDAuNDY4MiwwLjE4ODkyIDAuNjE2MDQsMC4zNDQ5OGMwLjE0Nzg1LDAuMTU2MDYgMC4yNjI4NCwwLjM2MTQyIDAuMzQ0OTgsMC42MTYwNWMwLjA0OTI4LC0wLjEzOTY0IDAuMDk4NTYsLTAuMjU0NjQgMC4xNDc4NSwtMC4zNTMyMWMwLjA0OTI4LC0wLjA5ODU2IDAuMTE1LC0wLjE4ODkzIDAuMTg4OTMsLTAuMjYyODRjMC4wNzM5MiwtMC4wNzM5MiAwLjE1NjA2LC0wLjEzOTY0IDAuMjU0NjQsLTAuMTg4OTJjMC4wOTg1NiwtMC4wNDkyOCAwLjIyMTc4LC0wLjEwNjc4IDAuMzYxNDIsLTAuMTU2MDZ6IiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljg4MTMzNDk5OTk5OTk3OTo5Ljg4MTMzNDk5OTk5OTk3OS0tPg==" class="settings-item-icon" alt="">低精度缓冲</label><label class="custom-switch-container"><input type="checkbox" id="low-precision-buffer-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">以较低精度缩放或播放动画，提高流畅度</p></div>
            </div>

            <div id="settings-panel-coords" class="settings-panel-content">
                <div class="settings-item-row"><label for="show-axes-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjM0LjUxNTkyLDE3MS45NjE2MWwtMC4xNzg2MywxNi42MTI2NSIvPjxwYXRoIGQ9Ik0yMzEuNDcwNzksMTg1LjY0MDgxbDE2LjYxMzU1LC0wLjA0MzgxIi8+PGc+PHBhdGggZD0iTTIzNC4zMzcyOSwxNzEuNDI1NzRsLTEuOTY0OTQsMi44NTgwOSIvPjxwYXRoIGQ9Ik0yMzQuNTE1OTIsMTcxLjQyNTc0bDIuMTQzNTcsMy4wMzY3MiIvPjwvZz48Zz48cGF0aCBkPSJNMjQ1LjU4NjE5LDE4My4zNTMwNmwyLjkzNTc1LDEuODQ2OSIvPjxwYXRoIGQ9Ik0yNDUuNTgyMzIsMTg3LjY0MzkxbDIuOTQ2ODksLTIuMjY1NDciLz48L2c+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjkuODgxMzM0OTk5OTk5OTc5OjkuODgxMzM0OTk5OTk5OTc5LS0+" class="settings-item-icon" alt="">显示坐标轴</label><label class="custom-switch-container"><input type="checkbox" id="show-axes-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item-row"><label for="show-axis-numbers-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yMzQuNjE5NDEsMTg4LjQxNTg0bDAuMTc4NjMsLTE2LjYxMjY1IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzEuNDY5MjcsMTc4LjgxNjczbDE2LjYxMzU1LC0wLjA0MzgxIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjMyLjY1NDQ3LDE3NC4xMjUzOWwxLjk2NDk0LC0yLjg1ODA5Ii8+PHBhdGggZD0iTTIzNi45NDE2MSwxNzQuMzA0MDNsLTIuMTQzNTcsLTMuMDM2NzIiLz48L2c+PGcgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yNDUuNTg0NjcsMTc2LjUyODk2bDIuOTM1NzUsMS44NDY5Ii8+PHBhdGggZD0iTTI0OC41Mjc2OSwxNzguNTU0MzdsLTIuOTQ2ODksMi4yNjU0NyIvPjwvZz48cGF0aCBkPSJNMjM4LjQ3MjQsMTg4LjY2Mjc3di00LjgwNDY2IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS40MTUyOCwxODQuMjEyMDFjMC4yNDEwOCwtMC4zNDg0MiAwLjY0MzUzLC0wLjU3NjY2IDEuMDk5MjksLTAuNTc2NjZjMC43Mzc3NywwIDEuMzM1ODUsMC41OTgwOCAxLjMzNTg1LDEuMzM1ODVjMCwwLjA2NDc3IC0wLjAwNDYxLDAuMTI4NDcgLTAuMDEzNTIsMC4xOTA3OGwtMi41MDk3NSwyLjc3Nzc4IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQzLjk5ODg1LDE4OC43MDc4N2gtMi4xNTIyIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4yNTI5NCwxODguMDEzOTdsMC40NDUyOCwwLjY2NzkzIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4xMDQ1MSwxODQuNjc0MzZsMC4zNzEwNywtMC41MTk1IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS40OTI4OSwxODguMjQzMDVsLTAuMjYwNTIsMC4xNzM2OCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48Zz48cGF0aCBkPSJNMjQ1Ljk3Mzc0LDE4NC44NTIyYzAuMDAxMjgsLTAuNjk4MTUgMC41Njc2NCwtMS4yNjM3MiAxLjI2NjA5LC0xLjI2MzcyYzAuNjk5MjQsMCAxLjI2NjA5LDAuNTY2ODUgMS4yNjYwOSwxLjI2NjA5YzAsMC42OTkyNCAtMC41NjY4NSwxLjI2NjA5IC0xLjI2NjA5LDEuMjY2MDljLTAuMDM4NjQsMCAtMC4wNzY4NywtMC4wMDE3MyAtMC4xMTQ2MywtMC4wMDUxMiIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0Ny4xNTAwMSwxODYuMjA1NjRjMC4wMzc3NiwtMC4wMDMzOSAwLjA3NTk5LC0wLjAwNTEyIDAuMTE0NjMsLTAuMDA1MTJjMC42OTkyNCwwIDEuMjY2MDksMC41NjY4NSAxLjI2NjA5LDEuMjY2MDljMCwwLjY5OTI0IC0wLjU2Njg1LDEuMjY2MDkgLTEuMjY2MDksMS4yNjYwOWMtMC42OTg0NiwwIC0xLjI2NDgxLC0wLjU2NTU3IC0xLjI2NjA5LC0xLjI2MzcyIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ3LjI0NTYyLDE4Ni4zNDIzdi0wLjQwMzY4IiBzdHJva2Utd2lkdGg9IjEuMjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">显示轴编号</label><label class="custom-switch-container"><input type="checkbox" id="show-axis-numbers-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item"><label><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTIzNC41NTk3MywxODguMTM1NzFsMC4xNzg2MywtMTYuNjEyNjUiIHN0cm9rZT0iIzAwMDAwMCIvPjxwYXRoIGQ9Ik0yNDguMzA2NzgsMTg1LjE1ODQ2bC0xNi42MTM1NSwwLjA0MzgxIiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjM5Ljg0MzEzLDE4OC4zNjU5NmwwLjE2MTQxLC0xNS4wMTE0NiIgc3Ryb2tlLW9wYWNpdHk9IjAuNjExNzYiIHN0cm9rZT0iIzAwMDAwMCIvPjxwYXRoIGQ9Ik0yNDUuMzI2NTgsMTg4LjQ3Njk0bDAuMTYwMTMsLTE0Ljg5MjYxIiBzdHJva2Utb3BhY2l0eT0iMC42MTE3NiIgc3Ryb2tlPSIjMDAwMDAwIi8+PHBhdGggZD0iTTI0Ny4yMDc2NywxNzkuOTg1MzdsLTE0LjUzNjc2LDAuMDY2MTIiIHN0cm9rZS1vcGFjaXR5PSIwLjYxMTc2IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjMzLjAxOTU3LDE3NS4wMzY1NWwxNC41MzY3NiwtMC4wNjYxMiIgc3Ryb2tlLW9wYWNpdHk9IjAuNjExNzYiIHN0cm9rZT0iIzAwMDAwMCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljg4MTMzNDk5OTk5OTk3OTo5Ljg4MTMzNDk5OTk5OTk3OS0tPg==" class="settings-item-icon" alt="">网格样式</label><div class="button-group" id="grid-style-buttons"><button data-style="hidden">隐藏</button><button data-style="grid" class="active">网格</button><button data-style="dots">格点</button><button data-style="polar">极坐标</button></div></div>
                <div class="settings-item-row"><label for="show-point-labels-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzMC4xMTg2NywxODkuODgxNHYtMTkuNzYyNzNoMTkuNzYyNzN2MTkuNzYyNzN6IiBmaWxsLW9wYWNpdHk9IjAuMDA3ODQiIGZpbGw9IiNjMmZmZmYiIHN0cm9rZS13aWR0aD0iMCIvPjxnIGZpbGw9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yNDQuMzI4OTgsMTcxLjM0MDE5bDMuNDg0MzMsOC42Mjc4N2gtMS44MjUxM2wtMC43NDY2NCwtMS45OTEwNWgtMy40MDEzN2wtMC43NDY2NCwxLjk5MTA1aC0xLjc0MjE3bDMuNDAxMzcsLTguNjI3ODd6TTI0NC42NjA4MiwxNzYuNTY2NjhsLTEuMTYxNDQsLTMuMDY5NTNsLTEuMTYxNDQsMy4wNjk1M3oiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yMzIuMTg2NjksMTg1LjE0Nzg1YzAsLTEuOTM5NiAxLjU3MjM2LC0zLjUxMTk2IDMuNTExOTYsLTMuNTExOTZjMS45Mzk2LDAgMy41MTE5NiwxLjU3MjM2IDMuNTExOTYsMy41MTE5NmMwLDEuOTM5NiAtMS41NzIzNiwzLjUxMTk2IC0zLjUxMTk2LDMuNTExOTZjLTEuOTM5NiwwIC0zLjUxMTk2LC0xLjU3MjM2IC0zLjUxMTk2LC0zLjUxMTk2eiIgc3Ryb2tlLXdpZHRoPSIwIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjkuODgxMzM0OTk5OTk5OTc5OjkuODgxMzM0OTk5OTk5OTc5LS0+" class="settings-item-icon" alt="">显示点的名称</label><label class="custom-switch-container"><input type="checkbox" id="show-point-labels-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item-row"><label for="show-hidden-math-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQzLjA4OTQ3LDE3MC43OTE4YzAsMCAtMi4yNDcyNywyMi42ODY2OCAtNS42NzE2NywxMS42NjQzOGMtMi4wMzMyNCwtNi42MzQ3OCAtMy4zMTczOSwtMi45OTYzNSAtNC4wNjY0OCwwLjc0OTA5IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC41MDMzOSwxNzAuNzkxOGMtMC40MjgwNSwxLjYwNTE5IC0zLjIxMDM4LDEyLjg0MTUyIC02LjYzNDc4LDEyLjg0MTUyYy0zLjQyNDQsMCAtNi4yMDY3MywtMTEuMjM2MzMgLTYuNjM0NzgsLTEyLjg0MTUyIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQyLjMxOTc5LDE4NS45ODUwMWMwLC0xLjc4MDExIDEuNDQzMDcsLTMuMjIzMTkgMy4yMjMxOSwtMy4yMjMxOWMxLjc4MDExLDAgMy4yMjMxOSwxLjQ0MzA3IDMuMjIzMTksMy4yMjMxOWMwLDEuNzgwMTEgLTEuNDQzMDcsMy4yMjMxOSAtMy4yMjMxOSwzLjIyMzE5Yy0xLjc4MDExLDAgLTMuMjIzMTksLTEuNDQzMDcgLTMuMjIzMTksLTMuMjIzMTl6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ3LjkxMDYxLDE4My45NTA2bC00LjkwMDcsMy43NzM1NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDIuMzkzODgsMTg1LjcxNDg1YzAsLTAuMDg3MDEgMC4wMjE0NSwtMC4xNjkgMC4wNTkzNSwtMC4yNDA5OWwwLjIzNzI1LC0wLjQ3NDQ5YzAuODA3NDEsLTEuNzYxODIgMi4zMjQyLC0yLjI3NTE5IDQuMDgwMzcsLTEuNjM4MTJjMC4xMzA0NSwtMC4wMzk3OCAwLjQ2MTQ5LC0wLjA5NjQ2IDAuNjMxMjMsMC4yNzY5N2MwLjIxNDM2LDAuNDcxNTkgLTAuMjU3MjMsMC42ODU5NSAtMC4yNTcyMywwLjY4NTk1Yy0wLjI5NTk4LDAuMTMzMSAtMC41OTUwOCwwLjI5MzgxIC0wLjg5MzY1LDAuNDc0MDhjMC4xMDY0NywwLjI2NjY1IC0wLjA5ODkyLDAuNTEzMTMgLTAuMDk4OTIsMC41MTMxM2wtMC4yNTMxNCwwLjMwMzUzYy0wLjU5MDk3LDAuNjc1MzkgLTEuMTEwNDksMS4xODM0MiAtMS45MjI0NCwxLjU5MjQzYzAsMCAtMC40MTgwMSwwLjIwOSAtMC42NTg0NywtMC4xNjcwN2MtMC4wNTUwNSwwLjA0Nzk3IC0wLjEwOTQ3LDAuMDk1NTIgLTAuMTYzMjEsMC4xNDI1OGwtMC4wMjM4MywwLjAyNTQ1YzAsMCAtMC4zNjYzLDAuMzY2MyAtMC43MzI1OSwwYy0wLjM2NjMsLTAuMzY2MyAwLC0wLjczMjU5IDAsLTAuNzMyNTlsMC4wNzQxOCwtMC4wNzI1NmMwLjA3OTA1LC0wLjA2OTEyIDAuMTU5MzksLTAuMTM5MDQgMC4yNDA5LC0wLjIwOTU2Yy0wLjE4Nzc0LC0wLjA3NzgyIC0wLjMxOTc4LC0wLjI2Mjg2IC0wLjMxOTc4LC0wLjQ3ODc0eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">显示隐藏的数学对象</label><label class="custom-switch-container"><input type="checkbox" id="show-hidden-math-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item-row"><label for="show-hidden-geo-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS44NjQ4NSIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljg2NDg1LDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjAxNjU0LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQyLjc4NzA4LDE4NS43NjE1MWMwLC0xLjc4MDExIDEuNDQzMDcsLTMuMjIzMTkgMy4yMjMxOSwtMy4yMjMxOWMxLjc4MDExLDAgMy4yMjMxOSwxLjQ0MzA3IDMuMjIzMTksMy4yMjMxOWMwLDEuNzgwMTEgLTEuNDQzMDcsMy4yMjMxOSAtMy4yMjMxOSwzLjIyMzE5Yy0xLjc4MDExLDAgLTMuMjIzMTksLTEuNDQzMDcgLTMuMjIzMTksLTMuMjIzMTl6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ4LjM3NzksMTgzLjcyNzA5bC00LjkwMDcsMy43NzM1NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDIuODYxMTcsMTg1LjQ5MTM2YzAsLTAuMDg3MDEgMC4wMjE0NSwtMC4xNjkgMC4wNTkzNSwtMC4yNDA5OGwwLjIzNzI1LC0wLjQ3NDQ5YzAuODA3NDEsLTEuNzYxODIgMi4zMjQyLC0yLjI3NTE5IDQuMDgwMzcsLTEuNjM4MTJjMC4xMzA0NSwtMC4wMzk3OCAwLjQ2MTQ5LC0wLjA5NjQ2IDAuNjMxMjMsMC4yNzY5N2MwLjIxNDM2LDAuNDcxNTkgLTAuMjU3MjMsMC42ODU5NSAtMC4yNTcyMywwLjY4NTk1Yy0wLjI5NTk4LDAuMTMzMSAtMC41OTUwOCwwLjI5MzgxIC0wLjg5MzY1LDAuNDc0MDhjMC4xMDY0NywwLjI2NjY1IC0wLjA5ODkzLDAuNTEzMTMgLTAuMDk4OTMsMC41MTMxM2wtMC4yNTMxMywwLjMwMzUzYy0wLjU5MDk3LDAuNjc1MzkgLTEuMTEwNDksMS4xODM0MSAtMS45MjI0NCwxLjU5MjQyYzAsMCAtMC40MTgwMSwwLjIwOTAxIC0wLjY1ODQ3LC0wLjE2NzA2Yy0wLjA1NTA1LDAuMDQ3OTcgLTAuMTA5NDcsMC4wOTU1MiAtMC4xNjMyMSwwLjE0MjU4bC0wLjAyMzgzLDAuMDI1NDVjMCwwIC0wLjM2NjMsMC4zNjYzIC0wLjczMjU5LDBjLTAuMzY2MywtMC4zNjYzIDAsLTAuNzMyNTkgMCwtMC43MzI1OWwwLjA3NDE4LC0wLjA3MjU2YzAuMDc5MDUsLTAuMDY5MTIgMC4xNTkzOCwtMC4xMzkwNCAwLjI0MDksLTAuMjA5NTZjLTAuMTg3NzQsLTAuMDc3ODIgLTAuMzE5NzgsLTAuMjYyODYgLTAuMzE5NzgsLTAuNDc4NzR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiPjxwYXRoIGQ9Ik0yMzAuNzY2NTUsMTc1Ljg5MjM2djcuODY5NzYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzguNTI1NDcsMTgzLjA5NzA0bC03LjQyNjM4LC03LjIwNDciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzAuODc3MzYsMTgzLjc2MjE0aDguMDkxNDIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuNTMwMzQsMTc0LjE3NDI5YzAsLTEuNzQ0NjYgMS40MTQzMiwtMy4xNTg5OCAzLjE1ODk4LC0zLjE1ODk4YzEuNzQ0NjYsMCAzLjE1ODk4LDEuNDE0MzQgMy4xNTg5OCwzLjE1ODk4YzAsMS43NDQ2NiAtMS40MTQzNCwzLjE1ODk4IC0zLjE1ODk4LDMuMTU4OThjLTEuNzQ0NjYsMCAtMy4xNTg5OCwtMS40MTQzNCAtMy4xNTg5OCwtMy4xNTg5OHoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljk4MzQ1NDk5OTk5OTk5Mjo5Ljg4MTMzNDk5OTk5OTk3OS0tPg==" class="settings-item-icon" alt="">显示隐藏的几何对象</label><label class="custom-switch-container"><input type="checkbox" id="show-hidden-geo-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
            </div>

            <div id="settings-panel-features" class="settings-panel-content">
                <div class="settings-item"><div class="settings-item-row"><label for="adaptive-plotting-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBzdHJva2U9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yMzEuMzI3NzcsMTgyLjMxODc4YzAsLTAuMTMxNDMgMC4wNDEwNywtMC4yNTQ2NCAwLjExNSwtMC4zNjk2M2MwLjA3MzkzLC0wLjExNSAwLjE4MDcxLC0wLjE4ODkzIDAuMzEyMTMsLTAuMjI5OTlsMC44NTQyNSwtMC4yNzkyOGMwLjA5ODU2LC0wLjAzMjg1IDAuMTk3MTQsLTAuMDgyMTQgMC4yOTU3LC0wLjE0Nzg1YzAuMDk4NTYsLTAuMDY1NzEgMC4xNzI1LC0wLjEzMTQzIDAuMjQ2NDIsLTAuMjA1MzRjMC4xNjQyOCwtMC4xNjQyOCAwLjI3MTA3LC0wLjM0NDk4IDAuMzQ0OTksLTAuNTUwMzNsMC4yNzkyNywtMC44NjI0N2MwLjA0MTA3LC0wLjEzMTQyIDAuMTIzMjEsLTAuMjI5OTkgMC4yMjk5OSwtMC4zMTIxM2MwLjEwNjc4LC0wLjA4MjE0IDAuMjM4MiwtMC4xMjMyMSAwLjM2OTYzLC0wLjEyMzIxYzAuMTMxNDMsMCAwLjI2Mjg0LDAuMDQxMDcgMC4zNjk2MywwLjExNWMwLjEwNjc4LDAuMDczOTIgMC4xOTcxNCwwLjE4MDcxIDAuMjM4MiwwLjMxMjEzbDAuMjc5MjgsMC44NTQyNWMwLjA2NTcxLDAuMjEzNTYgMC4xODA3LDAuNDAyNDggMC4zNDQ5OSwwLjU2Njc2YzAuMTU2MDYsMC4xNjQyOCAwLjM0NDk5LDAuMjc5MjggMC41NjY3NywwLjM0NDk5bDAuODQ2MDMsMC4yNzkyOGMwLjEzOTY0LDAuMDQxMDcgMC4yNDY0MiwwLjEyMzIxIDAuMzI4NTUsMC4yMjk5OWMwLjA4MjE0LDAuMTA2NzggMC4xMjMyMSwwLjIzODIgMC4xMjMyMSwwLjM4NjA2YzAsMC4xMzE0MyAtMC4wNDEwNywwLjI1NDY0IC0wLjEyMzIxLDAuMzY5NjNjLTAuMDgyMTQsMC4xMTUgLTAuMTgwNywwLjE4ODkzIC0wLjMxMjEzLDAuMjI5OTlsLTAuODU0MjUsMC4yNzkyOGMtMC4yMTM1NiwwLjA2NTcxIC0wLjQwMjQ5LDAuMTgwNyAtMC41NjY3NywwLjM0NDk5Yy0wLjA5ODU2LDAuMDk4NTYgLTAuMTg4OTMsMC4yMjE3NyAtMC4yNDY0MiwwLjM1MzJjLTAuMDU3NSwwLjEzMTQzIC0wLjExNSwwLjI2Mjg0IC0wLjE1NjA2LDAuNDAyNDljLTAuMDQxMDcsMC4xMzk2NCAtMC4wODIxNCwwLjI3MTA2IC0wLjEyMzIxLDAuNDAyNDljLTAuMDQxMDcsMC4xMzE0MiAtMC4wOTAzNSwwLjI0NjQyIC0wLjE0Nzg1LDAuMzQ0OTljLTAuMDU3NSwwLjA5ODU2IC0wLjEzMTQzLDAuMTg4OTMgLTAuMjEzNTYsMC4yNDY0M2MtMC4wODIxNCwwLjA1NzUgLTAuMTk3MTQsMC4wOTAzNSAtMC4zNDQ5OSwwLjA5MDM1Yy0wLjEzMTQzLDAgLTAuMjYyODQsLTAuMDQxMDcgLTAuMzY5NjMsLTAuMTE1Yy0wLjEwNjc4LC0wLjA3MzkyIC0wLjE4ODkzLC0wLjE4MDcgLTAuMjI5OTksLTAuMzEyMTNsLTAuMjc5MjgsLTAuODU0MjVjLTAuMDI0NjUsLTAuMDgyMTQgLTAuMDU3NSwtMC4xNTYwNiAtMC4wOTAzNSwtMC4yMjk5OWMtMC4wMzI4NSwtMC4wNzM5MyAtMC4wODIxNCwtMC4xMzk2NCAtMC4xMzE0MywtMC4yMDUzNGMtMC4xMDY3OCwtMC4xMzk2NCAtMC4yMjk5OSwtMC4yNDY0MyAtMC4zNjk2MywtMC4zMjg1NmMtMC4xMzk2NCwtMC4wODIxNCAtMC4yNzkyOCwtMC4xNDc4NSAtMC40MjcxMywtMC4xOTcxNGMtMC4xNDc4NSwtMC4wNDkyOCAtMC4yODc0OSwtMC4wOTg1NiAtMC40MjcxMywtMC4xMzE0MmMtMC4xMzk2NCwtMC4wMzI4NiAtMC4yNjI4NCwtMC4wODIxNCAtMC4zNzc4NCwtMC4xMzk2NGMtMC4xMTUsLTAuMDU3NSAtMC4xOTcxNCwtMC4xMzE0MyAtMC4yNjI4NCwtMC4yMTM1NmMtMC4wNjU3MSwtMC4wODIxNCAtMC4wOTAzNSwtMC4xOTcxNCAtMC4wOTAzNSwtMC4zNDQ5OHpNMjM2Ljg1NTc3LDE4Mi4zNTE2NWMtMC4yNDY0MywtMC4wOTAzNSAtMC40NzY0MiwtMC4xODA3MSAtMC42OTgxOSwtMC4yNTQ2NGMtMC4yMjE3OCwtMC4wNzM5MiAtMC40MjcxMywtMC4xNzI0OSAtMC42MTYwNCwtMC4yODc0OWMtMC4xODg5MiwtMC4xMTUgLTAuMzUzMjEsLTAuMjU0NjQgLTAuNTAxMDUsLTAuNDI3MTNjLTAuMTQ3ODUsLTAuMTcyNDkgLTAuMjYyODQsLTAuMzg2MDYgLTAuMzQ0OTksLTAuNjY1MzNsLTAuMjcxMDYsLTAuODQ2MDNsLTAuMzIwMzQsMC44NDYwM2MtMC4wNTc1LDAuMTU2MDYgLTAuMTIzMjEsMC4yOTU3MSAtMC4yMDUzNCwwLjQyNzEzYy0wLjA4MjE0LDAuMTMxNDIgLTAuMTcyNSwwLjI1NDY0IC0wLjI4NzQ5LDAuMzc3ODRjLTAuMTA2NzgsMC4xMDY3OCAtMC4yMjk5OSwwLjIwNTM0IC0wLjM2OTYzLDAuMjk1N2MtMC4xMzk2NCwwLjA5MDM1IC0wLjI3OTI3LDAuMTU2MDYgLTAuNDI3MTMsMC4yMDUzNGwtMC44NTQyNSwwLjI3MTA2YzAuMjM4MiwwLjA5MDM1IDAuNDY4MiwwLjE4MDcxIDAuNjg5OTcsMC4yNTQ2NGMwLjIyMTc3LDAuMDczOTMgMC40MjcxMywwLjE3MjUgMC42MDc4MywwLjI4NzQ5YzAuMTgwNzEsMC4xMTUgMC4zNTMyMSwwLjI1NDY0IDAuNTAxMDUsMC40MjcxM2MwLjE0Nzg1LDAuMTcyNSAwLjI2Mjg0LDAuMzg2MDYgMC4zNDQ5OSwwLjY1NzEybDAuMjcxMDYsMC44NDYwNGwwLjMyMDM0LC0wLjg0NjA0YzAuMTE1LC0wLjMxMjEzIDAuMjg3NDksLTAuNTgzMTkgMC41MDEwNCwtMC44MDQ5N2MwLjIxMzU2LC0wLjIyMTc3IDAuNDg0NjMsLTAuMzk0MjYgMC44MDQ5NywtMC40OTI4M3pNMjM2LjI1NjE3LDE4NS45OTg2MWMwLC0wLjA5ODU2IDAuMDMyODUsLTAuMTg4OTMgMC4wOTg1NiwtMC4yNzEwNmMwLjA2NTcxLC0wLjA4MjE0IDAuMTM5NjQsLTAuMTM5NjQgMC4yMzgyMSwtMC4xNzI1bDAuNDc2NDIsLTAuMTU2MDZjMC4xMDY3OCwtMC4wMzI4NSAwLjE5NzE0LC0wLjA5MDM1IDAuMjU0NjQsLTAuMTY0MjhjMC4wNTc1LC0wLjA3MzkyIDAuMTA2NzksLTAuMTU2MDYgMC4xNDc4NSwtMC4yNDY0MmMwLjA0MTA3LC0wLjA5MDM1IDAuMDY1NzEsLTAuMTg4OTMgMC4wOTAzNSwtMC4yNzkyOGMwLjAyNDY1LC0wLjA5MDM1IDAuMDU3NSwtMC4xODA3IDAuMDk4NTYsLTAuMjYyODRjMC4wNDEwNywtMC4wODIxNCAwLjA5MDM1LC0wLjEzOTY0IDAuMTU2MDYsLTAuMTk3MTRjMC4wNjU3MSwtMC4wNTc1IDAuMTU2MDYsLTAuMDczOTMgMC4yNzkyOCwtMC4wNzM5M2MwLjA5ODU2LDAgMC4xOTcxNCwwLjAzMjg2IDAuMjg3NDgsMC4wOTAzNWMwLjA5MDM1LDAuMDU3NSAwLjE0Nzg1LDAuMTM5NjQgMC4xODA3MSwwLjIzODJjMC4wMTY0MywwLjA2NTcxIDAuMDQxMDcsMC4xMzE0MyAwLjA1NzQ5LDAuMTk3MTRjMC4wMTY0MywwLjA2NTcxIDAuMDQxMDcsMC4xMzE0MiAwLjA1NzUsMC4xODg5M2MwLjAxNjQzLDAuMDU3NSAwLjA0OTI4LDAuMTIzMjEgMC4wODIxNCwwLjE4MDdjMC4wMzI4NiwwLjA1NzUgMC4wNzM5MiwwLjExNSAwLjEyMzIxLDAuMTY0MjhjMC4wNDkyOCwwLjA1NzUgMC4xMTUsMC4wOTg1NiAwLjE4ODkyLDAuMTMxNDNjMC4wNzM5MywwLjAzMjg2IDAuMTQ3ODUsMC4wNTc1IDAuMjI5OTksMC4wODIxNGMwLjA4MjE0LDAuMDI0NjUgMC4xNTYwNiwwLjA0OTI4IDAuMjM4MiwwLjA3MzkzYzAuMDgyMTQsMC4wMjQ2NCAwLjE0Nzg1LDAuMDU3NSAwLjIwNTM0LDAuMDk4NTZjMC4wNTc1LDAuMDQxMDcgMC4xMDY3OSwwLjA5MDM1IDAuMTQ3ODUsMC4xNTYwNmMwLjA0MTA3LDAuMDY1NzEgMC4wNTc1LDAuMTM5NjQgMC4wNTc1LDAuMjM4MmMwLDAuMTA2NzggLTAuMDMyODYsMC4yMDUzNCAtMC4wOTAzNSwwLjI4NzQ5Yy0wLjA1NzUsMC4wODIxNCAtMC4xMzk2NCwwLjE0Nzg1IC0wLjI0NjQyLDAuMTgwN2MtMC4wNTc1LDAuMDE2NDMgLTAuMTIzMjEsMC4wNDEwNyAtMC4xODg5MywwLjA1NzVjLTAuMDY1NzEsMC4wMTY0MyAtMC4xMzE0MiwwLjA0MTA3IC0wLjE5NzE0LDAuMDU3NWMtMC4wNjU3MSwwLjAxNjQzIC0wLjEzMTQzLDAuMDQ5MjggLTAuMTg4OTMsMC4wODIxNGMtMC4wNTc1LDAuMDMyODYgLTAuMTE0OTksMC4wNzM5MyAtMC4xNjQyOCwwLjEyMzIxYy0wLjA3MzkyLDAuMDgyMTQgLTAuMTMxNDMsMC4xODA3MSAtMC4xNzI1LDAuMzAzOTJjLTAuMDQxMDcsMC4xMjMyMSAtMC4wNzM5MywwLjIzODIxIC0wLjExNSwwLjM1MzIxYy0wLjA0MTA3LDAuMTE1IC0wLjA5ODU2LDAuMjEzNTYgLTAuMTY0MjcsMC4yODc0OGMtMC4wNjU3MSwwLjA3MzkzIC0wLjE4MDcxLDAuMTIzMjEgLTAuMzI4NTYsMC4xMjMyMWMtMC4wOTg1NiwwIC0wLjE5NzE0LC0wLjAzMjg2IC0wLjI4NzQ4LC0wLjA5MDM1Yy0wLjA5MDM1LC0wLjA1NzUgLTAuMTQ3ODUsLTAuMTM5NjQgLTAuMTgwNywtMC4yMzgyYy0wLjAxNjQzLC0wLjA1NzUgLTAuMDQxMDcsLTAuMTIzMjEgLTAuMDU3NSwtMC4xODg5M2MtMC4wMTY0MywtMC4wNjU3MSAtMC4wNDEwNywtMC4xMzE0MiAtMC4wNTc1LC0wLjE5NzE0Yy0wLjAxNjQzLC0wLjA2NTcxIC0wLjA0OTI4LC0wLjEzMTQzIC0wLjA4MjE0LC0wLjE4ODkzYy0wLjAzMjg1LC0wLjA1NzUgLTAuMDczOTMsLTAuMTE1IC0wLjExNSwtMC4xNTYwNmMtMC4wNTc1LC0wLjA1NzUgLTAuMTIzMjEsLTAuMDk4NTYgLTAuMTk3MTQsLTAuMTMxNDJjLTAuMDczOTIsLTAuMDMyODYgLTAuMTQ3ODUsLTAuMDU3NSAtMC4yMjk5OSwtMC4wODIxNGMtMC4wODIxNCwtMC4wMjQ2NCAtMC4xNTYwNiwtMC4wNDkyOCAtMC4yMjk5OSwtMC4wNzM5MmMtMC4wNzM5MiwtMC4wMjQ2NSAtMC4xNDc4NSwtMC4wNTc1IC0wLjIwNTM0LC0wLjA5ODU2Yy0wLjA1NzUsLTAuMDQxMDcgLTAuMTA2NzgsLTAuMDkwMzUgLTAuMTQ3ODUsLTAuMTU2MDZjLTAuMDQxMDcsLTAuMDY1NzEgLTAuMDQ5MjgsLTAuMTY0MjggLTAuMDQ5MjgsLTAuMjcxMDZ6TTIzOS4wNTcxLDE4Ni4wMjMyNGMtMC4xMzk2NCwtMC4wNDEwNyAtMC4yNTQ2NCwtMC4wOTAzNSAtMC4zNjE0MiwtMC4xNDc4NWMtMC4xMDY3OCwtMC4wNTc1IC0wLjE4ODkzLC0wLjEyMzIxIC0wLjI2Mjg0LC0wLjE5NzE0Yy0wLjA3MzkzLC0wLjA3MzkzIC0wLjEzOTY0LC0wLjE2NDI4IC0wLjE4ODkzLC0wLjI2Mjg0Yy0wLjA0OTI4LC0wLjA5ODU2IC0wLjEwNjc4LC0wLjIyMTc3IC0wLjE1NjA2LC0wLjM1MzIxYy0wLjA0MTA3LDAuMTMxNDMgLTAuMDgyMTQsMC4yNDY0MiAtMC4xMzk2NCwwLjM0NDk5Yy0wLjA1NzUsMC4wOTg1NiAtMC4xMjMyMSwwLjE4ODkzIC0wLjE5NzE0LDAuMjYyODRjLTAuMDczOTIsMC4wNzM5MiAtMC4xNjQyNywwLjE0Nzg1IC0wLjI2Mjg0LDAuMjA1MzRjLTAuMDk4NTYsMC4wNTc1IC0wLjIxMzU2LDAuMTA2NzggLTAuMzQ0OTksMC4xNDc4NWMwLjI2Mjg0LDAuMDczOTIgMC40NjgyLDAuMTg4OTIgMC42MTYwNCwwLjM0NDk4YzAuMTQ3ODUsMC4xNTYwNiAwLjI2Mjg0LDAuMzYxNDIgMC4zNDQ5OCwwLjYxNjA1YzAuMDQ5MjgsLTAuMTM5NjQgMC4wOTg1NiwtMC4yNTQ2NCAwLjE0Nzg1LC0wLjM1MzIxYzAuMDQ5MjgsLTAuMDk4NTYgMC4xMTUsLTAuMTg4OTMgMC4xODg5MywtMC4yNjI4NGMwLjA3MzkyLC0wLjA3MzkyIDAuMTU2MDYsLTAuMTM5NjQgMC4yNTQ2NCwtMC4xODg5MmMwLjA5ODU2LC0wLjA0OTI4IDAuMjIxNzgsLTAuMTA2NzggMC4zNjE0MiwtMC4xNTYwNnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDguNjcyMjQsMTcyLjEyODYyYy0xLjYyMjIzLDguMzQ3MTEgLTQuNTE3OTUsMTcuOTA1NjYgLTguMjIxMzIsNy43Mzk4MWMtMi42NTQ3OCwtNy4zODggLTQuNTYwMzgsLTYuMDEzNjMgLTUuODgwNzYsLTIuNTE4NzQiIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">自适应绘图</label><label class="custom-switch-container"><input type="checkbox" id="adaptive-plotting-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">根据函数变化率自动调节绘图精度，适用于部分显函数</p></div>
                <div class="settings-item"><div class="settings-item-row"><label for="adaptive-extend-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjUzOSIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2NTM5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIj48cGF0aCBkPSJNMjQwLjg0MDA2LDE3Mi41NTk1N2wtMC4xMzI1NCwtMi4zODQ4NCIvPjxwYXRoIGQ9Ik0yNDEuMDA1NTEsMTc1LjUzNjQ2bC0wLjEyMzc2LC0yLjIyNjg4Ii8+PHBhdGggZD0iTTI0OC41ODEzNSwxODEuNDc4MzJsLTEuNDQzODcsLTAuMDAxMjdjLTAuMDU1MzQsMC4wMDE1MiAtMC4xMTA4OCwwLjAwMjI5IC0wLjE2NjU5LDAuMDAyMjljLTMuMDMxMjUsMCAtNS41MzM3NiwtMi4yNjM3NCAtNS45MDkxOSwtNS4xOTI4OSIvPjxwYXRoIGQ9Ik0yMzkuMDA0NDgsMTg5LjgyNTI4bC0wLjEyMzM4LC0yLjA5NTI4Ii8+PHBhdGggZD0iTTIzOC44MzY5OCwxODYuOTgwOGwtMC4xMTA2MSwtMS44NzgyMyIvPjxwYXRoIGQ9Ik0yMzEuNDE4NjUsMTc4LjU0NjkybDEuMTE4NjMsLTAuMDAyN2MwLjA1NTM0LC0wLjAwMTcxIDAuMTEwODcsLTAuMDAyNjYgMC4xNjY1OCwtMC4wMDI4NGMzLjE0MDksLTAuMDEwMzYgNS43MjIxNCwyLjQxMTY3IDUuOTU5NjYsNS40OTM3NWwwLjAxODY5LDAuMzE3NDQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">自动延伸断点</label><label class="custom-switch-container"><input type="checkbox" id="adaptive-extend-toggle" checked><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">自动延伸断点上下图像，可能出现误判</p></div>
               <div class="settings-item-row"><label for="auto-breakpoint-detection-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNMjQ4LjczNTgsMTc5LjE5OTFjLTIuMTcxNTYsNy4yMTk2OCAtNS4xMTU2NiwxMS41MzUyOCAtOC42MTMzMywzLjEwNTg2IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMxLjI2NDIxLDE3Ni45NDg1YzEuNjcyNiwtNC40MjcxNyA0LjAzMDE4LC02LjM3MjM0IDcuMjUwMDYsMS4zNDc2NCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNy4zNTQzOSwxODAuNDIyMDNjMCwtMS4wOTg2NyAwLjg5MDY1LC0xLjk4OTMyIDEuOTg5MzIsLTEuOTg5MzJjMS4wOTg2NywwIDEuOTg5MzMsMC44OTA2NSAxLjk4OTMzLDEuOTg5MzJjMCwxLjA5ODY3IC0wLjg5MDY2LDEuOTg5MzIgLTEuOTg5MzMsMS45ODkzMmMtMS4wOTg2NywwIC0xLjk4OTMyLC0wLjg5MDY1IC0xLjk4OTMyLC0xLjk4OTMyeiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6OS44ODEzMzQ5OTk5OTk5Nzk6OS44ODEzMzQ5OTk5OTk5NzktLT4=" class="settings-item-icon" alt="">自动断点判断</label><label class="custom-switch-container"><input type="checkbox" id="auto-breakpoint-detection-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item-row"><label for="geometry-snap-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOS43NjI3MyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDE5Ljc2MjczLDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMwLjExODY3LC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBzdHJva2U9IiMwMDAwMDAiPjxwYXRoIGQ9Ik0yMzMuNTI4MzQsMTg3LjgyNTA0Yy0wLjY0Njg2LC0xLjQyMDE2IC0xLjAwNzIyLC0yLjk5ODM1IC0xLjAwNzIyLC00LjY2MDcxYzAsLTYuMjE2NTggNS4wMzk1NCwtMTEuMjU2MTEgMTEuMjU2MTIsLTExLjI1NjExYzEuMTE2NzUsMCAyLjE5NTUyLDAuMTYyNjIgMy4yMTM5MSwwLjQ2NTQ5IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMy42ODMwNSwxNzUuMDY2MjNjMCwtMS4wOTg2NyAwLjg5MDY1LC0xLjk4OTMyIDEuOTg5MzIsLTEuOTg5MzJjMS4wOTg2NywwIDEuOTg5MzIsMC44OTA2NSAxLjk4OTMyLDEuOTg5MzJjMCwxLjA5ODY3IC0wLjg5MDY1LDEuOTg5MzIgLTEuOTg5MzIsMS45ODkzMmMtMS4wOTg2NywwIC0xLjk4OTMyLC0wLjg5MDY1IC0xLjk4OTMyLC0xLjk4OTMyeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMy43MDA5NiwxODguMDkxNzlsLTAuNDEyMjksLTAuOTI3NjQiIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni4xMzg5NSwxNzIuMTA5NDhsMS4zMzk5MywwLjQxMjI4IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo5Ljg4MTMzNDk5OTk5OTk3OTo5Ljg4MTMzNDk5OTk5OTk3OS0tPg==" class="settings-item-icon" alt="">几何智能吸附</label><label class="custom-switch-container"><input type="checkbox" id="geometry-snap-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item-row"><label for="geometry-measurement-display-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC40MTA5NyIgaGVpZ2h0PSIxOS43NjI3MyIgdmlld0JveD0iMCwwLDIwLjQxMDk3LDE5Ljc2MjczIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5Ljc5NDUyLC0xNzAuMTE4NjcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxnPjxwYXRoIGQ9Ik0yMzAuNzk0NSwxODAuNDUxNTVsMC4wMjMwMywtMy4xMzEyN2MwLjAwMDMyLC0wLjAzMTgxIDAuMDAxMDUsLTAuMDYzNzcgMC4wMDIxLC0wLjA5NTVjMC4wODE1MywtMi41OTc3MyAyLjIxODE2LC00LjYzNjE5IDQuNzcyMTMsLTQuNTUzMjljMC4wMjAyNiwwLjAwMDczIDAuMDQwNDQsMC4wMDEzNyAwLjA2MDcxLDAuMDAyMzRsOC44NDEzMSwtMC4wMDM0N2MwLjAzMTI0LC0wLjAwMDQ4IDAuMDYyNjQsLTAuMDAwNzMgMC4wOTM5NiwtMC4wMDA0OGMyLjU1NTM1LDAuMDExMTQgNC42MTgwMywyLjEyNjk0IDQuNjA3MTMsNC43MjU5NmMtMC4wMDAwOCwwLjAyMDUgLTAuMDAwMzIsMC4wNDExNyAtMC4wMDA3MywwLjA2MTY3bDAuMDExMzcsMi42NjEyNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiLz48cGF0aCBkPSJNMjQ5LjIwMzY2LDE3OS40NTk5N2wtMC4wMDI3MiwzLjEzMTM1Yy0wLjAwMDExLDAuMDMxODEgLTAuMDAwNjMsMC4wNjM3OCAtMC4wMDE0OCwwLjA5NTUyYy0wLjA2NDY4LDIuNTk4MjEgLTIuMTg4MDUsNC42NTA0OCAtNC43NDI1LDQuNTg0MTRjLTAuMDIwMjYsLTAuMDAwNiAtMC4wNDA0NSwtMC4wMDExIC0wLjA2MDczLC0wLjAwMTk0bC04Ljg0MTEsMC4wNjA4MWMtMC4wMzEyNCwwLjAwMDY5IC0wLjA2MjY0LDAuMDAxMTQgLTAuMDkzOTUsMC4wMDEwOWMtMi41NTUzNywwLjAwNTQzIC00LjYzMTczLC0yLjA5Njk1IC00LjYzNzY5LC00LjY5NTk4Yy0wLjAwMDA2LC0wLjAyMDUgMC4wMDAwNiwtMC4wNDExOCAwLjAwMDMzLC0wLjA2MTY4bC0wLjAyODYzLC0yLjY2MTEiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTIzNC42OTkzMywxNzkuOTExMjFjMCwtMC43NzEyMiAwLjYyNTIsLTEuMzk2NDIgMS4zOTY0MiwtMS4zOTY0MmMwLjc3MTIyLDAgMS4zOTY0MiwwLjYyNTIgMS4zOTY0MiwxLjM5NjQyYzAsMC43NzEyMiAtMC42MjUyLDEuMzk2NDEgLTEuMzk2NDIsMS4zOTY0MWMtMC43NzEyMiwwIC0xLjM5NjQyLC0wLjYyNTE5IC0xLjM5NjQyLC0xLjM5NjQxeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM4LjcxMzYyLDE3OS45MDA1M2MwLC0wLjc3MTIyIDAuNjI1MiwtMS4zOTY0MSAxLjM5NjQyLC0xLjM5NjQxYzAuNzcxMjIsMCAxLjM5NjQyLDAuNjI1MTkgMS4zOTY0MiwxLjM5NjQxYzAsMC43NzEyMiAtMC42MjUyLDEuMzk2NDIgLTEuMzk2NDIsMS4zOTY0MmMtMC43NzEyMiwwIC0xLjM5NjQyLC0wLjYyNTIgLTEuMzk2NDIsLTEuMzk2NDJ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxwYXRoIGQ9Ik0yNDIuODEwMDUsMTc5Ljg4OTg1YzAsLTAuNzcxMjIgMC42MjUyLC0xLjM5NjQxIDEuMzk2NDIsLTEuMzk2NDFjMC43NzEyMiwwIDEuMzk2NDIsMC42MjUxOSAxLjM5NjQyLDEuMzk2NDFjMCwwLjc3MTIyIC0wLjYyNTIsMS4zOTY0MiAtMS4zOTY0MiwxLjM5NjQyYy0wLjc3MTIyLDAgLTEuMzk2NDIsLTAuNjI1MiAtMS4zOTY0MiwtMS4zOTY0MnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjEwLjIwNTQ3Nzk1NDIzNzY2NTo5Ljg4MTMzNDk5OTk5OTk3OS0tPg==" class="settings-item-icon" alt="">几何度量显示</label><label class="custom-switch-container"><input type="checkbox" id="geometry-measurement-display-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div>
                <div class="settings-item"><div class="settings-item-row"><label for="smooth-panning-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC43MTk1MyIgaGVpZ2h0PSIyMS40MDM0MiIgdmlld0JveD0iMCwwLDIwLjcxOTUzLDIxLjQwMzQyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjY0MDIzLC0xNjkuMjk4MjkpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiI+PGc+PHBhdGggZD0iTTI0MC42OTUwNywxNzguMzc5NTJsLTAuMTAxNjksNy4wMTY0OCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0OC40NzAyNywxODIuNjkxMjFsLTQuNzYxNTQsLTUuNzY2MTgiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuNzY0MTUsMTc4LjA5NzQyYzAuMjQ3NCwtMS4xNTcxNyAxLjE2MDc5LC0xLjk0NDI0IDIuMDQ2MjIsLTEuNzYwMDNjMC4zMDQ5NSwwLjA2MzQ1IDAuNTY3LDAuMjMzODcgMC43Njk5MiwwLjQ3NzQzIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDguNTY4ODYsMTgyLjgyMjk3YzAuMjUzNjcsMC40Mjg0MyAwLjMyMjY2LDAuOTA3MTEgMC4xNDY0NCwxLjMzMTczYy0wLjExOTM5LDAuMjg3NjkgLTAuMzM1ODQsMC41MTMyMiAtMC42MTMwOCwwLjY2Njk4bC01Ljg2NzM1LDEuODM1NjJjLTAuNDkzMjgsMC4wNjc2IC0wLjk2MTI0LC0wLjA1NDUgLTEuMjg0MjUsLTAuMzgxNjVjLTAuMjE4ODQsLTAuMjIxNjQgLTAuMzQyNzQsLTAuNTA4NjIgLTAuMzc2OTEsLTAuODIzOCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ0LjkzMzg4LDE4OC45MDMwOWwtMS4wMjY4MSwtMy4zNjU2NiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni4zNjAwMSwxODUuMDI0MDJsMS4wMjY4MSwzLjAyMzM5IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ0LjkzMzg4LDE4OC40MTgyYzAsLTAuNzA4ODcgMC41NjE4OCwtMS4yODM1MiAxLjI1NDk5LC0xLjI4MzUyYzAuNjkzMTIsMCAxLjI1NDk5LDAuNTc0NjUgMS4yNTQ5OSwxLjI4MzUyYzAsMC43MDg4NyAtMC41NjE4NywxLjI4MzUxIC0xLjI1NDk5LDEuMjgzNTFjLTAuNjkzMTEsMCAtMS4yNTQ5OSwtMC41NzQ2NSAtMS4yNTQ5OSwtMS4yODM1MXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0Mi4yNzg5MSwxODUuNTM3NDNsLTAuMDUyMjksLTcuNjg2ODJsMy4zOTE4LDIuMzI0NTlsMi4xMTA2NywzLjE5NDUyeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjxwYXRoIGQ9Ik0yMzYuOTk1NDEsMTg4Ljg5NTQ0bC0xLjYzNzk0LDAuMDAwMjdjLTAuMDMxNzYsMC4wMDAxMiAtMC4wNjM1NiwtMC4wMDAwNyAtMC4wOTU0NCwtMC4wMDA2Yy0yLjU5Mzk1LC0wLjA0MjQ5IC00LjY2MjkyLC0yLjIxNTYxIC00LjYyMTE3LC00Ljg1Mzg2YzAuMDAwMzUsLTAuMDIwODkgMC4wMDA3OSwtMC4wNDE3NiAwLjAwMTM5LC0wLjA2MjYxbDAuMDY1OTgsLTguOTU4MTJjMC4wMDAzOSwtMC4wMzIyOSAwLjAwMTA3LC0wLjA2NDYzIDAuMDAyMTEsLTAuMDk3MDRjMC4wODI3NCwtMi42MzcyNCAyLjI1MTg4LC00LjcwNjg5IDQuODQ0ODcsLTQuNjIyNzFjMC4wMjA1NSwwLjAwMDY3IDAuMDQxMDUsMC4wMDE0OCAwLjA2MTU0LDAuMDAyNDFsOC45NzU5MiwtMC4wMDMyN2MwLjAzMTc2LC0wLjAwMDUxIDAuMDYzNTYsLTAuMDAwNjkgMC4wOTU0NCwtMC4wMDA1NmMyLjUwOTE2LDAuMDEwOTEgNC41NTA0NSwyLjAyMDc0IDQuNjcxNjYsNC41Mzk5IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxMC4zNTk3NjU0NTE2MTI0MTg6MTAuNzAxNzA5NzYzNjI0NDUtLT4=" class="settings-item-icon" alt="">丝滑移动</label><label class="custom-switch-container"><input type="checkbox" id="smooth-panning-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">划动或缩放后提供惯性反馈</p></div>
            </div>
        </div>
    </div>

    <div id="file-panel" class="sidebar-panel" style="display: none;">
        <div class="menu-file-page-buttons">
            <div class="main-actions-group">
                <div id="new-file-btn" class="btn pill-btn blue-pill-btn" style="gap: 8px;">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMS4yMTcyMSIgaGVpZ2h0PSIxMS4yMjc0MSIgdmlld0JveD0iMCwwLDExLjIxNzIxLDExLjIyNzQxIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjM5MTQsLTE3NC4zODYzMSkiPjxnIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzNC42NDE0MSwxNzguNDYzODhjMCwtMC4xNjMzMiAwLjA1MTAzLC0wLjMxNjQyIDAuMTQyOSwtMC40NTkzMWMwLjA5MTg3LC0wLjE0MjkgMC4yMjQ1NiwtMC4yMzQ3NyAwLjM4Nzg2LC0wLjI4NTc5bDEuMDYxNTIsLTAuMzQ3MDRjMC4xMjI0NywtMC4wNDA4MiAwLjI0NDk3LC0wLjEwMjA3IDAuMzY3NDUsLTAuMTgzNzJjMC4xMjI0NywtMC4wODE2NSAwLjIxNDM1LC0wLjE2MzMyIDAuMzA2MjEsLTAuMjU1MTZjMC4yMDQxNCwtMC4yMDQxNCAwLjMzNjg0LC0wLjQyODY4IDAuNDI4NjksLTAuNjgzODZsMC4zNDcwMywtMS4wNzE3M2MwLjA1MTAzLC0wLjE2MzMxIDAuMTUzMSwtMC4yODU3OSAwLjI4NTc5LC0wLjM4Nzg2YzAuMTMyNjksLTAuMTAyMDcgMC4yOTU5OSwtMC4xNTMxIDAuNDU5MzEsLTAuMTUzMWMwLjE2MzMyLDAgMC4zMjY2MSwwLjA1MTAzIDAuNDU5MzEsMC4xNDI5YzAuMTMyNjksMC4wOTE4NiAwLjI0NDk3LDAuMjI0NTYgMC4yOTU5OSwwLjM4Nzg2bDAuMzQ3MDQsMS4wNjE1MmMwLjA4MTY1LDAuMjY1MzggMC4yMjQ1NCwwLjUwMDEzIDAuNDI4NjksMC43MDQyN2MwLjE5MzkyLDAuMjA0MTQgMC40Mjg2OSwwLjM0NzA0IDAuNzA0MjksMC40Mjg2OWwxLjA1MTMsMC4zNDcwNGMwLjE3MzUyLDAuMDUxMDMgMC4zMDYyMSwwLjE1MzEgMC40MDgyNywwLjI4NTc5YzAuMTAyMDcsMC4xMzI2OSAwLjE1MzEsMC4yOTU5OSAwLjE1MzEsMC40Nzk3M2MwLDAuMTYzMzIgLTAuMDUxMDMsMC4zMTY0MiAtMC4xNTMxLDAuNDU5MzFjLTAuMTAyMDcsMC4xNDI5IC0wLjIyNDU0LDAuMjM0NzcgLTAuMzg3ODYsMC4yODU3OWwtMS4wNjE1MiwwLjM0NzA0Yy0wLjI2NTM4LDAuMDgxNjUgLTAuNTAwMTUsMC4yMjQ1NCAtMC43MDQyOSwwLjQyODY5Yy0wLjEyMjQ3LDAuMTIyNDcgLTAuMjM0NzcsMC4yNzU1OCAtMC4zMDYyMSwwLjQzODljLTAuMDcxNDUsMC4xNjMzMiAtMC4xNDI5LDAuMzI2NjEgLTAuMTkzOTIsMC41MDAxNWMtMC4wNTEwMywwLjE3MzUyIC0wLjEwMjA3LDAuMzM2ODMgLTAuMTUzMSwwLjUwMDE1Yy0wLjA1MTAzLDAuMTYzMzEgLTAuMTEyMjcsMC4zMDYyMSAtMC4xODM3MiwwLjQyODY5Yy0wLjA3MTQ1LDAuMTIyNDcgLTAuMTYzMzIsMC4yMzQ3NyAtMC4yNjUzOCwwLjMwNjIyYy0wLjEwMjA3LDAuMDcxNDUgLTAuMjQ0OTcsMC4xMTIyNyAtMC40Mjg2OSwwLjExMjI3Yy0wLjE2MzMyLDAgLTAuMzI2NjEsLTAuMDUxMDMgLTAuNDU5MzEsLTAuMTQyOWMtMC4xMzI2OSwtMC4wOTE4NiAtMC4yMzQ3NywtMC4yMjQ1NCAtMC4yODU3OSwtMC4zODc4NmwtMC4zNDcwNCwtMS4wNjE1MmMtMC4wMzA2MywtMC4xMDIwNyAtMC4wNzE0NSwtMC4xOTM5MiAtMC4xMTIyNywtMC4yODU3OWMtMC4wNDA4MiwtMC4wOTE4NyAtMC4xMDIwNywtMC4xNzM1MiAtMC4xNjMzMiwtMC4yNTUxNmMtMC4xMzI2OSwtMC4xNzM1MiAtMC4yODU3OSwtMC4zMDYyMiAtMC40NTkzMSwtMC40MDgyOGMtMC4xNzM1MiwtMC4xMDIwNyAtMC4zNDcwNCwtMC4xODM3MiAtMC41MzA3NiwtMC4yNDQ5N2MtMC4xODM3MiwtMC4wNjEyNCAtMC4zNTcyNCwtMC4xMjI0NyAtMC41MzA3NiwtMC4xNjMzMWMtMC4xNzM1MiwtMC4wNDA4MyAtMC4zMjY2MSwtMC4xMDIwNyAtMC40Njk1MiwtMC4xNzM1MmMtMC4xNDI5LC0wLjA3MTQ1IC0wLjI0NDk3LC0wLjE2MzMyIC0wLjMyNjYxLC0wLjI2NTM4Yy0wLjA4MTY1LC0wLjEwMjA3IC0wLjExMjI3LC0wLjI0NDk3IC0wLjExMjI3LC0wLjQyODY4ek0yNDEuNTEwNjcsMTc4LjUwNDcyYy0wLjMwNjIyLC0wLjExMjI3IC0wLjU5MjAxLC0wLjIyNDU2IC0wLjg2NzU5LC0wLjMxNjQyYy0wLjI3NTU5LC0wLjA5MTg2IC0wLjUzMDc2LC0wLjIxNDM0IC0wLjc2NTUxLC0wLjM1NzI0Yy0wLjIzNDc2LC0wLjE0MjkgLTAuNDM4OTEsLTAuMzE2NDIgLTAuNjIyNjIsLTAuNTMwNzZjLTAuMTgzNzIsLTAuMjE0MzQgLTAuMzI2NjEsLTAuNDc5NzMgLTAuNDI4NjksLTAuODI2NzZsLTAuMzM2ODMsLTEuMDUxM2wtMC4zOTgwNiwxLjA1MTNjLTAuMDcxNDUsMC4xOTM5MiAtMC4xNTMxLDAuMzY3NDYgLTAuMjU1MTYsMC41MzA3NmMtMC4xMDIwNywwLjE2MzMxIC0wLjIxNDM1LDAuMzE2NDIgLTAuMzU3MjQsMC40Njk1MmMtMC4xMzI2OSwwLjEzMjY5IC0wLjI4NTc5LDAuMjU1MTYgLTAuNDU5MzEsMC4zNjc0NWMtMC4xNzM1MiwwLjExMjI3IC0wLjM0NzAzLDAuMTkzOTIgLTAuNTMwNzYsMC4yNTUxNmwtMS4wNjE1MiwwLjMzNjgzYzAuMjk1OTksMC4xMTIyNyAwLjU4MTgsMC4yMjQ1NiAwLjg1NzM4LDAuMzE2NDJjMC4yNzU1OCwwLjA5MTg3IDAuNTMwNzYsMC4yMTQzNSAwLjc1NTMxLDAuMzU3MjRjMC4yMjQ1NiwwLjE0MjkgMC40Mzg5MSwwLjMxNjQyIDAuNjIyNjIsMC41MzA3NmMwLjE4MzcyLDAuMjE0MzUgMC4zMjY2MSwwLjQ3OTczIDAuNDI4NjksMC44MTY1NmwwLjMzNjgzLDEuMDUxMzFsMC4zOTgwNiwtMS4wNTEzMWMwLjE0MjksLTAuMzg3ODYgMC4zNTcyNCwtMC43MjQ2OSAwLjYyMjYxLC0xLjAwMDI4YzAuMjY1MzgsLTAuMjc1NTggMC42MDIyMiwtMC40ODk5MiAxLjAwMDI4LC0wLjYxMjQxek0yNDAuNzY1NTYsMTgzLjAzNjU5YzAsLTAuMTIyNDcgMC4wNDA4MiwtMC4yMzQ3NyAwLjEyMjQ3LC0wLjMzNjgzYzAuMDgxNjUsLTAuMTAyMDcgMC4xNzM1MiwtMC4xNzM1MiAwLjI5NjAxLC0wLjIxNDM1bDAuNTkyMDEsLTAuMTkzOTJjMC4xMzI2OSwtMC4wNDA4MiAwLjI0NDk3LC0wLjExMjI3IDAuMzE2NDIsLTAuMjA0MTRjMC4wNzE0NSwtMC4wOTE4NiAwLjEzMjcsLTAuMTkzOTIgMC4xODM3MiwtMC4zMDYyMWMwLjA1MTAzLC0wLjExMjI3IDAuMDgxNjUsLTAuMjM0NzcgMC4xMTIyNywtMC4zNDcwNGMwLjAzMDYzLC0wLjExMjI3IDAuMDcxNDUsLTAuMjI0NTQgMC4xMjI0NywtMC4zMjY2MWMwLjA1MTAzLC0wLjEwMjA3IDAuMTEyMjcsLTAuMTczNTIgMC4xOTM5MiwtMC4yNDQ5N2MwLjA4MTY1LC0wLjA3MTQ1IDAuMTkzOTIsLTAuMDkxODcgMC4zNDcwNCwtMC4wOTE4N2MwLjEyMjQ3LDAgMC4yNDQ5NywwLjA0MDgzIDAuMzU3MjMsMC4xMTIyN2MwLjExMjI3LDAuMDcxNDUgMC4xODM3MiwwLjE3MzUyIDAuMjI0NTYsMC4yOTU5OWMwLjAyMDQyLDAuMDgxNjUgMC4wNTEwMywwLjE2MzMyIDAuMDcxNDQsMC4yNDQ5N2MwLjAyMDQyLDAuMDgxNjUgMC4wNTEwMywwLjE2MzMxIDAuMDcxNDUsMC4yMzQ3N2MwLjAyMDQyLDAuMDcxNDUgMC4wNjEyNCwwLjE1MzEgMC4xMDIwNywwLjIyNDU0YzAuMDQwODMsMC4wNzE0NSAwLjA5MTg2LDAuMTQyOSAwLjE1MzEsMC4yMDQxNGMwLjA2MTI0LDAuMDcxNDUgMC4xNDI5LDAuMTIyNDcgMC4yMzQ3NiwwLjE2MzMyYzAuMDkxODcsMC4wNDA4MyAwLjE4MzcyLDAuMDcxNDUgMC4yODU3OSwwLjEwMjA3YzAuMTAyMDcsMC4wMzA2MyAwLjE5MzkyLDAuMDYxMjQgMC4yOTU5OSwwLjA5MTg3YzAuMTAyMDcsMC4wMzA2MiAwLjE4MzcyLDAuMDcxNDUgMC4yNTUxNiwwLjEyMjQ3YzAuMDcxNDUsMC4wNTEwMyAwLjEzMjcsMC4xMTIyNyAwLjE4MzcyLDAuMTkzOTJjMC4wNTEwMywwLjA4MTY1IDAuMDcxNDUsMC4xNzM1MiAwLjA3MTQ1LDAuMjk1OTljMCwwLjEzMjY5IC0wLjA0MDgzLDAuMjU1MTYgLTAuMTEyMjcsMC4zNTcyNGMtMC4wNzE0NSwwLjEwMjA3IC0wLjE3MzUyLDAuMTgzNzIgLTAuMzA2MjEsMC4yMjQ1NGMtMC4wNzE0NSwwLjAyMDQyIC0wLjE1MzEsMC4wNTEwMyAtMC4yMzQ3NywwLjA3MTQ1Yy0wLjA4MTY1LDAuMDIwNDIgLTAuMTYzMzEsMC4wNTEwMyAtMC4yNDQ5NywwLjA3MTQ1Yy0wLjA4MTY1LDAuMDIwNDIgLTAuMTYzMzIsMC4wNjEyNCAtMC4yMzQ3NywwLjEwMjA3Yy0wLjA3MTQ1LDAuMDQwODMgLTAuMTQyODksMC4wOTE4NyAtMC4yMDQxNCwwLjE1MzFjLTAuMDkxODYsMC4xMDIwNyAtMC4xNjMzMiwwLjIyNDU2IC0wLjIxNDM1LDAuMzc3NjZjLTAuMDUxMDMsMC4xNTMxIC0wLjA5MTg3LDAuMjk2MDEgLTAuMTQyOSwwLjQzODkxYy0wLjA1MTAzLDAuMTQyOSAtMC4xMjI0NywwLjI2NTM4IC0wLjIwNDEzLDAuMzU3MjNjLTAuMDgxNjUsMC4wOTE4NyAtMC4yMjQ1NiwwLjE1MzEgLTAuNDA4MjgsMC4xNTMxYy0wLjEyMjQ3LDAgLTAuMjQ0OTcsLTAuMDQwODMgLTAuMzU3MjMsLTAuMTEyMjdjLTAuMTEyMjcsLTAuMDcxNDUgLTAuMTgzNzIsLTAuMTczNTIgLTAuMjI0NTQsLTAuMjk1OTljLTAuMDIwNDIsLTAuMDcxNDUgLTAuMDUxMDMsLTAuMTUzMSAtMC4wNzE0NSwtMC4yMzQ3N2MtMC4wMjA0MiwtMC4wODE2NSAtMC4wNTEwMywtMC4xNjMzMSAtMC4wNzE0NSwtMC4yNDQ5N2MtMC4wMjA0MiwtMC4wODE2NSAtMC4wNjEyNCwtMC4xNjMzMiAtMC4xMDIwNywtMC4yMzQ3N2MtMC4wNDA4MiwtMC4wNzE0NSAtMC4wOTE4NywtMC4xNDI5IC0wLjE0MjksLTAuMTkzOTJjLTAuMDcxNDUsLTAuMDcxNDUgLTAuMTUzMSwtMC4xMjI0NyAtMC4yNDQ5NywtMC4xNjMzMWMtMC4wOTE4NiwtMC4wNDA4MyAtMC4xODM3MiwtMC4wNzE0NSAtMC4yODU3OSwtMC4xMDIwN2MtMC4xMDIwNywtMC4wMzA2MiAtMC4xOTM5MiwtMC4wNjEyNCAtMC4yODU3OSwtMC4wOTE4NmMtMC4wOTE4NiwtMC4wMzA2MyAtMC4xODM3MiwtMC4wNzE0NSAtMC4yNTUxNiwtMC4xMjI0N2MtMC4wNzE0NSwtMC4wNTEwMyAtMC4xMzI2OSwtMC4xMTIyNyAtMC4xODM3MiwtMC4xOTM5MmMtMC4wNTEwMywtMC4wODE2NSAtMC4wNjEyNCwtMC4yMDQxNCAtMC4wNjEyNCwtMC4zMzY4M3pNMjQ0LjI0NjExLDE4My4wNjcxN2MtMC4xNzM1MiwtMC4wNTEwMyAtMC4zMTY0MiwtMC4xMTIyNyAtMC40NDkxMSwtMC4xODM3MmMtMC4xMzI2OSwtMC4wNzE0NSAtMC4yMzQ3NywtMC4xNTMxIC0wLjMyNjYxLC0wLjI0NDk3Yy0wLjA5MTg3LC0wLjA5MTg3IC0wLjE3MzUyLC0wLjIwNDE0IC0wLjIzNDc3LC0wLjMyNjYxYy0wLjA2MTI0LC0wLjEyMjQ3IC0wLjEzMjY5LC0wLjI3NTU4IC0wLjE5MzkyLC0wLjQzODkxYy0wLjA1MTAzLDAuMTYzMzIgLTAuMTAyMDcsMC4zMDYyMSAtMC4xNzM1MiwwLjQyODY5Yy0wLjA3MTQ1LDAuMTIyNDcgLTAuMTUzMSwwLjIzNDc3IC0wLjI0NDk3LDAuMzI2NjFjLTAuMDkxODYsMC4wOTE4NiAtMC4yMDQxMywwLjE4MzcyIC0wLjMyNjYxLDAuMjU1MTZjLTAuMTIyNDcsMC4wNzE0NSAtMC4yNjUzOCwwLjEzMjY5IC0wLjQyODY5LDAuMTgzNzJjMC4zMjY2MSwwLjA5MTg2IDAuNTgxOCwwLjIzNDc2IDAuNzY1NTEsMC40Mjg2OGMwLjE4MzcyLDAuMTkzOTIgMC4zMjY2MSwwLjQ0OTExIDAuNDI4NjgsMC43NjU1MmMwLjA2MTI0LC0wLjE3MzUyIDAuMTIyNDcsLTAuMzE2NDIgMC4xODM3MiwtMC40Mzg5MWMwLjA2MTI0LC0wLjEyMjQ3IDAuMTQyOSwtMC4yMzQ3NyAwLjIzNDc3LC0wLjMyNjYxYzAuMDkxODYsLTAuMDkxODYgMC4xOTM5MiwtMC4xNzM1MiAwLjMxNjQyLC0wLjIzNDc2YzAuMTIyNDcsLTAuMDYxMjQgMC4yNzU1OSwtMC4xMzI2OSAwLjQ0OTExLC0wLjE5MzkyeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuNjA4NTk1MDAwMDAwMDA4OjUuNjEzNjk0OTk5OTk5OTUtLT4=" alt="新文件" style="width: 20px; height: 20px; filter: invert(1);">
                    <span>创建文件</span>
                </div>
                <div id="load-file-btn" class="btn pill-btn blue-pill-btn" style="gap: 8px;">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMS45NTU3NSIgaGVpZ2h0PSIxMC42MTU4MSIgdmlld0JveD0iMCwwLDExLjk1NTc1LDEwLjYxNTgxIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjk1OTExLC0xNzQuNjkyMDkpIj48ZyBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PGc+PHBhdGggZD0iTTIzNC4zMzUxOCwxODMuMzA0NXYtNi42MDg5OWMwLC0wLjI2OTc2IDAsLTAuNDA0NjQgMC4xMzQ4NywtMC42NzQzOWMwLjEzNDg3LC0wLjI2OTc2IDAuMjY5NzYsLTAuNDA0NjMgMC40MDQ2MywtMC41Mzk1MWMwLjEzNDg4LC0wLjEzNDg3IDAuNDA0NjMsLTAuMjY5NzYgMC41Mzk1MSwtMC40MDQ2M2MwLjI2OTc1LC0wLjEzNDg3IDAuNDA0NjMsLTAuMTM0ODggMC42NzQzOCwtMC4xMzQ4OGgyLjE1ODA0YzAuMjY5NzYsMCAwLjUzOTUyLDAuMDAwMDEgMC42NzQzOSwwLjEzNDg4YzAuMTM0ODcsMC4xMzQ4NyAwLjQwNDYzLDAuMTM0ODggMC41Mzk1LDAuMjY5NzVjMC4xMzQ4OCwwLjEzNDg3IDAuMjY5NzYsMC4yNjk3NiAwLjQwNDY0LDAuNDA0NjNjMC4xMzQ4OCwwLjEzNDg3IDAuMjY5NzUsMC40MDQ2MyAwLjQwNDYzLDAuNTM5NTFoMy4xMDIxOGMwLjI2OTc2LDAgMC40MDQ2MywwLjAwMDAxIDAuNjc0MzksMC4xMzQ4OGMwLjI2OTc2LDAuMTM0ODcgMC40MDQ2MywwLjI2OTc2IDAuNTM5NTEsMC40MDQ2M2MwLjEzNDg4LDAuMTM0ODcgMC4yNjk3NiwwLjQwNDY0IDAuNDA0NjMsMC41Mzk1MWMwLjEzNDg4LDAuMjY5NzYgMC4xMzQ4OCwwLjQwNDYzIDAuMTM0ODgsMC42NzQzOWMwLjEzNDg3LDAuMTM0ODcgMC4yNjk3NiwwLjI2OTc1IDAuNDA0NjMsMC41Mzk1MWMwLjEzNDg3LDAuMTM0ODcgMC4xMzQ4NywwLjQwNDYzIDAuMTM0ODcsMC42NzQzOWMwLDAgMCwwIDAsMC4xMzQ4N2MwLDAgMCwwLjAwMDAxIDAsMC4xMzQ4OGwtMC41Mzk1MSw0LjA0NjMyYzAsMC4yNjk3NiAtMC4xMzQ4OCwwLjQwNDY0IC0wLjEzNDg4LDAuNTM5NTFjMCwwLjEzNDg3IC0wLjI2OTc2LDAuNDA0NjMgLTAuNDA0NjMsMC41Mzk1MWMtMC4xMzQ4OCwwLjEzNDg3IC0wLjI2OTc1LDAuMjY5NzYgLTAuNTM5NTEsMC4yNjk3NmMtMC4xMzQ4NywwLjEzNDg3IC0wLjQwNDYzLDAuMTM0ODggLTAuNjc0MzksMC4xMzQ4OGgtNy4yMzI1NGMwLjA5ODk0LC0wLjE2MTUzIDAuMTYyMjEsLTAuMzQ3MjcgMC4xNzg4NywtMC41NDYyNmw2LjkxODg0LC0wLjEyODEyYzAuMTM0ODcsMCAwLjI2OTc2LDAgMC40MDQ2MywwYzAuMTM0ODcsMCAwLjI2OTc2LC0wLjEzNDg4IDAuMjY5NzYsLTAuMTM0ODhjMCwwIDAuMTM0ODgsLTAuMTM0ODggMC4yNjk3NSwtMC4yNjk3NmMwLjEzNDg4LC0wLjEzNDg3IDAuMTM0ODgsLTAuMjY5NzYgMC4xMzQ4OCwtMC40MDQ2M2wwLjUzOTUxLC00LjA0NjMyYzAsLTAuMTM0ODcgMCwtMC4xMzQ4OCAwLC0wLjI2OTc2YzAsLTAuMTM0ODcgLTAuMTM0ODgsLTAuMTM0ODggLTAuMTM0ODgsLTAuMjY5NzZjMCwtMC4xMzQ4NyAtMC4xMzQ4OCwtMC4xMzQ4OCAtMC4yNjk3NiwtMC4xMzQ4OGMtMC4xMzQ4NywwIC0wLjEzNDg4LDAgLTAuMjY5NzUsMGMtMC4xMzQ4OCwwIC03LjAxMzYzLDAgLTcuMTQ4NSwwYy0wLjEzNDg3LDAgLTAuMTM0ODgsMC4wMDAwMSAtMC4yNjk3NiwwLjEzNDg4Yy0wLjEzNDg3LDAuMTM0ODcgLTAuMTM0ODcsMC4xMzQ4NyAtMC4xMzQ4NywwLjEzNDg3YzAsMCAtMC4xMzQ4NywwLjEzNDg4IC0wLjEzNDg3LDAuMjY5NzZsLTAuODQ0LDMuOTAzNTFjLTAuMTcyNTEsLTAuMDg5ODQgLTAuMzY4NiwtMC4xNDA2MiAtMC41NzY1NiwtMC4xNDA2MmMtMC4wMzYyMSwwIC0wLjA3MjA3LDAuMDAxNTQgLTAuMTA3NSwwLjAwNDU2bDAuODUzNjMsLTMuOTAyMzJjMCwtMC4xMzQ4NyAwLjEzNDg3LC0wLjI2OTc2IDAuMTM0ODcsLTAuNDA0NjRjMCwtMC4xMzQ4NyAwLjEzNDg4LC0wLjI2OTc2IDAuMjY5NzYsLTAuNDA0NjNjMC4xMzQ4NywtMC4xMzQ4NyAwLjI2OTc2LC0wLjEzNDg4IDAuNDA0NjMsLTAuMjY5NzZjMC4xMzQ4OCwtMC4xMzQ4NyAwLjI2OTc2LC0wLjEzNDg3IDAuNTM5NTEsLTAuMTM0ODdsNy4xNDg1MSwtMC4xMzQ4OGMtMC4xMzQ4NywwIC0wLjEzNDg3LDAgMCwwYy0wLjEzNDg3LDAgMCwwIDAsMGMwLC0wLjEzNDg3IC0wLjEzNDg4LC0wLjI2OTc2IC0wLjEzNDg4LC0wLjI2OTc2YzAsMCAtMC4xMzQ4OCwtMC4xMzQ4OCAtMC4yNjk3NiwtMC4yNjk3NmMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4xMzQ4OCwtMC4xMzQ4NyAtMC4yNjk3NiwtMC4xMzQ4N2MtMC4xMzQ4NywwIC0wLjI2OTc1LDAgLTAuMjY5NzUsMGgtMy4zNzE5NGwtMC44MDkyNiwtMC45NDQxNWMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4yNjk3NiwtMC4yNjk3NiAtMC40MDQ2MywtMC4yNjk3NmMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4yNjk3NiwtMC4xMzQ4NyAtMC41Mzk1MSwtMC4xMzQ4N2gtMi4xNTgwNGMtMC4xMzQ4OCwwIC0wLjI2OTc2LDAgLTAuNDA0NjQsMC4xMzQ4N2MtMC4xMzQ4OCwwIC0wLjI2OTc1LDAuMTM0ODggLTAuNDA0NjMsMC4yNjk3NmMtMC4xMzQ4OCwwLjEzNDg3IC0wLjEzNDg4LDAuMjY5NzYgLTAuMjY5NzUsMC40MDQ2NGMtMC4xMzQ4OCwwLjEzNDg3IC0wLjEzNDg4LDAuMjY5NzYgLTAuMTM0ODgsMC40MDQ2M3Y2LjA3MTRjLTAuMTk5NDEsMC4wMzE3NCAtMC4zODMxMSwwLjExMDYzIC0wLjUzOTI5LDAuMjI0OWMtMC4wMDAyMywtMC4wMjkwMSAtMC4wMDAyMywtMC4wNTk1IC0wLjAwMDIzLC0wLjA5MTk0eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNS41NjEwMSwxODQuNTI0MDFsLTAuNzMyNDMsLTAuOTc2NTciIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PHBhdGggZD0iTTIzNC43MDkxMSwxODMuNDc3MjZ2LTYuNjI5NzYiIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4wNDA4OTQ5OTk5OTk5NDk6NS4zMDc5MDUwMDAwMDAwMDUtLT4=" alt="加载存档" style="width: 20px; height: 20px; filter: invert(1);">
                    <span>加载存档</span>
                </div>
                <div id="save-file-btn" class="btn pill-btn blue-pill-btn" style="gap: 8px;">
                    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi41NTEwMyIgaGVpZ2h0PSIxMS4wMjY3OCIgdmlld0JveD0iMCwwLDEyLjU1MTAzLDExLjAyNjc4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjcyNDQ4LC0xNzQuNDg2NikiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjQ1LjUyNTQ5LDE4Mi40MTEyNmwtMC4wMDI4MiwwLjQyMzM0Yy0wLjAwMDE0LDAuMDEzMTQgLTAuMDAwNDIsMC4wMjYzMiAtMC4wMDA4MiwwLjAzOTUxYy0wLjAzMjk1LDEuMDczOTIgLTAuOTE1NjMsMS45MTczIC0xLjk3MTUzLDEuODgzNzRjLTAuMDA4MzYsLTAuMDAwMjcgLTAuMDE2NzIsLTAuMDAwNTkgLTAuMDI1MDYsLTAuMDAwOTZsLTEuNTg0MjIsMC4wMDE2OGwtNC41MjI0NSwwLjAwMzU0bC0wLjk2ODMxLDAuMDAxMDJjLTAuMDEyOTIsMC4wMDAyMSAtMC4wMjU4OCwwLjAwMDMgLTAuMDM4ODYsMC4wMDAyNmMtMS4wNTY0LC0wLjAwMzg1IC0xLjkwOTc0LC0wLjg3Nzk3IC0xLjkwNTk3LC0xLjk1MjRjMC4wMDAwMywtMC4wMDg1MSAwLjAwMDEyLC0wLjAxNzAxIDAuMDAwMjYsLTAuMDI1NTFsLTAuMDAxMjcsLTAuMjU0NDdsLTAuMDI5OTMsLTIuOTAyMzJsMC4wMDMxMiwtMC40MjMzNGMwLjAwMDE1LC0wLjAxMzE0IDAuMDAwNDQsLTAuMDI2MzIgMC4wMDA4NSwtMC4wMzk1MWMwLjAzMzcsLTEuMDczODggMC45MTY5NywtMS45MTY2NiAxLjk3MjgzLC0xLjg4MjM4YzAuMDA4MzYsMC4wMDAyNyAwLjAxNjcyLDAuMDAwNiAwLjAyNTA2LDAuMDAwOThsMS41ODQyMiwtMC4wMDA1OGw0LjUyMjQ2LC0wLjAwMDQxbDAuOTY4MzEsLTAuMDAwMzVjMC4wMTI5MiwtMC4wMDAyMSAwLjAyNTg4LC0wLjAwMDI4IDAuMDM4ODYsLTAuMDAwMjNjMS4wNTYzOSwwLjAwNDU5IDEuOTA5MTIsMC44NzkyOSAxLjkwNDYyLDEuOTUzNzFjLTAuMDAwMDMsMC4wMDg1MSAtMC4wMDAxMiwwLjAxNzAxIC0wLjAwMDI3LDAuMDI1NTFsMC4wMDEwOCwwLjI1NDQ3eiIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNC40OTUwOCwxNzkuOTA2NTZsMC4wMjI2NywtMi40NzE0M2wwLjAwMjUsLTAuMzk2NjljMC4wMDAxMiwtMC4wMTIzMiAwLjAwMDM1LC0wLjAyNDY2IDAuMDAwNjksLTAuMDM3MDNjMC4wMjcwNSwtMS4wMDYyOCAwLjczNTk2LC0xLjc5NTk5IDEuNTgzNCwtMS43NjM4NmMwLjAwNjcxLDAuMDAwMjYgMC4wMTM0MiwwLjAwMDU2IDAuMDIwMTEsMC4wMDA5MmwyLjkzMzQ5LC0wLjAwMTI1YzAuMDEwMzcsLTAuMDAwMTkgMC4wMjA3NywtMC4wMDAyNiAwLjAzMTE5LC0wLjAwMDIxYzAuODQ3ODYsMC4wMDQzIDEuNTMyMjUsMC44MjM5MyAxLjUyODYzLDEuODMwNzFjLTAuMDAwMDMsMC4wMDc5OSAtMC4wMDAxLDAuMDE1OTQgLTAuMDAwMjIsMC4wMjM5bDAuMDAwODcsMC4yMzg0NSIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOS43NTY2NiwxNzkuNDMzMDh2Mi42MDU4MiIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjU2NTk5LDE4Mi43MzgwM2wtMC44MjYyNCwtMS4yNzExMyIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjgyMDIxLDE4Mi43MzgwM2wwLjg4OTc5LC0xLjI3MTEzIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjI3NTUxODUwMDI1NzczMjo1LjUxMzM5Nzk2NzI5NjQ5OC0tPg==" alt="保存存档" style="width: 20px; height: 20px; filter: invert(1);">
                    <span>保存存档</span>
                </div>
                <div id="load-js-op-btn" class="btn pill-btn blue-pill-btn">加载js运算符</div>
            </div>
            <div class="example-actions-group">
             
            </div>
        </div>
    </div>

<div id="about-panel" class="sidebar-panel" style="display: none;">
        <div class="menu-about-page-content">
            <div class="about-icon-container">
                <img src="data:image/svg+xml;base64,PHN2ZyBpZD0i5Zu+5bGCXzEiIGRhdGEtbmFtZT0i5Zu+5bGCIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCA4NC40IDg0LjYiPjxkZWZzPjxzdHlsZT4uY2xzLTEsLmNscy0xMCwuY2xzLTExLC5jbHMtMTIsLmNscy0xMywuY2xzLTE0e2ZpbGw6bm9uZTt9LmNscy0ye2NsaXAtcGF0aDp1cmwoI2NsaXAtcGF0aCk7fS5jbHMtM3tmaWxsOnVybCgj5pyq5ZG95ZCN55qE5riQ5Y+YKTt9LmNscy00e2ZpbGw6I2ZmZjt9LmNscy01e2ZpbGw6dXJsKCPmnKrlkb3lkI3nmoTmuJDlj5hfMik7fS5jbHMtNntmaWxsOiMzMzg3YmE7fS5jbHMtN3tmaWxsOnVybCgj5pyq5ZG95ZCN55qE5riQ5Y+YXzMpO30uY2xzLTh7ZmlsbDp1cmwoI+acquWRveWQjeeahOa4kOWPmF80KTt9LmNscy05e2ZpbGw6dXJsKCPmnKrlkb3lkI3nmoTmuJDlj5hfNSk7fS5jbHMtMTB7c3Ryb2tlOiNiOWI5Yjk7c3Ryb2tlLW9wYWNpdHk6MC41O3N0cm9rZS13aWR0aDoyLjVweDt9LmNscy0xMCwuY2xzLTExLC5jbHMtMTIsLmNscy0xMywuY2xzLTE0e3N0cm9rZS1taXRlcmxpbWl0OjEwO30uY2xzLTExLC5jbHMtMTIsLmNscy0xNHtzdHJva2UtbGluZWNhcDpyb3VuZDt9LmNscy0xMSwuY2xzLTEye3N0cm9rZS13aWR0aDoxMHB4O30uY2xzLTExe3N0cm9rZTp1cmwoI+acquWRveWQjeeahOa4kOWPmF82KTt9LmNscy0xMntzdHJva2U6dXJsKCPmnKrlkb3lkI3nmoTmuJDlj5hfNyk7fS5jbHMtMTMsLmNscy0xNHtzdHJva2U6I2ZmZjtzdHJva2Utd2lkdGg6MS41cHg7fTwvc3R5bGU+PGNsaXBQYXRoIGlkPSJjbGlwLXBhdGgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiPjxyZWN0IGNsYXNzPSJjbHMtMSIgeD0iMC45NiIgeT0iMS4wMSIgd2lkdGg9IjgyLjQ3IiBoZWlnaHQ9IjgyLjQ3IiByeD0iMTgiLz48L2NsaXBQYXRoPjxsaW5lYXJHcmFkaWVudCBpZD0i5pyq5ZG95ZCN55qE5riQ5Y+YIiB4MT0iMjgwLjM2IiB5MT0iLTEyNi4zOCIgeDI9IjE5OS4yNSIgeTI9Ii02MS40NiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMSwgLTE5Ny44LCAtNTEuNykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMxYjE3NGUiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM2NzAwNTQiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0i5pyq5ZG95ZCN55qE5riQ5Y+YXzIiIHgxPSIxOTgiIHkxPSItMTAxLjMiIHgyPSIyNzEuOTgiIHkyPSItMTAxLjMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgLTEsIC0xOTcuOCwgLTUxLjcpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjNDA5NWZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNjJkMGUwIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9IuacquWRveWQjeeahOa4kOWPmF8zIiB4MT0iMjYzIiB5MT0iLTEwNS41IiB4Mj0iMTk3Ljg3IiB5Mj0iLTEwNS41IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAtMTk3LjgsIC01MS43KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzVkMWY3YyIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzMwOTBiZiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSLmnKrlkb3lkI3nmoTmuJDlj5hfNCIgeDE9IjIwOS42MSIgeTE9Ii0xMjIuOTUiIHgyPSIxOTcuOTMiIHkyPSItMTIyLjk1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIC0xLCAtMTk3LjgsIC01MS43KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzM1ODFiNiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzMwOGZiZiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSLmnKrlkb3lkI3nmoTmuJDlj5hfNSIgeDE9IjI0NC43NyIgeTE9Ii0xMzEuOCIgeDI9IjIwNS4zOCIgeTI9Ii0xMzEuOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMSwgLTE5Ny44LCAtNTEuNykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiMwMDM2YTMiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNDg3YmEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0i5pyq5ZG95ZCN55qE5riQ5Y+YXzYiIHgxPSIyMTUuMzUiIHkxPSItMTE1LjY1IiB4Mj0iMjcwLjY1IiB5Mj0iLTExNS42NSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAtMSwgLTE5Ny44LCAtNTEuNykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNlMjAwYzQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmJkYzAiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0i5pyq5ZG95ZCN55qE5riQ5Y+YXzciIHgxPSIyMTQuMDIiIHkxPSItOTEuNDYiIHgyPSIyNDAuNjEiIHkyPSItODkuOTQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgLTEsIC0xOTcuOCwgLTUxLjcpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZTMwN2M0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZiMGIwIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PGcgY2xhc3M9ImNscy0yIj48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0xNy42LDg0LjVhMjQuNTIsMjQuNTIsMCwwLDEtMi43LS4yLDksOSwwLDAsMC0xLjYtLjNjLS4xLDAtLjItLjEtLjMtLjFhNC44OCw0Ljg4LDAsMCwxLS43LS4zYy0uMSwwLS4yLS4xLS4zLS4xaC0uM2EuMS4xLDAsMCwxLS4xLS4xaDBjLS42LS4zLTEuMy0uNi0yLS45LS4xLDAtLjEtLjEtLjItLjFoMGwtLjEtLjFhNC4zNSw0LjM1LDAsMCwxLS43LS40SDguNWExMS44LDExLjgsMCwwLDEtMS44LTEuMy4xLjEsMCwwLDAtLjEtLjFjLS4yLS4xLS40LS4zLS42LS40bC0uMi0uMi0uMy0uM3YtLjFsLS4xLS4xLS41LS41aDBsLS4xLS4xYTEyLDEyLDAsMCwwLTEuMS0xLjJjMC0uMS0uMS0uMS0uMS0uMmExMC4xNCwxMC4xNCwwLDAsMC0uOS0xLjNjLS40LS43LS44LTEuNS0xLjItMi4zYTE1Ljg3LDE1Ljg3LDAsMCwwLS43LTJoMHYtLjJhLjM3LjM3LDAsMCwwLS4xLS4zaDB2LS43Yy0uMS0uMi0uMS0uNC0uMi0uNmExMSwxMSwwLDAsMS0uMi0xLjhWNjAuOGgwTDAsMTcuNmExOC42MSwxOC42MSwwLDAsMSwuNC0zLjRMLjcsMTNhMTMuMzYsMTMuMzYsMCwwLDEsLjctMS44LDkuMTQsOS4xNCwwLDAsMCwuNy0xLjRBMTcuNTYsMTcuNTYsMCwwLDEsMTcuOS40aC4zTDY2LjQsMEExNy42LDE3LjYsMCwwLDEsODQsMTcuNXYuM2wuNCw0OS40YTE3Ljc3LDE3Ljc3LDAsMCwxLTcuNywxNC4xYy0xLjUuNi00LjgsMS43LTUuOCwyLjNhLjIyLjIyLDAsMCwwLS4yLjJjLS4xLDAtLjIuMS0uMy4xYTE3LjIyLDE3LjIyLDAsMCwxLTMuOS40aC0uN1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik0xMi42LDg0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy01IiBkPSJNNzQuMiw4MS41di45YTcuNDYsNy40NiwwLDAsMC0xLjIuN2MtLjIsMC0uNC4xLS42LjFhNSw1LDAsMCwwLTIuNy44SDY5Yy0yLDAtNC4xLjItNi4xLjJINTAuNWEzMi43LDMyLjcsMCwwLDAtNC40LjRINDIuNWMtMS4zLDAtMi41LS4yLTMuOC0uMmE1Ljg2LDUuODYsMCwwLDEtMi4zLS4xLDQyLjc4LDQyLjc4LDAsMCwwLTYuMi0uMUgyNmExMC41NCwxMC41NCwwLDAsMC0zLjYtLjNoLS4xYy0xLS4xLTIuMS0uNS0zLjEtLjUtMS45LS4yLTMuNi0yLTUuNC0yLjZBMTguNTEsMTguNTEsMCwwLDEsOC40LDc4Yy0xLjQtLjctMy45LTIuNC00LjYtMy44LTEuMi0xLjEtMy0zLjQtMy01LjFBNjAuNzgsNjAuNzgsMCwwLDEsLjUsNjNWNTYuOGMwLTIuMS0uMi00LjEtLjItNi4xUy4xLDQ2LjYuMSw0NC42VjE1YTU3LjkyLDU3LjkyLDAsMCwxLDcuMi0uNEE2Ny4wOSw2Ny4wOSwwLDAsMSw3NC4yLDgxLjVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNOS4yLDgxLjZhLjU5LjU5LDAsMCwxLS45LjJsLS40LS4zYTEwLjU5LDEwLjU5LDAsMCwxLTEuMi0xLC42NS42NSwwLDAsMSwuMS0xLC42NC42NCwwLDAsMSwxLC4xLDYuNDcsNi40NywwLDAsMCwuOS44bC40LjNjLS4xLDAsLjUuMy4xLjlaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy03IiBkPSJNNjUuMiw4MS45djEuNWMtLjQuMi0uNy4zLS45LjRzLS4yLjEtLjMuM0g2MC43Yy0xLjgsMC0zLjYuMi01LjQuMkg0NC41Yy0xLjMsMC0yLjYuMi0zLjkuM0gzNy40Yy0xLjEsMC0yLjItLjItMy4zLS4yLS42LDAtMS41LjItMi0uMWE1MC40OCw1MC40OCwwLDAsMC01LjUtLjFIMjIuOWE2LjY5LDYuNjksMCwwLDAtMy4yLS4yaC0uMWMtLjktLjEtMS45LS40LTIuNy0uNS0xLjctLjItMy4yLTEuOC00LjctMi4zYTE2LjMzLDE2LjMzLDAsMCwxLTQuNy0yLjVjLTEuMi0uNi0zLjQtMi4xLTQuMS0zLjQtMS4xLS45LTIuNi0zLTIuNy00LjVhNDcuNTQsNDcuNTQsMCwwLDEtLjMtNS40VjYwYzAtMS44LS4yLTMuNi0uMi01LjRTMCw1MSwwLDQ5LjJWMjMuM1EzLjE1LDIzLDYuMywyM0E1OSw1OSwwLDAsMSw2NS4yLDgxLjlaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy04IiBkPSJNLjgsNjEuNWExOC43MywxOC43MywwLDAsMCwxLjksNS4yYy41LjgsMi41LDIuNiwyLjcsMy41QzYsNzMuNyw4LjYsNzcuOSwxMS44LDgxSDYuMWEuMS4xLDAsMCwwLS4xLS4xLDEuNzYsMS43NiwwLDAsMS0uNS0uNGMtLjItLjEtLjMtLjMtLjUtLjRWODBsLS4xLS4xLS41LS41aDBsLS4xLS4xYTExLDExLDAsMCwwLTEtMS4xLDE1LjI2LDE1LjI2LDAsMCwwLTEuMS0xLjZ2LS4xbC0uMS0uMWMwLS4xLS4xLS4xLS4xLS4ydi0uMUwxLjksNzZjMC0uMS0uMS0uMS0uMS0uMmgwdi0uMWMtLjEtLjEtLjEtLjMtLjItLjRhMTcsMTcsMCwwLDAtLjktMi40di0uMWEuMS4xLDAsMCwwLS4xLS4xdi0uM2EuOS45LDAsMCwwLS4xLS41Yy0uMS0uNC0uMi0uOS0uMy0xLjNWNjNaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy05IiBkPSJNOSw3NS45Yy4xLDAsLjEuMS4yLjFhMS42OSwxLjY5LDAsMCwwLC41LjIsNS43Myw1LjczLDAsMCwwLDEuNC40YzIuNS45LDUuNSw0LjgsNy4xLDYuNi4zLjQuNi43LjksMS4xaC01YTguNTgsOC41OCwwLDAsMC0xLjctLjMsNi44OSw2Ljg5LDAsMCwxLS44LS4zYy0uMSwwLS4yLS4xLS4zLS4xSDExYTE1LjM5LDE1LjM5LDAsMCwwLTEuOS0uOC4xLjEsMCwwLDEtLjEtLjF2LS4xbC0uMS0uMWMtLjMtLjEtLjQtLjMtLjctLjRIOC4xYTQuNDcsNC40NywwLDAsMS0uMi0zLjRaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy0xMCIgZD0iTTU0LjYuNGMzLjIsMjkuNSwyOC43LDI4LjgsMjguNywyOC44QzU1LDI3LjcsNTQuNi40LDU0LjYuNFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTEwIiBkPSJNNDcuMy44YzQuMSwzNy42LDM2LjYsMzYuNywzNi42LDM2LjdDNDcuOCwzNS42LDQ3LjMuOCw0Ny4zLjhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy0xMSIgZD0iTTE3LjYsNjQuMWw1NS4zLS4zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy0xMiIgZD0iTTQxLjQsMTQsMTcuNiw2NCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTMiIGQ9Ik02NC42LDkuOFY5LjdhMS43OSwxLjc5LDAsMCwxLDEuOC0xLjguOS45LDAsMCwxLC41LjEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTE0IiBkPSJNNjcuMiw4bC0uNC0uMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTQiIGQ9Ik02NC42LDE2VjkuOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTQiIGQ9Ik02NS45LDExSDYzLjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTEzIiBkPSJNNzIuNiwxMi4yYTIuODQsMi44NCwwLDAsMSwuNywxLjcsMi44NywyLjg3LDAsMCwxLS43LDEuOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTMiIGQ9Ik02Ny45LDE1LjZhMi44NCwyLjg0LDAsMCwxLS43LTEuNywyLjcyLDIuNzIsMCwwLDEsLjYtMS43IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy0xNCIgZD0iTTY4LjEsMTUuOWwtLjMtLjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTE0IiBkPSJNNjguMSwxMmwtLjMuMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTQiIGQ9Ik03Mi40LDExLjlsLjIuMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjxwYXRoIGNsYXNzPSJjbHMtMTQiIGQ9Ik03Mi4zLDE2bC40LS40IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDApIi8+PHBhdGggY2xhc3M9ImNscy0xNCIgZD0iTTcxLjQsMTQuOWwtMi0yLjEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz48cGF0aCBjbGFzcz0iY2xzLTE0IiBkPSJNNzEuMywxMi45bC0xLjksMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAwKSIvPjwvZz48L3N2Zz4=" alt="App Icon">
            </div>
            <div class="about-text-container">
                <p class="text-bold-black-xlarge">Arch图形计算器</p>
                <p class="text-bold-italic-gray"> version 1.19.0 (2601)</p>
                <p class="text-bold"> 本次更新内容：</p>
                <p class="text-italic"> 1.3D绘图支持，解锁数学新维度</p>
                <p class="text-italic"> 2.数学绘图支持粗细调节</p>
                <p class="text-italic"> 3.算式解析优化，变量支持多字符命名</p>
                <p class="text-italic"> 4.几何与批注功能上新</p>
                <p class="text-italic"> 5.UI细节优化，新增工作区调度功能</p>
                <p class="text-italic"> 6.乘方计算优化</p>
            </div>
        </div>
    </div>
<div id="code-panel" style="display: none;">
        <div id="code-list-view">
            <div id="code-entry-list"></div>
<div class="code-panel-actions">
    <div id="code-new-btn" class="btn pill-btn main-ui-btn-color" style="gap: 8px;">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42NjA0MiIgaGVpZ2h0PSIxMi4zNTkzOSIgdmlld0JveD0iMCwwLDEwLjY2MDQyLDEyLjM1OTM5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY2OTc5LC0xNzMuODIwMzEpIj48ZyBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTIzNi45ODI4NiwxNzkuMDM5OTVjMCwtMC4wODMzNCAwLjAyNjA0LC0wLjE2MTQ3IDAuMDcyOTIsLTAuMjM0MzljMC4wNDY4OCwtMC4wNzI5MiAwLjExNDU5LC0wLjExOTggMC4xOTc5MywtMC4xNDU4NGwwLjU0MTcsLTAuMTc3MWMwLjA2MjUsLTAuMDIwODMgMC4xMjUwMSwtMC4wNTIwOSAwLjE4NzUxLC0wLjA5Mzc1YzAuMDYyNSwtMC4wNDE2NyAwLjEwOTM4LC0wLjA4MzM0IDAuMTU2MjYsLTAuMTMwMjFjMC4xMDQxNywtMC4xMDQxNyAwLjE3MTg5LC0wLjIxODc2IDAuMjE4NzYsLTAuMzQ4OThsMC4xNzcwOSwtMC41NDY5MWMwLjAyNjA0LC0wLjA4MzM0IDAuMDc4MTMsLTAuMTQ1ODQgMC4xNDU4NCwtMC4xOTc5M2MwLjA2NzcxLC0wLjA1MjA5IDAuMTUxMDUsLTAuMDc4MTMgMC4yMzQzOSwtMC4wNzgxM2MwLjA4MzM0LDAgMC4xNjY2NywwLjAyNjA0IDAuMjM0MzksMC4wNzI5MmMwLjA2NzcxLDAuMDQ2ODggMC4xMjUwMSwwLjExNDU5IDAuMTUxMDUsMC4xOTc5M2wwLjE3NzEsMC41NDE3YzAuMDQxNjcsMC4xMzU0MyAwLjExNDU4LDAuMjU1MjIgMC4yMTg3NiwwLjM1OTM5YzAuMDk4OTYsMC4xMDQxNyAwLjIxODc2LDAuMTc3MSAwLjM1OTQsMC4yMTg3NmwwLjUzNjQ5LDAuMTc3MWMwLjA4ODU1LDAuMDI2MDQgMC4xNTYyNiwwLjA3ODEzIDAuMjA4MzQsMC4xNDU4NGMwLjA1MjA5LDAuMDY3NzEgMC4wNzgxMywwLjE1MTA1IDAuMDc4MTMsMC4yNDQ4MWMwLDAuMDgzMzQgLTAuMDI2MDQsMC4xNjE0NyAtMC4wNzgxMywwLjIzNDM5Yy0wLjA1MjA5LDAuMDcyOTIgLTAuMTE0NTgsMC4xMTk4IC0wLjE5NzkzLDAuMTQ1ODRsLTAuNTQxNywwLjE3NzFjLTAuMTM1NDMsMC4wNDE2NyAtMC4yNTUyMywwLjExNDU4IC0wLjM1OTQsMC4yMTg3NmMtMC4wNjI1LDAuMDYyNSAtMC4xMTk4LDAuMTQwNjMgLTAuMTU2MjYsMC4yMjM5N2MtMC4wMzY0NiwwLjA4MzM0IC0wLjA3MjkyLDAuMTY2NjcgLTAuMDk4OTYsMC4yNTUyM2MtMC4wMjYwNCwwLjA4ODU1IC0wLjA1MjA5LDAuMTcxODkgLTAuMDc4MTMsMC4yNTUyM2MtMC4wMjYwNCwwLjA4MzM0IC0wLjA1NzI5LDAuMTU2MjYgLTAuMDkzNzUsMC4yMTg3NmMtMC4wMzY0NiwwLjA2MjUgLTAuMDgzMzQsMC4xMTk4IC0wLjEzNTQzLDAuMTU2MjdjLTAuMDUyMDksMC4wMzY0NiAtMC4xMjUwMSwwLjA1NzI5IC0wLjIxODc2LDAuMDU3MjljLTAuMDgzMzQsMCAtMC4xNjY2NywtMC4wMjYwNCAtMC4yMzQzOSwtMC4wNzI5MmMtMC4wNjc3MSwtMC4wNDY4OCAtMC4xMTk4LC0wLjExNDU4IC0wLjE0NTg0LC0wLjE5NzkzbC0wLjE3NzEsLTAuNTQxN2MtMC4wMTU2MywtMC4wNTIwOSAtMC4wMzY0NiwtMC4wOTg5NiAtMC4wNTcyOSwtMC4xNDU4NGMtMC4wMjA4MywtMC4wNDY4OCAtMC4wNTIwOSwtMC4wODg1NSAtMC4wODMzNCwtMC4xMzAyMWMtMC4wNjc3MSwtMC4wODg1NSAtMC4xNDU4NCwtMC4xNTYyNyAtMC4yMzQzOSwtMC4yMDgzNWMtMC4wODg1NSwtMC4wNTIwOSAtMC4xNzcxLC0wLjA5Mzc1IC0wLjI3MDg1LC0wLjEyNTAxYy0wLjA5Mzc1LC0wLjAzMTI1IC0wLjE4MjMsLTAuMDYyNSAtMC4yNzA4NSwtMC4wODMzNGMtMC4wODg1NSwtMC4wMjA4NCAtMC4xNjY2NywtMC4wNTIwOSAtMC4yMzk2LC0wLjA4ODU1Yy0wLjA3MjkyLC0wLjAzNjQ2IC0wLjEyNTAxLC0wLjA4MzM0IC0wLjE2NjY3LC0wLjEzNTQzYy0wLjA0MTY3LC0wLjA1MjA5IC0wLjA1NzI5LC0wLjEyNTAxIC0wLjA1NzI5LC0wLjIxODc2ek0yNDAuNDg4MywxNzkuMDYwNzljLTAuMTU2MjcsLTAuMDU3MjkgLTAuMzAyMTEsLTAuMTE0NTkgLTAuNDQyNzQsLTAuMTYxNDdjLTAuMTQwNjQsLTAuMDQ2ODggLTAuMjcwODUsLTAuMTA5MzggLTAuMzkwNjUsLTAuMTgyM2MtMC4xMTk4LC0wLjA3MjkyIC0wLjIyMzk4LC0wLjE2MTQ3IC0wLjMxNzczLC0wLjI3MDg1Yy0wLjA5Mzc1LC0wLjEwOTM4IC0wLjE2NjY3LC0wLjI0NDgxIC0wLjIxODc2LC0wLjQyMTlsLTAuMTcxODksLTAuNTM2NDlsLTAuMjAzMTMsMC41MzY0OWMtMC4wMzY0NiwwLjA5ODk2IC0wLjA3ODEzLDAuMTg3NTIgLTAuMTMwMjEsMC4yNzA4NWMtMC4wNTIwOSwwLjA4MzM0IC0wLjEwOTM4LDAuMTYxNDcgLTAuMTgyMywwLjIzOTZjLTAuMDY3NzEsMC4wNjc3MSAtMC4xNDU4NCwwLjEzMDIxIC0wLjIzNDM5LDAuMTg3NTFjLTAuMDg4NTUsMC4wNTcyOSAtMC4xNzcwOSwwLjA5ODk2IC0wLjI3MDg1LDAuMTMwMjFsLTAuNTQxNywwLjE3MTg5YzAuMTUxMDUsMC4wNTcyOSAwLjI5NjksMC4xMTQ1OSAwLjQzNzUzLDAuMTYxNDdjMC4xNDA2MywwLjA0Njg4IDAuMjcwODUsMC4xMDkzOCAwLjM4NTQ0LDAuMTgyM2MwLjExNDU5LDAuMDcyOTIgMC4yMjM5OCwwLjE2MTQ3IDAuMzE3NzMsMC4yNzA4NWMwLjA5Mzc1LDAuMTA5MzggMC4xNjY2NywwLjI0NDgxIDAuMjE4NzYsMC40MTY3bDAuMTcxODksMC41MzY0OWwwLjIwMzEzLC0wLjUzNjQ5YzAuMDcyOTIsLTAuMTk3OTMgMC4xODIzLC0wLjM2OTgxIDAuMzE3NzIsLTAuNTEwNDVjMC4xMzU0MywtMC4xNDA2MyAwLjMwNzMyLC0wLjI1MDAxIDAuNTEwNDUsLTAuMzEyNTJ6TTI0MC4xMDgwNywxODEuMzczNDRjMCwtMC4wNjI1IDAuMDIwODMsLTAuMTE5OCAwLjA2MjUsLTAuMTcxODljMC4wNDE2NywtMC4wNTIwOSAwLjA4ODU1LC0wLjA4ODU1IDAuMTUxMDYsLTAuMTA5MzhsMC4zMDIxMSwtMC4wOTg5NmMwLjA2NzcxLC0wLjAyMDgzIDAuMTI1MDEsLTAuMDU3MjkgMC4xNjE0NywtMC4xMDQxN2MwLjAzNjQ2LC0wLjA0Njg4IDAuMDY3NzIsLTAuMDk4OTYgMC4wOTM3NSwtMC4xNTYyNmMwLjAyNjA0LC0wLjA1NzI5IDAuMDQxNjcsLTAuMTE5OCAwLjA1NzI5LC0wLjE3NzFjMC4wMTU2MywtMC4wNTcyOSAwLjAzNjQ2LC0wLjExNDU4IDAuMDYyNSwtMC4xNjY2N2MwLjAyNjA0LC0wLjA1MjA5IDAuMDU3MjksLTAuMDg4NTUgMC4wOTg5NiwtMC4xMjUwMWMwLjA0MTY3LC0wLjAzNjQ2IDAuMDk4OTYsLTAuMDQ2ODggMC4xNzcxLC0wLjA0Njg4YzAuMDYyNSwwIDAuMTI1MDEsMC4wMjA4NCAwLjE4MjMsMC4wNTcyOWMwLjA1NzI5LDAuMDM2NDYgMC4wOTM3NSwwLjA4ODU1IDAuMTE0NTksMC4xNTEwNWMwLjAxMDQyLDAuMDQxNjcgMC4wMjYwNCwwLjA4MzM0IDAuMDM2NDYsMC4xMjUwMWMwLjAxMDQyLDAuMDQxNjcgMC4wMjYwNCwwLjA4MzM0IDAuMDM2NDYsMC4xMTk4YzAuMDEwNDIsMC4wMzY0NiAwLjAzMTI1LDAuMDc4MTMgMC4wNTIwOSwwLjExNDU4YzAuMDIwODQsMC4wMzY0NiAwLjA0Njg4LDAuMDcyOTIgMC4wNzgxMywwLjEwNDE3YzAuMDMxMjUsMC4wMzY0NiAwLjA3MjkyLDAuMDYyNSAwLjExOTgsMC4wODMzNGMwLjA0Njg4LDAuMDIwODQgMC4wOTM3NSwwLjAzNjQ2IDAuMTQ1ODQsMC4wNTIwOWMwLjA1MjA5LDAuMDE1NjMgMC4wOTg5NiwwLjAzMTI1IDAuMTUxMDUsMC4wNDY4OGMwLjA1MjA5LDAuMDE1NjMgMC4wOTM3NSwwLjAzNjQ2IDAuMTMwMjEsMC4wNjI1YzAuMDM2NDYsMC4wMjYwNCAwLjA2NzcyLDAuMDU3MjkgMC4wOTM3NSwwLjA5ODk2YzAuMDI2MDQsMC4wNDE2NyAwLjAzNjQ2LDAuMDg4NTUgMC4wMzY0NiwwLjE1MTA1YzAsMC4wNjc3MSAtMC4wMjA4NCwwLjEzMDIxIC0wLjA1NzI5LDAuMTgyM2MtMC4wMzY0NiwwLjA1MjA5IC0wLjA4ODU1LDAuMDkzNzUgLTAuMTU2MjYsMC4xMTQ1OGMtMC4wMzY0NiwwLjAxMDQyIC0wLjA3ODEzLDAuMDI2MDQgLTAuMTE5OCwwLjAzNjQ2Yy0wLjA0MTY3LDAuMDEwNDIgLTAuMDgzMzQsMC4wMjYwNCAtMC4xMjUwMSwwLjAzNjQ2Yy0wLjA0MTY3LDAuMDEwNDIgLTAuMDgzMzQsMC4wMzEyNSAtMC4xMTk4LDAuMDUyMDljLTAuMDM2NDYsMC4wMjA4NCAtMC4wNzI5MiwwLjA0Njg4IC0wLjEwNDE3LDAuMDc4MTNjLTAuMDQ2ODgsMC4wNTIwOSAtMC4wODMzNCwwLjExNDU5IC0wLjEwOTM4LDAuMTkyNzJjLTAuMDI2MDQsMC4wNzgxMyAtMC4wNDY4OCwwLjE1MTA2IC0wLjA3MjkyLDAuMjIzOThjLTAuMDI2MDQsMC4wNzI5MiAtMC4wNjI1LDAuMTM1NDMgLTAuMTA0MTcsMC4xODIzYy0wLjA0MTY3LDAuMDQ2ODggLTAuMTE0NTksMC4wNzgxMyAtMC4yMDgzNSwwLjA3ODEzYy0wLjA2MjUsMCAtMC4xMjUwMSwtMC4wMjA4NCAtMC4xODIzLC0wLjA1NzI5Yy0wLjA1NzI5LC0wLjAzNjQ2IC0wLjA5Mzc1LC0wLjA4ODU1IC0wLjExNDU4LC0wLjE1MTA1Yy0wLjAxMDQyLC0wLjAzNjQ2IC0wLjAyNjA0LC0wLjA3ODEzIC0wLjAzNjQ2LC0wLjExOThjLTAuMDEwNDIsLTAuMDQxNjcgLTAuMDI2MDQsLTAuMDgzMzQgLTAuMDM2NDYsLTAuMTI1MDFjLTAuMDEwNDIsLTAuMDQxNjcgLTAuMDMxMjUsLTAuMDgzMzQgLTAuMDUyMDksLTAuMTE5OGMtMC4wMjA4MywtMC4wMzY0NiAtMC4wNDY4OCwtMC4wNzI5MiAtMC4wNzI5MiwtMC4wOTg5NmMtMC4wMzY0NiwtMC4wMzY0NiAtMC4wNzgxMywtMC4wNjI1IC0wLjEyNTAxLC0wLjA4MzM0Yy0wLjA0Njg4LC0wLjAyMDg0IC0wLjA5Mzc1LC0wLjAzNjQ2IC0wLjE0NTg0LC0wLjA1MjA5Yy0wLjA1MjA5LC0wLjAxNTYzIC0wLjA5ODk2LC0wLjAzMTI1IC0wLjE0NTg0LC0wLjA0Njg4Yy0wLjA0Njg4LC0wLjAxNTYzIC0wLjA5Mzc1LC0wLjAzNjQ2IC0wLjEzMDIxLC0wLjA2MjVjLTAuMDM2NDYsLTAuMDI2MDQgLTAuMDY3NzEsLTAuMDU3MjkgLTAuMDkzNzUsLTAuMDk4OTZjLTAuMDI2MDQsLTAuMDQxNjcgLTAuMDMxMjUsLTAuMTA0MTcgLTAuMDMxMjUsLTAuMTcxODl6TTI0MS44ODQyMSwxODEuMzg5MDRjLTAuMDg4NTUsLTAuMDI2MDQgLTAuMTYxNDcsLTAuMDU3MjkgLTAuMjI5MTgsLTAuMDkzNzVjLTAuMDY3NzEsLTAuMDM2NDYgLTAuMTE5OCwtMC4wNzgxMyAtMC4xNjY2NywtMC4xMjUwMWMtMC4wNDY4OCwtMC4wNDY4OCAtMC4wODg1NSwtMC4xMDQxNyAtMC4xMTk4LC0wLjE2NjY3Yy0wLjAzMTI1LC0wLjA2MjUgLTAuMDY3NzEsLTAuMTQwNjMgLTAuMDk4OTYsLTAuMjIzOThjLTAuMDI2MDQsMC4wODMzNCAtMC4wNTIwOSwwLjE1NjI2IC0wLjA4ODU1LDAuMjE4NzZjLTAuMDM2NDYsMC4wNjI1IC0wLjA3ODEzLDAuMTE5OCAtMC4xMjUwMSwwLjE2NjY3Yy0wLjA0Njg4LDAuMDQ2ODggLTAuMTA0MTcsMC4wOTM3NSAtMC4xNjY2NywwLjEzMDIxYy0wLjA2MjUsMC4wMzY0NiAtMC4xMzU0MywwLjA2NzcxIC0wLjIxODc2LDAuMDkzNzVjMC4xNjY2NywwLjA0Njg4IDAuMjk2OSwwLjExOTggMC4zOTA2NSwwLjIxODc2YzAuMDkzNzUsMC4wOTg5NiAwLjE2NjY3LDAuMjI5MTggMC4yMTg3NiwwLjM5MDY1YzAuMDMxMjUsLTAuMDg4NTUgMC4wNjI1LC0wLjE2MTQ3IDAuMDkzNzUsLTAuMjIzOThjMC4wMzEyNSwtMC4wNjI1IDAuMDcyOTIsLTAuMTE5OCAwLjExOTgsLTAuMTY2NjdjMC4wNDY4OCwtMC4wNDY4OCAwLjA5ODk2LC0wLjA4ODU1IDAuMTYxNDcsLTAuMTE5OGMwLjA2MjUsLTAuMDMxMjUgMC4xNDA2NCwtMC4wNjc3MSAwLjIyOTE4LC0wLjA5ODk2eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjM1IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxnIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNMjQ0LjU4MDIsMTc4LjU0Njk0bC0wLjAxMjc1LDQuNzU2OTZjMC4wMDA0MSwwLjAxMTQzIDAuMDAwNzMsMC4wMjI4OCAwLjAwMDk2LDAuMDM0MzZjMC4wMjExNCwxLjA4ODM0IC0wLjgzMzg2LDEuOTg5OSAtMS45MTcsMi4wMzEwNmwtNS4yMDM4LDAuMDYwMDljLTAuMDExNDMsMC4wMDAxOSAtMC4wMjI4OCwwLjAwMDI5IC0wLjAzNDM2LDAuMDAwMjljLTEuMDg4NTUsMCAtMS45NzMzNCwtMC44NzIzMyAtMS45OTM0NiwtMS45NTYwN2wwLjAwMjA5LC02LjkyNzg5YzAuMDAwMiwtMC4wMTE0MyAwLjAwMDQ4LC0wLjAyMjg5IDAuMDAwODgsLTAuMDM0MzZjMC4wMzcyLC0xLjA4NzkxIDAuOTM5MjcsLTEuOTQyMzcgMi4wMjMwNiwtMS45MjU0NGwzLjA3NDkxLC0wLjAxNTY0IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDEuMTAwNjUsMTc0LjczNmwzLjQ3OTU2LDMuNzI4MDkiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuOTI4OTQsMTc0LjYwMzczaC0xLjE3NTE0IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzMwMjEyMTAwMTEyNzg5OjYuMTc5NjkwMjk4NjY0NTUzLS0+" alt="新建" style="width: 20px; height: 20px;">
        <span>新建</span>
    </div>
    <div id="code-upload-btn" class="btn pill-btn main-ui-btn-color" style="gap: 8px;">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMS45NTU3NSIgaGVpZ2h0PSIxMC42MTU4MSIgdmlld0JveD0iMCwwLDExLjk1NTc1LDEwLjYxNTgxIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjk1OTExLC0xNzQuNjkyMDkpIj48ZyBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PGc+PHBhdGggZD0iTTIzNC4zMzUxOCwxODMuMzA0NXYtNi42MDg5OWMwLC0wLjI2OTc2IDAsLTAuNDA0NjQgMC4xMzQ4NywtMC42NzQzOWMwLjEzNDg3LC0wLjI2OTc2IDAuMjY5NzYsLTAuNDA0NjMgMC40MDQ2MywtMC41Mzk1MWMwLjEzNDg4LC0wLjEzNDg3IDAuNDA0NjMsLTAuMjY5NzYgMC41Mzk1MSwtMC40MDQ2M2MwLjI2OTc1LC0wLjEzNDg3IDAuNDA0NjMsLTAuMTM0ODggMC42NzQzOCwtMC4xMzQ4OGgyLjE1ODA0YzAuMjY5NzYsMCAwLjUzOTUyLDAuMDAwMDEgMC42NzQzOSwwLjEzNDg4YzAuMTM0ODcsMC4xMzQ4NyAwLjQwNDYzLDAuMTM0ODggMC41Mzk1LDAuMjY5NzVjMC4xMzQ4OCwwLjEzNDg3IDAuMjY5NzYsMC4yNjk3NiAwLjQwNDY0LDAuNDA0NjNjMC4xMzQ4OCwwLjEzNDg3IDAuMjY5NzUsMC40MDQ2MyAwLjQwNDYzLDAuNTM5NTFoMy4xMDIxOGMwLjI2OTc2LDAgMC40MDQ2MywwLjAwMDAxIDAuNjc0MzksMC4xMzQ4OGMwLjI2OTc2LDAuMTM0ODcgMC40MDQ2MywwLjI2OTc2IDAuNTM5NTEsMC40MDQ2M2MwLjEzNDg4LDAuMTM0ODcgMC4yNjk3NiwwLjQwNDY0IDAuNDA0NjMsMC41Mzk1MWMwLjEzNDg4LDAuMjY5NzYgMC4xMzQ4OCwwLjQwNDYzIDAuMTM0ODgsMC42NzQzOWMwLjEzNDg3LDAuMTM0ODcgMC4yNjk3NiwwLjI2OTc1IDAuNDA0NjMsMC41Mzk1MWMwLjEzNDg3LDAuMTM0ODcgMC4xMzQ4NywwLjQwNDYzIDAuMTM0ODcsMC42NzQzOWMwLDAgMCwwIDAsMC4xMzQ4N2MwLDAgMCwwLjAwMDAxIDAsMC4xMzQ4OGwtMC41Mzk1MSw0LjA0NjMyYzAsMC4yNjk3NiAtMC4xMzQ4OCwwLjQwNDY0IC0wLjEzNDg4LDAuNTM5NTFjMCwwLjEzNDg3IC0wLjI2OTc2LDAuNDA0NjMgLTAuNDA0NjMsMC41Mzk1MWMtMC4xMzQ4OCwwLjEzNDg3IC0wLjI2OTc1LDAuMjY5NzYgLTAuNTM5NTEsMC4yNjk3NmMtMC4xMzQ4NywwLjEzNDg3IC0wLjQwNDYzLDAuMTM0ODggLTAuNjc0MzksMC4xMzQ4OGgtNy4yMzI1NGMwLjA5ODk0LC0wLjE2MTUzIDAuMTYyMjEsLTAuMzQ3MjcgMC4xNzg4NywtMC41NDYyNmw2LjkxODg0LC0wLjEyODEyYzAuMTM0ODcsMCAwLjI2OTc2LDAgMC40MDQ2MywwYzAuMTM0ODcsMCAwLjI2OTc2LC0wLjEzNDg4IDAuMjY5NzYsLTAuMTM0ODhjMCwwIDAuMTM0ODgsLTAuMTM0ODggMC4yNjk3NSwtMC4yNjk3NmMwLjEzNDg4LC0wLjEzNDg3IDAuMTM0ODgsLTAuMjY5NzYgMC4xMzQ4OCwtMC40MDQ2M2wwLjUzOTUxLC00LjA0NjMyYzAsLTAuMTM0ODcgMCwtMC4xMzQ4OCAwLC0wLjI2OTc2YzAsLTAuMTM0ODcgLTAuMTM0ODgsLTAuMTM0ODggLTAuMTM0ODgsLTAuMjY5NzZjMCwtMC4xMzQ4NyAtMC4xMzQ4OCwtMC4xMzQ4OCAtMC4yNjk3NiwtMC4xMzQ4OGMtMC4xMzQ4NywwIC0wLjEzNDg4LDAgLTAuMjY5NzUsMGMtMC4xMzQ4OCwwIC03LjAxMzYzLDAgLTcuMTQ4NSwwYy0wLjEzNDg3LDAgLTAuMTM0ODgsMC4wMDAwMSAtMC4yNjk3NiwwLjEzNDg4Yy0wLjEzNDg3LDAuMTM0ODcgLTAuMTM0ODcsMC4xMzQ4NyAtMC4xMzQ4NywwLjEzNDg3YzAsMCAtMC4xMzQ4NywwLjEzNDg4IC0wLjEzNDg3LDAuMjY5NzZsLTAuODQ0LDMuOTAzNTFjLTAuMTcyNTEsLTAuMDg5ODQgLTAuMzY4NiwtMC4xNDA2MiAtMC41NzY1NiwtMC4xNDA2MmMtMC4wMzYyMSwwIC0wLjA3MjA3LDAuMDAxNTQgLTAuMTA3NSwwLjAwNDU2bDAuODUzNjMsLTMuOTAyMzJjMCwtMC4xMzQ4NyAwLjEzNDg3LC0wLjI2OTc2IDAuMTM0ODcsLTAuNDA0NjRjMCwtMC4xMzQ4NyAwLjEzNDg4LC0wLjI2OTc2IDAuMjY5NzYsLTAuNDA0NjNjMC4xMzQ4NywtMC4xMzQ4NyAwLjI2OTc2LC0wLjEzNDg4IDAuNDA0NjMsLTAuMjY5NzZjMC4xMzQ4OCwtMC4xMzQ4NyAwLjI2OTc2LC0wLjEzNDg3IDAuNTM5NTEsLTAuMTM0ODdsNy4xNDg1MSwtMC4xMzQ4OGMtMC4xMzQ4NywwIC0wLjEzNDg3LDAgMCwwYy0wLjEzNDg3LDAgMCwwIDAsMGMwLC0wLjEzNDg3IC0wLjEzNDg4LC0wLjI2OTc2IC0wLjEzNDg4LC0wLjI2OTc2YzAsMCAtMC4xMzQ4OCwtMC4xMzQ4OCAtMC4yNjk3NiwtMC4yNjk3NmMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4xMzQ4OCwtMC4xMzQ4NyAtMC4yNjk3NiwtMC4xMzQ4N2MtMC4xMzQ4NywwIC0wLjI2OTc1LDAgLTAuMjY5NzUsMGgtMy4zNzE5NGwtMC44MDkyNiwtMC45NDQxNWMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4yNjk3NiwtMC4yNjk3NiAtMC40MDQ2MywtMC4yNjk3NmMtMC4xMzQ4NywtMC4xMzQ4NyAtMC4yNjk3NiwtMC4xMzQ4NyAtMC41Mzk1MSwtMC4xMzQ4N2gtMi4xNTgwNGMtMC4xMzQ4OCwwIC0wLjI2OTc2LDAgLTAuNDA0NjQsMC4xMzQ4N2MtMC4xMzQ4OCwwIC0wLjI2OTc1LDAuMTM0ODggLTAuNDA0NjMsMC4yNjk3NmMtMC4xMzQ4OCwwLjEzNDg3IC0wLjEzNDg4LDAuMjY5NzYgLTAuMjY5NzUsMC40MDQ2NGMtMC4xMzQ4OCwwLjEzNDg3IC0wLjEzNDg4LDAuMjY5NzYgLTAuMTM0ODgsMC40MDQ2M3Y2LjA3MTRjLTAuMTk5NDEsMC4wMzE3NCAtMC4zODMxMSwwLjExMDYzIC0wLjUzOTI5LDAuMjI0OWMtMC4wMDAyMywtMC4wMjkwMSAtMC4wMDAyMywtMC4wNTk1IC0wLjAwMDIzLC0wLjA5MTk0eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNS41NjEwMSwxODQuNTI0MDFsLTAuNzMyNDMsLTAuOTc2NTciIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PHBhdGggZD0iTTIzNC43MDkxMSwxODMuNDc3MjZ2LTYuNjI5NzYiIGZpbGw9Im5vbmUiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni4wNDA4OTQ5OTk5OTk5NDk6NS4zMDc5MDUwMDAwMDAwMDUtLT4=" alt="上传" style="width: 20px; height: 20px;">
        <span>上传</span>
    </div>
</div>
        </div>
        <div id="code-editor-view" style="display: none;">
           <button id="code-editor-exit-btn" class="btn small-circle-btn main-ui-btn-color">
    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI1LjQwMjI0IiBoZWlnaHQ9IjUuNzEwMzEiIHZpZXdCb3g9IjAsMCw1LjQwMjI0LDUuNzEwMzEiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzcuMjk4ODgsLTE3Ny4xNDQ4NCkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjM4LjE1MTU3LDE3Ny45OTc1NGwzLjc5OTU1LDQuMDA0OTMiLz48cGF0aCBkPSJNMjQxLjk1MTEyLDE3Ny44OTQ4NGwtMy45MDIyNCw0LjIxMDMxIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Mi43MDExMTkzMjYzNTAzODoyLjg1NTE1NTA2MjY0MTIxNjUtLT4=" alt="退出" style="width: 12px; height: 12px;">
</button>
            <div class="code-editor-content">
                <div class="code-editor-input-group">
                    <label for="code-editor-name">名称:</label>
                    <input type="text" id="code-editor-name" class="code-editor-input">
                </div>
                <div class="code-editor-input-group">
                    <label for="code-editor-params">变量:</label>
                    <input type="text" id="code-editor-params" class="code-editor-input" placeholder="例如: 'a', 'b'">
                </div>
                <div class="code-editor-input-group code-editor-input-group-large">
                    <label for="code-editor-body">代码:</label>
                    <textarea id="code-editor-body" class="code-editor-textarea"></textarea>
                </div>
            </div>
<div class="code-panel-actions">
    <div id="code-add-btn" class="btn pill-btn blue-pill-btn" style="gap: 8px;">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI5LjUzNDk0IiBoZWlnaHQ9IjEwLjU5OTAzIiB2aWV3Qm94PSIwLDAsOS41MzQ5NCwxMC41OTkwMyI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS4zNTc1MywtMTc0LjgwMTE1KSI+PGcgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnPjxwYXRoIGQ9Ik0yNDEuNzY4MzYsMTc1LjA5OTg2YzAuMjQxNjEsMCAwLjQ4MzIsMCAwLjY2NDQsMC4wNjA0YzAuMTgxMjEsMC4wNjA0IDAuNDIyOCwwLjE4MTIxIDAuNjA0LDAuMzAyMDFjMC4xODEyMSwwLjEyMDc5IDAuMzAyMDEsMC4zMDIwMSAwLjQyMjgsMC40ODMyYzAuMTIwNzksMC4xODEyMSAwLjE4MTIxLDAuNDIyOCAwLjE4MTIxLDAuNjY0NGMwLDAuMjQxNjEgMCwwLjQyMjggLTAuMDYwNCwwLjY2NDRjLTAuMDYwNCwwLjE4MTIxIC0wLjE4MTIxLDAuNDIyOCAtMC4zMDIwMSwwLjYwNGwtNC40Njk2MSw1LjczODAzYy0wLjEyMDc5LDAuMTgxMjEgLTAuMzAyMDEsMC4zMDIwMSAtMC40ODMyLDAuMzYyNGwtMi4yMzQ4MiwwLjg0NTYxYzAsMCAwLDAgLTAuMDYwNCwwYzAsMCAwLDAgLTAuMDYwNCwwYy0wLjEyMDc5LDAgLTAuMTgxMjEsMCAtMC4yNDE2MSwtMC4wNjA0Yy0wLjA2MDQsLTAuMDYwNCAtMC4xMjA3OSwtMC4xMjA3OSAtMC4xMjA3OSwtMC4yNDE2MXYtMC4wNjA0YzAsMCAwLDAgMCwtMC4wNjA0bDAuMzAyMDEsLTIuMzU1NjFjMCwtMC4xMjA3OSAwLjA2MDQsLTAuMTgxMjEgMC4wNjA0LC0wLjMwMjAxYzAuMDYwNCwtMC4xMjA3OSAwLjA2MDQsLTAuMTgxMjEgMC4xMjA3OSwtMC4yNDE2MWw0LjQ2OTYxLC01LjczODAzYzAuMTIwNzksLTAuMTgxMjEgMC4zMDIwMSwtMC4zMDIwMSAwLjQ4MzIsLTAuNDIyOGMwLjI0MTYxLC0wLjEyMDc5IDAuNDgzMiwtMC4xODEyMSAwLjcyNDgxLC0wLjI0MTYxek0yNDEuODI4NzcsMTc1LjgyNDY2Yy0wLjEyMDc5LDAgLTAuMjQxNjEsMC4wNjA0IC0wLjM2MjQsMC4xMjA3OWMtMC4xMjA3OSwwLjA2MDQgLTAuMTgxMjEsMC4xMjA3OSAtMC4zMDIwMSwwLjI0MTYxbC00LjQ2OTYxLDUuNzM4MDNjLTAuMDYwNCwwLjA2MDQgLTAuMDYwNCwwLjEyMDc5IC0wLjA2MDQsMC4xODEyMWwtMC4yNDE2MSwxLjc1MTYxbDEuNjMwODIsLTAuNjA0YzAuMDYwNCwwIDAuMTIwNzksLTAuMDYwNCAwLjE4MTIxLC0wLjEyMDc5bDQuNDY5NjEsLTUuNzM4MDNjMC4wNjA0LC0wLjEyMDc5IDAuMTIwNzksLTAuMTgxMjEgMC4xODEyMSwtMC4zMDIwMWMwLjA2MDQsLTAuMTIwNzkgMC4wNjA0LC0wLjI0MTYxIDAsLTAuMzYyNGMwLC0wLjEyMDc5IC0wLjA2MDQsLTAuMjQxNjEgLTAuMTIwNzksLTAuMzYyNGMtMC4wNjA0LC0wLjEyMDc5IC0wLjEyMDc5LC0wLjE4MTIxIC0wLjI0MTYxLC0wLjMwMjAxYy0wLjEyMDc5LC0wLjEyMDc5IC0wLjE4MTIxLC0wLjEyMDc5IC0wLjMwMjAxLC0wLjE4MTIxYy0wLjA2MDQsLTAuMDYwNCAtMC4xODEyMSwtMC4wNjA0IC0wLjM2MjQsLTAuMDYwNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDEuMjU1MTQsMTgzLjU5OTMzbDEuMDcxMjksMS4zMDA4NSIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQyLjMyNjQyLDE4NC45MDAxN2wyLjA2NjA1LC0yLjgzMTI1IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo0LjY0MjQ3MDU5NjY4ODMyNzo1LjE5ODg1NDY5NzUxOTAxLS0+" alt="添加" style="width: 20px; height: 20px;">
        <span>添加</span>
    </div>
    <div id="code-download-btn" class="btn pill-btn blue-pill-btn" style="gap: 8px;">
        <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi41NTEwMyIgaGVpZ2h0PSIxMS4wMjY3OCIgdmlld0JveD0iMCwwLDEyLjU1MTAzLDExLjAyNjc4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjcyNDQ4LC0xNzQuNDg2NikiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjQ1LjUyNTQ5LDE4Mi40MTEyNmwtMC4wMDI4MiwwLjQyMzM0Yy0wLjAwMDE0LDAuMDEzMTQgLTAuMDAwNDIsMC4wMjYzMiAtMC4wMDA4MiwwLjAzOTUxYy0wLjAzMjk1LDEuMDczOTIgLTAuOTE1NjMsMS45MTczIC0xLjk3MTUzLDEuODgzNzRjLTAuMDA4MzYsLTAuMDAwMjcgLTAuMDE2NzIsLTAuMDAwNTkgLTAuMDI1MDYsLTAuMDAwOTZsLTEuNTg0MjIsMC4wMDE2OGwtNC41MjI0NSwwLjAwMzU0bC0wLjk2ODMxLDAuMDAxMDJjLTAuMDEyOTIsMC4wMDAyMSAtMC4wMjU4OCwwLjAwMDMgLTAuMDM4ODYsMC4wMDAyNmMtMS4wNTY0LC0wLjAwMzg1IC0xLjkwOTc0LC0wLjg3Nzk3IC0xLjkwNTk3LC0xLjk1MjRjMC4wMDAwMywtMC4wMDg1MSAwLjAwMDEyLC0wLjAxNzAxIDAuMDAwMjYsLTAuMDI1NTFsLTAuMDAxMjcsLTAuMjU0NDdsLTAuMDI5OTMsLTIuOTAyMzJsMC4wMDMxMiwtMC40MjMzNGMwLjAwMDE1LC0wLjAxMzE0IDAuMDAwNDQsLTAuMDI2MzIgMC4wMDA4NSwtMC4wMzk1MWMwLjAzMzcsLTEuMDczODggMC45MTY5NywtMS45MTY2NiAxLjk3MjgzLC0xLjg4MjM4YzAuMDA4MzYsMC4wMDAyNyAwLjAxNjcyLDAuMDAwNiAwLjAyNTA2LDAuMDAwOThsMS41ODQyMiwtMC4wMDA1OGw0LjUyMjQ2LC0wLjAwMDQxbDAuOTY4MzEsLTAuMDAwMzVjMC4wMTI5MiwtMC4wMDAyMSAwLjAyNTg4LC0wLjAwMDI4IDAuMDM4ODYsLTAuMDAwMjNjMS4wNTYzOSwwLjAwNDU5IDEuOTA5MTIsMC44NzkyOSAxLjkwNDYyLDEuOTUzNzFjLTAuMDAwMDMsMC4wMDg1MSAtMC4wMDAxMiwwLjAxNzAxIC0wLjAwMDI3LDAuMDI1NTFsMC4wMDEwOCwwLjI1NDQ3eiIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNC40OTUwOCwxNzkuOTA2NTZsMC4wMjI2NywtMi40NzE0M2wwLjAwMjUsLTAuMzk2NjljMC4wMDAxMiwtMC4wMTIzMiAwLjAwMDM1LC0wLjAyNDY2IDAuMDAwNjksLTAuMDM3MDNjMC4wMjcwNSwtMS4wMDYyOCAwLjczNTk2LC0xLjc5NTk5IDEuNTgzNCwtMS43NjM4NmMwLjAwNjcxLDAuMDAwMjYgMC4wMTM0MiwwLjAwMDU2IDAuMDIwMTEsMC4wMDA5MmwyLjkzMzQ5LC0wLjAwMTI1YzAuMDEwMzcsLTAuMDAwMTkgMC4wMjA3NywtMC4wMDAyNiAwLjAzMTE5LC0wLjAwMDIxYzAuODQ3ODYsMC4wMDQzIDEuNTMyMjUsMC44MjM5MyAxLjUyODYzLDEuODMwNzFjLTAuMDAwMDMsMC4wMDc5OSAtMC4wMDAxLDAuMDE1OTQgLTAuMDAwMjIsMC4wMjM5bDAuMDAwODcsMC4yMzg0NSIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOS43NTY2NiwxNzkuNDMzMDh2Mi42MDU4MiIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjU2NTk5LDE4Mi43MzgwM2wtMC44MjYyNCwtMS4yNzExMyIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjgyMDIxLDE4Mi43MzgwM2wwLjg4OTc5LC0xLjI3MTEzIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjI3NTUxODUwMDI1NzczMjo1LjUxMzM5Nzk2NzI5NjQ5OC0tPg==" alt="下载" style="width: 20px; height: 20px;">
        <span>下载</span>
    </div>
</div>
        </div>
                  <button id="global-script-toggle-btn" class="btn pill-btn">全局脚本</button>
        <div id="global-script-view" style="display: none;">
            <textarea id="global-script-input"></textarea>
            <div id="global-script-actions">
                <button id="global-script-run-btn" class="btn">运行</button>
                <button id="global-script-stop-btn" class="btn">停止</button>
            </div>
        </div>
    </div>
<div id="portrait-nav-toggle-btn" class="btn circle-btn">
    <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC4xNzE3MyIgaGVpZ2h0PSIyMC45MTMwNiIgdmlld0JveD0iMCwwLDIwLjE3MTczLDIwLjkxMzA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjkxNDE0LC0xNjkuNTQzNDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzAuMTE4NjcsMTg5Ljg4MTR2LTE5Ljc2MjczaDE5Ljc2MjczdjE5Ljc2MjczeiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjYzJmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxwYXRoIGQ9Ik0yMzMuMDgwOTEsMTkwLjEzMTUzYy0wLjM3MDY3LDAgLTAuNzQxMzMsLTAuMTIzNTUgLTEuMTEyLC0wLjI0NzExYy0wLjM3MDY3LC0wLjEyMzU2IC0wLjYxNzc3LC0wLjM3MDY3IC0wLjg2NDg4LC0wLjYxNzc4Yy0wLjI0NzExLC0wLjI0NzExIC0wLjQ5NDIyLC0wLjQ5NDIyIC0wLjYxNzc4LC0wLjg2NDg4Yy0wLjEyMzU2LC0wLjM3MDY3IC0wLjI0NzExLC0wLjYxNzc4IC0wLjI0NzExLC0wLjk4ODQ1di04LjE1NDY0YzAsLTAuMjQ3MTEgMCwtMC40OTQyMiAwLjEyMzU2LC0wLjc0MTMzYzAuMTIzNTYsLTAuMjQ3MTEgMC4yNDcxMSwtMC40OTQyMiAwLjQ5NDIyLC0wLjYxNzc3bDcuNDEzMzEsLTcuMTY2MmMwLjI0NzExLC0wLjI0NzExIDAuNDk0MjMsLTAuMzcwNjcgMC43NDEzMywtMC40OTQyMmMwLjI0NzExLC0wLjEyMzU2IDAuNzQxMzMsLTAuMzcwNjcgMC45ODg0NCwtMC4zNzA2N2MwLjI0NzExLDAgMC42MTc3NywwIDAuOTg4NDQsMC4xMjM1NmMwLjM3MDY3LDAuMTIzNTYgMC42MTc3OCwwLjI0NzExIDAuNzQxMzMsMC40OTQyMmw3LjQxMzMxLDcuMTY2MjFjMC4yNDcxMSwwLjEyMzU2IDAuMzcwNjcsMC4zNzA2NyAwLjQ5NDIzLDAuNjE3NzdjMC4xMjM1NiwwLjI0NzExIDAuMTIzNTYsMC40OTQyMiAwLjEyMzU2LDAuNzQxMzN2OC4xNTQ2NGMwLDAuMzcwNjcgLTAuMTIzNTUsMC43NDEzNCAtMC4yNDcxMSwwLjk4ODQ1Yy0wLjEyMzU2LDAuMzcwNjcgLTAuMzcwNjcsMC42MTc3NyAtMC42MTc3OCwwLjg2NDg4Yy0wLjI0NzExLDAuMjQ3MTEgLTAuNDk0MjIsMC40OTQyMiAtMC44NjQ4OCwwLjYxNzc3Yy0wLjM3MDY3LDAuMTIzNTYgLTAuNzQxMzMsMC4yNDcxMSAtMS4xMTIsMC4yNDcxMWgtNC4yMDA4OGMtMC4yNDcxMSwwIC0wLjM3MDY2LDAgLTAuNDk0MjIsLTAuMTIzNTZjLTAuMTIzNTYsLTAuMTIzNTYgLTAuMzcwNjcsLTAuMTIzNTUgLTAuNDk0MjIsLTAuMjQ3MTFjLTAuMTIzNTYsLTAuMTIzNTYgLTAuMjQ3MTEsLTAuMjQ3MTEgLTAuMjQ3MTEsLTAuMzcwNjdjMCwwIDAsLTAuMjQ3MTEgMCwtMC4zNzA2N3YtNS40MzY0M2gtMi44NDE3N3Y1LjQzNjQzYzAsMC4yNDcxMSAwLDAuMzcwNjYgLTAuMTIzNTYsMC40OTQyMmMtMC4xMjM1NiwwLjEyMzU2IC0wLjEyMzU2LDAuMjQ3MTEgLTAuMjQ3MTEsMC4zNzA2N2MtMC4xMjM1NiwwLjEyMzU2IC0wLjM3MDY3LDAuMjQ3MTEgLTAuNDk0MjIsMC4zNzA2N2MtMC4xMjM1NiwwLjEyMzU2IC0wLjM3MDY3LDAuMTIzNTYgLTAuNDk0MjIsMC4xMjM1NnpNMjM3LjI4MTc4LDE4OC43NzI0MnYtNS40MzY0M2MwLC0wLjI0NzExIDAsLTAuMzcwNjcgMC4xMjM1NiwtMC40OTQyMmMwLjEyMzU2LC0wLjEyMzU2IDAuMTIzNTUsLTAuMjQ3MTEgMC4yNDcxMSwtMC4zNzA2NmMwLjEyMzU2LC0wLjEyMzU2IDAuMjQ3MTEsLTAuMjQ3MTEgMC40OTQyMiwtMC4yNDcxMWMwLjI0NzExLDAgMC4zNzA2NywtMC4xMjM1NiAwLjQ5NDIzLC0wLjEyMzU2aDIuODQxNzdjMC4yNDcxMSwwIDAuMzcwNjcsMCAwLjQ5NDIyLDAuMTIzNTZjMC4xMjM1NiwwLjEyMzU2IDAuMzcwNjYsMC4xMjM1NiAwLjQ5NDIyLDAuMjQ3MTFjMC4xMjM1NiwwLjEyMzU2IDAuMjQ3MTEsMC4yNDcxMSAwLjI0NzExLDAuMzcwNjZjMCwwLjEyMzU2IDAuMTIzNTYsMC4zNzA2NyAwLjEyMzU2LDAuNDk0MjJ2NS40MzY0M2g0LjIwMDg4YzAuMjQ3MTEsMCAwLjM3MDY2LDAgMC40OTQyMiwtMC4xMjM1NmMwLjEyMzU2LC0wLjEyMzU2IDAuMzcwNjcsLTAuMTIzNTUgMC40OTQyMiwtMC4yNDcxMWMwLjEyMzU2LC0wLjEyMzU2IDAuMjQ3MTEsLTAuMjQ3MTEgMC4yNDcxMSwtMC4zNzA2N2MwLC0wLjEyMzU2IDAuMTIzNTYsLTAuMzcwNjcgMC4xMjM1NiwtMC40OTQyM3YtOC4yNzgyYzAsLTAuMTIzNTYgLTAuMTIzNTYsLTAuMzcwNjYgLTAuMjQ3MTEsLTAuNDk0MjJsLTcuNDEzMzEsLTcuMTY2MmMtMC4yNDcxMSwtMC4yNDcxMSAtMC40OTQyMiwtMC4yNDcxMSAtMC43NDEzMywtMC4yNDcxMWMtMC4yNDcxMSwwIC0wLjQ5NDIyLDAuMTIzNTYgLTAuNzQxMzMsMC4yNDcxMWwtNy40MTMzMiw3LjE2NjJjLTAuMTIzNTYsMC4xMjM1NiAtMC4xMjM1NSwwLjI0NzExIC0wLjEyMzU1LDAuNDk0MjJ2OC4xNTQ2NGMwLDAuMjQ3MTEgMCwwLjM3MDY3IDAuMTIzNTUsMC40OTQyM2MwLjEyMzU2LDAuMTIzNTYgMC4xMjM1NiwwLjI0NzExIDAuMjQ3MTEsMC4zNzA2N2MwLjEyMzU2LDAuMTIzNTYgMC4yNDcxMSwwLjI0NzExIDAuNDk0MjIsMC4yNDcxMWMwLjI0NzExLDAgMC4zNzA2NywwLjEyMzU1IDAuNDk0MjMsMC4xMjM1NWg0LjIwMDg3eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxMC4wODU4NjI0OTk5OTk5OToxMC40NTY1Mjc0OTk5OTk5OTMtLT4=" alt="toggle navigation">
</div>
</div>
<div id="stage-manager-container"></div>
<div id="canvas-container">
    <canvas id="plot-canvas"></canvas>
    <canvas id="axis-canvas"></canvas>

    <div id="fps-display">FPS: --</div>
<div id="info-display"></div>
<div id="geometry-measurement-display"></div>
</div>
<div id="main-content-title"></div>
<div id="annotation-menu" style="display: none;">
    <div class="annotation-header">
        <div class="anno-btn-group" id="anno-group-left">

            <button id="annotation-color-btn" class="anno-circle-btn" title="颜色/展开">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzNy43OTY4OCwxODEuMDgxMDJjLTAuMTY0MiwtMC4wMDE3MiAtMC4zMjY2LDAuMDM0MzcgLTAuNDc0NjEsMC4xMDU0N2MtMC4xNDQ1MywwLjA3MDMxIC0wLjI4NzExLDAuMTQ4NDMgLTAuNDI3NzQsMC4yMzQzN2MtMC4xNDAyOCwwLjA4NTc1IC0wLjI4NTAxLDAuMTYzOTkgLTAuNDMzNTksMC4yMzQzOGMtMC4xNTQxLDAuMDcxNTQgLTAuMzIyMywwLjEwNzU5IC0wLjQ5MjE5LDAuMTA1NDZjLTAuMjQxNjYsMC4wMDExMyAtMC40Nzk2MiwtMC4wNTkzNyAtMC42OTE0LC0wLjE3NTc4Yy0wLjIxMDUzLC0wLjExNDI0IC0wLjQwODg0LC0wLjI0OTcxIC0wLjU5MTgsLTAuNDA0MjljLTAuMjI5ODIsLTAuMTkwMjEgLTAuNDA5ODEsLTAuNDMzNTcgLTAuNTI0NDIsLTAuNzA5Yy0wLjEwOTcxLC0wLjI3NzgzIC0wLjE2NDQzLC0wLjU3NDMxIC0wLjE2MTEzLC0wLjg3M2MtMC4wMDAyMSwtMC4zMTQ4MSAwLjA0MjE4LC0wLjYyODIgMC4xMjYsLTAuOTMxNjVjMC4wODM5MSwtMC4zMDQ0NyAwLjE5MDY2LC0wLjYwMjIgMC4zMTkzMywtMC44OTA2MmMwLjI3NDIzLC0wLjYxMjIgMC42MzEwNywtMS4xODM5MiAxLjA2MDU1LC0xLjY5OTIyYzAuMTkwMjcsLTAuMjMzMTEgMC4zOTM3MywtMC40NTUxNCAwLjYwOTM4LC0wLjY2NWMwLjIxNjU0LC0wLjIxMDMyIDAuNDU0MTIsLTAuMzk3ODMgMC43MDksLTAuNTU5NTdjMC40MzcwOSwtMC4yNzk1NSAwLjkxMDE4LC0wLjQ5ODM1IDEuNDA2MjUsLTAuNjUwMzljMC40OTc4NywtMC4xNDk4NCAxLjAxNTIzLC0wLjIyNDg4IDEuNTM1MTYsLTAuMjIyNjZjMC40OTQ4OCwtMC4wMDA2OSAwLjk4NzYsMC4wNjUzNCAxLjQ2NDg0LDAuMTk2MjljMC40Nzc3OCwwLjEzMTM0IDAuOTM5NTksMC4zMTUwNyAxLjM3NywwLjU0Nzg2YzAuNTIxMzksMC4yNzY1IDEuMDA0ODcsMC42MTkxOCAxLjQzODQ4LDEuMDE5NTNjMC40MTI1NCwwLjM4MTYxIDAuNzcwNDEsMC44MTgzNSAxLjA2MzQ4LDEuMjk3ODVjMC4yOTE0OSwwLjQ4MDI3IDAuNTE0MzYsMC45OTg5NiAwLjY2MjExLDEuNTQxYzAuMTU0NjIsMC41NzAwNCAwLjIzMTQ5LDEuMTU4MzcgMC4yMjg1MSwxLjc0OWMtMC4wMDA4NCwwLjQ1NDg5IC0wLjA0MiwwLjkwODgyIC0wLjEyMywxLjM1NjQ0Yy0wLjA4MTE0LDAuNDU1ODQgLTAuMjA3NzQsMC45MDI0IC0wLjM3NzkyLDEuMzMzYy0wLjE2OTAxLDAuNDI3OTYgLTAuMzg1MTksMC44MzU3NSAtMC42NDQ1NCwxLjIxNTgyYy0wLjI1NzE2LDAuMzc4MDIgLTAuNTY4MDQsMC43MTY1NCAtMC45MjI4NSwxLjAwNDg4Yy0wLjI4Nzc2LDAuMjM1MTcgLTAuNjA4NTgsMC40MjY2OSAtMC45NTIxNSwwLjU2ODM2Yy0wLjM0NDg3LDAuMTQxMjMgLTAuNzE0MjUsMC4yMTI5MiAtMS4wODY5MSwwLjIxMDk0Yy0wLjM1MTU4LC0wLjAwMTM3IC0wLjcwMDM2LC0wLjA2MjggLTEuMDMxMjUsLTAuMTgxNjRjLTAuMzEzMTYsLTAuMTA3MjkgLTAuNjA5MTgsLTAuMjU5MjUgLTAuODc4OTEsLTAuNDUxMTdjLTAuMjM5NjksLTAuMTczMTIgLTAuNDQ3OCwtMC4zODYxOSAtMC42MTUyMywtMC42Mjk4OWMtMC4xNjcxNSwtMC4yNDY4NSAtMC4yOTM3NSwtMC41MTg4MyAtMC4zNzUsLTAuODA1NjZjLTAuMDg5MjgsLTAuMzE3MjEgLTAuMTQyMzYsLTAuNjQzNTEgLTAuMTU4MiwtMC45NzI2NmMtMC4wMDc4MiwtMC4xMjEwOSAtMC4wMTQ2NiwtMC4yNDAyMyAtMC4wMjA1MSwtMC4zNTc0MmMtMC4wMDU4NSwtMC4xMTcxOSAtMC4wMTI2OSwtMC4yMzYzMyAtMC4wMjA1MSwtMC4zNTc0MmMtMC4wMDM5MSwtMC4wNjY0MSAtMC4wMDk3NywtMC4xNDE2IC0wLjAxNzU4LC0wLjIyNTU4Yy0wLjAwODA1LC0wLjA4NTU5IC0wLjAyMDc3LC0wLjE3MDY4IC0wLjAzODA4LC0wLjI1NDg5Yy0wLjAxNjY0LC0wLjA4MjU2IC0wLjAzOTE2LC0wLjE2MzgxIC0wLjA2NzM5LC0wLjI0MzE2Yy0wLjAyNDAzLC0wLjA2OTY5IC0wLjA1NzU0LC0wLjEzNTc1IC0wLjA5OTYxLC0wLjE5NjI5Yy0wLjA0MDQsLTAuMDUxMjYgLTAuMDkxMzYsLTAuMDkzMjMgLTAuMTQ5NDEsLTAuMTIzMDVjLTAuMDY1NzUsLTAuMDM1NjYgLTAuMTM1NiwtMC4wNjMyIC0wLjIwOCwtMC4wODJjLTAuMDcyMzMsLTAuMDE5MTcgLTAuMTQ1NzYsLTAuMDMzODcgLTAuMjE5ODksLTAuMDQ0MDFjLTAuMDY1MDIsLTAuMDA5MjMgLTAuMTMwNTksLTAuMDE0MTIgLTAuMTk2MjcsLTAuMDE0NjN6TTI0MC40Njg3NSwxNzYuNzkxOTVjMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQyLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTQsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4NCAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMiwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MiwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0Mi41MzEyNSwxODIuOTc5NDVjMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQyLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTQsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4NCAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMiwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MiwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0Mi43MTg3NSwxNzcuNTQxOTVjMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQyLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTQsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4NCAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMiwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MiwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0NC4wMzEyNSwxNzkuMjI5NDVjMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQyLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTQsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4NCAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMiwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MiwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0NC4wMzEyNSwxODEuNDc5NDVjMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQyLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTQsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4NCAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMiwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MiwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjMzLjMxMzA4LDE4Ni43NTk5M3YtMTMuNTE5ODZoMTMuMzczODV2MTMuNTE5ODZ6IiBmaWxsLW9wYWNpdHk9IjAuMDgyMzUiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni42ODY5MjUwMDAwMDAwMDI6Ni43NTk5Mjk5OTk5OTk5OTctLT4=" alt="Color">
            </button>
            

            <button id="annotation-pen-btn" class="anno-circle-btn annotation-mode-switch-btn active" title="画笔">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzQuMzc1LDE4NC40Nzk1NWMtMC4yMDU5NCwtMC4wMDI4IC0wLjM3MjIsLTAuMTY5MDYgLTAuMzc1LC0wLjM3NWMwLjAxMzk4LC0wLjA4NTc1IDAuMDM1NTUsLTAuMTcwMDcgMC4wNjQ0NiwtMC4yNTJjMC4wNDI5NywtMC4xNDA2MiAwLjA5NjY4LC0wLjMxMDU0IDAuMTYxMTMsLTAuNTA5NzZjMC4wNjQ0NiwtMC4xOTkyMiAwLjEzNDc2LC0wLjQxMzA5IDAuMjEwOTQsLTAuNjQxNjFjMC4wNzYxOCwtMC4yMjg1MSAwLjE0OTQyLC0wLjQ0NzI2IDAuMjE5NzIsLTAuNjU2MjVjMC4wNzAzLC0wLjIwODk5IDAuMTMyOCwtMC4zOTI1OCAwLjE4NzUsLTAuNTUwNzhjMC4wNTQ2NiwtMC4xNTgyIDAuMDkxNzgsLTAuMjY0NjUgMC4xMTEzMywtMC4zMTkzM2MwLjAxODc3LC0wLjA1NTc4IDAuMDUwOTYsLTAuMTA2MDggMC4wOTM3NSwtMC4xNDY0OWw2LjQ2ODc1LC02LjQ2ODc1YzAuMTcwMDgsLTAuMTcwNjcgMC4zNzIxOSwtMC4zMDYwNiAwLjU5NDczLC0wLjM5ODQzYzAuMjIxNjcsLTAuMDkzMTYgMC40NTk3NCwtMC4xNDA5OCAwLjcwMDE5LC0wLjE0MDYzYzAuMjQzNjgsLTAuMDAxMjggMC40ODUwMiwwLjA0NzU4IDAuNzA5LDAuMTQzNTZjMC40NDE3OSwwLjE4Nzg3IDAuNzkzNTcsMC41Mzk2NSAwLjk4MTQ0LDAuOTgxNDRjMC4xOTAzOSwwLjQ1MDIzIDAuMTkxNDQsMC45NTgxNiAwLjAwMjkzLDEuNDA5MThjLTAuMDk0MjksMC4yMjE1MSAtMC4yMjk0NSwwLjQyMzI2IC0wLjM5ODQzLDAuNTk0NzNsLTAuOTQ5MjIsMC45NTUwN2MwLjE0MzI1LDAuMTUzNjYgMC4yNjYzMSwwLjMyNDk2IDAuMzY2MjEsMC41MDk3N2MwLjA5MzEyLDAuMTkxMzcgMC4xMzgzNiwwLjQwMjUgMC4xMzE4MywwLjYxNTIzYzAuMDAwMDcsMC4zOTc4MyAtMC4xNTgwMiwwLjc3OTM2IC0wLjQzOTQ1LDEuMDYwNTVsLTEuMDc4MTcsMS4wNzgxOGMtMC4wOTQwMSwwLjA5NTE4IC0wLjIzMTgsMC4xMzI3MiAtMC4zNjEwOSwwLjA5ODM2Yy0wLjEyOTI5LC0wLjAzNDM2IC0wLjIzMDI4LC0wLjEzNTM0IC0wLjI2NDYzLC0wLjI2NDYzYy0wLjAzNDM2LC0wLjEyOTI5IDAuMDAzMTgsLTAuMjY3MDggMC4wOTgzNywtMC4zNjEwOWwxLjA3ODE3LC0xLjA3ODEzYzAuMTQ0NjUsLTAuMTM5MzggMC4yMjUyMywtMC4zMzIzNiAwLjIyMjY1LC0wLjUzMzIxYzAuMDAxNjgsLTAuMTEzOTQgLTAuMDI0NDcsLTAuMjI2NTcgLTAuMDc2MTcsLTAuMzI4MTJjLTAuMDUzLC0wLjEwMDQ1IC0wLjEyNDU3LC0wLjE4OTkyIC0wLjIxMDk0LC0wLjI2MzY3bC00Ljk4NjM2LDQuOTgwNDhjLTAuMDQ2MzksMC4wNDgyMiAtMC4xMDUyLDAuMDgyNjkgLTAuMTY5OTMsMC4wOTk2MWwtMywwLjc1Yy0wLjAzMDgsMC4wMDY4MiAtMC4wNjIxNywwLjAxMDc0IC0wLjA5MzcxLDAuMDExNzF6TTIzNC45MTQwNywxODUuMTI5OTZsMS4wMDc4MSwtMC4yNTJjMC4yMjQ5OSwwLjExMjcxIDAuNDYxNzcsMC4yMDAxNSAwLjcwNiwwLjI2MDc0YzAuMjQ0MzksMC4wNjA1OCAwLjQ5NTI4LDAuMDkxMDggMC43NDcwNywwLjA5MDgyYzAuMjY4ODgsLTAuMDAwNyAwLjUzNDU0LC0wLjA1ODYyIDAuNzc5MywtMC4xNjk5MmMwLjI2MTgzLC0wLjExNzc4IDAuNTExOTcsLTAuMjYwMDEgMC43NDcwNywtMC40MjQ4YzAuMjQ0MTQsLTAuMTY5OTIgMC40ODQzOCwtMC4zNTM1MiAwLjcyMDcsLTAuNTUwNzhjMC4yMzYzMiwtMC4xOTcyNiAwLjQ2ODc1LC0wLjM4MDg2IDAuNjk3MjcsLTAuNTUwNzhjMC4yMTI1NSwtMC4xNTk5IDAuNDM3OTIsLTAuMzAxOTggMC42NzM4MywtMC40MjQ4MWMwLjIwMDk5LC0wLjEwODI0IDAuNDI1MDcsLTAuMTY2NTIgMC42NTMzMiwtMC4xNjk5MmMwLjExNzgxLC0wLjAwMTI0IDAuMjM0ODgsMC4wMTg2MSAwLjM0NTcsMC4wNTg1OWMwLjE0ODcyLDAuMDQ5NzEgMC4yODYxMiwwLjEyODM4IDAuNDA0MywwLjIzMTQ1YzAuMTAzNjYsMC4wOTM0OCAwLjE5MjU2LDAuMjAyMTQgMC4yNjM2NywwLjMyMjI2YzAuMDcyMzcsMC4xMjM2MiAwLjEzMjI0LDAuMjU0MTUgMC4xNzg3MSwwLjM4OTY1YzAuMDQ4ODMsMC4xNDA2NCAwLjA5NjY5LDAuMjg1MTcgMC4xNDM1NiwwLjQzMzZjMC4wMTk3NiwwLjA2Njk3IDAuMDQ2MjYsMC4xMzE3NSAwLjA3OTEsMC4xOTMzNmMwLjAzMjU1LDAuMDYxNTggMC4wNzI5MiwwLjExODY5IDAuMTIwMTEsMC4xNjk5MmMwLjAyNTUsMC4wMjkyNiAwLjA1Mzk5LDAuMDU1NzcgMC4wODUsMC4wNzkxYzAuMDMwODEsMC4wMjQ1NSAwLjA2OSwwLjAzNzk3IDAuMTA4NCwwLjAzODA4YzAuMTA2ODYsLTAuMDA1MTIgMC4yMTE1NSwtMC4wMzIwNCAwLjMwNzYyLC0wLjA3OTFjMC4xMjQyMSwtMC4wNTU0MSAwLjI0NDU5LC0wLjExOTAzIDAuMzYwMzUsLTAuMTkwNDNjMC4xMjExLC0wLjA3NDIyIDAuMjM3MzEsLTAuMTUwMzkgMC4zNDg2MywtMC4yMjg1MWMwLjExMTMyLC0wLjA3ODEyIDAuMjA0MDksLTAuMTQyNTcgMC4yNzgzMywtMC4xOTMzNmMwLjExOTYzLC0wLjA3OTU1IDAuMjQzODcsLTAuMTUxOTUgMC4zNzIwNywtMC4yMTY4YzAuMTMwMzQsLTAuMDY2MTcgMC4yNjQzNCwtMC4xMjQ4NiAwLjQwMTM2LC0wLjE3NTc4YzAuMDU3MzEsLTAuMDI1MzQgMC4xMTksLTAuMDM5MjcgMC4xODE2NCwtMC4wNDFjMC4wOTk4NSwtMC4wMDEzIDAuMTk1OTksMC4wMzc3OSAwLjI2NjYsMC4xMDg0YzAuMDcwNjEsMC4wNzA2MSAwLjEwOTcsMC4xNjY3NSAwLjEwODQsMC4yNjY2YzAuMDAwNDYsMC4wODA2OSAtMC4wMjYzOCwwLjE1OTE2IC0wLjA3NjE3LDAuMjIyNjZjLTAuMDQ4MjEsMC4wNjQ2MiAtMC4xMTYwNSwwLjExMTkgLTAuMTkzMzYsMC4xMzQ3N2MtMC4wMDM5LDAuMDA3ODEgLTAuMDE1NjEsMC4wMTE3MiAtMC4wMzUxNSwwLjAxMTcyYy0wLjE5NzE1LDAuMDgxNDUgLTAuMzg1NiwwLjE4MjU1IC0wLjU2MjUsMC4zMDE3NWMtMC4xOTE0MSwwLjEyNjk2IC0wLjM4NDc3LDAuMjUxOTYgLTAuNTgwMDgsMC4zNzVjLTAuMTg4ODgsMC4xMTk1NyAtMC4zODU2MiwwLjIyNjI2IC0wLjU4ODg3LDAuMzE5MzRjLTAuMTg0MjYsMC4wODY4OSAtMC4zODUxNiwwLjEzMjg3IC0wLjU4ODg3LDAuMTM0NzZjLTAuMTQ0NzgsMC4wMDE4MiAtMC4yODc3NCwtMC4wMzI0MSAtMC40MTYsLTAuMDk5NmMtMC4xMjgzMywtMC4wNjkwNCAtMC4yNDM0LC0wLjE2MDMgLTAuMzM5ODUsLTAuMjY5NTRjLTAuMDg1MjIsLTAuMDkxMDQgLTAuMTU3MjEsLTAuMTkzNiAtMC4yMTM4NiwtMC4zMDQ2OGMtMC4wNTUwOSwtMC4xMTEzNiAtMC4xMDExNCwtMC4yMjY5NyAtMC4xMzc3LC0wLjM0NTcxYy0wLjAyMzQ0LC0wLjA3MDMxIC0wLjA1MDc4LC0wLjE1NjI1IC0wLjA4MiwtMC4yNTc4MWMtMC4wMzEwNiwtMC4xMDExMSAtMC4wNzEyNiwtMC4xOTkxOCAtMC4xMjAxMiwtMC4yOTNjLTAuMDQ1MzMsLTAuMDg4OTkgLTAuMTA0NjgsLTAuMTcwMSAtMC4xNzU3OCwtMC4yNDAyM2MtMC4wNjQyNCwtMC4wNjQ3MyAtMC4xNTE5NywtMC4xMDA2NiAtMC4yNDMxNiwtMC4wOTk2MWMtMC4xNzY3NiwwLjAwOTMxIC0wLjM0NzMzLDAuMDY4MiAtMC40OTIxOSwwLjE2OTkyYy0wLjIwMjgzLDAuMTI5ODkgLTAuMzk4NDMsMC4yNzA3MiAtMC41ODU5NCwwLjQyMTg4Yy0wLjIxMDk0LDAuMTY3OTYgLTAuNDM3NDksMC4zNTE1NSAtMC42Nzk2OCwwLjU1MDc4Yy0wLjI0Mjg3LDAuMTk5NzEgLTAuNDk4MjgsMC4zODM2OCAtMC43NjQ2NSwwLjU1MDc4Yy0wLjI2NjExLDAuMTY3MjQgLTAuNTQ3NjgsMC4zMDg1MSAtMC44NDA4MiwwLjQyMTg3Yy0wLjI4OTU0LDAuMTEyNjQgLTAuNTk3NTQsMC4xNzAyNyAtMC45MDgyMSwwLjE2OTkyYy0wLjQzNDY3LC0wLjAwMDE4IC0wLjg2NjMxLC0wLjA3MjQ0IC0xLjI3NzM0LC0wLjIxMzg2Yy0wLjQxMjY0LC0wLjEzOTc3IC0wLjgwMDMzLC0wLjM0NDQ5IC0xLjE0ODQ0LC0wLjYwNjQ1ek0yMzQuOTQ5MjEsMTgzLjU3NzIybDIuMjMyNDIsLTAuNTYyNDZsNi4zOTg0NCwtNi4zOTI1OGMwLjEwMDc4LC0wLjEwMDM5IDAuMTgwNDcsLTAuMjE5OTIgMC4yMzQzOCwtMC4zNTE1NmMwLjA1NDUsLTAuMTMxOSAwLjA4MjM2LC0wLjI3MzI4IDAuMDgyLC0wLjQxNmMwLjAwMTI3LC0wLjE0NTk1IC0wLjAyNzY2LC0wLjI5MDU4IC0wLjA4NSwtMC40MjQ4Yy0wLjExLC0wLjI1ODQyIC0wLjMxNTgsLTAuNDY0MjIgLTAuNTc0MjIsLTAuNTc0MjJjLTAuMTM0MjIsLTAuMDU3MzMgLTAuMjc4ODYsLTAuMDg2MjggLTAuNDI0ODEsLTAuMDg1Yy0wLjE0MjcyLC0wLjAwMDM2IC0wLjI4NDEsMC4wMjc1IC0wLjQxNiwwLjA4MmMtMC4xMzE2NCwwLjA1MzkgLTAuMjUxMTcsMC4xMzM1OSAtMC4zNTE1NiwwLjIzNDM4bC02LjQwNDIzLDYuNDEwMTZ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41Ii8+PHBhdGggZD0iTTIzMy4zMTMwOCwxODYuNzU5OTN2LTEzLjUxOTg2aDEzLjM3Mzg1djEzLjUxOTg2eiIgZmlsbC1vcGFjaXR5PSIwLjA4MjM1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iTmFOIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6Ni42ODY5MjUwMDAwMDAwMDI6Ni43NTk5Mjk5OTk5OTk5OTctLT4=" alt="Pen">
            </button>
            <button id="annotation-text-btn" class="anno-circle-btn annotation-mode-switch-btn" title="文字">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIzNS40NzA3LDE4NC4xMjQ5OWMtMC4xOTI5NywwLjAwMDUxIC0wLjM4MzgsLTAuMDQwNDYgLTAuNTU5NTcsLTAuMTIwMTFjLTAuMzUyMjgsLTAuMTU2OTcgLTAuNjM0MDMsLTAuNDM4NzMgLTAuNzkxLC0wLjc5MWMtMC4wNzk2NiwtMC4xNzU3NyAtMC4xMjA2MiwtMC4zNjY2IC0wLjEyMDEyLC0wLjU1OTU3di01LjMwODYxYy0wLjAwMDUsLTAuMTkyOTcgMC4wNDA0NiwtMC4zODM4IDAuMTIwMTIsLTAuNTU5NTdjMC4xNTY5NywtMC4zNTIyNyAwLjQzODcyLC0wLjYzNDAzIDAuNzkxLC0wLjc5MWMwLjE3NTc3LC0wLjA3OTY2IDAuMzY2NiwtMC4xMjA2MiAwLjU1OTU3LC0wLjEyMDEyaDkuMDU4NmMwLjE5Mjk3LC0wLjAwMDUgMC4zODM4LDAuMDQwNDcgMC41NTk1NywwLjEyMDEyYzAuMzUyMjgsMC4xNTY5NyAwLjYzNDAzLDAuNDM4NzMgMC43OTEsMC43OTFjMC4wNzk2NiwwLjE3NTc3IDAuMTIwNjIsMC4zNjY2IDAuMTIwMTIsMC41NTk1N3Y1LjMwODU5YzAuMDAwNSwwLjE5Mjk3IC0wLjA0MDQ2LDAuMzgzOCAtMC4xMjAxMiwwLjU1OTU3Yy0wLjE1Njk3LDAuMzUyMjcgLTAuNDM4NzIsMC42MzQwMyAtMC43OTEsMC43OTFjLTAuMTc1NzcsMC4wNzk2NiAtMC4zNjY2LDAuMTIwNjIgLTAuNTU5NTcsMC4xMjAxMXpNMjM3LjA5MzcyLDE3OC4zMTI0OWMwLjAwNDI4LC0wLjE3NTMyIC0wLjA2MzQ5LC0wLjM0NDc0IC0wLjE4NzUsLTAuNDY4NzVjLTAuMTI0MDEsLTAuMTI0MDEgLTAuMjkzNDMsLTAuMTkxNzggLTAuNDY4NzUsLTAuMTg3NWMtMC4wODc3MiwtMC4wMDA0NCAtMC4xNzQ1NSwwLjAxNzUzIC0wLjI1NDg4LDAuMDUyNzRjLTAuMTU2NzksMC4wNjY5NCAtMC4yODE2OSwwLjE5MTgzIC0wLjM0ODYzLDAuMzQ4NjNjLTAuMDcwMzIsMC4xNjI2NSAtMC4wNzAzMiwwLjM0NzEyIDAsMC41MDk3N2MwLjA2Njk0LDAuMTU2NzkgMC4xOTE4NCwwLjI4MTY5IDAuMzQ4NjMsMC4zNDg2M2MwLjE2MjY0LDAuMDcwMyAwLjM0NzExLDAuMDcwMyAwLjUwOTc2LDBjMC4xNTY3OSwtMC4wNjY5NSAwLjI4MTY5LC0wLjE5MTg0IDAuMzQ4NjQsLTAuMzQ4NjNjMC4wMzUyMywtMC4wODAzNCAwLjA1MzIxLC0wLjE2NzE3IDAuMDUyNzgsLTAuMjU0ODl6TTI0My4zNzQ5NywxODIuNjI0OTljMC4yMDcxMSwwIDAuMzc1LC0wLjE2Nzg5IDAuMzc1LC0wLjM3NWMwLC0wLjIwNzExIC0wLjE2Nzg5LC0wLjM3NSAtMC4zNzUsLTAuMzc1aC02Ljc1Yy0wLjIwNzExLDAgLTAuMzc1LDAuMTY3ODkgLTAuMzc1LDAuMzc1YzAsMC4yMDcxMSAwLjE2Nzg5LDAuMzc1IDAuMzc1LDAuMzc1ek0yMzguNTkzNzcsMTgwLjU2MjQ5YzAuMDA0MjgsLTAuMTc1MzIgLTAuMDYzNDksLTAuMzQ0NzQgLTAuMTg3NSwtMC40Njg3NWMtMC4xMjQwMSwtMC4xMjQwMSAtMC4yOTM0MywtMC4xOTE3OCAtMC40Njg3NSwtMC4xODc1Yy0wLjA4NzcyLC0wLjAwMDQ0IC0wLjE3NDU1LDAuMDE3NTMgLTAuMjU0ODgsMC4wNTI3NGMtMC4xNTY3OSwwLjA2Njk0IC0wLjI4MTY5LDAuMTkxODMgLTAuMzQ4NjMsMC4zNDg2M2MtMC4wNzAzMiwwLjE2MjY1IC0wLjA3MDMyLDAuMzQ3MTIgMCwwLjUwOTc3YzAuMDY2OTQsMC4xNTY3OSAwLjE5MTg0LDAuMjgxNjkgMC4zNDg2MywwLjM0ODYzYzAuMTYyNjQsMC4wNzAzIDAuMzQ3MTEsMC4wNzAzIDAuNTA5NzYsMGMwLjE1Njc5LC0wLjA2Njk1IDAuMjgxNjksLTAuMTkxODQgMC4zNDg2NCwtMC4zNDg2M2MwLjAzNTIxLC0wLjA4MDM0IDAuMDUzMTcsLTAuMTY3MTcgMC4wNTI3MywtMC4yNTQ4OXpNMjM5LjM0Mzc3LDE3OC4zMTI0OWMwLjAwNDI4LC0wLjE3NTMyIC0wLjA2MzQ5LC0wLjM0NDc0IC0wLjE4NzUsLTAuNDY4NzVjLTAuMTI0MDEsLTAuMTI0MDEgLTAuMjkzNDMsLTAuMTkxNzggLTAuNDY4NzUsLTAuMTg3NWMtMC4wODc3MiwtMC4wMDA0NCAtMC4xNzQ1NSwwLjAxNzUzIC0wLjI1NDg4LDAuMDUyNzRjLTAuMTU2NzksMC4wNjY5NCAtMC4yODE2OSwwLjE5MTgzIC0wLjM0ODYzLDAuMzQ4NjNjLTAuMDcwMzIsMC4xNjI2NSAtMC4wNzAzMiwwLjM0NzEyIDAsMC41MDk3N2MwLjA2Njk0LDAuMTU2NzkgMC4xOTE4NCwwLjI4MTY5IDAuMzQ4NjMsMC4zNDg2M2MwLjE2MjY0LDAuMDcwMyAwLjM0NzExLDAuMDcwMyAwLjUwOTc2LDBjMC4xNTY3OSwtMC4wNjY5NSAwLjI4MTY5LC0wLjE5MTg0IDAuMzQ4NjQsLTAuMzQ4NjNjMC4wMzUyMSwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0MC44NDM3NywxODAuNTYyNDljMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQzLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTUsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4MyAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMSwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MjEsLTAuMDgwMzQgMC4wNTMxNywtMC4xNjcxNyAwLjA1MjczLC0wLjI1NDg5ek0yNDEuNTkzNzcsMTc4LjMxMjQ5YzAuMDA0MjgsLTAuMTc1MzIgLTAuMDYzNDksLTAuMzQ0NzQgLTAuMTg3NSwtMC40Njg3NWMtMC4xMjQwMSwtMC4xMjQwMSAtMC4yOTM0MywtMC4xOTE3OCAtMC40Njg3NSwtMC4xODc1Yy0wLjA4NzcyLC0wLjAwMDQ0IC0wLjE3NDU1LDAuMDE3NTMgLTAuMjU0ODgsMC4wNTI3NGMtMC4xNTY3OSwwLjA2Njk0IC0wLjI4MTY5LDAuMTkxODMgLTAuMzQ4NjMsMC4zNDg2M2MtMC4wNzAzMiwwLjE2MjY1IC0wLjA3MDMyLDAuMzQ3MTIgMCwwLjUwOTc3YzAuMDY2OTQsMC4xNTY3OSAwLjE5MTg0LDAuMjgxNjkgMC4zNDg2MywwLjM0ODYzYzAuMTYyNjQsMC4wNzAzIDAuMzQ3MTEsMC4wNzAzIDAuNTA5NzYsMGMwLjE1Njc5LC0wLjA2Njk1IDAuMjgxNjksLTAuMTkxODQgMC4zNDg2NCwtMC4zNDg2M2MwLjAzNTIxLC0wLjA4MDM0IDAuMDUzMTcsLTAuMTY3MTcgMC4wNTI3MywtMC4yNTQ4OXpNMjQzLjA5Mzc3LDE4MC41NjI0OWMwLjAwNDI4LC0wLjE3NTMyIC0wLjA2MzQ5LC0wLjM0NDc0IC0wLjE4NzUsLTAuNDY4NzVjLTAuMTI0MDEsLTAuMTI0MDEgLTAuMjkzNDMsLTAuMTkxNzggLTAuNDY4NzUsLTAuMTg3NWMtMC4wODc3MiwtMC4wMDA0NCAtMC4xNzQ1NSwwLjAxNzUzIC0wLjI1NDg4LDAuMDUyNzRjLTAuMTU2NzksMC4wNjY5NCAtMC4yODE2OSwwLjE5MTgzIC0wLjM0ODYzLDAuMzQ4NjNjLTAuMDcwMzIsMC4xNjI2NSAtMC4wNzAzMiwwLjM0NzEyIDAsMC41MDk3N2MwLjA2Njk0LDAuMTU2NzkgMC4xOTE4NCwwLjI4MTY5IDAuMzQ4NjMsMC4zNDg2M2MwLjE2MjY0LDAuMDcwMyAwLjM0NzExLDAuMDcwMyAwLjUwOTc2LDBjMC4xNTY3OSwtMC4wNjY5NSAwLjI4MTY5LC0wLjE5MTg0IDAuMzQ4NjQsLTAuMzQ4NjNjMC4wMzUyMSwtMC4wODAzNCAwLjA1MzE3LC0wLjE2NzE3IDAuMDUyNzMsLTAuMjU0ODl6TTI0My44NDM3NywxNzguMzEyNDljMC4wMDQyOCwtMC4xNzUzMiAtMC4wNjM0OSwtMC4zNDQ3NCAtMC4xODc1LC0wLjQ2ODc1Yy0wLjEyNDAxLC0wLjEyNDAxIC0wLjI5MzQzLC0wLjE5MTc4IC0wLjQ2ODc1LC0wLjE4NzVjLTAuMDg3NzIsLTAuMDAwNDQgLTAuMTc0NTUsMC4wMTc1MyAtMC4yNTQ4OCwwLjA1Mjc0Yy0wLjE1Njc5LDAuMDY2OTQgLTAuMjgxNjksMC4xOTE4MyAtMC4zNDg2MywwLjM0ODYzYy0wLjA3MDMyLDAuMTYyNjUgLTAuMDcwMzIsMC4zNDcxMiAwLDAuNTA5NzdjMC4wNjY5NCwwLjE1Njc5IDAuMTkxODQsMC4yODE2OSAwLjM0ODYzLDAuMzQ4NjNjMC4xNjI2NCwwLjA3MDMgMC4zNDcxMSwwLjA3MDMgMC41MDk3NiwwYzAuMTU2NzksLTAuMDY2OTUgMC4yODE2OSwtMC4xOTE4NCAwLjM0ODY0LC0wLjM0ODYzYzAuMDM1MjEsLTAuMDgwMzQgMC4wNTMxNywtMC4xNjcxNyAwLjA1MjczLC0wLjI1NDg5eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTIzMy4zMTMwOCwxODYuNzU5OTN2LTEzLjUxOTg2aDEzLjM3Mzg1djEzLjUxOTg2eiIgZmlsbC1vcGFjaXR5PSIwLjA4MjM1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjYuNjg2OTI1MDAwMDAwMDAyOjYuNzU5OTI5OTk5OTk5OTk3LS0+" alt="Text">
            </button>
            <button id="annotation-image-btn" class="anno-circle-btn annotation-mode-switch-btn" title="图片">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDMuMDQ2ODcsMTc0Ljc1YzAuMjg5NzcsLTAuMDAwNjggMC41NzYzNywwLjA2MDI1IDAuODQwODIsMC4xNzg3MmMwLjUyOTAxLDAuMjMyMTIgMC45NTE0NiwwLjY1NDU4IDEuMTgzNTksMS4xODM1OWMwLjExODQ3LDAuMjY0NDQgMC4xNzkzOSwwLjU1MTA1IDAuMTc4NzEsMC44NDA4MnY2LjA5Mzc1YzAuMDAwNjgsMC4yODk3NyAtMC4wNjAyNCwwLjU3NjM4IC0wLjE3ODcxLDAuODQwODJjLTAuMjMyMTQsMC41MjkgLTAuNjU0NTksMC45NTE0NSAtMS4xODM1OSwxLjE4MzU5Yy0wLjI2NDQ1LDAuMTE4NDcgLTAuNTUxMDUsMC4xNzkzOSAtMC44NDA4MiwwLjE3ODcxaC02LjA5MzczYy0wLjI4OTc3LDAuMDAwNjggLTAuNTc2MzcsLTAuMDYwMjQgLTAuODQwODIsLTAuMTc4NzFjLTAuNTI5MDEsLTAuMjMyMTMgLTAuOTUxNDYsLTAuNjU0NTggLTEuMTgzNiwtMS4xODM1OWMtMC4xMTg0NywtMC4yNjQ0NCAtMC4xNzkzOSwtMC41NTEwNSAtMC4xNzg3MSwtMC44NDA4MnYtNi4wOTM3NWMtMC4wMDA2OCwtMC4yODk3NyAwLjA2MDI0LC0wLjU3NjM4IDAuMTc4NzEsLTAuODQwODJjMC4yMzIxMywtMC41MjkwMSAwLjY1NDU4LC0wLjk1MTQ3IDEuMTgzNiwtMS4xODM1OWMwLjI2NDQ1LC0wLjExODQ4IDAuNTUxMDUsLTAuMTc5MzkgMC44NDA4MiwtMC4xNzg3MnpNMjM1LjcxMDkzLDE4My43NjE3MmwzLjM2MzI4LC0zLjM2MzI4YzAuMTIxMDQsLTAuMTIyMzUgMC4yNjU1MiwtMC4yMTkwMSAwLjQyNDgxLC0wLjI4NDE4YzAuMzIxNTUsLTAuMTI4OTEgMC42ODA0MSwtMC4xMjg5MSAxLjAwMTk1LDBjMC4xNTkyOCwwLjA2NTE4IDAuMzAzNzYsMC4xNjE4NCAwLjQyNDgsMC4yODQxOGwzLjM2MzI4LDMuMzYzMjhjMC4wNzAwOSwtMC4xMTI3NyAwLjEyMzM5LC0wLjIzNTE0IDAuMTU4MjEsLTAuMzYzMjhjMC4wMzUyOCwtMC4xMjk4NiAwLjA1MzAyLC0wLjI2Mzg3IDAuMDUyNzMsLTAuMzk4NDR2LTYuMDI5MjljMC4wMDA1LC0wLjE5Mjk3IC0wLjA0MDQ2LC0wLjM4MzggLTAuMTIwMTIsLTAuNTU5NTdjLTAuMTU2OTcsLTAuMzUyMjcgLTAuNDM4NzIsLTAuNjM0MDMgLTAuNzkxLC0wLjc5MWMtMC4xNzU3NywtMC4wNzk2NiAtMC4zNjY2LC0wLjEyMDYyIC0wLjU1OTU3LC0wLjEyMDEyaC02LjA1ODZjLTAuMTkyOTcsLTAuMDAwNSAtMC4zODM4LDAuMDQwNDcgLTAuNTU5NTcsMC4xMjAxMmMtMC4zNTIyOCwwLjE1Njk3IC0wLjYzNDAzLDAuNDM4NzMgLTAuNzkxLDAuNzkxYy0wLjA3OTY2LDAuMTc1NzcgLTAuMTIwNjIsMC4zNjY1OSAtMC4xMjAxMiwwLjU1OTU3djYuMDI5MjljLTAuMDAwMjksMC4xMzQ1NyAwLjAxNzQ1LDAuMjY4NTggMC4wNTI3NCwwLjM5ODQ0YzAuMDM0ODEsMC4xMjgxMyAwLjA4ODEsMC4yNTA1MSAwLjE1ODE4LDAuMzYzMjh6TTI0Mi45OTk5OSwxODQuNWMwLjI2ODY1LDAuMDAyNDEgMC41MzI1NywtMC4wNzA2NyAwLjc2MTcyLC0wLjIxMDkzbC0zLjM2MzI4LC0zLjM2MzI4Yy0wLjIyMDU5LC0wLjIxODc2IC0wLjU3NjMsLTAuMjE4NzYgLTAuNzk2ODgsMGwtMy4zNjMyOCwzLjM2MzI4YzAuMTEyNzcsMC4wNzAwOSAwLjIzNTE1LDAuMTIzMzggMC4zNjMyOCwwLjE1ODJjMC4xMjk4NiwwLjAzNTI4IDAuMjYzODcsMC4wNTMwMiAwLjM5ODQ0LDAuMDUyNzN6TTI0MC43NDk5OSwxNzguMTI1Yy0wLjAwMDY3LC0wLjE0OTAyIDAuMDI5MjQsLTAuMjk2NTkgMC4wODc4OSwtMC40MzM1OWMwLjExNTQ2LC0wLjI3MTcxIDAuMzMxODEsLTAuNDg4MDUgMC42MDM1MiwtMC42MDM1MWMwLjI3NzE4LC0wLjExNzIgMC41OTAwMSwtMC4xMTcyIDAuODY3MTksMGMwLjI3MTcxLDAuMTE1NDYgMC40ODgwNSwwLjMzMTggMC42MDM1MSwwLjYwMzUxYzAuMTE3MTksMC4yNzcxOSAwLjExNzE5LDAuNTkgMCwwLjg2NzE5Yy0wLjExNTQ2LDAuMjcxNzEgLTAuMzMxOCwwLjQ4ODA1IC0wLjYwMzUxLDAuNjAzNTFjLTAuMjc3MTgsMC4xMTcxOSAtMC41OTAwMSwwLjExNzE5IC0wLjg2NzE5LDBjLTAuMjcxNzEsLTAuMTE1NDYgLTAuNDg4MDYsLTAuMzMxOCAtMC42MDM1MiwtMC42MDM1MWMtMC4wNTg2NSwtMC4xMzcgLTAuMDg4NTYsLTAuMjg0NTggLTAuMDg3ODksLTAuNDMzNnpNMjQxLjQ5OTk5LDE3OC4xMjVjLTAuMDAyNDgsMC4xODE4NyAwLjEyNDE4LDAuMzQwMDMgMC4zMDIyLDAuMzc3MzRjMC4xNzgwMiwwLjAzNzMxIDAuMzU3NTMsLTAuMDU2NjggMC40MjgyOCwtMC4yMjQyNGMwLjA3MDc1LC0wLjE2NzU2IDAuMDEyOTIsLTAuMzYxNzcgLTAuMTM3OTcsLTAuNDYzMzNjLTAuMTUwODksLTAuMTAxNTYgLTAuMzUyNTgsLTAuMDgyMDQgLTAuNDgxMTksMC4wNDY1N2MtMC4wNzE5MSwwLjA2ODc2IC0wLjExMjIsMC4xNjQxOCAtMC4xMTEzMywwLjI2MzY3eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIvPjxwYXRoIGQ9Ik0yMzMuMzEzMDgsMTg2Ljc1OTkzdi0xMy41MTk4NmgxMy4zNzM4NXYxMy41MTk4NnoiIGZpbGwtb3BhY2l0eT0iMC4wODIzNSIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjYuNjg2OTI1MDAwMDAwMDAyOjYuNzU5OTI5OTk5OTk5OTk3LS0+" alt="Image">
            </button>
            <button id="annotation-pdf-btn" class="anno-circle-btn annotation-mode-switch-btn" title="PDF">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNTAwMjQsMTc5LjMxNDQ1YzAuMTEwNDMsMC4wMzc3MSAwLjIxMzk5LDAuMDkzMTIgMC4zMDY2NCwwLjE2NDA2YzAuMDkxMzksMC4wNjk1NSAwLjE3MTcyLDAuMTUyNTEgMC4yMzgyOCwwLjI0NjA5YzAuMTM0OTMsMC4xODk5IDAuMjA2NjgsMC40MTc0NSAwLjIwNTA4LDAuNjUwMzl2M2MwLjAwMTYsMC4yMzI5NSAtMC4wNzAxNSwwLjQ2MDUgLTAuMjA1MDgsMC42NTA0Yy0wLjA2NjU2LDAuMDkzNTggLTAuMTQ2OSwwLjE3NjU1IC0wLjIzODI4LDAuMjQ2MDljLTAuMDkyNjUsMC4wNzA5NCAtMC4xOTYyMSwwLjEyNjM1IC0wLjMwNjY0LDAuMTY0MDZ2MC4wOTM3NWMwLjAwMDE3LDAuMTkzMDQgLTAuMDQxMTMsMC4zODM4NyAtMC4xMjEwOSwwLjU1OTU3Yy0wLjE1Njk3LDAuMzUyMjcgLTAuNDM4NzMsMC42MzQwMyAtMC43OTEsMC43OTFjLTAuMTc1NDIsMC4wNzk2NSAtMC4zNjU5MywwLjEyMDYyIC0wLjU1ODU5LDAuMTIwMTFoLTYuMDU4NmMtMC4xOTM5OCwwLjAwMTEzIC0wLjM4NTksLTAuMDM5ODYgLTAuNTYyNSwtMC4xMjAxMWMtMC4xNzI4MiwtMC4wNzgwMSAtMC4zMjk3NCwtMC4xODcyNyAtMC40NjI4OSwtMC4zMjIyN2MtMC4xMzM5LC0wLjEzNTg3IC0wLjI0MjM4LC0wLjI5NDYzIC0wLjMyMDMxLC0wLjQ2ODc1Yy0wLjA3OTM3LC0wLjE3NjA1IC0wLjEyMTkyLC0wLjM2NjQ3IC0wLjEyNSwtMC41NTk1N3YtMC4wOTM3NWMtMC4xMTA5MywtMC4wMzc1OSAtMC4yMTQ5OSwtMC4wOTMgLTAuMzA4MSwtMC4xNjQwNmMtMC4wOTEwOCwtMC4wNjk1NyAtMC4xNzExLC0wLjE1MjU0IC0wLjIzNzMxLC0wLjI0NjA5Yy0wLjEzNDkyLC0wLjE4OTkxIC0wLjIwNjY3LC0wLjQxNzQ1IC0wLjIwNTA4LC0wLjY1MDR2LTNjLTAuMDAxNTgsLTAuMjMyOTUgMC4wNzAxNywtMC40NjA0OCAwLjIwNTA4LC0wLjY1MDM5YzAuMDY2MjEsLTAuMDkzNTUgMC4xNDYyMywtMC4xNzY1MiAwLjIzNzMxLC0wLjI0NjA5YzAuMDkzMTEsLTAuMDcxMDYgMC4xOTcxNywtMC4xMjY0NyAwLjMwODEsLTAuMTY0MDZ2LTMuODQzNzNjLTAuMDAwODQsLTAuMTkyOSAwLjAzOTc5LC0wLjM4Mzc0IDAuMTE5MTQsLTAuNTU5NTdjMC4xNTY5NywtMC4zNTIyNyAwLjQzODczLC0wLjYzNDAzIDAuNzkxLC0wLjc5MWMwLjE3NjExLC0wLjA3OTY2IDAuMzY3MjYsLTAuMTIwNjMgMC41NjA1NCwtMC4xMjAxMmgyLjk0MTQxYzAuMzk3ODMsLTAuMDAwMDYgMC43NzkzNiwwLjE1ODA0IDEuMDYwNTUsMC40Mzk0NmwzLjA4Nzg5LDMuMDg3ODljMC4wOTAxNCwwLjA5MTczIDAuMTY4ODMsMC4xOTQwNCAwLjIzNDM3LDAuMzA0NjljMC4wNTY5OSwwLjA5Nzg1IDAuMTAyMjMsMC4yMDIwOCAwLjEzNDc3LDAuMzEwNTRjMC4wMzEyMiwwLjEwNzA1IDAuMDUxNSwwLjIxNjk5IDAuMDYwNTUsMC4zMjgxM2MwLjAwOTc2LDAuMTEzMjggMC4wMTU2MiwwLjIyODUxIDAuMDE1NjIsMC4zNDU3YzAsMC4wNzgxMyAtMC4wMDIsMC4xNTkxOCAtMC4wMDM5MSwwLjI0MzE3Yy0wLjAwMTkxLDAuMDgzOTkgLTAuMDAxOTUsMC4xNjg5MiAtMC4wMDE5NSwwLjI1NDg2ek0yNDQuNTAwMjQsMTgwLjM3NDk5Yy0wLjAwMjgxLC0wLjIwNTkzIC0wLjE2OTA3LC0wLjM3MjE5IC0wLjM3NSwtMC4zNzVoLTguMjVjLTAuMjA1OTMsMC4wMDI4MSAtMC4zNzIxOSwwLjE2OTA3IC0wLjM3NSwwLjM3NXYzYzAuMDAyOCwwLjIwNTk0IDAuMTY5MDYsMC4zNzIyIDAuMzc1LDAuMzc1aDguMjVjMC4yMDU5NCwtMC4wMDI4IDAuMzcyMiwtMC4xNjkwNiAwLjM3NSwtMC4zNzV6TTIzNy4wMDAyNCwxNzQuNzQ5OTljLTAuMTAwNjcsLTAuMDAwOTcgLTAuMjAwNDUsMC4wMTg5OCAtMC4yOTMsMC4wNTg2Yy0wLjE3OTI3LDAuMDc2NCAtMC4zMjIwNCwwLjIxOTE3IC0wLjM5ODQ0LDAuMzk4NDRjLTAuMDM5NjEsMC4wOTI1NiAtMC4wNTk1NywwLjE5MjMzIC0wLjA1ODU5LDAuMjkzdjMuNzVoNy41di0wLjY2MjFjMC4wMDA3MiwtMC4wMjk0MiAtMC4wMDEyNCwtMC4wNTg4NCAtMC4wMDU4NiwtMC4wODc5aC0yLjI3MzQxYy0wLjE5NzQ1LDAuMDAxMzEgLTAuMzkyNzksLTAuMDQwNjggLTAuNTcyMjYsLTAuMTIzYy0wLjE3Mzk2LC0wLjA3OTYgLTAuMzMxNTksLTAuMTkwODcgLTAuNDY0ODUsLTAuMzI4MTNjLTAuMTMzOTIsLTAuMTM4MzggLTAuMjQxMTgsLTAuMzAwMjcgLTAuMzE2NCwtMC40Nzc1NGMtMC4wNzc4NywtMC4xODAzNiAtMC4xMTc3NiwtMC4zNzQ4NCAtMC4xMTcxOSwtMC41NzEyOXYtMi4yNDQyMmMtMC4wMjkwNiwtMC4wMDQ2MSAtMC4wNTg0NywtMC4wMDY1NyAtMC4wODc4OSwtMC4wMDU4NnpNMjQzLjAwMDI0LDE4NS4yNDk5OWMwLjEwMDY3LDAuMDAwOTggMC4yMDA0NSwtMC4wMTg5OCAwLjI5MywtMC4wNTg1OWMwLjE3ODIxLC0wLjA3Nzk1IDAuMzIwNDksLTAuMjIwMjIgMC4zOTg0NCwtMC4zOTg0NGMwLjAzOTYxLC0wLjA5MjU2IDAuMDU5NTcsLTAuMTkyMzMgMC4wNTg1OSwtMC4yOTNoLTcuNWMtMC4wMDEyNiwwLjE5OTQ0IDAuMDc2NzEsMC4zOTEyMyAwLjIxNjgsMC41MzMyMWMwLjA2Nzc4LDAuMDY3NTUgMC4xNDgwNCwwLjEyMTI4IDAuMjM2MzMsMC4xNTgyYzAuMDkzOTcsMC4wMzk0MyAwLjE5NDk3LDAuMDU5MzcgMC4yOTY4NywwLjA1ODU5ek0yMzguMDAyMjUsMTgwLjc0OTk5YzAuMTE1NjYsLTAuMDAwMjUgMC4yMzAwOSwwLjAyMzcgMC4zMzU5NCwwLjA3MDMyYzAuMjEwNDQsMC4wODgzOCAwLjM3Nzk3LDAuMjU1NTcgMC40NjY4LDAuNDY1ODJjMC4wOTM3NSwwLjIxNTg1IDAuMDkzNzUsMC40NjA5MiAwLDAuNjc2NzZjLTAuMDQ1MzgsMC4xMDMyMyAtMC4xMDg4OCwwLjE5NzQ5IC0wLjE4NzUsMC4yNzgzMmMtMC4wNzg3NywwLjA4MDUxIC0wLjE3MjI2LDAuMTQ1MTYgLTAuMjc1MzksMC4xOTA0M2MtMC4xMDcwNCwwLjA0NzIgLTAuMjIyODcsMC4wNzExNyAtMC4zMzk4NSwwLjA3MDMxaC0wLjI1MmMtMC4wMDAxOCwwLjA2MDg4IC0wLjAwNTQxLDAuMTIxNjMgLTAuMDE1NjIsMC4xODE2NGMtMC4wMDg4NCwwLjA1NjEgLTAuMDI4NzYsMC4xMDk4OCAtMC4wNTg2LDAuMTU4MmMtMC4wMjkzNSwwLjA0NjkyIC0wLjA2OTU0LDAuMDg2MTEgLTAuMTE3MTksMC4xMTQyNmMtMC4wNTYwMiwwLjAzMTE4IC0wLjExOTUzLDAuMDQ2MzkgLTAuMTgzNTksMC4wNDM5NGMtMC4yMDU5NCwtMC4wMDI4IC0wLjM3MjIsLTAuMTY5MDYgLTAuMzc1LC0wLjM3NXYtMS41YzAuMDAyODEsLTAuMjA1OTMgMC4xNjkwNywtMC4zNzIxOSAwLjM3NSwtMC4zNzV6TTIzOC4wMDIyNSwxODEuNzUxOTljMC4wMzQwMywwLjAwMDUzIDAuMDY2NDMsLTAuMDE0NTggMC4wODc4OSwtMC4wNDFjMC4wMjIxMiwtMC4wMjM5OSAwLjAzNDYzLC0wLjA1NTI3IDAuMDM1MTYsLTAuMDg3ODljLTAuMDAwODUsLTAuMDMyNDggLTAuMDE0OTYsLTAuMDYzMiAtMC4wMzkwNiwtMC4wODVjLTAuMDIxNSwtMC4wMjM4IC0wLjA1MTkzLC0wLjAzNzYgLTAuMDg0LC0wLjAzODA5aC0wLjI1MnYwLjI1MnpNMjQwLjAwMDI0LDE4MC43NDk5OWMwLjE0OTAyLC0wLjAwMDY4IDAuMjk2NTksMC4wMjkyNCAwLjQzMzU5LDAuMDg3OWMwLjI3MTE5LDAuMTE2MjMgMC40ODcyOSwwLjMzMjMyIDAuNjAzNTIsMC42MDM1MWMwLjExNzE5LDAuMjc3MTkgMC4xMTcxOSwwLjU5IDAsMC44NjcxOWMtMC4xMTYyMywwLjI3MTE5IC0wLjMzMjMzLDAuNDg3MjggLTAuNjAzNTIsMC42MDM1MWMtMC4xMzcsMC4wNTg2NSAtMC4yODQ1NywwLjA4ODU3IC0wLjQzMzU5LDAuMDg3ODloLTAuMzc1Yy0wLjIwNTk0LC0wLjAwMjggLTAuMzcyMiwtMC4xNjkwNiAtMC4zNzUsLTAuMzc1di0xLjVjMC4wMDI4MSwtMC4yMDU5MyAwLjE2OTA3LC0wLjM3MjE5IDAuMzc1LC0wLjM3NXpNMjQwLjAwMDI0LDE4Mi4yNDk5OWMwLjIwNzExLDAgMC4zNzUsLTAuMTY3ODkgMC4zNzUsLTAuMzc1YzAsLTAuMjA3MTEgLTAuMTY3ODksLTAuMzc1IC0wLjM3NSwtMC4zNzV6TTI0My4yMjI5MSwxNzcuNzQ5OTlsLTIuNDcyNjYsLTIuNDcyNjV2MS43MjI2NWMtMC4wMDEyNiwwLjE5OTQ0IDAuMDc2NzIsMC4zOTEyMyAwLjIxNjgsMC41MzMyMWMwLjA2Nzc4LDAuMDY3NTUgMC4xNDgwNCwwLjEyMTI4IDAuMjM2MzMsMC4xNTgyYzAuMDkzOTcsMC4wMzk0MyAwLjE5NDk3LDAuMDU5MzcgMC4yOTY4NywwLjA1ODU5ek0yNDIuMjUwMjQsMTgxLjQ5OTk5djAuMjUyaDAuMjA1MDhjMC4wNjUyOCwtMC4wMDAwNSAwLjEzMDUsMC4wMDM4NiAwLjE5NTMxLDAuMDExNzJjMC4wNjA5NCwwLjAwNjgxIDAuMTIwMzMsMC4wMjM2NCAwLjE3NTc4LDAuMDQ5OGMwLjA1MTk3LDAuMDI0NDEgMC4wOTYsMC4wNjMgMC4xMjcsMC4xMTEzM2MwLjA2Mzg1LDAuMTI4NTcgMC4wNjI0LDAuMjc5OTEgLTAuMDAzOTEsMC40MDcyM2MtMC4wMzE1MywwLjA0OTMxIC0wLjA3NjE3LDAuMDg4ODYgLTAuMTI4OTEsMC4xMTQyNWMtMC4wNTU0NSwwLjAyNjE3IC0wLjExNDg1LDAuMDQzIC0wLjE3NTc4LDAuMDQ5ODFjLTAuMDY0ODEsMC4wMDc4NiAtMC4xMzAwMywwLjAxMTc2IC0wLjE5NTMxLDAuMDExNzJjLTAuMDM1MTYsMCAtMC4wNzAzMSwtMC4wMDEgLTAuMTAzNTIsLTAuMDAyOTNjLTAuMDMzMjEsLTAuMDAxOTMgLTAuMDY0NDUsLTAuMDAyOTMgLTAuMDk1NywtMC4wMDI5M2MtMC4wMDAyNywwLjA2MTg0IC0wLjAwNTUsMC4xMjM1NiAtMC4wMTU2MiwwLjE4NDU3Yy0wLjAwODUxLDAuMDU3MTEgLTAuMDI4NDQsMC4xMTE5MSAtMC4wNTg2LDAuMTYxMTNjLTAuMDI4OTEsMC4wNDY1MSAtMC4wNjkyNSwwLjA4NDg0IC0wLjExNzE5LDAuMTExMzNjLTAuMDU2NjUsMC4wMjkyNSAtMC4xMTk4OCwwLjA0MzM3IC0wLjE4MzU5LDAuMDQxYy0wLjIwNTk0LC0wLjAwMjggLTAuMzcyMiwtMC4xNjkwNiAtMC4zNzUsLTAuMzc1di0xLjVjMC4wMDI4MSwtMC4yMDU5MyAwLjE2OTA3LC0wLjM3MjE5IDAuMzc1LC0wLjM3NWgwLjc1YzAuMjA1OTMsMC4wMDI4MSAwLjM3MjE5LDAuMTY5MDcgMC4zNzUsMC4zNzVjMC4wMDMzNCwwLjA3MTg0IC0wLjAxNDMsMC4xNDMxIC0wLjA1MDc4LDAuMjA1MDhjLTAuMDMxNTMsMC4wNDkzMSAtMC4wNzYxNywwLjA4ODg3IC0wLjEyODkxLDAuMTE0MjZjLTAuMDU1NDUsMC4wMjYxNiAtMC4xMTQ4NSwwLjA0MyAtMC4xNzU3OCwwLjA0OTgxYy0wLjA2NDgxLDAuMDA3ODUgLTAuMTMwMDMsMC4wMTE3NiAtMC4xOTUzMSwwLjAxMTcxYy0wLjAzNTE2LDAgLTAuMDcwMzEsLTAuMDAxIC0wLjEwMzUyLC0wLjAwMjkzYy0wLjAzMzIxLC0wLjAwMTkzIC0wLjA2NDQ1LC0wLjAwMjk2IC0wLjA5NTc0LC0wLjAwMjk2eiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuMyIvPjxwYXRoIGQ9Ik0yMzMuMzEzMDgsMTg2Ljc1OTkzdi0xMy41MTk4NmgxMy4zNzM4NXYxMy41MTk4NnoiIGZpbGwtb3BhY2l0eT0iMC4wODIzNSIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjYuNjg2OTI1MDAwMDAwMDAyOjYuNzU5OTI5OTk5OTk5OTk3LS0+" alt="PDF">
            </button>
            <button id="annotation-audio-btn" class="anno-circle-btn annotation-mode-switch-btn" title="音频">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA4LC0xNzMuMjQwMDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzMuMzEzMDgsMTg2Ljc1OTkzdi0xMy41MTk4NmgxMy4zNzM4NXYxMy41MTk4NnoiIGZpbGwtb3BhY2l0eT0iMC4wODIzNSIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yNDMuNzg3NjksMTc0Ljg0NTl2OC43NzE0OGMwLjAwMTU4LDAuMjQ2NSAtMC4wNTA0LDAuNDkwNDEgLTAuMTUyMzQsMC43MTQ4NGMtMC4wOTg2NCwwLjIxODUxIC0wLjIzNzgyLDAuNDE2MzQgLTAuNDEwMTYsMC41ODNjLTAuMTczMTEsMC4xNjY4MyAtMC4zNzU3OSwwLjI5OTk3IC0wLjU5NzY1LDAuMzkyNThjLTAuNDYzNDQsMC4xOTI0MiAtMC45ODQ2MSwwLjE5MTM2IC0xLjQ0NzI3LC0wLjAwMjkzYy0wLjQ0ODQyLC0wLjE5MDYxIC0wLjgwNTQ4LC0wLjU0NzY2IC0wLjk5NjA5LC0wLjk5NjA5Yy0wLjE5NDMxLC0wLjQ2MjY2IC0wLjE5NTM2LC0wLjk4MzgzIC0wLjAwMjkzLC0xLjQ0NzI3YzAuMDkyNjIsLTAuMjIxODcgMC4yMjU3NCwtMC40MjQ1NCAwLjM5MjU3LC0wLjU5NzY2YzAuMTY2NjcsLTAuMTcyMzMgMC4zNjQ1LC0wLjMxMTUgMC41ODMsLTAuNDEwMTVjMC4yMjQ0NCwtMC4xMDE5NSAwLjQ2ODM0LC0wLjE1MzkzIDAuNzE0ODUsLTAuMTUyMzVjMC4yMDg0NCwtMC4wMDAzNiAwLjQxNTc4LDAuMDMwMjUgMC42MTUyMywwLjA5MDgyYzAuMTk5MjksMC4wNjA1OSAwLjM4NTkxLDAuMTU2ODggMC41NTA3OCwwLjI4NDE4di00LjMzNTkybC01LjI1LDEuOTY4NzV2NC42NTgyYzAuMDAxNTgsMC4yNDY1IC0wLjA1MDM5LDAuNDkwNDEgLTAuMTUyMzQsMC43MTQ4NGMtMC4wOTg2NCwwLjIxODUxIC0wLjIzNzgyLDAuNDE2MzQgLTAuNDEwMTYsMC41ODNjLTAuMTczMTEsMC4xNjY4MyAtMC4zNzU3OSwwLjI5OTk3IC0wLjU5NzY1LDAuMzkyNThjLTAuNDYzNDQsMC4xOTI0MiAtMC45ODQ2MSwwLjE5MTM2IC0xLjQ0NzI3LC0wLjAwMjkzYy0wLjQ0ODQyLC0wLjE5MDYxIC0wLjgwNTQ4LC0wLjU0NzY2IC0wLjk5NjA5LC0wLjk5NjA5Yy0wLjE5NDMxLC0wLjQ2MjY2IC0wLjE5NTM3LC0wLjk4MzgzIC0wLjAwMjkzLC0xLjQ0NzI3YzAuMDkyNjIsLTAuMjIxODcgMC4yMjU3NCwtMC40MjQ1NCAwLjM5MjU3LC0wLjU5NzY2YzAuMTY2NjcsLTAuMTcyMzMgMC4zNjQ0OSwtMC4zMTE1IDAuNTgzLC0wLjQxMDE1YzAuMjI0NDQsLTAuMTAxOTUgMC40NjgzNCwtMC4xNTM5MyAwLjcxNDg1LC0wLjE1MjM1YzAuMjA3NDksLTAuMDAwNTEgMC40MTM4OSwwLjAzMDExIDAuNjEyMywwLjA5MDgyYzAuMTk3MjcsMC4wNjA1NSAwLjM4MjYxLDAuMTU0NzIgMC41NDc4NSwwLjI3ODMzbC0wLjAyMzQ0LC01Ljg1OTM4YzAuMDAwMzgsLTAuMTE0NDkgMC4wMzYyLC0wLjIyNjA0IDAuMTAyNTQsLTAuMzE5MzRjMC4wNjQ5MywtMC4wOTY4NiAwLjE1Nzk3LC0wLjE3MTUgMC4yNjY2MSwtMC4yMTM4Nmw1LjY1NDMyLC0yLjEwOTM2YzAuMDYxNiwtMC4wMjQgMC4xMjcyNSwtMC4wMzU5MiAwLjE5MzM2LC0wLjAzNTE1YzAuMTQ5MzgsLTAuMDAwNjMgMC4yOTI4MiwwLjA1ODQzIDAuMzk4NDQsMC4xNjQwNWMwLjEwNTYyLDAuMTA1NjMgMC4xNjQ2OSwwLjI0OTA3IDAuMTY0MDYsMC4zOTg0NXpNMjM3LjAzNzY5LDE4NC4zMjA1MWMwLjAwMDY4LC0wLjE0OTAyIC0wLjAyOTI0LC0wLjI5NjYgLTAuMDg3ODksLTAuNDMzNmMtMC4wNTY3MywtMC4xMzM5OCAtMC4xMzkzNiwtMC4yNTU0NSAtMC4yNDMxNiwtMC4zNTc0MmMtMC4xMDQwNCwtMC4xMDE5IC0wLjIyNjI3LC0wLjE4MzM5IC0wLjM2MDM1LC0wLjI0MDIzYy0wLjI3NzE4LC0wLjExNzIgLTAuNTkwMDEsLTAuMTE3MiAtMC44NjcxOSwwYy0wLjI3MTcxLDAuMTE1NDYgLTAuNDg4MDYsMC4zMzE4IC0wLjYwMzUyLDAuNjAzNTFjLTAuMTE3MTksMC4yNzcxOSAtMC4xMTcxOSwwLjU5IDAsMC44NjcxOWMwLjExNTQ2LDAuMjcxNzEgMC4zMzE4MSwwLjQ4ODA1IDAuNjAzNTIsMC42MDM1MWMwLjEzNywwLjA1ODY1IDAuMjg0NTcsMC4wODg1NiAwLjQzMzU5LDAuMDg3ODljMC4xNTEyNSwwLjAwMTA0IDAuMzAxLC0wLjAyOTkxIDAuNDM5NDUsLTAuMDkwODJjMC4xMzMyMSwtMC4wNTgxNSAwLjI1NDQyLC0wLjE0MDYyIDAuMzU3NDMsLTAuMjQzMTZjMC4yMDk4NiwtMC4yMTIxNyAwLjMyNzc0LC0wLjQ5ODQ0IDAuMzI4MTIsLTAuNzk2ODd6TTIzNy43NjQyNSwxNzcuMDg0MTh2MS44MjgxMmw1LjI3MzQ0LC0xLjk2ODc1di0xLjgyODEyek0yNDMuMDM3NjksMTgzLjU3NjM2YzAuMDAwNjcsLTAuMTQ5MDIgLTAuMDI5MjQsLTAuMjk2NTkgLTAuMDg3ODksLTAuNDMzNTljLTAuMTE1NDYsLTAuMjcxNzEgLTAuMzMxOCwtMC40ODgwNSAtMC42MDM1MSwtMC42MDM1MWMtMC4yNzcxOCwtMC4xMTcyIC0wLjU5MDAxLC0wLjExNzIgLTAuODY3MTksMGMtMC4yNzE3MSwwLjExNTQ2IC0wLjQ4ODA2LDAuMzMxOCAtMC42MDM1MiwwLjYwMzUxYy0wLjExNzE5LDAuMjc3MTkgLTAuMTE3MTksMC41OSAwLDAuODY3MTljMC4xMTU0NiwwLjI3MTcxIDAuMzMxODEsMC40ODgwNSAwLjYwMzUyLDAuNjAzNTFjMC4yNzcxOCwwLjExNzE5IDAuNTkwMDEsMC4xMTcxOSAwLjg2NzE5LDBjMC4yNzE3MSwtMC4xMTU0NiAwLjQ4ODA1LC0wLjMzMTggMC42MDM1MSwtMC42MDM1MWMwLjA1ODY1LC0wLjEzNyAwLjA4ODU3LC0wLjI4NDU4IDAuMDg3ODksLTAuNDMzNnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjY4NjkyMzY3OTI3OTc3Mjo2Ljc1OTkyODAyMTg5Mjk4OS0tPg==" alt="Audio">
            </button>
            <button id="annotation-edit-text-btn" class="anno-circle-btn" style="display: none;" title="编辑内容">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" alt="Edit">
            </button>
            <button id="annotation-delete-btn" class="anno-circle-btn" style="display: none;" title="删除">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" alt="Delete">
            </button>
             <button id="annotation-eraser-btn" class="anno-circle-btn annotation-mode-switch-btn" title="橡皮">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMi4yMzk1IiBoZWlnaHQ9IjEyLjczNTY5IiB2aWV3Qm94PSIwLDAsMTIuMjM5NSwxMi43MzU2OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzMy44ODAyNSwtMTczLjYzMjE2KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjMzLjg4MDI1LDE4Ni4zNjc4NnYtMTIuNzM1NjloMTIuMjM5NXYxMi43MzU2OXoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM4LjQxMTAxLDE4NS4xNjk3M2MtMC4xMjUyMiwwLjAwMDQ0IC0wLjI0OTIsLTAuMDI0ODIgLTAuMzY0MjYsLTAuMDc0MjJjLTAuMTE2MzksLTAuMDQ4NjcgLTAuMjIxNywtMC4xMjA0MyAtMC4zMDk1NywtMC4yMTA5NGwtMi43MTE0MiwtMi43NjU2MmMtMC4wODgyLC0wLjA5MTIxIC0wLjE1Nzg0LC0wLjE5ODY2IC0wLjIwNTA4LC0wLjMxNjQxYy0wLjA5OTYxLC0wLjI0MTYgLTAuMDk5NjEsLTAuNTEyNzkgMCwtMC43NTQzOWMwLjA0NzAxLC0wLjExNzU3IDAuMTE2NjksLTAuMjI0NzUgMC4yMDUwOCwtMC4zMTU0M2w1LjU5NzY1LC01LjcxMDQ1YzAuMDg4NjIsLTAuMDkxMSAwLjE5NDk3LC0wLjE2MzA2IDAuMzEyNSwtMC4yMTE0M2MwLjExNjIxLC0wLjA0ODk1IDAuMjQxMDksLTAuMDc0MDEgMC4zNjcxOSwtMC4wNzM2OGMwLjI1NTksLTAuMDA0MTUgMC41MDE3OSwwLjA5OTMxIDAuNjc3NzQsMC4yODUxNmwyLjcxMjg5LDIuNzY2MTFjMC4xODMxOCwwLjE4MzM1IDAuMjgzOTksMC40MzMyNiAwLjI3OTI5LDAuNjkyMzljLTAuMDAwNDYsMC4xMjgyNSAtMC4wMjQ5OCwwLjI1NTI5IC0wLjA3MjI2LDAuMzc0NTFjLTAuMDQ3MzQsMC4xMTg3MyAtMC4xMTc2OCwwLjIyNjkzIC0wLjIwNywwLjMxODM2bC01LjIzODgsNS4zNDM3aDUuMTk3NzVjMC4wODUxLC0wLjAwMDY0IDAuMTY2NTgsMC4wMzQ0MyAwLjIyNDYxLDAuMDk2NjhjMC4wNjE5OSwwLjA2MDE1IDAuMDk2NTksMC4xNDMxMSAwLjA5NTcsMC4yMjk0OWMwLjAwMTI3LDAuMDg2NDUgLTAuMDMzMzgsMC4xNjk1NiAtMC4wOTU3LDAuMjI5NDljLTAuMDU4MDMsMC4wNjIyNSAtMC4xMzk1LDAuMDk3MzIgLTAuMjI0NjEsMC4wOTY2OHpNMjM1LjA2NTMxLDE4NS4xNjk3M2MtMC4wODUwOCwwLjAwMDU1IC0wLjE2NjUzLC0wLjAzNDUgLTAuMjI0NjEsLTAuMDk2NjhjLTAuMDYxNDgsLTAuMDYwNDMgLTAuMDk1NjksLTAuMTQzMjkgLTAuMDk0NzMsLTAuMjI5NDljLTAuMDAwNTksLTAuMDg2MTMgMC4wMzM1NywtMC4xNjg4NiAwLjA5NDczLC0wLjIyOTQ5YzAuMDU4MDksLTAuMDYyMTcgMC4xMzk1MywtMC4wOTcyMyAwLjIyNDYxLC0wLjA5NjY4aDEuMjc4MzJjMC4wODUyNCwtMC4wMDA2NSAwLjE2Njg4LDAuMDM0NDEgMC4yMjUxLDAuMDk2NjhjMC4wNjExNiwwLjA2MDY0IDAuMDk1MywwLjE0MzM2IDAuMDk0NzIsMC4yMjk0OWMwLjAwMDk2LDAuMDg2MiAtMC4wMzMyNSwwLjE2OTA2IC0wLjA5NDcyLDAuMjI5NDljLTAuMDU4MjIsMC4wNjIyNyAtMC4xMzk4NiwwLjA5NzMzIC0wLjIyNTEsMC4wOTY2OHpNMjM4LjQxNjM4LDE4NC41MjMyNWMwLjA4NTMxLDAuMDAwNjMgMC4xNjY4OSwtMC4wMzQ4NCAwLjIyNDYxLC0wLjA5NzY2bDEuMDc4MTMsLTEuMDk5NjFsLTMuMTY1NTMsLTMuMjNsLTEuMDc4NjEsMS4xMDAxMmMtMC4wNTk5LDAuMDYxMSAtMC4wOTIzMywwLjE0Mzk2IC0wLjA4OTg1LDAuMjI5NDljMC4wMDAwMiwwLjA0MTcyIDAuMDA3NjMsMC4wODMwOCAwLjAyMjQ2LDAuMTIyMDdjMC4wMTQ1MywwLjA0MDIxIDAuMDM3NTEsMC4wNzY4NCAwLjA2NzM5LDAuMTA3NDJsMi43MTYyNywyLjc3MDUxYzAuMDU3ODYsMC4wNjI5MiAwLjEzOTY2LDAuMDk4NCAwLjIyNTEzLDAuMDk3NjZ6TTI0NC4zMzIzOCwxNzguNDgwNzdjMC4wMDA5LC0wLjA4NTg1IC0wLjAzMjksLTAuMTY4NDIgLTAuMDkzNzUsLTAuMjI5bC0yLjcxMDkyLC0yLjc2NjEyYy0wLjA1ODI1LC0wLjA2MTk0IC0wLjEzOTU4LC0wLjA5Njk1IC0wLjIyNDYxLC0wLjA5NjY4Yy0wLjA4NTE4LC0wLjAwMTAyIC0wLjE2NjgxLDAuMDM0MSAtMC4yMjQ2MSwwLjA5NjY4bC00LjA3MDMxLDQuMTUxODVsMy4xNjAxNiwzLjIyNDY2bDQuMDcwMzEsLTQuMTUxOWMwLjA2MDk0LC0wLjA2MDcxIDAuMDk0NzQsLTAuMTQzNDcgMC4wOTM3NSwtMC4yMjk0OXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo2LjExOTc1MDAwMDAwMDAxMDU6Ni4zNjc4MzQ5OTk5OTk5ODUtLT4=" alt="Eraser">
            </button>


        </div>

        <div class="anno-btn-group" id="anno-group-right">
            <button id="annotation-exit-btn" class="anno-circle-btn close-btn" title="关闭">
                <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMy4zNzM4NSIgaGVpZ2h0PSIxMy41MTk4NiIgdmlld0JveD0iMCwwLDEzLjM3Mzg1LDEzLjUxOTg2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMzLjMxMzA3LC0xNzMuMjQwMDcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDMuNTU3NzMsMTc2LjQ4MTkybC0zLjQ3MzM0LDMuNDczMzQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjA4NDQsMTgwLjEzMzM4bDMuNDczMzQsMy4yOTUyMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuNDQyMywxODMuNTE4MDhsMy41NTY3MywtMy4zODc5MiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuMDAzMzUsMTc5Ljk1MjA3bC0zLjM5MjI2LC0zLjM3ODY2IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzMy4zMTMwOCwxODYuNzU5OTN2LTEzLjUxOTg2aDEzLjM3Mzg1djEzLjUxOTg2eiIgZmlsbC1vcGFjaXR5PSIwLjA4MjM1IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iTmFOIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjYuNjg2OTI1MDAwMDAwMDAyOjYuNzU5OTI5OTk5OTk5OTk3LS0+" alt="Close">
            </button>
        </div>
    </div>

    <div class="annotation-sliders-container">
        <div class="slider-group" id="slider-group-h"><label>颜色</label><div id="pen-color-slider-h" class="custom-slider-container"></div></div>
        <div class="slider-group" id="slider-group-s"><label>饱和度</label><div id="pen-color-slider-s" class="custom-slider-container"></div></div>
        <div class="slider-group" id="slider-group-b"><label>亮度</label><div id="pen-color-slider-b" class="custom-slider-container"></div></div>
        <div class="slider-group" id="slider-group-a"><label>透明度</label><div id="pen-color-slider-a" class="custom-slider-container"></div></div>
        <div class="slider-group" id="pen-thickness-group"><label>粗细</label><div id="pen-thickness-slider" class="custom-slider-container"></div></div>
        <div class="slider-group" id="text-size-group" style="display: none;"><label>字号</label><div id="text-size-slider" class="custom-slider-container"></div></div>
    </div>
</div>
<script id="line-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_vertexPosition;

    uniform vec2 u_canvasCssSize;
    uniform vec2 u_viewOffset;
    uniform float u_viewScale;

    void main() {
        vec2 screenPos = vec2(
            u_viewOffset.x + a_vertexPosition.x * u_viewScale,
            u_viewOffset.y - a_vertexPosition.y * u_viewScale
        );
        vec2 normalizedScreenPos = screenPos / u_canvasCssSize;
        vec2 clipSpacePos = (normalizedScreenPos * 2.0 - 1.0) * vec2(1.0, -1.0);
        gl_Position = vec4(clipSpacePos, 0.0, 1.0);
    }
</script>

<script id="line-fragment-shader" type="x-shader/x-fragment">
    precision highp float;
    uniform vec4 u_color;

    void main() {
        gl_FragColor = u_color;
    }
</script>
<script id="shader-3d-vertex" type="x-shader/x-vertex">
    attribute vec3 a_position;
    attribute vec3 a_normal;
    
    uniform mat4 u_modelViewProjection;
    uniform mat4 u_normalMatrix;
    
    varying vec3 v_normal;
    varying vec3 v_position;
    
    void main() {
        v_position = a_position;

        v_normal = mat3(u_normalMatrix) * a_normal;
        gl_Position = u_modelViewProjection * vec4(a_position, 1.0);
    }
</script>

<script id="shader-3d-fragment" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec3 v_normal;
    varying vec3 v_position;
    
    uniform vec4 u_color;
    uniform vec3 u_lightDirection;
    uniform vec3 u_viewPosition;
    uniform float u_bounds;
    
    void main() {

        if (abs(v_position.x) > u_bounds || abs(v_position.y) > u_bounds || abs(v_position.z) > u_bounds) discard;

        vec3 normal = normalize(v_normal);
        vec3 lightDir = normalize(u_lightDirection);
        

        float ambient = 0.3;
        

        float diff = max(dot(normal, lightDir), 0.0);
        

        float backDiff = max(dot(normal, -lightDir), 0.0) * 0.5;
        
        vec3 finalColor = u_color.rgb * (ambient + diff + backDiff);
        
        gl_FragColor = vec4(finalColor, u_color.a);
    }
</script>
<script id="shader-3d-thick-line-vertex" type="x-shader/x-vertex">
    attribute vec3 a_pos;
    attribute vec3 a_other;
    attribute float a_side;
    
    uniform mat4 u_mvp;
    uniform vec2 u_viewport;
    uniform float u_thickness;
    
    void main() {
        vec4 p1 = u_mvp * vec4(a_pos, 1.0);
        vec4 p2 = u_mvp * vec4(a_other, 1.0);
        
        vec2 s1 = p1.xy / p1.w * u_viewport;
        vec2 s2 = p2.xy / p2.w * u_viewport;
        
        vec2 dir = normalize(s2 - s1);
        vec2 normal = vec2(-dir.y, dir.x);
        

        vec2 offset = normal * (u_thickness * 0.5) * a_side;
        vec2 offsetNDC = offset / (u_viewport * 0.5); 
        
        gl_Position = p1 + vec4(offsetNDC * p1.w, 0.0, 0.0);
    }
</script>

<script id="shader-3d-thick-line-fragment" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    uniform float u_bounds;
    
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
     const NEW_WORKSPACE_THUMBNAIL_BASE64 = ""; 


 const Mat4 = {
        create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
        perspective: (out, fovy, aspect, near, far) => {
            const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            return out;
        },
        lookAt: (out, eye, center, up) => {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex=eye.x, eyey=eye.y, eyez=eye.z;
            let upx=up.x, upy=up.y, upz=up.z;
            let centerx=center.x, centery=center.y, centerz=center.z;
            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;
            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0=0; x1=0; x2=0; } else { len=1/len; x0*=len; x1*=len; x2*=len; }
            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0=0; y1=0; y2=0; } else { len=1/len; y0*=len; y1*=len; y2*=len; }
            out[0]=x0; out[1]=y0; out[2]=z0; out[3]=0;
            out[4]=x1; out[5]=y1; out[6]=z1; out[7]=0;
            out[8]=x2; out[9]=y2; out[10]=z2; out[11]=0;
            out[12]=-(x0*eyex + x1*eyey + x2*eyez);
            out[13]=-(y0*eyex + y1*eyey + y2*eyez);
            out[14]=-(z0*eyex + z1*eyey + z2*eyez);
            out[15]=1;
            return out;
        },
        multiply: (out, a, b) => {
            let a00=a[0], a01=a[1], a02=a[2], a03=a[3];
            let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
            let a20=a[8], a21=a[9], a22=a[10], a23=a[11];
            let a30=a[12], a31=a[13], a32=a[14], a33=a[15];
            let b0=b[0], b1=b[1], b2=b[2], b3=b[3];
            out[0]=b0*a00+b1*a10+b2*a20+b3*a30; out[1]=b0*a01+b1*a11+b2*a21+b3*a31; out[2]=b0*a02+b1*a12+b2*a22+b3*a32; out[3]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
            out[4]=b0*a00+b1*a10+b2*a20+b3*a30; out[5]=b0*a01+b1*a11+b2*a21+b3*a31; out[6]=b0*a02+b1*a12+b2*a22+b3*a32; out[7]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
            out[8]=b0*a00+b1*a10+b2*a20+b3*a30; out[9]=b0*a01+b1*a11+b2*a21+b3*a31; out[10]=b0*a02+b1*a12+b2*a22+b3*a32; out[11]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
            out[12]=b0*a00+b1*a10+b2*a20+b3*a30; out[13]=b0*a01+b1*a11+b2*a21+b3*a31; out[14]=b0*a02+b1*a12+b2*a22+b3*a32; out[15]=b0*a03+b1*a13+b2*a23+b3*a33;
            return out;
        },
        invert: (out, a) => {
            let a00=a[0], a01=a[1], a02=a[2], a03=a[3],
                a10=a[4], a11=a[5], a12=a[6], a13=a[7],
                a20=a[8], a21=a[9], a22=a[10], a23=a[11],
                a30=a[12], a31=a[13], a32=a[14], a33=a[15],
                b00=a00*a11-a01*a10, b01=a00*a12-a02*a10, b02=a00*a13-a03*a10,
                b03=a01*a12-a02*a11, b04=a01*a13-a03*a11, b05=a02*a13-a03*a12,
                b06=a20*a31-a21*a30, b07=a20*a32-a22*a30, b08=a20*a33-a23*a30,
                b09=a21*a32-a22*a31, b10=a21*a33-a23*a31, b11=a22*a33-a23*a32,
                det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;
            if(!det)return null;
            det=1.0/det;
            out[0]=(a11*b11-a12*b10+a13*b09)*det; out[1]=(a02*b10-a01*b11-a03*b09)*det; out[2]=(a31*b05-a32*b04+a33*b03)*det; out[3]=(a22*b04-a21*b05-a23*b03)*det;
            out[4]=(a12*b08-a10*b11-a13*b07)*det; out[5]=(a00*b11-a02*b08+a03*b07)*det; out[6]=(a32*b02-a30*b05-a33*b01)*det; out[7]=(a20*b05-a22*b02+a23*b01)*det;
            out[8]=(a10*b10-a11*b08+a13*b06)*det; out[9]=(a01*b08-a00*b10-a03*b06)*det; out[10]=(a30*b04-a31*b02+a33*b00)*det; out[11]=(a21*b02-a20*b04-a23*b00)*det;
            out[12]=(a11*b07-a10*b09-a12*b06)*det; out[13]=(a00*b09-a01*b07+a02*b06)*det; out[14]=(a31*b01-a30*b03-a32*b00)*det; out[15]=(a20*b03-a21*b01+a22*b00)*det;
            return out;
        },
        transpose: (out, a) => {
            let a01 = a[1], a02 = a[2], a03 = a[3];
            let a12 = a[6], a13 = a[7];
            let a23 = a[11];
            out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
            out[4] = a01; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
            out[8] = a02; out[9] = a12; out[10] = a[10]; out[11] = a[14];
            out[12] = a03; out[13] = a13; out[14] = a23; out[15] = a[15];
            return out;
        },
        transformVec3: (out, a, m) => {
            let x = a[0], y = a[1], z = a[2];
            let w = m[3] * x + m[7] * y + m[11] * z + m[15];
            w = w || 1.0;
            out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
            out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
            out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
            return out;
        }
        
    };



const edgeTable = new Int32Array([
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
]);

const triTable = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
];


const ADVANCED_FUNCTION_DEFINITIONS = [
{
    name: 'pow',
    params: ["in1","in2"],
    bodyJsString: `
const list1 = [
            66666667, 40000000, 80000000, 28571429, 57142857, 85714286, 22222222, 44444444, 88888889,
            18181818, 36363636, 54545455, 72727273, 90909091, 15384615, 30769231, 46153846, 61538462,
            76923077, 92307692, 13333333, 26666667, 53333333, 93333333, 11764706, 23529412, 35294118,
            47058824, 58823529, 70588235, 82352941, 94117647, 10526316, 21052632, 31578947, 42105263,
            52631579, 63157895, 73684211, 84210526, 94736842, 9523810, 19047619, 38095238, 47619048,
            76190476, 95238095, 8695652, 17391304, 26086957, 34782609, 43478261, 52173913, 60869565,
            69565217, 78260870, 86956522, 95652174, 8000000, 16000000, 24000000, 32000000, 48000000,
            56000000, 64000000, 72000000, 88000000, 96000000, 7407407, 14814815, 29629630, 37037037,
            51851852, 59259259, 74074074, 81481481, 96296296, 6896552, 13793103, 20689655, 27586207,
            34482759, 41379310, 48275862, 55172414, 62068966, 68965517, 75862069, 82758621, 89655172,
            96551724, 6451613, 12903226, 19354839, 25806452, 32258065, 38709677, 45161290, 51612903,
            58064516, 64516129, 70967742, 77419355, 83870968, 90322581, 96774194, 6060606, 12121212,
            24242424, 30303030, 42424242, 48484848, 60606061, 78787879, 84848485, 96969697, 5714286,
            11428571, 17142857, 22857143, 34285714, 45714286, 51428571, 62857143, 68571429, 74285714,
            91428571, 97142857, 5405405, 10810811, 16216216, 21621622, 27027027, 32432432, 37837838,
            43243243, 48648649, 54054054, 59459459, 64864865, 70270270, 75675676, 81081081, 86486486,
            91891892, 97297297, 5128205, 10256410, 20512821, 25641026, 35897436, 41025641, 51282051,
            56410256, 71794872, 82051282, 87179487, 97435897, 4878049, 9756098, 14634146, 19512195,
            24390244, 29268293, 34146341, 39024390, 43902439, 48780488, 53658537, 58536585, 63414634,
            68292683, 73170732, 78048780, 82926829, 87804878, 92682927, 97560976
        ];

        const list2 = [
            33333333, 20000000, 60000000, 14285714, 42857143, 71428571, 11111111, 55555556, 77777778,
            9090909, 27272727, 45454545, 63636364, 81818182, 7692308, 23076923, 38461538, 53846154,
            69230769, 84615385, 6666667, 46666667, 73333333, 86666667, 5882353, 17647059, 29411765,
            41176471, 52941176, 64705882, 76470588, 88235294, 5263158, 15789474, 26315789, 36842105,
            47368421, 57894737, 68421053, 78947368, 89473684, 4761905, 23809524, 52380952, 61904762,
            80952381, 90476190, 4347826, 13043478, 21739130, 30434783, 39130435, 47826087, 56521739,
            65217391, 73913043, 82608696, 91304348, 4000000, 12000000, 28000000, 36000000, 44000000,
            52000000, 68000000, 76000000, 84000000, 92000000, 3703704, 18518519, 25925926, 40740741,
            48148148, 62962963, 70370370, 85185185, 92592593, 3448276, 10344828, 17241379, 24137931,
            31034483, 37931034, 44827586, 51724138, 58620690, 65517241, 72413793, 79310345, 86206897,
            93103448, 3225806, 9677419, 16129032, 22580645, 29032258, 35483871, 41935484, 48387097,
            54838710, 61290323, 67741935, 74193548, 80645161, 87096774, 93548387, 3030303, 15151515,
            21212121, 39393939, 51515152, 57575758, 69696970, 75757576, 87878788, 93939394, 2857143,
            8571429, 25714286, 31428571, 37142857, 48571429, 54285714, 65714286, 77142857, 82857143,
            88571429, 94285714, 2702703, 8108108, 13513514, 18918919, 24324324, 29729730, 35135135,
            40540541, 45945946, 51351351, 56756757, 62162162, 67567568, 72972973, 78378378, 83783784,
            89189189, 94594595, 2564103, 12820513, 17948718, 28205128, 43589744, 48717949, 58974359,
            64102564, 74358974, 79487179, 89743590, 94871795, 2439024, 7317073, 12195122, 17073171,
            21951220, 26829268, 31707317, 36585366, 41463415, 46341463, 51219512, 56097561, 60975610,
            65853659, 70731707, 75609756, 80487805, 85365854, 90243902, 95121951
        ];
const base = Number(in1);
const exp1 = Number(in2);
let result;


if (base > 0) {
    result = Math.exp(Math.log(base) * exp1);
} 

else if (base === 0) {
    if (exp1 > 0) result = 0;
    else if (exp1 === 0) result = 1;
    else result = NaN; 
} 

else {

    if (Math.round(exp1) === exp1) {
        result = Math.pow(Math.abs(base), exp1);

        if (Math.abs(exp1 % 2) === 1) {
            result = 0 - result;
        }
    } 

    else {
        const absExp = Math.abs(exp1);
        

        const MAX_DENOM = 25; 
        const EPSILON = 1e-9; 
        
        let n = 0; // 分子
        let d = 0; // 分母
        let found = false; // 是否找到符合条件的“漂亮分数”
        
        // --- 连分数算法 ---
        let h1 = 1, k1 = 0; 
        let h2 = 0, k2 = 1;
        let b = absExp;
        
        // 迭代寻找
        for (let i = 0; i < 20; i++) {
            let a = Math.floor(b);
            
            // 递推计算
            let h = a * h1 + h2;
            let k = a * k1 + k2;
            
            // 【关键修改 1】如果在逼近过程中分母超过 13，直接停止，视为无效小数
            if (k > MAX_DENOM) {
                break;
            }
            
            // 【关键修改 2】检查当前分数 h/k 是否足够接近原指数
            // 只有误差极小时才采纳，防止 1.3456 被强行匹配成某个粗糙的分数
            if (Math.abs(absExp - h / k) < EPSILON) {
                n = h;
                d = k;
                found = true;
                break; // 找到了符合限制且足够精确的分数，跳出
            }
            
            // 更新变量进行下一次逼近
            h2 = h1; k2 = k1;
            h1 = h; k1 = k;
            
            if (Math.abs(b - a) < 1e-15) break; // 处理整数边界
            b = 1 / (b - a);
        }

        // --- 计算结果 ---
        // 只有找到了分母 <= 13 的分数，且分母是奇数时，负底数幂才有实数解
        if (found && d % 2 !== 0) {
            // 1. 先计算绝对值的幂
            result = Math.exp(Math.log(Math.abs(base)) * exp1);
            
            // 2. 符号判断：如果分子 n 是奇数，结果取负
            // 注意：Math.exp算出来永远是正数，需手动加负号
            // 例如 (-8)^(1/3) -> n=1(奇), d=3(奇) -> 结果 -2
            // 例如 (-2)^(2/3) -> n=2(偶), d=3(奇) -> 结果 +1.587...
            if (n % 2 !== 0) {
                result = 0 - result;
            }
        } else {
            // 没找到合适的分数（如 1.3456），或者分母是偶数（如 0.5=1/2），返回 NaN
            result = NaN;
        }
    }
}

return result;
    `
},{
        name: 'gamma',
        params: ['input'],
        bodyJsString: `
let count0;
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN; 
}


if (numInput <= 0 && numInput === Math.floor(numInput)) {
    return Infinity; 
}

if (numInput < 0.5) {
    const inputtemp = 1 - numInput; 
    if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
         if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
             return NaN;
         }
    }
    let gammaOfInputtemp = 2.5066282746310002 *
                           Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * 
                           Math.exp(-inputtemp - 6.5) *
                           (0.99999999999980993 +
                            676.5203681218851 / inputtemp -
                            1259.1392167224028 / (inputtemp + 1) +
                            771.32342877765313 / (inputtemp + 2) -
                            176.61502916214059 / (inputtemp + 3) +
                            12.507343278686905 / (inputtemp + 4) -
                            0.13857109526572012 / (inputtemp + 5) +
                            0.0000099843695780195716 / (inputtemp + 6) +
                            0.00000015056327351493116 / (inputtemp + 7));

    const sinOfPiInput = Math.sin(3.141592653589793 * numInput);

    if (Math.abs(sinOfPiInput) < 1e-15) { 
        return Infinity; 
    }
    if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
        return NaN; 
    }


    count0 = 3.141592653589793 / (gammaOfInputtemp * sinOfPiInput);

} else { 
    const inputtemp = numInput; 
    count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *Math.exp(0 -inputtemp - 6.5) *(0.99999999999980993 +676.5203681218851 / inputtemp -
              1259.1392167224028 / (inputtemp + 1) +
              771.32342877765313 / (inputtemp + 2) -
              176.61502916214059 / (inputtemp + 3) +
              12.507343278686905 / (inputtemp + 4) -
              0.13857109526572012 / (inputtemp + 5) +
              0.0000099843695780195716 / (inputtemp + 6) +
              0.00000015056327351493116 / (inputtemp + 7));
}

if (!isFinite(count0)) {
    if (numInput <= 0 && numInput === Math.floor(numInput)) {
        return Infinity;
    }
    return NaN; 
}
if (Math.abs(count0) < 1e-15) { 
    count0 = 0;
}
return count0;
        `
    },{
        name: 'erf',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
const intList1 = [0.9862838086968123,0.9284348836635736,0.827201315069765,0.6872929048116855,0.5152486363581541,0.31911236892788974,0.10805494870734365,-0.10805494870734365,-0.31911236892788974,-0.5152486363581541,-0.6872929048116855,-0.827201315069765,-0.9284348836635736,-0.9862838086968123];
const intList2 = [0.035119460331752,0.08015808715976036,0.12151857068790316,0.15720316715819357,0.18553839747793788,0.20519846372129574,0.21526385346315768,0.21526385346315768,0.20519846372129574,0.18553839747793788,0.15720316715819357,0.12151857068790316,0.08015808715976036,0.035119460331752];
let ram41 = 0;
let ram4205 = 0;
let ram42 = 0;
for (let i=0; i<intList1.length; i++){
ram4205 = 0.5*Math.atan(numInput)*(1+intList1[i]);
ram42 = Math.tan(ram4205);
ram41 += intList2[i]*Math.exp(-ram42*ram42)*(1+Math.tan(ram4205)*Math.tan(ram4205));
}
ram4205 =  ram41*0.5*Math.atan(numInput);
ram41 = 1.12837916709551257*ram4205;
return ram41;
        `
    },
    {
        name: 'erfc',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
const intList1 = [0.9862838086968123,0.9284348836635736,0.827201315069765,0.6872929048116855,0.5152486363581541,0.31911236892788974,0.10805494870734365,-0.10805494870734365,-0.31911236892788974,-0.5152486363581541,-0.6872929048116855,-0.827201315069765,-0.9284348836635736,-0.9862838086968123];
const intList2 = [0.035119460331752,0.08015808715976036,0.12151857068790316,0.15720316715819357,0.18553839747793788,0.20519846372129574,0.21526385346315768,0.21526385346315768,0.20519846372129574,0.18553839747793788,0.15720316715819357,0.12151857068790316,0.08015808715976036,0.035119460331752];
let ram41 = 0;
let ram4205 = 0;
let ram42 = 0;
for (let i=0; i<intList1.length; i++){
ram4205 = 0.5*Math.atan(numInput)*(1+intList1[i]);
ram42 = Math.tan(ram4205);
ram41 += intList2[i]*Math.exp(-ram42*ram42)*(1+Math.tan(ram4205)*Math.tan(ram4205));
}
ram4205 =  ram41*0.5*Math.atan(numInput);
ram41 = 1-1.12837916709551257*ram4205;
return ram41;
        `
    },{
        name: 'elliptice',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
    let ram41 = 0;
    let ram42 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = 0.5*((intList1[i]+1)*1.5707963267948966);
        ram41 += intList2[i] * 0.7853981633974483 * Math.sqrt(1-(numInput*Math.sin(ram42))*(numInput*Math.sin(ram42)));
    }
return ram41;
        `
    },
    {
        name: 'elliptick',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
    let ram41 = 0;
    let ram42 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = 0.5*((intList1[i]+1)*1.5707963267948966);
        ram41 += intList2[i] * 0.7853981633974483 / Math.sqrt(1-(numInput*Math.sin(ram42))*(numInput*Math.sin(ram42)));
    }
return ram41;
        `
    },{
        name: 'sign',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput < 0) {
    return -1;
} else if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'heaviside',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'sgn',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}

if (numInput < 0) {
    return -1;
} else if (numInput > 0) {
    return 1;
} else { 
    return 0;
}
        `
    },{
        name: 'fresnels',
        params: ['input'],
        bodyJsString: `
const intList5 = [0, -0.11833633389852105, 0.11833633389852105, -0.23501148310291813, 0.23501148310291813, -0.34838758198902867, 0.34838758198902867, -0.4568730756140824, 0.4568730756140824, -0.5589450609425611, 0.5589450609425611, -0.6531706636968095, 0.6531706636968095, -0.7382271498464599, 0.7382271498464599, -0.8129204868958123, 0.8129204868958123, -0.8762020862145225, 0.8762020862145225, -0.9271834587251158, 0.9271834587251158, -0.9651484024508189, 0.9651484024508189, -0.9895609637285506, 0.9895609637285506, -1.0, 1.0];
const intList6 = [0.11861397766276303, 0.11778143658595616, 0.11778143658595616, 0.11529550025465198, 0.11529550025465198, 0.11119106525743703, 0.11119106525743703, 0.10552574782125301, 0.10552574782125301, 0.09837907458595276, 0.09837907458595276, 0.08985136525929056, 0.08985136525929056, 0.08006232197053846, 0.08006232197053846, 0.06914934236004328, 0.06914934236004328, 0.05726556968016273, 0.05726556968016273, 0.0445776579330617, 0.0445776579330617, 0.031262951735202384, 0.031262951735202384, 0.01750197487606558, 0.01750197487606558, 0.002849002849002849, 0.002849002849002849];
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN;
}

function sfnintsub(alpha) {
    const inputsfnint = Number(alpha);
    if (inputsfnint > 4.59) {
        return (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.318309886183791) + 0.0967546032995985) * inputsfnint * inputsfnint * inputsfnint * inputsfnint - 0.343115182520605) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 3.44171880544581) / Math.exp(13 * Math.log(inputsfnint)) * Math.cos(1.5707963267948966 * inputsfnint * inputsfnint) + 0.5 + (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.101321183642338) + 0.153989733820265) * inputsfnint * inputsfnint * inputsfnint * inputsfnint - 0.982952592264580) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 14.2419305760949) / Math.exp(15 * Math.log(inputsfnint)) * Math.sin(1.5707963267948966 * inputsfnint * inputsfnint);
    } else {
        let ram41 = 0;
        let ram42 = 0;
        for (let i = 0; i < intList5.length; i++) {
            ram42 = 0.5 * ((intList5[i] + 1) * inputsfnint);
            ram41 += intList6[i] * 0.5 * inputsfnint * Math.sin(ram42 * ram42 * 1.5707963267948966);
        }
        return ram41;
    }
}

if (numInput > 10000000) {
    return 0.5;
} else if (numInput < -10000000) {
    return -0.5;
} else if (numInput < 0) {
    return -sfnintsub(-numInput);
} else {
    return sfnintsub(numInput);
}
        `
    },{
        name: 'fresnelc',
        params: ['input'],
        bodyJsString: `
const intList5 = [0, -0.11833633389852105, 0.11833633389852105, -0.23501148310291813, 0.23501148310291813, -0.34838758198902867, 0.34838758198902867, -0.4568730756140824, 0.4568730756140824, -0.5589450609425611, 0.5589450609425611, -0.6531706636968095, 0.6531706636968095, -0.7382271498464599, 0.7382271498464599, -0.8129204868958123, 0.8129204868958123, -0.8762020862145225, 0.8762020862145225, -0.9271834587251158, 0.9271834587251158, -0.9651484024508189, 0.9651484024508189, -0.9895609637285506, 0.9895609637285506, -1.0, 1.0];
const intList6 = [0.11861397766276303, 0.11778143658595616, 0.11778143658595616, 0.11529550025465198, 0.11529550025465198, 0.11119106525743703, 0.11119106525743703, 0.10552574782125301, 0.10552574782125301, 0.09837907458595276, 0.09837907458595276, 0.08985136525929056, 0.08985136525929056, 0.08006232197053846, 0.08006232197053846, 0.06914934236004328, 0.06914934236004328, 0.05726556968016273, 0.05726556968016273, 0.0445776579330617, 0.0445776579330617, 0.031262951735202384, 0.031262951735202384, 0.01750197487606558, 0.01750197487606558, 0.002849002849002849, 0.002849002849002849];
const numInput = Number(input);

if (isNaN(numInput)) {
    return NaN;
}

function cfnintsub(alpha) {
    const inputsfnint = Number(alpha);
    if (inputsfnint > 4.59) {
        return (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * (-0.101321183642338) +0.153989733820265) * inputsfnint * inputsfnint * inputsfnint * inputsfnint -0.98295259226458) * inputsfnint * inputsfnint * inputsfnint * inputsfnint + 14.2419305760949) / Math.exp(15 * Math.log(inputsfnint)) * Math.cos(1.5707963267948966 * inputsfnint * inputsfnint) + 0.5 + (((inputsfnint * inputsfnint * inputsfnint * inputsfnint * 0.318309886183791 -0.096754603299598) * inputsfnint * inputsfnint * inputsfnint * inputsfnint +0.343115182520605) * inputsfnint * inputsfnint * inputsfnint * inputsfnint -3.44171880544581) / Math.exp(13 * Math.log(inputsfnint)) * Math.sin(1.5707963267948966 * inputsfnint * inputsfnint);
    } else {
        let ram41 = 0;
        let ram42 = 0;
        for (let i = 0; i < intList5.length; i++) {
            ram42 = 0.5 * ((intList5[i] + 1) * inputsfnint);
            ram41 += intList6[i] * 0.5 * inputsfnint * Math.cos(ram42 * ram42 * 1.5707963267948966);
        }
        return ram41;
    }
}

if (numInput > 10000000) {
    return 0.5;
} else if (numInput < -10000000) {
    return -0.5;
} else if (numInput < 0) {
    return -cfnintsub(-numInput);
} else {
    return cfnintsub(numInput);
}
        `
    },{
        name: 'psi',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
    function calculateGamma(gammaInput) {
        const numInputGamma = Number(gammaInput);

        if (isNaN(numInputGamma)) {
            return NaN;
        }

        if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
            return Infinity;
        }

        let count0;
        if (numInputGamma < 0.5) {
            const inputtemp = 1 - numInputGamma;
            if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
                if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
                    return NaN;
                }
            }
            let gammaOfInputtemp = 2.5066282746310002 *
                Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *
                Math.exp(-inputtemp - 6.5) *
                (0.99999999999980993 +
                    676.5203681218851 / inputtemp -
                    1259.1392167224028 / (inputtemp + 1) +
                    771.32342877765313 / (inputtemp + 2) -
                    176.61502916214059 / (inputtemp + 3) +
                    12.507343278686905 / (inputtemp + 4) -
                    0.13857109526572012 / (inputtemp + 5) +
                    0.0000099843695780195716 / (inputtemp + 6) +
                    0.00000015056327351493116 / (inputtemp + 7));

            const sinOfPiInput = Math.sin(Math.PI * numInputGamma);

            if (Math.abs(sinOfPiInput) < 1e-15) {
                return Infinity;
            }
            if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
                return NaN;
            }
            count0 = Math.PI / (gammaOfInputtemp * sinOfPiInput);
        } else {
            const inputtemp = numInputGamma;
            count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * Math.exp(0 - inputtemp - 6.5) * (0.99999999999980993 + 676.5203681218851 / inputtemp -
                1259.1392167224028 / (inputtemp + 1) +
                771.32342877765313 / (inputtemp + 2) -
                176.61502916214059 / (inputtemp + 3) +
                12.507343278686905 / (inputtemp + 4) -
                0.13857109526572012 / (inputtemp + 5) +
                0.0000099843695780195716 / (inputtemp + 6) +
                0.00000015056327351493116 / (inputtemp + 7));
        }

        if (!isFinite(count0)) {
            if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
                return Infinity;
            }
            return NaN;
        }
        if (Math.abs(count0) < 1e-15) {
            count0 = 0;
        }
        return count0;
    }

if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < 0 && numInput % 2 > 1) {
    return NaN;
}
const ram48 = Math.log(calculateGamma(numInput+0.0000001));
const ram49 = Math.log(calculateGamma(numInput-0.0000001));
const ram50 = (ram48-ram49)/0.0000002;
return ram50;
        `
    },
    {
        name: 'lambertw',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < -0.3698) {
    return NaN; 
}
let ram48 = 0;
let ram4801 = 0;
if (numInput > 1) {
ram48 = Math.log(0.367879441171+Math.sqrt(0.735758882343*(0.367879441171+numInput))+0.30406826609*(0.367879441171+numInput));
} else if (numInput <=0) {
ram48 = 0.5;
} else {
ram48 = 0.5*Math.exp(Math.log(numInput)/3);
}
for (let i=0; i<6; i++){
    if (numInput > 1) {
        ram48 = ram48 - (ram48*Math.log(ram48)-numInput)/(Math.log(ram48)+1);
    } else {
        ram48 = ram48 - (ram48*Math.exp(ram48)-numInput)/(Math.exp(ram48)*(ram48+1));
    }
}
if (numInput > 1) {
    ram48 = Math.log(ram48);
}
return ram48;
        `
    },
    {
        name: 'ltw',
        params: ['input'],
        bodyJsString: `
const numInput = Number(input);
if (isNaN(numInput)) { 
    return NaN;
}
if (numInput < -0.3698) {
    return NaN; 
}
let ram48 = 0;
let ram4801 = 0;
if (numInput > 1) {
ram48 = Math.log(0.367879441171+Math.sqrt(0.735758882343*(0.367879441171+numInput))+0.30406826609*(0.367879441171+numInput));
} else if (numInput <=0) {
ram48 = 0.5;
} else {
ram48 = 0.5*Math.exp(Math.log(numInput)/3);
}
for (let i=0; i<6; i++){
    if (numInput > 1) {
        ram48 = ram48 - (ram48*Math.log(ram48)-numInput)/(Math.log(ram48)+1);
    } else {
        ram48 = ram48 - (ram48*Math.exp(ram48)-numInput)/(Math.exp(ram48)*(ram48+1));
    }
}
if (numInput > 1) {
    ram48 = Math.log(ram48);
}
return ram48;
        `
    },{
        name: 'li',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];
let anstemp;
function Ei(inputValue) {
    let ram39;
    let ram40;
    let ram41;
    let ram42;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput === 0) {
        return -Infinity;
    }

    if (numericInput < 0) {
        ram41 = 0;
        ram39 = 1.5707963266948965;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -ram41;
    } else { 
        ram41 = 0;
        ram39 = -0.09966865249116204;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -1.62281281396928 - ram41;
    }
    return ram41;
}

const numInput = Number(input);
if (isNaN(numInput)) {
    return NaN;
}
if (numInput < 1){
    let ram41 = 0;
    let ram42 = 0;
    ram41 = 0;
    for (let i = 0; i < intList1.length; i++) {
        ram42 = Math.tan(0.5*((intList1[i]+1)*Math.atan(numInput)));
        ram41 += intList2[i] / Math.log(ram42) * (1 + ram42 * ram42);
    }
    anstemp = ram41*0.5*Math.atan(numInput);
} else {
    anstemp = Ei(Math.log(numInput));
}
return anstemp;
        `
    },
    {
        name: 'zeta',
        params: ['input'],
        bodyJsString: `
function zeta(input) {
    const intList3 = [-3767.07295202344238794, 20718.90129135376820461, -54269.3950178977148402, 89585.7044308550386081, -104281.5200530007626999, 90823.1555035673480261, -61337.2850255043749233, 32857.2738403674460368, -14173.10630299342443144, 4967.16480612721712562, -1424.318629211626147828, 332.985035713196841030, -65.1540800052316053923, 9.05528272984254832110, -2.27838421479562171980, -0.869333702853347646837, -1.010605698722239028067, -0.999327686833876549310, -1.000032388528751445375, -1.000000132160679152173, -1.000001970769606935476, -0.999879298988036314809, -1.000785194482447799159, -1.003178227954262160056, -0.918938533204672809162, -0.499999999999999999975];
    const intList4 = [1.3083048186768757010e-24, -1.7999869864062488602e-22, 1.1931012369756043030e-20, -5.0751802223521389106e-19, 1.5570752325465378835e-17, -3.6713955155400826896e-16, 6.922805756662876691e-15, -1.0725610525682801118e-13, 1.3922618091090791236e-12, -1.5364814246219452810e-11, 1.4579564085640510737e-10, -1.2001975969275128697e-9, 8.633561918653007587e-9, -5.4594868401656446764e-8, 3.0503075328141795841e-7, -1.5125434905810207720e-6, 6.684076591078296649e-6, -0.000026431136828897944873, 0.00009393159806725266375, -0.00030149203693227594249, 0.0008792353824119747563, -0.0023471823395646685576, 0.005789968439669778913, -0.013349584800389788883, 0.029149267728612186032, -0.06110256079651455023, 0.12443817580896012489, -0.24813667949159626221, 0.48506436189962881445, -0.9222804836540180001, 1.6692184480209623179, -2.7428447125055807821, 3.6757500000505673416, -1.9999996917015266665];

    function calculateGamma(gammaInput) {
        const numInputGamma = Number(gammaInput);

        if (isNaN(numInputGamma)) {
            return NaN;
        }

        if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
            return Infinity;
        }

        let count0;
        if (numInputGamma < 0.5) {
            const inputtemp = 1 - numInputGamma;
            if (inputtemp <= 0 && inputtemp === Math.floor(inputtemp)) {
                if (inputtemp <= 0 && Math.floor(inputtemp) === inputtemp) {
                    return NaN;
                }
            }
            let gammaOfInputtemp = 2.5066282746310002 *
                Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) *
                Math.exp(-inputtemp - 6.5) *
                (0.99999999999980993 +
                    676.5203681218851 / inputtemp -
                    1259.1392167224028 / (inputtemp + 1) +
                    771.32342877765313 / (inputtemp + 2) -
                    176.61502916214059 / (inputtemp + 3) +
                    12.507343278686905 / (inputtemp + 4) -
                    0.13857109526572012 / (inputtemp + 5) +
                    0.0000099843695780195716 / (inputtemp + 6) +
                    0.00000015056327351493116 / (inputtemp + 7));

            const sinOfPiInput = Math.sin(Math.PI * numInputGamma);

            if (Math.abs(sinOfPiInput) < 1e-15) {
                return Infinity;
            }
            if (Math.abs(gammaOfInputtemp) < 1e-15 && Math.abs(sinOfPiInput) < 1e-15) {
                return NaN;
            }
            count0 = Math.PI / (gammaOfInputtemp * sinOfPiInput);
        } else {
            const inputtemp = numInputGamma;
            count0 = 2.5066282746310002 * Math.exp((inputtemp - 0.5) * Math.log(inputtemp + 6.5)) * Math.exp(0 - inputtemp - 6.5) * (0.99999999999980993 + 676.5203681218851 / inputtemp -
                1259.1392167224028 / (inputtemp + 1) +
                771.32342877765313 / (inputtemp + 2) -
                176.61502916214059 / (inputtemp + 3) +
                12.507343278686905 / (inputtemp + 4) -
                0.13857109526572012 / (inputtemp + 5) +
                0.0000099843695780195716 / (inputtemp + 6) +
                0.00000015056327351493116 / (inputtemp + 7));
        }

        if (!isFinite(count0)) {
            if (numInputGamma <= 0 && numInputGamma === Math.floor(numInputGamma)) {
                return Infinity;
            }
            return NaN;
        }
        if (Math.abs(count0) < 1e-15) {
            count0 = 0;
        }
        return count0;
    }

    if (input === 1) {
        return Infinity;
    }

    let ram48;

    if (input < 0) {
        const oneMinusInput = 1 - input;
        const ramzeta = calculateGamma(oneMinusInput);
        const term_2pi_pow_s_minus_1 = Math.exp(Math.log(2 * Math.PI) * (input - 1));
        const sin_pi_s_div_2 = Math.cos((1 - input) * (Math.PI / 2)); 
        const reflectionFactor = 2 * ramzeta * sin_pi_s_div_2 * term_2pi_pow_s_minus_1;
        
        const zetaOneMinusInput = zeta(oneMinusInput);
        ram48 = zetaOneMinusInput * reflectionFactor;
        return ram48;
    } else if (input < 1) { 
        if (input > 0.5) { 
            const oneMinusInput = 1 - input;
            const zetaOneMinusInput = zeta(oneMinusInput); 
            const ramzeta = calculateGamma(oneMinusInput);
            
            const factor_2_s_pi_s_minus_1 = Math.exp(Math.LN2 * input + Math.log(Math.PI) * (input - 1));
            const sin_pi_s_div_2 = Math.sin(input * (Math.PI / 2));
            
            ram48 = factor_2_s_pi_s_minus_1 * ramzeta * zetaOneMinusInput * sin_pi_s_div_2;
            return ram48;
        } else { 
            ram48 = intList3[0];
            for (let i = 1; i < intList3.length; i++) {
                ram48 = ram48 * input + intList3[i];
            }
            return ram48;
        }
    } else { 
        if (input < 6) {
            ram48 = intList4[0];
            for (let i = 1; i < intList4.length; i++) {
                ram48 = ram48 * input + intList4[i];
            }
            ram48 = 1 / ram48;
            return ram48;
        } else {
            let ram51 = 0;
            let ram46 = 1;
            let ram37 = 1;
            const limit = Math.ceil(75 / input) + 2;
            for (let i = 1; i < limit; i++) {
                ram51 += ram37 / Math.pow(ram46, input);
                ram46 += 1;
                ram37 = -ram37;
            }
            ram48 = ram51 / (1 - Math.pow(2, 1 - input));
            return ram48;
        }
    }
}
const numInputz2 = Number(input);
const anstemp = zeta(numInputz2);
return anstemp;
        `
    },
    {
        name: 'sinintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Si(inputValue) {
    let ram41;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput < 0) {
        const ram4105 = Si(-numericInput);
        ram41 = -ram4105;
    } else {
        if (numericInput > 21.991148575128552) {
            ram41 = Math.PI / 2 +
                Math.sin(numericInput) * (
                    -1 / Math.pow(numericInput, 2) +
                    6 / Math.pow(numericInput, 4) -
                    120 / Math.pow(numericInput, 6) +
                    5040 / Math.pow(numericInput, 8)
                ) +
                Math.cos(numericInput) * (
                    -1 / numericInput +
                    2 / Math.pow(numericInput, 3) -
                    24 / Math.pow(numericInput, 5) +
                    720 / Math.pow(numericInput, 7)
                );
        } else {
            let ram42 = 0;
            ram41 = 0;
            for (let i = 0; i < intList1.length; i++) {
                ram42 = 0.5 * (numericInput + numericInput * intList1[i]);
                if (ram42 === 0) {
                    ram41 += intList2[i] * numericInput / 2;
                } else {
                    ram41 += intList2[i] * 0.5 * numericInput * Math.sin(ram42) / ram42;
                }
            }
        }
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Si(numInputsi);
return anstemp;
        `
    },
    {
        name: 'cosintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Ci(inputValue) {
    let ram41;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput < 0) {
        return NaN;
    } else {
        if (numericInput > 21.991148575128552) {
            ram41 = 
                Math.cos(numericInput) * (
                    -1 / Math.pow(numericInput, 2) +
                    6 / Math.pow(numericInput, 4) -
                    120 / Math.pow(numericInput, 6) +
                    5040 / Math.pow(numericInput, 8)
                ) -
                Math.sin(numericInput) * (
                    -1 / numericInput +
                    2 / Math.pow(numericInput, 3) -
                    24 / Math.pow(numericInput, 5) +
                    720 / Math.pow(numericInput, 7)
                );
        } else {
            let ram42 = 0;
            ram41 = 0;
            for (let i = 0; i < intList1.length; i++) {
                ram42 = 0.5 * (numericInput + numericInput * intList1[i]);
                if (ram42 === 0) {
                    ram41 += intList2[i] * numericInput / 2;
                } else {
                    ram41 += intList2[i] * 0.5 * numericInput * (Math.cos(ram42)-1) / ram42;
                }
            }
            ram41+=Math.log(numericInput);
            ram41+=0.577215664901532;
        }
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Ci(numInputsi);
return anstemp;
        `
    },
    {
        name: 'expintegral',
        params: ['input'],
        bodyJsString: `
const intList1 = [0.9862838086968123, 0.9284348836635736, 0.827201315069765, 0.6872929048116855, 0.5152486363581541, 0.31911236892788974, 0.10805494870734365, -0.10805494870734365, -0.31911236892788974, -0.5152486363581541, -0.6872929048116855, -0.827201315069765, -0.9284348836635736, -0.9862838086968123];
const intList2 = [0.035119460331752, 0.08015808715976036, 0.12151857068790316, 0.15720316715819357, 0.18553839747793788, 0.20519846372129574, 0.21526385346315768, 0.21526385346315768, 0.20519846372129574, 0.18553839747793788, 0.15720316715819357, 0.12151857068790316, 0.08015808715976036, 0.035119460331752];

function Ei(inputValue) {
    let ram39;
    let ram40;
    let ram41;
    let ram42;
    const numericInput = Number(inputValue);

    if (isNaN(numericInput)) {
        return NaN;
    }

    if (numericInput === 0) {
        return -Infinity;
    }

    if (numericInput < 0) {
        ram41 = 0;
        ram39 = 1.5707963266948965;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -ram41;
    } else {
        ram41 = 0;
        ram39 = -0.09966865249116204;
        ram40 = Math.atan(-numericInput);
        for (let i = 0; i < intList1.length; i++) {
            ram42 = 0.5 * (ram39 + ram40 + (ram39 - ram40) * intList1[i]);
            ram41 += intList2[i] * Math.exp(-Math.tan(ram42)) / Math.tan(ram42) * (ram39 - ram40) / 2 * (1 + Math.tan(ram42) * Math.tan(ram42));
        }
        ram41 = -1.62281281396928 - ram41;
    }
    return ram41;
}
const numInputsi = Number(input);
const anstemp = Ei(numInputsi);
return anstemp;
        `
    },{name: 'range',
      params: [
        "x",
        "m",
        "n"
      ],
      bodyJsString: "const num = Number(x);\nconst min = Number(m);\nconst max = Number(n);\n\n\nif (num<min || num>max){\nreturn NaN;\n} else {\nreturn 0;\n}"
    },
    {
      name: "llim",
      params: [
        "x",
        "n"
      ],
      bodyJsString: "const a = Number(x);\nconst b = Number(n);\nif (a<b){\nreturn NaN;\n} else {\nreturn 0;\n}"
    },
    {
      name: "ulim",
      params: [
        "x",
        "n"
      ],
      bodyJsString: "const a = Number(x);\nconst b = Number(n);\nif (a>b){\nreturn NaN;\n} else {\nreturn 0;\n}"
    }
];

class CustomSlider {
    constructor(containerId, options = {}) {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            console.error(`Slider container #${containerId} not found.`);
            return;
        }

        this.options = {
            min: 0,
            max: 1,
            step: 0.01,
            value: 0.5,
            onInput: () => {},
            onChange: () => {},
            type: 'default'
        };
        Object.assign(this.options, options);

        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.container.innerHTML = '';
        this.container.appendChild(this.canvas);
        
        this.isDragging = false;
        this.visualValue = this.options.value;
        this.visualRadiusMultiplier = 1.0;
        this.targetRadiusMultiplier = 1.0;
        this.animationId = null;
        this.resizeObserver = new ResizeObserver(() => this.resizeCanvas());
        this.resizeObserver.observe(this.container);

        this.setupEventListeners();
        this.resizeCanvas();
    }

    resizeCanvas() {
        const rect = this.container.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width * window.devicePixelRatio;
        this.canvas.height = this.height * window.devicePixelRatio;
        this.canvas.style.width = `${this.width}px`;
        this.canvas.style.height = `${this.height}px`;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        this.draw();
    }
    
    setValue(newValue, triggerCallbacks = false) {
        const { min, max, step } = this.options;
        let value = Math.max(min, Math.min(max, newValue));
        if (step > 0) {
            value = min + Math.round((value - min) / step) * step;
        }
        
        if (this.options.value !== value) {
            this.options.value = value;
            if (triggerCallbacks) {
                this.options.onInput({ target: this });
                this.options.onChange({ target: this });
            }
        }
        this.startAnimation();
    }

      
draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        const { min, max, type, context } = this.options;
        const normalizedValue = (this.visualValue - min) / (max - min);

        const w = this.width;
        const h = this.height;
        const radius = h / 2;
        const rootStyle = getComputedStyle(document.documentElement);
        const trackBgColor = rootStyle.getPropertyValue('--input-range-track-bg').trim();

        this.ctx.fillStyle = trackBgColor;
        this.ctx.beginPath();
        this.ctx.arc(radius, radius, radius, Math.PI / 2, 3 * Math.PI / 2);
        this.ctx.lineTo(w - radius, 0);
        this.ctx.arc(w - radius, radius, radius, 3 * Math.PI / 2, Math.PI / 2);
        this.ctx.closePath();
        this.ctx.fill();
        
        let fillStyle;
        const gradient = this.ctx.createLinearGradient(radius, 0, w - radius, 0);

        switch(type) {
            case 'hue':
                gradient.addColorStop(0, 'hsl(0, 100%, 50%)');
                gradient.addColorStop(0.16, 'hsl(60, 100%, 50%)');
                gradient.addColorStop(0.33, 'hsl(120, 100%, 50%)');
                gradient.addColorStop(0.5, 'hsl(180, 100%, 50%)');
                gradient.addColorStop(0.66, 'hsl(240, 100%, 50%)');
                gradient.addColorStop(0.83, 'hsl(300, 100%, 50%)');
                gradient.addColorStop(1, 'hsl(360, 100%, 50%)');
                fillStyle = gradient;
                break;
            case 'saturation':
                if (context) {
                    gradient.addColorStop(0, `hsl(${context.h * 3.6}, 0%, 50%)`);
                    gradient.addColorStop(1, `hsl(${context.h * 3.6}, 100%, 50%)`);
                    fillStyle = gradient;
                }
                break;
            case 'brightness':
                if (context) {
                    gradient.addColorStop(0, `hsl(${context.h * 3.6}, 100%, 0%)`);
                    gradient.addColorStop(1, `hsl(${context.h * 3.6}, 100%, 50%)`);
                    fillStyle = gradient;
                }
                break;
            case 'alpha':
                // 修改：强制使用蓝色 (Hue=56, 对应角度约201度)
                const alphaGradient = this.ctx.createLinearGradient(radius, 0, w - radius, 0);
                // 56 * 3.6 = 201.6度
                alphaGradient.addColorStop(0, `hsla(201.6, 100%, 50%, 1)`);
                alphaGradient.addColorStop(1, `hsla(201.6, 100%, 50%, 0)`);
                fillStyle = alphaGradient;
                break;
            default:
                const isDark = rootStyle.getPropertyValue('--bg-color').trim() < '#888';
                const preferredHue = parseFloat(rootStyle.getPropertyValue('--preferred-hue')) || 0;

                if (!isDark && preferredHue !== 0) {
                    gradient.addColorStop(0, `hsl(${preferredHue}, 100%, 50%)`);
                    gradient.addColorStop(1, `hsl(${preferredHue}, 100%, 50%)`);
                } else {
                    const accentColor = rootStyle.getPropertyValue('--text-color-accent').trim();
                    gradient.addColorStop(0, accentColor);
                    gradient.addColorStop(1, accentColor);
                }
                fillStyle = gradient;
        }

        const knobCenterX = radius + (w - h) * normalizedValue;
        if (knobCenterX > radius) {
            this.ctx.save();
            this.ctx.fillStyle = fillStyle || '#007bff'; 
            this.ctx.beginPath();
            this.ctx.arc(radius, radius, radius, Math.PI / 2, 3 * Math.PI / 2); 
            this.ctx.lineTo(knobCenterX, 0); 
            this.ctx.arc(knobCenterX, radius, radius, 3 * Math.PI / 2, Math.PI / 2); 
            this.ctx.closePath(); 
            this.ctx.fill();
            this.ctx.restore();
        }

        const knobSize = h * 0.675 * 0.75 * this.visualRadiusMultiplier;
        const knobRadius = knobSize / 2;
        this.ctx.fillStyle = 'rgb(255, 255, 255)';
        this.ctx.beginPath();
        this.ctx.arc(knobCenterX, radius, knobRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    startAnimation() {
        if (!this.animationId) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }

    animate() {
        const deltaValue = this.options.value - this.visualValue;
        const deltaRadius = this.targetRadiusMultiplier - this.visualRadiusMultiplier;
        
        const EASING_FACTOR = 0.2;
        if (Math.abs(deltaValue) < (this.options.max - this.options.min) * 0.001 && Math.abs(deltaRadius) < 0.01) {
            this.visualValue = this.options.value;
            this.visualRadiusMultiplier = this.targetRadiusMultiplier;
            this.draw();
            this.animationId = null;
            return;
        }

        this.visualValue += deltaValue * EASING_FACTOR;
        this.visualRadiusMultiplier += deltaRadius * EASING_FACTOR;
        this.draw();
        this.animationId = requestAnimationFrame(() => this.animate());
    }

             handleInteraction(event) {
        event.preventDefault();
        const { min, max, step } = this.options;
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = (event.clientX ?? event.touches[0].clientX) - rect.left;
        
        const travelRange = this.width - this.height;
        const startOffset = this.height / 2;
        
        let normalizedValue = (mouseX - startOffset) / travelRange;
        normalizedValue = Math.max(0, Math.min(1, normalizedValue));
        
        let newValue = min + normalizedValue * (max - min);
        if (step > 0) {
            newValue = min + Math.round((newValue - min) / step) * step;
        }
        
        if (this.options.value !== newValue) {
            this.options.value = newValue;
            this.options.onInput({ target: this });
        }
        this.startAnimation();
    }

    setupEventListeners() {
        const handleDown = (event) => {
            this.isDragging = true;
            this.targetRadiusMultiplier = 1.2;
            this.startAnimation();
            this.handleInteraction(event);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('mouseup', handleUp);
            window.addEventListener('touchend', handleUp);
        };

        const handleMove = (event) => {
            if (this.isDragging) {
                this.handleInteraction(event);
            }
        };

        const handleUp = () => {
            if (this.isDragging) {
                this.isDragging = false;
                this.targetRadiusMultiplier = 1.0;
                this.startAnimation();
                this.options.onChange({ target: this });
                window.removeEventListener('mousemove', handleMove);
                window.removeEventListener('touchmove', handleMove);
                window.removeEventListener('mouseup', handleUp);
                window.removeEventListener('touchend', handleUp);
            }
        };

        this.container.addEventListener('mousedown', handleDown);
        this.container.addEventListener('touchstart', handleDown, { passive: false });
    }

    disconnect() {
        this.resizeObserver.disconnect();
    }
}

class ArchEngine {
    constructor() {
        this.canvas = document.getElementById('plot-canvas');
        this.axisCanvas = document.getElementById('axis-canvas');
        this.axisCtx = this.axisCanvas.getContext('2d');
        this.gl = null;
        this.shaderProgramLines = null;
        this.attributeLocations = {};
        this.uniformLocations = {};
        this.lineVertexBuffer = null;

        this.sidebar = document.getElementById('sidebar');
        this.entryList = document.getElementById('entry-list');
        this.canvasContainer = document.getElementById('canvas-container');
        this.fpsDisplay = document.getElementById('fps-display');
        this.entries = [];
        this.variables = new Map();

        this.allowedVariableKeys = new Set('abcdfghijklmnopqrsuvw'.split(''));
        this.disallowedVariableKeys = new Set('etxyz'.split('')); 

        this.globalPlayState = 0;
        this.rafId = null;
        this.lastAnimationTime = 0;
        this.needsRedraw = false;
        this.lastFPSUpdateTime = 0;
        this.fps = 0;
        this.frameCounter = 0;
        this.editingEntryIndex = -1;

        this.scale = 50;
        this.offset = { x: 0, y: 0 };
        this.dragging = false;
        this.lastPos = { x: 0, y: 0 };
        this.minScale = 0.05;
        this.maxScale = 50000;

        this.isResizingSidebar = false;
        this.initialResizeX = 0;
        this.initialResizeY = 0;
        this.resizeHandleWidth = 10;
        this.touchResizePadding = 20;

        this.isResizingSidebarTouch = false;
        this.initialResizeTouchX = 0;
        this.initialResizeTouchY = 0;
        this.isPortraitMode = false;

        this.highlightedObject = null;
        this.highlightTimeout = null;
        this.snapTargetObject = null;
        this.mouseMoved = false;

        this.selectedPointIndex = -1;
        this.draggingPoint = false;
        this.dragHitboxRadiusMouse = 12;
        this.dragHitboxRadiusTouch = 24;
        this.infoDisplay = null;
        this.infoDisplayTimeout = null;
        this.highlightedObject = null;
        this.snapTargetObject = null;
        this.mouseMoved = false;
        this.currentCodeEditIndex = -1;
        this.defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral','pow','range','llim','ulim']);

        this.touchState = {
            panning: false,
            pinching: false,
            lastPanPos: { x: 0, y: 0 },
            initialPinchDist: 0,
            initialPinch: {
                center: { x: 0, y: 0 },
                scale: 1,
                offset: { x: 0, y: 0 }
            }
        };
        this.isTransformingCache = false;
        this.transformInitialState = {
            offset: { x: 0, y: 0 },
            scale: 1
        };
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        this.isUsingPanOptimization = true;
        this.panStartOffset = { x: 0, y: 0 };
        this.touchMoved = false; 
        this.touchStartPos = { x: 0, y: 0 }; 
        this.interactionWasPinch = false;
        this.isSmoothZoomingActive = false;
this.smoothZoomVelocity = 1.0;
this.smoothZoomTarget = { x: 0, y: 0 };
this.mouseZoomInertiaScale = 0.3;
this.touchZoomInertiaScale = 0.3;
this.zoomEventHistory = [];
this.currentUIMode = 'plot'; 
this.filename = "Arch Graph 1";
        this.appVersion = 11900;
        this.fileNameDisplay = document.getElementById('file-name-display');


        this.is3DMode = false;
        this.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
        this.center3D = { x:0, y:0, z:0 };
        this.offset3D = { x: 0, y: 0 };
        this.bounds3D = 8;
        this.scale3D = 1.0; 
        this.isDragging3D = false;
        this.lastMouse3D = { x: 0, y: 0 };
        this.pinchStartDist3D = 0;
        this.pinchStartScale3D = 1;
        this.viewport3D = { x: 0, y: 0, w: 0, h: 0 };
        

        this.cache3D = {
            axes: null,
            grid: null,
            box: null,
            meshes: new Map(), 
            lines: new Map(),
            ticks: null,
            labels: []
        };
        
 
        this.shaderProgram3D = null;
        this.shaderProgram3DLine = null;
        this.attribLoc3D = {};
        this.uniformLoc3D = {};

        this.geometryInteractionState = {
            active: false,
            type: null, 
            prompt: '',
            clicksNeeded: 0,
            pointsSelected: [],
        };
        this.geometryPanel = document.getElementById('geometry-panel');
        this.lastGeometryTouchTime = 0; 
        this.geometryTouchDelay = 500; 
        this.traceState = {
            active: false,
            targetName: null,
            path: []
        };
                this.globalScript = "";
              
        this.globalScriptIntervalId = null;
        this.pen = {
            color: [1, 0, 0, 1],
            thickness: 2,
            isDown: false,
            x: 0,
            y: 0,
            segments: []
        };


        this.explicitPrecisionSlider = null;
        this.implicitPrecisionSlider = null;
        this.integralPrecisionSlider = null;
        this.preferredColorSlider = null;
        this.activeSliders = []; 

        this.categoryFilterMode = 0; 
        this.categoryIcons = [
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzQuNjUxOTcsMTg1LjM0ODAzdi0xMC42OTYwNmgxMC42OTYwNnYxMC42OTYwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMTU2OSIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM1LjM5NzI3LDE3Ni41NTQ2NmMwLC0wLjEyMjY0IDAuMDIyOTksLTAuMjI5OTQgMC4wNjg5OCwtMC4zMzcyNWMwLjA0NTk5LC0wLjEwNzMxIDAuMTA3MzEsLTAuMTk5MjkgMC4xODM5NiwtMC4yNzU5M2MwLjA3NjY1LC0wLjA3NjY1IDAuMTY4NjIsLTAuMTM3OTcgMC4yNzU5MywtMC4xODM5NmMwLjEwNzMxLC0wLjA0NTk5IDAuMjE0NjIsLTAuMDY4OTggMC4zMzcyNSwtMC4wNjg5OGg3LjQ3MzIxYzAuMTIyNjQsMCAwLjIyOTk0LDAuMDIyOTkgMC4zMzcyNSwwLjA2ODk4YzAuMTA3MzEsMC4wNDU5OSAwLjE5OTI5LDAuMTA3MzEgMC4yNzU5MywwLjE4Mzk2YzAuMDc2NjUsMC4wNzY2NSAwLjEzNzk3LDAuMTY4NjIgMC4xODM5NiwwLjI3NTkzYzAuMDQ1OTksMC4xMDczMSAwLjA2ODk4LDAuMjE0NjIgMC4wNjg5OCwwLjMzNzI1YzAsMC4yNDUyOCAtMC4wOTE5NywwLjQ1MjIzIC0wLjI2ODI3LDAuNjIwODVsLTIuOTEyNjMsMi43NzQ2N2MtMC4wMzgzMywwLjAzODMzIC0wLjA3NjY1LDAuMDg0MzEgLTAuMTE0OTgsMC4xMzc5N2MtMC4wMzgzMywwLjA1MzY1IC0wLjA2MTMyLDAuMDk5NjQgLTAuMDg0MzEsMC4xNDU2M2MtMC4wNDU5OSwwLjEwNzMxIC0wLjA2ODk4LDAuMjIyMjggLTAuMDY4OTgsMC4zNDQ5MnYzLjQ0OTE3YzAsMC4wNzY2NSAtMC4wMzA2NiwwLjE0NTYzIC0wLjA4NDMxLDAuMTk5MjljLTAuMDUzNjUsMC4wNTM2NSAtMC4xMjI2NCwwLjA4NDMxIC0wLjE5OTI5LDAuMDg0MzFjLTAuMDUzNjUsMCAtMC4xMDczMSwtMC4wMTUzMyAtMC4xNjA5NiwtMC4wNDU5OWwtMS43MjQ1OSwtMS4xNDk3M2MtMC4wODQzMSwtMC4wNTM2NSAtMC4xMzAzLC0wLjEzNzk3IC0wLjEzMDMsLTAuMjM3NnYtMi4yOTk0NWMwLC0wLjEyMjY0IC0wLjAyMjk5LC0wLjIyOTk0IC0wLjA2ODk4LC0wLjM0NDkyYy0wLjAyMjk5LC0wLjA1MzY1IC0wLjA1MzY1LC0wLjEwNzMxIC0wLjA4NDMxLC0wLjE1MzI5Yy0wLjAzMDY2LC0wLjA0NTk5IC0wLjA2ODk4LC0wLjA5MTk3IC0wLjExNDk4LC0wLjEzMDNsLTIuOTEyNjMsLTIuNzc0NjdjLTAuMTkxNjIsLTAuMTY4NjIgLTAuMjc1OTMsLTAuMzc1NTcgLTAuMjc1OTMsLTAuNjIwODV6TTI0NC4wMjAxOSwxNzYuNTU0NjZjMCwtMC4wNzY2NSAtMC4wMzA2NiwtMC4xNDU2MyAtMC4wODQzMSwtMC4xOTkyOWMtMC4wNTM2NSwtMC4wNTM2NSAtMC4xMjI2NCwtMC4wODQzMSAtMC4xOTkyOSwtMC4wODQzMWgtNy40NzMyMWMtMC4wNzY2NSwwIC0wLjE0NTYzLDAuMDMwNjYgLTAuMTk5MjksMC4wODQzMWMtMC4wNTM2NSwwLjA1MzY1IC0wLjA4NDMxLDAuMTIyNjQgLTAuMDg0MzEsMC4xOTkyOWMwLDAuMDg0MzEgMC4wMzA2NiwwLjE2MDk2IDAuMDkxOTcsMC4yMTQ2MmwyLjkxMjYzLDIuNzc0NjdjMC4xMzc5NywwLjEzNzk3IDAuMjUyOTQsMC4yOTEyNiAwLjMyOTU5LDAuNDc1MjJjMC4wNzY2NSwwLjE4Mzk2IDAuMTE0OTgsMC4zNjc5MSAwLjExNDk4LDAuNTY3MnYyLjE0NjE1bDEuMTQ5NzMsMC43NjY0OHYtMi45MTI2M2MwLC0wLjE5MTYyIDAuMDM4MzMsLTAuMzgzMjUgMC4xMTQ5OCwtMC41NjcyYzAuMDc2NjUsLTAuMTgzOTYgMC4xODM5NiwtMC4zNDQ5MiAwLjMyOTU5LC0wLjQ3NTIybDIuOTEyNjMsLTIuNzc0NjdjMC4wNTM2NSwtMC4wNjEzMiAwLjA4NDMxLC0wLjEzMDMgMC4wODQzMSwtMC4yMTQ2MnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo1LjM0ODAyOTI3ODMwODUzOjUuMzQ4MDI5Mjc4MzA4NTMtLT4=",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzUuMTUyNjMsMTgxLjUwNTY4YzAsLTEuMDg2ODkgMC44ODExLC0xLjk2OCAxLjk2OCwtMS45NjhjMS4wODY4OSwwIDEuOTY4LDAuODgxMSAxLjk2OCwxLjk2OGMwLDEuMDg2ODkgLTAuODgxMSwxLjk2OCAtMS45NjgsMS45NjhjLTEuMDg2ODksMCAtMS45NjgsLTAuODgxMSAtMS45NjgsLTEuOTY4eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0MS42MDU5NiwxODEuOTY3OThjMCwtMC44OTUwOSAwLjcyNTYyLC0xLjYyMDcgMS42MjA3LC0xLjYyMDdjMC44OTUwOSwwIDEuNjIwNywwLjcyNTYyIDEuNjIwNywxLjYyMDdjMCwwLjg5NTA5IC0wLjcyNTYyLDEuNjIwNyAtMS42MjA3LDEuNjIwN2MtMC44OTUwOSwwIC0xLjYyMDcsLTAuNzI1NjIgLTEuNjIwNywtMS42MjA3eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOS4wNTkxNSwxNzkuMjY2ODJsMC4wNzcxOCw0LjMyMTg3IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4yMjAwOCwxODMuNjY1ODd2LTcuMzMxNzQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM0LjY1MTk3LDE4NS4zNDgwM3YtMTAuNjk2MDZoMTAuNjk2MDZ2MTAuNjk2MDZ6IiBmaWxsLW9wYWNpdHk9IjAuMDE1NjkiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzQ4MDI5OTk5OTk5OTk0OjUuMzQ4MDI5OTk5OTk5OTk0LS0+",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzYuODgyMjUsMTc4LjIzMTg0Yy0wLjAwMjEsLTAuMDMyNjEgLTAuMDAzMTcsLTAuMDY1NSAtMC4wMDMxNywtMC4wOTg2NGMwLC0wLjgzMjg4IDAuNjc1MTgsLTEuNTA4MDYgMS41MDgwNiwtMS41MDgwNmMwLjEzMzEyLDAgMC4yNjIxOSwwLjAxNzI2IDAuMzg1MTQsMC4wNDk2MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzOC43MDkwNywxNzYuNjU5MDJsMC4zMDUsMC4xMDE2NiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuODc5MDgsMTc4LjIxNzkzdjUuMTUxMTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM1Ljg2MjQxLDE3OS4yMDA3aDIuMTAxMTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQzLjU3NSwxODAuMjQxODRjMC4zNDk0NCwwLjM4MjU1IDAuNTYyNTksMC44OTE3NCAwLjU2MjU5LDEuNDUwNzFjMCwwLjU3MTYyIC0wLjIyMjkyLDEuMDkxMiAtMC41ODY1NiwxLjQ3NjUzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjYyMzU0LDE4My4wOTEzMWMtMC4zMzcxMywtMC4zNzk4NiAtMC41NDE4OSwtMC44Nzk4NiAtMC41NDE4OSwtMS40Mjc3MWMwLC0wLjUzNDU3IDAuMTk0OTMsLTEuMDIzNjEgMC41MTc2LC0xLjM5OTg4IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjgxNjUsMTgzLjMxNjk2bC0wLjIzMTU4LC0wLjI2MDUyIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzOS41NTU5OCwxODAuMzA2NDlsMC4yMzE1NywtMC4yODk0OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuMzc2OTYsMTc5Ljk4ODA3bDAuMjAyNjIsMC4yMzE1OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuNjM3NDYsMTgzLjA1NjQ0bC0wLjMxODQyLDAuMzE4NDIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjg2MTE2LDE4MC43NTQ0M2wxLjY3Nzg4LDEuNzYzMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDAuODMyNzEsMTgyLjUxNzYxbDEuNjIxMDMsLTEuNjc3ODgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM0LjY1MTk3LDE4NS4zNDgwM3YtMTAuNjk2MDZoMTAuNjk2MDZ2MTAuNjk2MDZ6IiBmaWxsLW9wYWNpdHk9IjAuMDE1NjkiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzQ4MDI5OTk5OTk5OTk0OjUuMzQ4MDI5OTk5OTk5OTk0LS0+",
"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42OTYwNiIgaGVpZ2h0PSIxMC42OTYwNiIgdmlld0JveD0iMCwwLDEwLjY5NjA2LDEwLjY5NjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1MTk3LC0xNzQuNjUxOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzYuMDQzMDEsMTc4LjI3NDU2djUuNzMxNzIiLz48cGF0aCBkPSJNMjM2LjA0OTEyLDE4NC4xNDU1MWg1Ljk3NTYyIi8+PHBhdGggZD0iTTI0Mi4wMjQ3NCwxODQuMDA2MjhsLTUuNjA5NzcsLTUuODUzNjciLz48L2c+PHBhdGggZD0iTTIzOS45MzAxMywxNzcuODY3OTJjMCwtMS4xMTE5OSAwLjkwMTQ0LC0yLjAxMzQzIDIuMDEzNDMsLTIuMDEzNDNjMS4xMTE5OSwwIDIuMDEzNDMsMC45MDE0NCAyLjAxMzQzLDIuMDEzNDNjMCwxLjExMTk5IC0wLjkwMTQ0LDIuMDEzNDMgLTIuMDEzNDMsMi4wMTM0M2MtMS4xMTE5OSwwIC0yLjAxMzQzLC0wLjkwMTQ0IC0yLjAxMzQzLC0yLjAxMzQzeiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNC42NTE5NywxODUuMzQ4MDN2LTEwLjY5NjA2aDEwLjY5NjA2djEwLjY5NjA2eiIgZmlsbC1vcGFjaXR5PSIwLjAxNTY5IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo1LjM0ODAyOTk5OTk5OTk5NDo1LjM0ODAyOTk5OTk5OTk5NC0tPg=="
        ];
        this.categoryFilterBtn = document.getElementById('category-filter-btn');
        this.categoryFilterIcon = document.getElementById('category-filter-icon');
        
        if (this.categoryFilterBtn) {
            this.categoryFilterBtn.addEventListener('click', () => {
                this.categoryFilterMode = (this.categoryFilterMode + 1) % 4;
                this.updateCategoryButtonIcon();
                this.updateEntryList();
            });
            this.updateCategoryButtonIcon();
        }


        this.explicitPrecisionValueSpan = document.getElementById('explicit-precision-value');
        this.implicitPrecisionValueSpan = document.getElementById('implicit-precision-value');
        this.explicitPrecisionStep = 2; 
        this.implicitPrecisionStep = 5; 
        
        this.highPerformancePlottingToggle = document.getElementById('high-performance-plotting-toggle');
        this.highPerformancePlottingEnabled = false; 
        this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;

        this.smoothPanningEnabled = false;
        this.smoothPanningToggle = document.getElementById('smooth-panning-toggle');
        this.baseAccsmooth = 0.15; 
        this.maxAccsmooth = 0.50; 
        this.accsmoothVelocityFactor = 0.1; 
        this.accsmooth = this.baseAccsmooth; 

        this.isSmoothPanningActive = false;
        this.smoothPanVelocity = { x: 0, y: 0 };
        this.panEventHistory = [];
        this.minFlickVelocityMagnitude = 500; 
        this.lastPanEventTime = 0;
        this.lastSmoothPanTime = 0;


        this.tmin = -2 * Math.PI;
        this.tmax = 2 * Math.PI;
        this.tminValueSpan = document.getElementById('tmin-value');
        this.tmaxValueSpan = document.getElementById('tmax-value');


        this.developerMode = false;
        this.devModeToggle = document.getElementById('dev-mode-toggle');
        this.preferredColorValue = 0;
        this.preferredColorValueSpan = document.getElementById('preferred-color-value');
        this.darkModeToggle = document.getElementById('dark-mode-toggle');
        this.isDarkModeActive = false;
        this.colorInversionEnabled = false;
        this.showAxes = true;
        this.showAxisNumbers = true;
        this.gridStyle = 'grid'; 
        this.showPointLabels = true;
        this.showHiddenMath = false;
        this.showHiddenGeo = false;

        this.blocks01 = new Set();
        this.implictplotindex = [];
        this.implictplotindex.push(0);
        this.implictplotdata = [];
        this.implicttempdata = [];
        this.implictjump = 1;
        this.orderedBlocks01ForImplicitProcessing = [];
        this.currentUnitStep = 0;

this.isPanning = false;
        this.isZooming = false;
        this.performanceModeEnabled = true; 
        this.overlayDrawingEnabled = true;
        this.lowPrecisionBufferEnabled = true;
        this.isUsingLowPrecisionBuffer = true;
        this.originalExplicitPrecision = 2;
        this.originalImplicitPrecision = 5; 
        this.zoomEndTimeout = null;
        this.overlayDrawingToggle = document.getElementById('overlay-drawing-toggle');
        this.lowPrecisionBufferToggle = document.getElementById('low-precision-buffer-toggle');
        this.integralPrecisionValueSpan = document.getElementById('integral-precision-value');
        this.integralNumSteps = 100; 
        this.autoBreakpointDetectionEnabled = true;
                this.showPlaybackControls = false;
        this.currentFrame = 0;
        this.totalFrames = 100;
        this.playbackFPS = 10;
        this.isFramePlaying = false;
        this.frameAccumulator = 0;
this.adaptiveExtendEnabled = true;
        this.geometryMeasurementDisplayEnabled = true;
        this.lastValidSidebarRight = 415;

const settingsPanelFeatures = document.getElementById('settings-panel-features');
        if (settingsPanelFeatures) {
            const toggleHtml = `
                <div class="settings-item"><div class="settings-item-row"><label for="show-playback-controls-toggle"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNC45Mjk5NiIgaGVpZ2h0PSIxNC45Mjk5NiIgdmlld0JveD0iMCwwLDE0LjkyOTk2LDE0LjkyOTk2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjMyLjUzNTAyLC0xNzIuNTM1MDIpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMzMuMjg1MDIsMTgwYzAsLTMuNzA4NTggMy4wMDY0LC02LjcxNDk4IDYuNzE0OTgsLTYuNzE0OThjMy43MDg1OCwwIDYuNzE0OTgsMy4wMDY0IDYuNzE0OTgsNi43MTQ5OGMwLDMuNzA4NTggLTMuMDA2NCw2LjcxNDk4IC02LjcxNDk4LDYuNzE0OThjLTMuNzA4NTgsMCAtNi43MTQ5OCwtMy4wMDY0IC02LjcxNDk4LC02LjcxNDk4eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM4Ljk3Mjc0LDE4MS4zMTg1OHYtMy4wNTI0NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuMjI2OTgsMTgwLjA2NDgzbC0yLjE4MzI2LC0xLjk0MDY3IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS4wMzEzNywxODAuMTgyNzlsLTIuMDU4NjMsMS40MTk3NSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzguODkyNjUsMTc5LjgxMjUyYzAsLTAuNTE2NTEgMC40MTg3MiwtMC45MzUyNCAwLjkzNTI0LC0wLjkzNTI0YzAuNTE2NTEsMCAwLjkzNTI0LDAuNDE4NzIgMC45MzUyNCwwLjkzNTI0YzAsMC41MTY1MSAtMC40MTg3MiwwLjkzNTI0IC0wLjkzNTI0LDAuOTM1MjRjLTAuNTE2NTEsMCAtMC45MzUyNCwtMC40MTg3MiAtMC45MzUyNCwtMC45MzUyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo3LjQ2NDk3OTk5OTk5OTk5Nzo3LjQ2NDk3OTk5OTk5OTk5Ny0tPg==" class="settings-item-icon" alt="">显示播放控制</label><label class="custom-switch-container"><input type="checkbox" id="show-playback-controls-toggle"><span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span></label></div><p class="settings-comment">在函数列表顶部显示逐帧动画控制卡片</p></div>
            `;
            settingsPanelFeatures.insertAdjacentHTML('afterbegin', toggleHtml);
        }

        this.showPlaybackControlsToggle = document.getElementById('show-playback-controls-toggle');
        if (this.showPlaybackControlsToggle) {
            this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
            this.showPlaybackControlsToggle.addEventListener('change', e => {
                this.showPlaybackControls = e.target.checked;
                this.updateEntryList();
                this.requestDraw();
            });
        }
        this.adaptivePlottingToggle = document.getElementById('adaptive-plotting-toggle');
        this.adaptiveExtendToggle = document.getElementById('adaptive-extend-toggle');
        this.geometrySnapEnabled = true;
        this.autoBreakpointDetectionToggle = document.getElementById('auto-breakpoint-detection-toggle');
        this.isAnimatingWithPerformanceMode = false; 
        this.plottedFunctionPoints = [];
         this.lastValidSidebarRight = 422; 
this.geometryKeywords = new Set(['point', 'midpoint', 'intercept', 'segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'circle', 'ellipse', 'parabola', 'hyperbola', 'polygon', 'length', 'angle', 'area', 'isparallel', 'isperpendicular', 'isconcyclic', 'rotate', 'reflect', 'translate', 'fitline', 'circulararc', 'tangent']);
        this.builtinFuncNames = [];


        this.annotations = [];
        this.annotationMenu = null;
this.annotationState = {
            mode: 'pen',
            isDrawing: false,
            currentDrawingPath: [],
            pen: {
                color: { h: 0, s: 100, b: 0, a: 0 },
                thickness: 0.1, 
                fontSize: 0.5   
            },

            currentPos: { x: 0, y: 0 }
        };
        this.penFontSizeSlider = null;
        this.selectedAnnotationIndex = -1;
        this.annotationInteraction = {
            type: null, 
            startX: 0,
            startY: 0,
            original: {}
        };
        this.penColorSliders = {};
        this.penThicknessSlider = null;


this.calcJSUtils = {
            calc1: ['ln', 'lg', 'log', 'exp', 'sqrt', 'cbrt', 'abs', 'floor', 'ceil', 'round', 'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh', 'sum', 'prod', 'int','diff','diffat'],
            calc2: ['+', '-', '*', '/', '^', ','],
            calc3: [], 
            customFunctions: {}, 
            advancedCustomFunctions: {},
            advancedCustomFunctionNames: [],
            constants: { 'e': Math.E, 'π': Math.PI, 'pi': Math.PI },
            getAdvancedFuncsMap: function() {
                const map = {};
                for (const name in this.advancedCustomFunctions) {
                    if (this.advancedCustomFunctions.hasOwnProperty(name)) {
                        map[name] = this.advancedCustomFunctions[name].compiledFunc;
                    }
                }
                return map;
            },
            isNumericString: function(str) {
                if (typeof str !== 'string') return false;
                return !isNaN(str) && !isNaN(parseFloat(str));
            },
isLetter: function(str) {
                return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str);
            },
            tokenize: function(expression_input) {
    let expression = expression_input;
    if (typeof expression !== 'string') {
        if (expression === null || expression === undefined) expression = "";
        else expression = String(expression);
    }
    
    expression = expression.toLowerCase().replace(/\s+/g, '');
    if (!expression) return [];

    const allOpsOriginalCase = [
        ...this.calc1, 
        ...this.calc3, 
        ...this.advancedCustomFunctionNames, 
        'sum', 'prod', 'int', 'diff', 'diffat' 
    ];

    const opDetails = [];
    const seenLcOps = new Set();
    const constantLcKeys = Object.keys(this.constants).map(c => c.toLowerCase());

    for (const op of allOpsOriginalCase) {
        if (!op || typeof op !== 'string') continue;
        const lcOp = op.toLowerCase();
        if (constantLcKeys.includes(lcOp)) continue;
        
        if (!seenLcOps.has(lcOp)) {
            opDetails.push({ lc: lcOp, original: op, len: lcOp.length });
            seenLcOps.add(lcOp);
        }
    }

    opDetails.sort((a, b) => b.len - a.len); 

    let segments = [expression]; 

    for (const opDetail of opDetails) {
        const lcOp = opDetail.lc;
        const originalOp = opDetail.original;

        const newSegmentsAccumulator = [];
        for (const segment of segments) {
            if (typeof segment !== 'string' || allOpsOriginalCase.includes(segment)) {
                newSegmentsAccumulator.push(segment);
                continue;
            }

            const parts = [];
            let lastIndex = 0;
            let k = 0;
            while (k < segment.length) {
                if (segment.substring(k).startsWith(lcOp) && (k + lcOp.length < segment.length && segment[k + lcOp.length] === '(')) {
                    if (k > lastIndex) {
                        parts.push(segment.substring(lastIndex, k)); 
                    }
                    parts.push(originalOp); 
                    lastIndex = k + lcOp.length;
                    k = lastIndex; 
                } else {
                    k++;
                }
            }
            if (lastIndex < segment.length) {
                parts.push(segment.substring(lastIndex)); 
            }
            newSegmentsAccumulator.push(...parts.filter(p => p !== ""));
        }
        segments = newSegmentsAccumulator;
    }
    
    const finalTokens = [];
    const sortedConstantsDetails = Object.keys(this.constants)
        .map(c => ({ lc: c.toLowerCase(), original: c, len: c.length }))
        .sort((a, b) => b.len - a.len);

    for (const segmentItem of segments) {
        if (typeof segmentItem !== 'string' || allOpsOriginalCase.includes(segmentItem) ) {
            finalTokens.push(segmentItem);
            continue;
        }

        let i = 0;
        const currentSegmentLc = segmentItem; 

        while (i < currentSegmentLc.length) {
            let char = currentSegmentLc[i];
            let matchedInPhase2 = false;

            for (const cnstDetail of sortedConstantsDetails) {
                if (currentSegmentLc.substring(i).startsWith(cnstDetail.lc)) {
                    finalTokens.push(cnstDetail.original); 
                    i += cnstDetail.len;
                    matchedInPhase2 = true;
                    break;
                }
            }
            if (matchedInPhase2) continue;

            if (char.match(/[0-9.]/)) {
                let numStr = '';
                while (i < currentSegmentLc.length && currentSegmentLc[i].match(/[0-9.]/)) {
                    numStr += currentSegmentLc[i];
                    i++;
                }
                finalTokens.push(numStr);
                matchedInPhase2 = true;
            } 
            else if (this.calc2.includes(char) || char === '(' || char === ')') { 
                finalTokens.push(char);
                i++;
                matchedInPhase2 = true;
            } 
            else if (this.isLetter(char)) { 
                let identifier = '';
                while (i < currentSegmentLc.length && /[a-z0-9]/.test(currentSegmentLc[i])) {
                    identifier += currentSegmentLc[i];
                    i++;
                }
                finalTokens.push(identifier);
                matchedInPhase2 = true;
            } 
            else {
                throw new Error("输入的表达式语法有误，请检查！");
            }
        }
    }
    return finalTokens.filter(t => t !== "");
},
            processTokensForEval: function(inputTokens) {
                let result = [];
                const tokens = [...inputTokens];

                for (let i = 0; i < tokens.length; i++) {
                    let token = tokens[i];
                    let nextToken = (i + 1 < tokens.length) ? tokens[i + 1] : null;

                    result.push(token);

                    const isCurrentNumber = this.isNumericString(token);
                    const isCurrentClosingParen = token === ')';
                    
                    const isCurrentKnownName = this.calc1.includes(token) || this.calc3.includes(token) || this.advancedCustomFunctionNames.includes(token) || Object.keys(this.constants).includes(token);
                    const isCurrentVariable = this.isLetter(token) && !isCurrentKnownName && !Object.keys(this.constants).includes(token);
                    if (nextToken && !this.calc2.includes(nextToken) && nextToken !== ')') {
                        const nextIsNumber = this.isNumericString(nextToken);
                        const nextIsKnownName = this.calc1.includes(nextToken) || this.calc3.includes(nextToken) || this.advancedCustomFunctionNames.includes(nextToken) || Object.keys(this.constants).includes(nextToken);
                        const nextIsVariable = this.isLetter(nextToken) && !nextIsKnownName && !Object.keys(this.constants).includes(nextToken);

                        const nextIsOpeningParen = nextToken === '(';

                        const currentCanMultiply = isCurrentNumber ||
                                                   isCurrentClosingParen ||
                                                   isCurrentVariable ||
                                                   (isCurrentKnownName && token !== '(' && !this.calc1.includes(token) && !this.calc3.includes(token) && !this.advancedCustomFunctionNames.includes(token)) || 
                                                   (Object.keys(this.constants).includes(token));


                        const nextCanBeMultiplied = nextIsNumber ||
                                                    nextIsVariable ||
                                                    (nextIsKnownName && !this.calc1.includes(nextToken) && !this.calc3.includes(nextToken) && !this.advancedCustomFunctionNames.includes(nextToken)) || 
                                                    (Object.keys(this.constants).includes(nextToken)) ||
                                                    nextIsOpeningParen ||
                                                    this.calc1.includes(nextToken) || 
                                                    this.calc3.includes(nextToken) ||
                                                    this.advancedCustomFunctionNames.includes(nextToken);  

                        const isCurrentFuncName = this.calc1.includes(token) || this.calc3.includes(token) || this.advancedCustomFunctionNames.includes(token);

                        if (isCurrentFuncName && nextToken === '(') {
                        } else if (currentCanMultiply && nextCanBeMultiplied) {
                             result.push('*');
                        }
                    }
                }
                
                const findMatchingParenBackwards = (toks, endIdx) => {
                    let balance = 0;
                    for (let i = endIdx; i >= 0; i--) {
                        if (toks[i] === ')') balance++;
                        else if (toks[i] === '(') balance--;
                        if (balance === 0) return i;
                    }
                    return -1;
                };
                
                let i = result.length - 1;
                while (i >= 0) {
                    if (result[i] === '^') {
                        let rightStart = i + 1;
                        let rightEnd = rightStart;

                        const prevTokenForUnaryCheck = i > 0 ? result[i - 1] : null;
                        if (result[rightStart] === '-' && (prevTokenForUnaryCheck === null || ['(', '^', ',', '*', '/', '+', '-'].includes(prevTokenForUnaryCheck))) {
                            rightStart++;
                            rightEnd++;
                        }

                        if (result[rightStart] === '(') {
                            rightEnd = this.findMatchingParen(result, rightStart);
                        } else {
                            const funcNames = [...this.calc1, ...this.calc3, ...this.advancedCustomFunctionNames];
                            if (funcNames.includes(result[rightStart]) && result[rightStart + 1] === '(') {
                                rightEnd = this.findMatchingParen(result, rightStart + 1);
                            }
                        }

                        let leftEnd = i - 1;
                        let leftStart = leftEnd;
                        if (result[leftEnd] === ')') {
                            leftStart = findMatchingParenBackwards(result, leftEnd);
                            if (leftStart > 0) {
                                const funcNames = [...this.calc1, ...this.calc3, ...this.advancedCustomFunctionNames];
                                if (funcNames.includes(result[leftStart - 1])) {
                                    leftStart--;
                                }
                            }
                        }


                        
                        const leftTokens = result.slice(leftStart, leftEnd + 1);
                        const rightTokens = result.slice(i + 1, rightEnd + 1);
                        
                        const replacement = ['__advanced__.pow', '(', ...leftTokens, ',', ...rightTokens, ')'];
                        result.splice(leftStart, (rightEnd - leftStart + 1), ...replacement);
                        
                        i = result.length;
                    }
                    i--;
                }

                return result.map(token => {
                    if (['sum', 'prod', 'int'].includes(token)) return token;
                    if (this.calc1.includes(token)) {
                        if (token === 'ln') return 'Math.log';
                        if (token === 'lg') return 'Math.log10';
                        if (token === 'log') return 'Math.log10';
                        return `Math.${token}`;
                    }
                    if (this.advancedCustomFunctionNames.includes(token) || token === '__advanced__.pow') {
                         return `__advanced__.${token.replace('__advanced__.', '')}`;
                    }
                    if (this.constants[token]) return this.constants[token].toString();
                    return token;
                });
            },
            findMatchingParen: function(tokens, startIndex) {
                let balance = 0;
                for (let i = startIndex; i < tokens.length; i++) {
                    if (tokens[i] === '(') balance++;
                    else if (tokens[i] === ')') balance--;
                    if (balance === 0) return i;
                }
                return -1;
            },
            extractArguments: function(tokens, openParenIdx, closeParenIdx, expectedParamCount) {
                const argTokens = tokens.slice(openParenIdx + 1, closeParenIdx);
                
                if (expectedParamCount === 0) {
                    if (argTokens.length > 0) throw new Error("语法错误-参数数量有误！");
                    return [];
                }
                if (argTokens.length === 0 && expectedParamCount > 0) throw new Error("语法错误-参数数量有误！");

                let args = [];
                let currentArg = [];
                let parenBalance = 0;

                for (let i = 0; i < argTokens.length; i++) {
                    const token = argTokens[i];
                    if (token === '(') parenBalance++;
                    else if (token === ')') parenBalance--;

                    if (token === ',' && parenBalance === 0) {
                        if (currentArg.length === 0) throw new Error("语法错误-参数输入错误！");
                        args.push(currentArg);
                        currentArg = [];
                    } else {
                        currentArg.push(token);
                    }
                }
                if (currentArg.length > 0 || args.length < expectedParamCount ) { 
                     if (currentArg.length === 0 && args.length === expectedParamCount -1 && expectedParamCount > 0) {
                         throw new Error("语法错误-参数输入错误！");
                     }
                    args.push(currentArg);
                }

                if (args.length !== expectedParamCount) {
                    throw new Error("语法错误-参数输入错误！");
                }
                return args.map(arg => (arg.length === 0 ? [''] : arg) );
            },
                        expandDiffOperations: function(initialTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames) {
            let tokens = JSON.parse(JSON.stringify(initialTokens));
            let expandedSomething = true;
            let iterationGuard = 0;
            const MAX_EXPANSION_ITERATIONS = 50; 

            const h_str = '0.00001';
            const h_inv_2h_str = '50000'; 

            while (expandedSomething && iterationGuard < MAX_EXPANSION_ITERATIONS) {
                expandedSomething = false;
                iterationGuard++;
                let i = 0;
                while (i < tokens.length) {
                    const token = tokens[i];
                    if (token === 'diff' || token === 'diffat') {
                        const opName = token;
                        if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                            throw new Error("语法错误-括号匹配错误！");
                        }
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.findMatchingParen(tokens, openParenIdx);
                        if (closeParenIdx === -1) {
                            throw new Error("语法错误-括号匹配错误！");
                        }

                        const expectedArgs = (opName === 'diff') ? 2 : 3;
                        const argListTokenArrays = this.extractArguments(tokens, openParenIdx, closeParenIdx, expectedArgs);

                        let exprTokens = argListTokenArrays[0];
                        let varNameTokenArrayForCheck = argListTokenArrays[1]; 
                        let varNameTokenArrayActual = argListTokenArrays[1];

                        if (varNameTokenArrayActual.length === 3 &&
                            varNameTokenArrayActual[0] === '(' &&
                            varNameTokenArrayActual[2] === ')' &&
                            this.isLetter(varNameTokenArrayActual[1]) &&
                            varNameTokenArrayActual[1].length === 1) {
                            varNameTokenArrayActual = [varNameTokenArrayActual[1]];
                        }
                        
                        if (varNameTokenArrayActual.length !== 1 || !this.isLetter(varNameTokenArrayActual[0]) || calc1_list.includes(varNameTokenArrayActual[0]) || calc3_list.includes(varNameTokenArrayActual[0]) || Object.keys(constants_obj).includes(varNameTokenArrayActual[0])) {
                            throw new Error("语法错误-变量语法错误，请检查算式！");
                        }
                        const varName = varNameTokenArrayActual[0];

                        let pointExprTokens = null;
                        if (opName === 'diffat') {
                            pointExprTokens = argListTokenArrays[2];
                            let preProcessedPointTokens = this.expandCustomFunctions(pointExprTokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames);
                            pointExprTokens = this.expandDiffOperations(preProcessedPointTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames);
                        }

                        const substituteInTokens = (targetTokens, variableToReplace, replacementValueTokens) => {
                            let result = [];
                            for (const t of targetTokens) {
                                if (t === variableToReplace) {
                                    result.push('('); 
                                    result.push(...replacementValueTokens);
                                    result.push(')');
                                } else {
                                    result.push(t);
                                }
                            }
                            return result;
                        };

                        let finalExpansion = [];

                        finalExpansion.push('('); 

                        finalExpansion.push('('); 
                        let varPlusH_Tokens;
                        if (opName === 'diff') {
                            varPlusH_Tokens = ['(', varName, '+', h_str, ')'];
                        } else { 
                            varPlusH_Tokens = ['(', ...pointExprTokens, '+', h_str, ')'];
                        }
                        finalExpansion.push(...substituteInTokens(exprTokens, varName, varPlusH_Tokens));
                        finalExpansion.push(')'); 

                        finalExpansion.push('-'); 

                        finalExpansion.push('('); 
                        let varMinusH_Tokens;
                        if (opName === 'diff') {
                            varMinusH_Tokens = ['(', varName, '-', h_str, ')'];
                        } else { 
                            varMinusH_Tokens = ['(', ...pointExprTokens, '-', h_str, ')'];
                        }
                        finalExpansion.push(...substituteInTokens(exprTokens, varName, varMinusH_Tokens));
                        finalExpansion.push(')'); 
                        
                        finalExpansion.push(')'); 
                        finalExpansion.push('*');
                        finalExpansion.push(h_inv_2h_str);

                        tokens.splice(i, closeParenIdx - i + 1, ...finalExpansion);
                        expandedSomething = true;
                        i = -1; 
                    }
                    i++;
                }
            }
            if (iterationGuard >= MAX_EXPANSION_ITERATIONS && expandedSomething) {
                throw new Error("语法错误-循环解析错误，请检查！");
            }
            return tokens;
        },

            expandCustomFunctions: function(initialTokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames) {
                let tokens = JSON.parse(JSON.stringify(initialTokens)); 
                let expandedSomething = true;
                let iterationGuard = 0; 
                const MAX_EXPANSION_ITERATIONS = 50;


                while (expandedSomething && iterationGuard < MAX_EXPANSION_ITERATIONS) {
                    expandedSomething = false;
                    iterationGuard++;
                    let i = 0;
                    while (i < tokens.length) {
                        const token = tokens[i];
                        if (calc3_list.includes(token) && !advancedCustomFunctionNames.includes(token)) {
                            const funcName = token;
                            const funcData = customFunctions[funcName];

                            if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                                throw new Error(`自定义函数 '${funcName}' 后面必须是 '('。`);
                            }

                            const openParenIdx = i + 1;
                            const closeParenIdx = this.findMatchingParen(tokens, openParenIdx);

                            if (closeParenIdx === -1) {
                                throw new Error(`函数调用 '${funcName}' 的括号不匹配。`);
                            }

                            const argValues = this.extractArguments(tokens, openParenIdx, closeParenIdx, funcData.params.length);

                            let bodyCopy = JSON.parse(JSON.stringify(funcData.bodyTokens));

                            let substitutedBody = [];
                            for (const bodyToken of bodyCopy) {
                                const paramIndex = funcData.params.indexOf(bodyToken);
                                if (paramIndex !== -1) {
                                    substitutedBody.push('('); 
                                    substitutedBody.push(...argValues[paramIndex]);
                                    substitutedBody.push(')');
                                } else {
                                    substitutedBody.push(bodyToken);
                                }
                            }
                            
                            const finalExpansionForCustomFunc = ['(', ...substitutedBody, ')'];
                            tokens.splice(i, closeParenIdx - i + 1, ...finalExpansionForCustomFunc);
                            expandedSomething = true;
                            i = -1; 
                        }
                        i++;
                    }
                }
                if (iterationGuard >= MAX_EXPANSION_ITERATIONS && expandedSomething) {
                    throw new Error("语法错误-循环解析错误，请检查！");
                }
                return tokens;

            },
            evaluateScopedExpression: function(tokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap) {
                let currentTokens = this.expandCustomFunctions(tokens, customFunctions, calc3_list, advancedCustomFunctions, advancedCustomFunctionNames);
                currentTokens = this.expandDiffOperations(currentTokens, customFunctions, calc3_list, constants_obj, calc1_list, advancedCustomFunctions, advancedCustomFunctionNames);
                currentTokens = JSON.parse(JSON.stringify(currentTokens));
                
                const replaceVarInTokens = (targetTokens, varName, val) => {
                    const result = [];
                    const valStr = val.toString();
                    const replacement = val < 0 ? ['(', valStr, ')'] : [valStr]; 
                    for (let i = 0; i < targetTokens.length; i++) {
                        if (targetTokens[i] === varName) {
                            for(let k = 0; k < replacement.length; k++) result.push(replacement[k]);
                        } else {
                            result.push(targetTokens[i]);
                        }
                    }
                    return result;
                };

                let hasOps = true;
                let iterationGuard = 0;
                const MAX_MACRO_EXPANSION_PASSES = 20; 
                const MAX_LOOP_ITERATIONS = 1000000; 

                while (hasOps && iterationGuard < MAX_MACRO_EXPANSION_PASSES) {
                    hasOps = false;
                    iterationGuard++;
                    let foundOpIndex = -1;

                    for (let i = currentTokens.length - 1; i >= 0; i--) {
                        if (['sum', 'prod', 'int'].includes(currentTokens[i])) {
                            if (i + 1 < currentTokens.length && currentTokens[i+1] === '(') {
                                foundOpIndex = i;
                                break;
                            }
                        }
                    }

                    if (foundOpIndex !== -1) {
                        const i = foundOpIndex;
                        const token = currentTokens[i];
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.findMatchingParen(currentTokens, openParenIdx);

                        if (closeParenIdx === -1) {
                            throw new Error(`${token} 的括号不匹配`);
                        }

                        const argList = this.extractArguments(currentTokens, openParenIdx, closeParenIdx, 4);
                        const bodyTokens = argList[0];
                        const varNameTokens = argList[1];
                        const startTokens = argList[2];
                        const endTokens = argList[3];

                        if (varNameTokens.length !== 1 || !this.isLetter(varNameTokens[0])) {
                            throw new Error(`${token} 的第二个参数必须是变量名`);
                        }
                        const varName = varNameTokens[0];

                        const startVal = this.evaluateScopedExpression(startTokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap);
                        const endVal = this.evaluateScopedExpression(endTokens, scopeVars, customFunctions, calc3_list, constants_obj, calc1_list, integralNumSteps_param, advancedCustomFunctions, advancedCustomFunctionNames, advancedFuncsMap);

                        if (!Number.isFinite(startVal) || !Number.isFinite(endVal)) {
                            throw new Error(`${token} 的范围必须是有效数字`);
                        }

                        let expandedTokens = [];

                        if (token === 'sum' || token === 'prod') {
                            const s = Math.round(startVal);
                            const e = Math.round(endVal);
                            const isSum = token === 'sum';
                            const op = isSum ? '+' : '*';
                            const identity = isSum ? '0' : '1';

                            if (Math.abs(e - s) > MAX_LOOP_ITERATIONS) {
                                throw new Error(`${token} 循环次数过多 (${Math.abs(e - s)})`);
                            }

                            if (s > e) {
                                expandedTokens.push(identity);
                            } else {
                                expandedTokens.push('(');
                                for (let k = s; k <= e; k++) {
                                    if (k > s) expandedTokens.push(op);
                                    
                                    const replacedBody = replaceVarInTokens(bodyTokens, varName, k);
                                    
                                    for(let m = 0; m < replacedBody.length; m++) expandedTokens.push(replacedBody[m]);
                                }
                                expandedTokens.push(')');
                            }
                        } else if (token === 'int') {
                            const N = integralNumSteps_param || 50;
                            const a = startVal;
                            const b = endVal;
                            const h = (b - a) / N;

                            if (Math.abs(h) < 1e-15) {
                                expandedTokens.push('0');
                            } else {
                                expandedTokens.push('(');
                                expandedTokens.push(h.toString());
                                expandedTokens.push('*');
                                expandedTokens.push('(');
                                
                                for (let k = 0; k <= N; k++) {
                                    if (k > 0) expandedTokens.push('+');
                                    
                                    const currentX = a + k * h;
                                    
                                    if (k === 0 || k === N) {
                                        expandedTokens.push('0.5');
                                        expandedTokens.push('*');
                                    }
                                    
                                    expandedTokens.push('(');
                                    const replacedBody = replaceVarInTokens(bodyTokens, varName, currentX);
                                    for(let m = 0; m < replacedBody.length; m++) expandedTokens.push(replacedBody[m]);
                                    expandedTokens.push(')');
                                }
                                
                                expandedTokens.push(')'); 
                                expandedTokens.push(')'); 
                            }
                        }

                        const before = currentTokens.slice(0, i);
                        const after = currentTokens.slice(closeParenIdx + 1);
                        currentTokens = before.concat(expandedTokens).concat(after);
                        
                        hasOps = true; 
                    }
                }

                let tokensForFinalEval = [];
                for (let i = 0; i < currentTokens.length; i++) {
                    const token = currentTokens[i];
                    
                    if (scopeVars[token] !== undefined && this.isLetter(token) && 
                        !calc1_list.includes(token) && 
                        !calc3_list.includes(token) && 
                        !Object.keys(constants_obj).includes(token) && 
                        !advancedCustomFunctionNames.includes(token)) {
                        
                        const value = scopeVars[token];
                        const prevToken = i > 0 ? currentTokens[i-1] : null;
                        
                        if (typeof value === 'number' && value < 0 && prevToken === '-') {
                             tokensForFinalEval.push('(');
                             tokensForFinalEval.push(value.toString());
                             tokensForFinalEval.push(')');
                        } else {
                            tokensForFinalEval.push(value.toString());
                        }
                    } else {
                        tokensForFinalEval.push(token);
                    }
                }
                
                let processedFinalTokens = this.processTokensForEval(tokensForFinalEval); 
                let finalExprStringToEvaluate = processedFinalTokens.join('');

                if (finalExprStringToEvaluate.trim() === "") return 0; 

                try {
                    const executor = new Function('__advanced__', 'return ' + finalExprStringToEvaluate);
                    return executor(advancedFuncsMap);
                } catch (e) {
                    return NaN;
                }
            }, };
        this.init();
    }

    getRayPlaneIntersection(mouseX, mouseY) {
        const aspect = this.canvas.width / this.canvas.height;
        const proj = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta) + this.center3D.x,
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta) + this.center3D.y,
            z: cam.rho * Math.cos(cam.phi) + this.center3D.z
        };
        const view = Mat4.lookAt(Mat4.create(), eye, this.center3D, {x:0, y:0, z:1});
        
        const vp = Mat4.multiply(Mat4.create(), proj, view);
        const invVP = Mat4.invert(Mat4.create(), vp);
        if (!invVP) return null;

        const x = (mouseX / (this.canvas.width / window.devicePixelRatio)) * 2 - 1;
        const y = -(mouseY / (this.canvas.height / window.devicePixelRatio)) * 2 + 1;
        
        const near = [x, y, -1], far = [x, y, 1];
        Mat4.transformVec3(near, near, invVP);
        Mat4.transformVec3(far, far, invVP);

        const dirZ = far[2] - near[2];
        if (Math.abs(dirZ) < 1e-6) return null;
        
        const planeZ = this.center3D.z;
        const t = (planeZ - near[2]) / dirZ;
        
        if (t < 0 || t > 1) return null;
        
        return { 
            x: near[0] + t * (far[0] - near[0]), 
            y: near[1] + t * (far[1] - near[1]) 
        };
    }

    getAdaptiveStep3D(visibleRangeMath) {
        const targetTickCount = 8;
        const rawStep = visibleRangeMath / targetTickCount;
        const mag = Math.floor(Math.log10(rawStep));
        const base = Math.pow(10, mag);
        const ratio = rawStep / base;
        
        let step;
        if (ratio <= 1) step = base;
        else if (ratio <= 2) step = 2 * base;
        else if (ratio <= 5) step = 5 * base;
        else step = 10 * base;
        
        return { step, precision: mag < 0 ? -mag : 0 };
    }

    pushBox(vertices, x1, y1, z1, x2, y2, z2, r, g, b) {
        const w = 0.05;
        const minX = Math.min(x1, x2)-(x1===x2?w:0), maxX = Math.max(x1, x2)+(x1===x2?w:0);
        const minY = Math.min(y1, y2)-(y1===y2?w:0), maxY = Math.max(y1, y2)+(y1===y2?w:0);
        const minZ = Math.min(z1, z2)-(z1===z2?w:0), maxZ = Math.max(z1, z2)+(z1===z2?w:0);
        const p = [[minX,minY,minZ],[maxX,minY,minZ],[maxX,maxY,minZ],[minX,maxY,minZ],[minX,minY,maxZ],[maxX,minY,maxZ],[maxX,maxY,maxZ],[minX,maxY,maxZ]];
        const faces = [[0,1,2,3],[4,7,6,5],[0,4,5,1],[3,2,6,7],[0,3,7,4],[1,5,6,2]];
        const normals = [[0,0,-1],[0,0,1],[0,-1,0],[0,1,0],[-1,0,0],[1,0,0]];
        faces.forEach((f, fi) => {
            const n = normals[fi];
            const idx = [f[0], f[1], f[2], f[0], f[2], f[3]];
            idx.forEach(i => vertices.push(p[i][0], p[i][1], p[i][2], n[0], n[1], n[2]));
        });
    }

    initializeAdvancedCalcJSFunctions() {
        this.calcJSUtils.advancedCustomFunctions = {};
        this.calcJSUtils.advancedCustomFunctionNames = [];

        ADVANCED_FUNCTION_DEFINITIONS.forEach(def => {
            try {
                const compiledFunc = new Function(...def.params, def.bodyJsString);
                this.calcJSUtils.advancedCustomFunctions[def.name] = {
                    params: def.params,
                    bodyJsString: def.bodyJsString,
                    compiledFunc: compiledFunc
                };
                if (!this.calcJSUtils.advancedCustomFunctionNames.includes(def.name)) {
                    this.calcJSUtils.advancedCustomFunctionNames.push(def.name);
                }
            } catch (e) {
                console.error(`函数语法编译错误！`);
            }
        });
        this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
    }


    autoname() {
        let i = 1;
        while (true) {
            const funcName = 'f' + i;
            if (!this.calcJSUtils.customFunctions.hasOwnProperty(funcName) && !this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(funcName)) {
                return funcName;
            }
            i++;
            if (i > 10000) { 
                return 'f_error_' + Date.now(); 
            }
        }
    }
    autonameConstant() {
        let i = 1;
        while (true) {
            const constName = 'value' + i;
            const constNameLower = constName.toLowerCase();
            const isNameTaken = this.entries.some(entry =>
                (entry.type === 'constant' && entry.name.toLowerCase() === constNameLower) ||
                (entry.type === 'variable' && entry.key === constNameLower) ||
                (entry.type === 'custom_function_definition' && entry.name.toLowerCase() === constNameLower) ||
                (entry.type === 'advanced_custom_function_definition' && entry.name.toLowerCase() === constNameLower)
            ) || this.calcJSUtils.constants.hasOwnProperty(constNameLower) || this.calcJSUtils.calc1.includes(constNameLower);

            if (!isNameTaken) {
                return constName;
            }
            i++;
            if (i > 10000) {
                return 'value_error_' + Date.now();
            }
        }
    }



startEditEntry(index) {
        if (index < 0 || index >= this.entries.length) return;
        this.editingEntryIndex = index;
        const entry = this.entries[index];
        let stringToEdit = "";

        if (entry.type === 'variable') {
            const parts = entry.expr.split('=');
            stringToEdit = parts.length > 1 ? parts.slice(1).join('=').trim() : (entry.isEditableIndependent ? String(entry.value) : '');
        } else if (entry.type === 'geometry') {
            stringToEdit = entry.expr;
          } else if (entry.type === 'custom_function_definition') {
            stringToEdit = entry.body || "";
        } else if (entry.type === 'advanced_custom_function_definition') {
            stringToEdit = entry.bodyJs || "";
        } else if (entry.type === 'function') {

            const explicitTypes = ['x', 'y', 'z', 'x3d', 'y3d'];
            

            if (explicitTypes.includes(entry.plotType) && entry.expr.includes('=')) {

                stringToEdit = entry.expr.substring(entry.expr.indexOf('=') + 1).trim();
            } else {

                stringToEdit = entry.expr;
            }

        } else if (entry.type === 'constant') {

            stringToEdit = entry.expr;
        } else if (entry.type === 'text') {
            stringToEdit = '//' + entry.content;
        }

        if (typeof window.globalOpenKeyboardForEdit === 'function') {
            window.globalOpenKeyboardForEdit(stringToEdit);
        } else {
            console.error("globalOpenKeyboardForEdit function is not defined on window.");
        }
    }




applyEditToEntry(editedString) {
        if (this.editingEntryIndex < 0 || this.editingEntryIndex >= this.entries.length) {
            this.editingEntryIndex = -1;
            return;
        }

        const originalEntryIndex = this.editingEntryIndex;
        const entryBeingEdited = this.entries[originalEntryIndex];
        const oldIdentifier = entryBeingEdited.name || entryBeingEdited.expr;

        const originalAllEntriesBackup = JSON.parse(JSON.stringify(this.entries));
        const originalCustomFunctionsBackup = JSON.parse(JSON.stringify(this.calcJSUtils.customFunctions));
        const originalCalc3Backup = [...this.calcJSUtils.calc3];
        const originalAdvancedCustomFunctionsBackup = JSON.parse(JSON.stringify(this.calcJSUtils.advancedCustomFunctions, (k, v) => k === 'compiledFunc' ? undefined : v));
        const originalAdvancedCustomFunctionNamesBackup = [...this.calcJSUtils.advancedCustomFunctionNames];
        const originalVariablesBackup = new Map(this.variables);

        const _preserveEntryState = (target, source) => {
            if (!target || !source) return;
            if ('color' in source) target.color = source.color;
            if ('visible' in source) target.visible = source.visible;
            if ('expanded' in source) target.expanded = source.expanded;
            if ('sliderActive' in source) target.sliderActive = source.sliderActive;
            if ('displayFrame' in source) target.displayFrame = source.displayFrame;
            if ('extendTo3D' in source) target.extendTo3D = source.extendTo3D;
            if ('sliceAxis' in source) target.sliceAxis = source.sliceAxis;
            if ('sliceVal' in source) target.sliceVal = source.sliceVal;

            if (source.isEditableIndependent) {
                let newMin = source.min;
                let newMax = source.max;
                const newValue = target.value;
                if (Number.isFinite(newValue) && Number.isFinite(newMin) && newValue < newMin) newMin = newValue;
                if (Number.isFinite(newValue) && Number.isFinite(newMax) && newValue > newMax) newMax = newValue;
                target.min = newMin; target.max = newMax; target.step = source.step;
                target.playState = source.playState; target.playDirection = source.playDirection; target.playMode = source.playMode;
            }
        };

        let newExpr = "";
        let definitionChanged = false;
        let geoNameChangeInfo = null;

        try {
            if (entryBeingEdited.type === 'point_list') {
                newExpr = editedString;
                const parsedEntry = this.parsePointList(newExpr, originalEntryIndex);
                if (!parsedEntry) throw new Error("编辑后的点列表达式无效。");
                _preserveEntryState(parsedEntry, entryBeingEdited);
                parsedEntry.name = entryBeingEdited.name; 
                this.entries[originalEntryIndex] = parsedEntry;
            } else if (entryBeingEdited.type === 'variable') {
                newExpr = `${entryBeingEdited.name}=${editedString}`;
                const updatedEntryData = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (updatedEntryData && updatedEntryData.type === 'variable' && updatedEntryData.key === entryBeingEdited.key) {
                    _preserveEntryState(updatedEntryData, entryBeingEdited);
                    this.entries[originalEntryIndex] = updatedEntryData;
                } else {
                    throw new Error("编辑后变量类型或名称不匹配，或解析失败。");
                }
            } else if (entryBeingEdited.type === 'geometry') {
                newExpr = editedString;
                const parsedEntry = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (!parsedEntry || parsedEntry.type !== 'geometry') throw new Error("编辑后的表达式无效或不是一个有效的几何对象。");
                if (parsedEntry.geometryType !== entryBeingEdited.geometryType) throw new Error(`几何对象类型不能更改 (从 ${entryBeingEdited.geometryType} 到 ${parsedEntry.geometryType})。`);
                
                const oldName = entryBeingEdited.name;
                const newName = parsedEntry.name;
                if (oldName.toLowerCase() !== newName.toLowerCase()) {
                    definitionChanged = true;
                    geoNameChangeInfo = { oldName, newName, oldNameLower: oldName.toLowerCase() };
                }
                _preserveEntryState(parsedEntry, entryBeingEdited);
                this.entries[originalEntryIndex] = parsedEntry;
            } else if (entryBeingEdited.type === 'custom_function_definition' || entryBeingEdited.type === 'advanced_custom_function_definition') {
                const functionSignature = `${entryBeingEdited.name}(${entryBeingEdited.params.join(',')})`;
                newExpr = entryBeingEdited.type === 'custom_function_definition' ? `${functionSignature}=${editedString}` : `${functionSignature}={${editedString}}`;
                
                // 传入 allowOverwriteName，允许重新定义自己
                const newFuncData = this.defineCalcJSFunction(newExpr, true, entryBeingEdited.name); 
                
                if (!newFuncData) throw new Error("编辑后的函数定义无效或导致错误。");
                
                let updatedEntryData;
                if (newFuncData.type === 'custom_function_definition') {
                    updatedEntryData = {
                        type: 'custom_function_definition',
                        name: newFuncData.name, params: newFuncData.params, body: newFuncData.rawBodyString, expr: newFuncData.originalExpression,
                        dependencies: this._extractDependenciesFromTokensWithLargeOps(
                            newFuncData.bodyTokens, newFuncData.params,
                            this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                            this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                            this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames
                        ),
                        compilationError: undefined, hasLargeOps: newFuncData.bodyTokens.some(t => ['sum', 'prod', 'int'].includes(t))
                    };
                } else {
                     updatedEntryData = { type: 'advanced_custom_function_definition', name: newFuncData.name, params: newFuncData.params, bodyJs: newFuncData.bodyJsString, expr: `${newFuncData.name}(${newFuncData.params.join(',')}) { /* JS body */ }`, dependencies: [], compilationError: undefined };
                }
                _preserveEntryState(updatedEntryData, entryBeingEdited);
                this.entries[originalEntryIndex] = updatedEntryData;
                definitionChanged = true;

            } else if (entryBeingEdited.type === 'function') {
                newExpr = editedString;
                const explicitTypes = ['x', 'y', 'z', 'x3d', 'y3d'];

                if (explicitTypes.includes(entryBeingEdited.plotType) && entryBeingEdited.expr.includes('=')) {
                    const hasEquals = newExpr.includes('=');
                    const hasInequality = newExpr.match(/>=|<=|>|</);

                    // 修复 Bug 3：无条件补全头部，除非用户自己输入了等号/不等号
                    // 这样输入 xy-z 会补全为 z=xy-z，然后交给 parseInputInternal 智能判断是否自引用
                    if (!hasEquals && !hasInequality) {
                        const originalHeader = entryBeingEdited.expr.substring(0, entryBeingEdited.expr.indexOf('=') + 1);
                        newExpr = originalHeader + newExpr;
                    }
                }

                const parsedEntry = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                if (parsedEntry && parsedEntry.type === 'function') {
                    _preserveEntryState(parsedEntry, entryBeingEdited);
                    this.entries[originalEntryIndex] = parsedEntry; 
                } else {
                    const funcDefAttempt = this.parseInputInternal(newExpr.toLowerCase(), newExpr, originalEntryIndex);
                    if (funcDefAttempt && (funcDefAttempt.type === 'custom_function_definition' || funcDefAttempt.type === 'advanced_custom_function_definition')) {
                         _preserveEntryState(funcDefAttempt, entryBeingEdited);
                         this.entries[originalEntryIndex] = funcDefAttempt;
                         definitionChanged = true;
                    } else {
                        throw new Error("编辑后的表达式无效或解析失败。");
                    }
                }
            } else if (entryBeingEdited.type === 'text') {
                 if (!editedString.startsWith('//')) throw new Error("文本条目必须以 // 开头。");
                entryBeingEdited.content = editedString.substring(2).trim();
                entryBeingEdited.expr = editedString;
            }

            if (definitionChanged) {
                let currentEntriesSnapshot = JSON.parse(JSON.stringify(this.entries));
                if (geoNameChangeInfo) {
                    currentEntriesSnapshot.forEach(snapEntry => {
                        if (snapEntry.dependencies && snapEntry.dependencies.includes(geoNameChangeInfo.oldNameLower)) {
                            const oldNameRegex = new RegExp(`\\b${geoNameChangeInfo.oldName}\\b`, 'g');
                            snapEntry.expr = snapEntry.expr.replace(oldNameRegex, geoNameChangeInfo.newName);
                        }
                    });
                } else if (entryBeingEdited.type === 'custom_function_definition' || entryBeingEdited.type === 'advanced_custom_function_definition') {
                    const updatedEntryInSnapshot = currentEntriesSnapshot[originalEntryIndex];
                    if (updatedEntryInSnapshot && updatedEntryInSnapshot.name === entryBeingEdited.name) {
                        if (updatedEntryInSnapshot.type === 'custom_function_definition') {
                            updatedEntryInSnapshot.expr = `${updatedEntryInSnapshot.name}(${updatedEntryInSnapshot.params.join(',')})=${updatedEntryInSnapshot.body}`;
                        } else {
                            updatedEntryInSnapshot.expr = `${updatedEntryInSnapshot.name}(${updatedEntryInSnapshot.params.join(',')}) = {${updatedEntryInSnapshot.bodyJs}}`;
                        }
                    }
                }

                this.entries = []; 
                this.calcJSUtils.customFunctions = {};
                this.calcJSUtils.calc3 = [];
                this.calcJSUtils.advancedCustomFunctions = {};
                this.calcJSUtils.advancedCustomFunctionNames = [];
                this.initializeAdvancedCalcJSFunctions();
                this.initializeCalcJSBuiltinFunctions();
                
                const definitions = currentEntriesSnapshot.filter(e => e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition');
                const existingUserSymbolNames = new Set(currentEntriesSnapshot.map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean));

                definitions.forEach(snapEntry => {
                    const funcDefMatch = snapEntry.expr.match(/^([a-zA-Z_][\w]*)\s*\(/);
                    if (funcDefMatch) {
                        const funcName = funcDefMatch[1];
                        if (snapEntry.type === 'custom_function_definition') {
                            if (!this.calcJSUtils.calc3.includes(funcName)) this.calcJSUtils.calc3.push(funcName);
                        } else {
                            if (!this.calcJSUtils.advancedCustomFunctionNames.includes(funcName)) this.calcJSUtils.advancedCustomFunctionNames.push(funcName);
                        }
                    }
                });
                this.calcJSUtils.calc3.sort((a, b) => b.length - a.length);
                this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
            
                for (const snapEntry of definitions) {
                    const parsed = this.parseInputInternal(snapEntry.expr.toLowerCase(), snapEntry.expr, -1, existingUserSymbolNames);
                    if (parsed) {
                        _preserveEntryState(parsed, snapEntry);
                        this.entries.push(parsed);
                    } else {
                        snapEntry.compilationError = "依赖更新后解析失败";
                        this.entries.push(snapEntry);
                    }
                }
                const others = currentEntriesSnapshot.filter(e => e.type !== 'custom_function_definition' && e.type !== 'advanced_custom_function_definition');
                for (const snapEntry of others) {
                    const normalizedSnapExpr = snapEntry.expr.replace(/\s+/g, '').toLowerCase();
                    const existingIndex = this.entries.findIndex(e => e.type === snapEntry.type && e.expr.replace(/\s+/g, '').toLowerCase() === normalizedSnapExpr);
                    if (existingIndex !== -1) {
                        _preserveEntryState(this.entries[existingIndex], snapEntry);
                    } else {
                        const parsed = this.parseInputInternal(snapEntry.expr.toLowerCase(), snapEntry.expr, -1, existingUserSymbolNames);
                        if (parsed) {
                            _preserveEntryState(parsed, snapEntry);
                            this.entries.push(parsed);
                        }
                    }
                }
            }
            
            const updatedEntry = this.entries[originalEntryIndex];
            const newIdentifier = updatedEntry.name || updatedEntry.expr;
            if (oldIdentifier && newIdentifier && oldIdentifier !== newIdentifier) {
                this.annotations.forEach(anno => {
                    if (anno.type === 'checkbox' && anno.controlledNames) {
                        const idx = anno.controlledNames.indexOf(oldIdentifier);
                        if (idx !== -1) anno.controlledNames[idx] = newIdentifier;
                    }
                });
            }
            this.recalculateAll();
        } catch (err) {
            alert(`编辑失败: ${err.message}\n更改将被撤销。`);
            this.entries = originalAllEntriesBackup;
            this.calcJSUtils.customFunctions = originalCustomFunctionsBackup;
            this.calcJSUtils.calc3 = originalCalc3Backup;
            this.calcJSUtils.advancedCustomFunctions = originalAdvancedCustomFunctionsBackup;
            this.calcJSUtils.advancedCustomFunctionNames = originalAdvancedCustomFunctionNamesBackup;
            this.variables = new Map(originalVariablesBackup); 
            this.recalculateAll(); 
        }
        this.editingEntryIndex = -1;
    }
    initializeCalcJSBuiltinFunctions() {
        this.builtinFuncNames = [];
        const builtinfunc = [
            'root(m,n,p,q)=(-n+q*sqrt(n*n-4*m*p))/(2*m)',
            'cot(a)=1/tan(a)',
            'sec(a)=(1/cos(a))',
            'csc(a)=(1/sin(a))',
            'acot(b)=(1.57079632679-atan(b))',
            'asec(b)=(acos(1/b))',
            'acsc(b)=(asin(1/b))',
            'csch(a)=(1/sinh(a))',
            'sech(a)=(1/cosh(a))',
            'coth(a)=(1/tanh(a))',
            'acoth(b)=(atanh(1/b))',
            'asech(b)=(acosh(1/b))',
            'acsch(b)=(asinh(1/b))',
            'max(a,b)=(0.5*(a+b+abs(a-b)))',
            'min(a,b)=(0.5*(a+b-abs(a-b)))',
            'beta(a,b)=gamma(a)*gamma(b)/gamma(a+b)',
            'gammadist(a,b,c)=(c^(a-1)*e^(0-c/b))/(b^a*gamma(a))',
            'normdist(a,b,c,m)=m*0.5*(1+erf((c-a)/(sqrt(2)*abs(b))))+(1-m)*((e^(0-(c-a)^2)/(2*b*b))/(sqrt(2*3.1415926*abs(b))))',
            'tdist(a,b)=(gamma(0.5*(a+1))*(b*b/a+1)^(0-0.5*(a+1)))/gamma(a/2)/sqrt(3.1415926536*a)',
            'chisqdist(a,b)=0.5*(sgn(b)+1)*(e^(0-0.5*b)*b^(0.5*a-1))/(2^(0.5*a)*gamma(0.5*a))',
            'lognormdist(a,b,c,m)=0.5*(1+sgn(c))*((erf((ln(c)-a)/(1.4142135*abs(b)))*0.5+0.5)*m+(e^(0-(ln(c)-a)^2/2/(b*b))/(abs(b)*c*sqrt(2*3.1415926)))*(1-m))'
        ];
        builtinfunc.forEach(def => {
            const funcDefMatch = def.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
            if (funcDefMatch) {
                this.builtinFuncNames.push(funcDefMatch[1]);
            }
            this.defineCalcJSFunction(def, true)
        });
    }
    
    defineCalcJSFunction(defString, silentAlerts = false, allowOverwriteName = null) {
        const funcDefMatchOriginal = defString.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
        if (!funcDefMatchOriginal) {
            if (!silentAlerts) alert("无效的函数定义格式。请使用: 名称(参数1,参数2,...)=表达式 或 名称(参数1,...) { JS 主体 }");
            return false;
        }

        let name = funcDefMatchOriginal[1];
        const paramsStr = funcDefMatchOriginal[2];
        let bodyStr = funcDefMatchOriginal[3];
        
        const nameLower = name.toLowerCase();
        
        // 检查是否允许覆盖（编辑模式）
        if (allowOverwriteName && nameLower === allowOverwriteName.toLowerCase()) {
            // 允许覆盖自身，跳过重名检查
        } else {
            const isBuiltInMath = this.calcJSUtils.calc1.includes(nameLower);
            const isExistingSimpleCustom = this.calcJSUtils.customFunctions.hasOwnProperty(nameLower);
            const isExistingAdvancedCustom = this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(nameLower);
            const isExistingConstant = this.calcJSUtils.constants.hasOwnProperty(nameLower);

            // 修复 Bug 2：强制检查重名
            if (isBuiltInMath || isExistingConstant || isExistingSimpleCustom || isExistingAdvancedCustom) {
                if (nameLower !== 'x' && nameLower !== 'y' && nameLower !== 't') {
                     if (!silentAlerts) alert(`函数名 '${name}' 与现有函数或内置对象冲突，将作为方程处理。`);
                     return false; 
                }
            }
        }

        if (this.calcJSUtils.calc2.some(op => name.includes(op))) {
            if (!silentAlerts) alert(`函数名 '${name}' 不能包含运算符 (+-*/^,)。`);
            return false;
        }
        if (this.calcJSUtils.isNumericString(name[0])) {
             if (!silentAlerts) alert(`函数名 '${name}' 不能以数字开头。`);
            return false;
        }

        const params = paramsStr.split(',').map(p => p.trim()).filter(p => p);
        if (new Set(params).size !== params.length) {
            if (!silentAlerts) alert(`函数 '${name}' 中存在重复的参数名。`);
            return false;
        }
        let paramError = false;
        params.forEach(param => {
            if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                if (!silentAlerts) alert(`参数名如 '${param}' 必须是有效的JS标识符。`);
                paramError = true;
            }
            if (this.calcJSUtils.constants[param.toLowerCase()] || this.calcJSUtils.calc1.includes(param.toLowerCase()) || ['e'].includes(param.toLowerCase())) {
                if (!silentAlerts) alert(`参数名 '${param}' 是保留的常量或内置函数名。`);
                paramError = true;
            }
        });
        if(paramError) return false;

        const bodyTrimmed = bodyStr.trim();
        const looksLikeAdvancedJs = bodyTrimmed.startsWith('{') && bodyTrimmed.endsWith('}') && bodyTrimmed.length > 2;

        if (looksLikeAdvancedJs) {
            try {
                const actualJsBody = bodyTrimmed.substring(1, bodyTrimmed.length - 1);
                const compiledFunc = new Function(...params, actualJsBody); 

                this.calcJSUtils.advancedCustomFunctions[nameLower] = { params, bodyJsString: actualJsBody, compiledFunc };
                if (!this.calcJSUtils.advancedCustomFunctionNames.includes(nameLower)) {
                    this.calcJSUtils.advancedCustomFunctionNames.push(nameLower);
                    this.calcJSUtils.advancedCustomFunctionNames.sort((a, b) => b.length - a.length);
                }
                return { type: 'advanced_custom_function_definition', name, params, bodyJs: actualJsBody, originalExpression: defString };
            } catch (e) {
                if (!silentAlerts) alert(`定义高级JS函数 '${name}' 时出错: ${e.message}`);
                return false;
            }
        } else {
           try {
                const contextSymbols = new Set([
                    ...this.calcJSUtils.calc1,
                    ...this.calcJSUtils.calc3,
                    ...this.calcJSUtils.advancedCustomFunctionNames,
                    ...Object.keys(this.calcJSUtils.constants),
                    ...this.entries.map(e => e.name || e.key),
                    ...params
                ].filter(Boolean).map(n => n.toLowerCase()));

                let bodyTokens = this.improvedTokenize(bodyStr, contextSymbols);
                const paramsLower = params.map(p => p.toLowerCase());

                this.calcJSUtils.customFunctions[nameLower] = { params: paramsLower, bodyTokens, rawBodyString: bodyStr };

                if (!this.calcJSUtils.calc3.includes(nameLower)) {
                    this.calcJSUtils.calc3.push(nameLower);
                    this.calcJSUtils.calc3.sort((a,b) => b.length - a.length);
                }
                return { type: 'custom_function_definition', name, params, body: bodyStr, rawBodyString: bodyStr, bodyTokens, originalExpression: defString };
            } catch (e) {
                if (!silentAlerts) alert(`定义函数 '${name}' 时出错: ${e.message}`);
                return false;
            }
        }
    }

_extractDependenciesFromTokensWithLargeOps(tokens, excludeParams = [], customFunctions, calc3_list, constants_obj, calc1_list, allowedVarKeys, advancedCustomFunctions, advancedCustomFunctionNames, existingUserSymbolNames = new Set()) {
        const dependencies = new Set();
        // 预处理：将排除参数转换为小写 Set
        const currentExcludeParams = new Set(excludeParams.map(p => p.toLowerCase()));
        
        // 这是一个递归辅助函数，用于处理嵌套结构
        const recurse = (subTokens, localExcludes) => {
            let i = 0;
            while (i < subTokens.length) {
                const token = subTokens[i];
                const lowerToken = token.toLowerCase();

                // 检查是否为大型运算符 sum/prod/int
                if (['sum', 'prod', 'int'].includes(lowerToken)) {
                    // 检查括号结构
                    if (i + 1 >= subTokens.length || subTokens[i + 1] !== '(') {
                        i++; continue; 
                    }
                    const openParenIdx = i + 1;
                    const closeParenIdx = this.calcJSUtils.findMatchingParen(subTokens, openParenIdx);
                    if (closeParenIdx === -1) {
                        i++; continue; 
                    }

                    try {
                        // 提取 4 个参数：[表达式, 变量名, 起始值, 终止值]
                        // 注意：这里我们使用 calcJSUtils 的提取工具
                        const args = this.calcJSUtils.extractArguments(subTokens, openParenIdx, closeParenIdx, 4);
                        
                        const bodyTokens = args[0];
                        const varNameToken = args[1]; // 这是一个 token 数组
                        const startTokens = args[2];
                        const endTokens = args[3];

                        // 获取循环变量名 (例如 'n')
                        let loopVarName = null;
                        if (varNameToken && varNameToken.length === 1 && this.calcJSUtils.isLetter(varNameToken[0])) {
                            loopVarName = varNameToken[0].toLowerCase();
                        }

                        // 关键逻辑：
                        // 1. 分析主体 (bodyTokens)：排除当前的 localExcludes 加上 新的 loopVarName
                        //    因为在 sum(n, n, 1, a) 中，第一个 n 是局部变量
                        const nextLevelExcludes = loopVarName ? new Set([...localExcludes, loopVarName]) : localExcludes;
                        recurse(bodyTokens, nextLevelExcludes);

                        // 2. 分析起始和结束值 (startTokens, endTokens)：只能排除 localExcludes
                        //    因为 sum(..., n, 1, a) 中的 a 是外部依赖，不能被 n 屏蔽
                        recurse(startTokens, localExcludes);
                        recurse(endTokens, localExcludes);

                    } catch (e) {
                        // 如果参数解析失败（比如用户还没输完），忽略并继续
                    }
                    
                    // 跳过整个 sum(...) 结构
                    i = closeParenIdx + 1; 
                    continue;

                } else if (['diff', 'diffat'].includes(lowerToken)) {
                    // 处理导数 diff(expr, var)
                    if (i + 1 >= subTokens.length || subTokens[i + 1] !== '(') { i++; continue; }
                    const openParenIdx = i + 1;
                    const closeParenIdx = this.calcJSUtils.findMatchingParen(subTokens, openParenIdx);
                    if (closeParenIdx === -1) { i++; continue; }

                    try {
                        const expectedArgs = (lowerToken === 'diff') ? 2 : 3;
                        const args = this.calcJSUtils.extractArguments(subTokens, openParenIdx, closeParenIdx, expectedArgs);
                        
                        const bodyTokens = args[0];
                        const varNameToken = args[1];
                        let diffVarName = null;
                        if (varNameToken && varNameToken.length === 1) diffVarName = varNameToken[0].toLowerCase();

                        // 导数变量也是局部的
                        const nextLevelExcludes = diffVarName ? new Set([...localExcludes, diffVarName]) : localExcludes;
                        recurse(bodyTokens, nextLevelExcludes);
                        
                        // diffat 的第三个参数是求值点，它依赖外部变量
                        if (args.length === 3) {
                            recurse(args[2], localExcludes);
                        }

                    } catch (e) {}
                    i = closeParenIdx + 1;
                    continue;
                }

                // 常规 Token 处理
                // 如果是变量名（字母开头），且不在已知函数/常量/排除列表中，则视为依赖
                if (this.calcJSUtils.isLetter(token)) {
                    const isKnownFunc = calc1_list.includes(lowerToken) || calc3_list.includes(lowerToken) || advancedCustomFunctionNames.includes(lowerToken);
                    const isKnownConst = constants_obj.hasOwnProperty(lowerToken);
                    
                    if (!isKnownFunc && !isKnownConst && !localExcludes.has(lowerToken)) {
                        dependencies.add(lowerToken);
                    }
                }
                i++;
            }
        };

        // 启动递归
        recurse(tokens, currentExcludeParams);

        return Array.from(dependencies);
    }    
evaluateExpressionWithCalcJS(tokensOrString, scopeVars, customMap) {
    let tokens;
    if (typeof tokensOrString === 'string') {
        tokens = this.calcJSUtils.tokenize.call(this.calcJSUtils, tokensOrString);
    } else {
        // 避免昂贵的 JSON 序列化
        tokens = tokensOrString; 
    }
    
    // 关键修复：将 Map 转换为 Object 才能进行解构合并
    const variablesObj = Object.fromEntries(this.variables);
    const fullScope = { ...variablesObj, ...scopeVars };

    return this.calcJSUtils.evaluateScopedExpression.call(
        this.calcJSUtils, 
        tokens,
        fullScope,
        this.calcJSUtils.customFunctions,
        this.calcJSUtils.calc3,
        this.calcJSUtils.constants,
        this.calcJSUtils.calc1,
        this.integralNumSteps,
        this.calcJSUtils.advancedCustomFunctions,
        this.calcJSUtils.advancedCustomFunctionNames,
        customMap || this.calcJSUtils.getAdvancedFuncsMap()
    );
}


initWebGL() {
        this.gl = this.canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true }) || this.canvas.getContext('experimental-webgl', { antialias: true, preserveDrawingBuffer: true });
        if (!this.gl) {
            alert('WebGL 不支持。程序将崩溃');
            throw new Error('WebGL 不支持');
        }
        const gl = this.gl;


        const vsSource = document.getElementById('line-vertex-shader').textContent;
        const fsSource = document.getElementById('line-fragment-shader').textContent;
        this.shaderProgramLines = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSource), this.createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        this.attributeLocations.vertexPosition = gl.getAttribLocation(this.shaderProgramLines, 'a_vertexPosition');
        this.uniformLocations.canvasCssSize = gl.getUniformLocation(this.shaderProgramLines, 'u_canvasCssSize');
        this.uniformLocations.viewOffset = gl.getUniformLocation(this.shaderProgramLines, 'u_viewOffset');
        this.uniformLocations.viewScale = gl.getUniformLocation(this.shaderProgramLines, 'u_viewScale');
        this.uniformLocations.color = gl.getUniformLocation(this.shaderProgramLines, 'u_color');


        const vsSource3D = document.getElementById('shader-3d-vertex').textContent;
        const fsSource3D = document.getElementById('shader-3d-fragment').textContent;
        this.shaderProgram3D = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSource3D), this.createShader(gl, gl.FRAGMENT_SHADER, fsSource3D));
        this.attribLoc3D.position = gl.getAttribLocation(this.shaderProgram3D, 'a_position');
        this.attribLoc3D.normal = gl.getAttribLocation(this.shaderProgram3D, 'a_normal');
        this.uniformLoc3D.mvp = gl.getUniformLocation(this.shaderProgram3D, 'u_modelViewProjection');
        this.uniformLoc3D.normalMat = gl.getUniformLocation(this.shaderProgram3D, 'u_normalMatrix');
        this.uniformLoc3D.color = gl.getUniformLocation(this.shaderProgram3D, 'u_color');
        this.uniformLoc3D.lightDir = gl.getUniformLocation(this.shaderProgram3D, 'u_lightDirection');
        this.uniformLoc3D.bounds = gl.getUniformLocation(this.shaderProgram3D, 'u_bounds');


        const vsSourceLine3D = `attribute vec3 a_position; uniform mat4 u_mvp; varying vec3 v_position; void main() { v_position = a_position; gl_Position = u_mvp * vec4(a_position, 1.0); }`;
        const fsSourceLine3D = `precision mediump float; uniform vec4 u_color; uniform float u_bounds; varying vec3 v_position; void main() { if (abs(v_position.x) > u_bounds || abs(v_position.y) > u_bounds || abs(v_position.z) > u_bounds) discard; gl_FragColor = u_color; }`;
        this.shaderProgram3DLine = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSourceLine3D), this.createShader(gl, gl.FRAGMENT_SHADER, fsSourceLine3D));
        this.attribLoc3D.linePos = gl.getAttribLocation(this.shaderProgram3DLine, 'a_position');
        this.uniformLoc3D.lineMvp = gl.getUniformLocation(this.shaderProgram3DLine, 'u_mvp');
        this.uniformLoc3D.lineColor = gl.getUniformLocation(this.shaderProgram3DLine, 'u_color');
        this.uniformLoc3D.lineBounds = gl.getUniformLocation(this.shaderProgram3DLine, 'u_bounds');

        const vsSourceThick = document.getElementById('shader-3d-thick-line-vertex').textContent;
        const fsSourceThick = document.getElementById('shader-3d-thick-line-fragment').textContent;
        this.shaderProgram3DThick = this.createProgram(gl, this.createShader(gl, gl.VERTEX_SHADER, vsSourceThick), this.createShader(gl, gl.FRAGMENT_SHADER, fsSourceThick));
        this.attribLoc3D.thickPos = gl.getAttribLocation(this.shaderProgram3DThick, 'a_pos');
        this.attribLoc3D.thickOther = gl.getAttribLocation(this.shaderProgram3DThick, 'a_other');
        this.attribLoc3D.thickSide = gl.getAttribLocation(this.shaderProgram3DThick, 'a_side');
        this.uniformLoc3D.thickMvp = gl.getUniformLocation(this.shaderProgram3DThick, 'u_mvp');
        this.uniformLoc3D.thickViewport = gl.getUniformLocation(this.shaderProgram3DThick, 'u_viewport');
        this.uniformLoc3D.thickThickness = gl.getUniformLocation(this.shaderProgram3DThick, 'u_thickness');
        this.uniformLoc3D.thickColor = gl.getUniformLocation(this.shaderProgram3DThick, 'u_color');


        this.lineVertexBuffer = gl.createBuffer();
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  this.implicitFillData = new Map();
    }

  autonamePointList() {
        return this.autonameByPrefix('array');
    }

parsePointList(originalInput, ignoreIndex = -1) {
        const name = this.autonamePointList();
        const entry = {
            type: 'point_list',
            expr: originalInput,
            name: name,
            pointCache: [],
            segments: [],
            dependencies: [],
            color: { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 },
            visible: true,
            thickness: 3,
            displayFrame: 0,
            webglVertices: null,
            compilationError: undefined,
            hasLargeOps: false,
        };

        const existingUserSymbolNamesForDepExtraction = new Set(
            this.entries.filter((e, i) => i !== ignoreIndex).map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean)
        );

        const content = originalInput.substring(3).trim();
        
        const items = [];
        let currentStr = '';
        let parenLevel = 0;
        
        for (let i = 0; i < content.length; i++) {
            const char = content[i];
            
            if (char === '(') {
                if (parenLevel === 0 && currentStr.trim() === '') {
                    currentStr = '(';
                } else {
                    currentStr += char;
                }
                parenLevel++;
            } else if (char === ')') {
                parenLevel--;
                currentStr += char;
                if (parenLevel === 0) {
                    items.push(currentStr.trim());
                    currentStr = '';
                } else if (parenLevel < 0) {
                     throw new Error("点列语法无效: 括号不匹配。");
                }
            } else if (char === '/' && parenLevel === 0) {
                 items.push('/');
                 currentStr = '';
            } else {
                if (parenLevel > 0 || char.trim() !== '') {
                    currentStr += char;
                }
            }
        }
        
        if (parenLevel !== 0) throw new Error("点列语法无效: 括号不匹配。");
        if (items.length === 0) throw new Error("点列语法无效: 未找到任何点或分隔符。");

        let currentSegmentIndices = [];
        const allDependencies = new Set();

        const parseCoordinates = (str) => {
            const inner = str.substring(1, str.length - 1);
            let pLevel = 0;
            let splitIndex = -1;
            for(let i = 0; i < inner.length; i++) {
                if (inner[i] === '(') pLevel++;
                else if (inner[i] === ')') pLevel--;
                else if (inner[i] === ',' && pLevel === 0) {
                    splitIndex = i;
                    break;
                }
            }
            if (splitIndex === -1) throw new Error(`点坐标格式错误: ${str}`);
            return [inner.substring(0, splitIndex).trim(), inner.substring(splitIndex + 1).trim()];
        };

        for (const item of items) {
            const isBreak = item === '/' || item.toLowerCase() === '(x,x)';
            if (isBreak) {
                if (currentSegmentIndices.length > 0) {
                    entry.segments.push(currentSegmentIndices);
                }
                currentSegmentIndices = [];
            } else {
                let rawX, rawY;
                try {
                    [rawX, rawY] = parseCoordinates(item);
                } catch (e) {
                     throw new Error(`点坐标格式错误: ${item}`);
                }

                const isNumericX = this.calcJSUtils.isNumericString(rawX);
                const isNumericY = this.calcJSUtils.isNumericString(rawY);
                
                const dependenciesX = isNumericX ? [] : this._extractDependenciesFromTokensWithLargeOps(
                    this.calcJSUtils.tokenize.call(this.calcJSUtils, rawX), [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingUserSymbolNamesForDepExtraction
                );
                const dependenciesY = isNumericY ? [] : this._extractDependenciesFromTokensWithLargeOps(
                    this.calcJSUtils.tokenize.call(this.calcJSUtils, rawY), [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingUserSymbolNamesForDepExtraction
                );

                dependenciesX.forEach(dep => allDependencies.add(dep));
                dependenciesY.forEach(dep => allDependencies.add(dep));

                const pointCacheEntry = {
                    rawX,
                    rawY,
                    isNumericX,
                    isNumericY,
                    valueX: isNumericX ? parseFloat(rawX) : NaN,
                    valueY: isNumericY ? parseFloat(rawY) : NaN,
                    dependenciesX,
                    dependenciesY,
                };

                const cacheIndex = entry.pointCache.length;
                entry.pointCache.push(pointCacheEntry);
                currentSegmentIndices.push(cacheIndex);
            }
        }
        if (currentSegmentIndices.length > 0) {
            entry.segments.push(currentSegmentIndices);
        }
        
        entry.dependencies = Array.from(allDependencies);
        return entry;
    }

    recalculatePointLists() {
        this.entries.forEach(entry => {
            if (entry.type !== 'point_list') return;

            let changed = false;
            entry.pointCache.forEach(point => {
                if (!point.isNumericX) {
                    const newValueX = this.evaluateExpressionWithCalcJS(point.rawX, Object.fromEntries(this.variables));
                    if (point.valueX !== newValueX) {
                        point.valueX = newValueX;
                        changed = true;
                    }
                }
                if (!point.isNumericY) {
                    const newValueY = this.evaluateExpressionWithCalcJS(point.rawY, Object.fromEntries(this.variables));
                    if (point.valueY !== newValueY) {
                        point.valueY = newValueY;
                        changed = true;
                    }
                }
            });

            if (changed) {
                entry.webglVertices = null;
            }
        });
    }

    plotPointListGL(entry, cssWidth, cssHeight) {
        if (this.is3DMode) return;
        const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && !this.showHiddenMath) return; if (entry.compilationError || !entry.color) return;


        const gl = this.gl;
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);

        if (!entry.webglVertices) {
            const vertices = [];
            for (const segment of entry.segments) {
                for (let i = 0; i < segment.length - 1; i++) {
                    const p1_cache = entry.pointCache[segment[i]];
                    const p2_cache = entry.pointCache[segment[i + 1]];

                    if (Number.isFinite(p1_cache.valueX) && Number.isFinite(p1_cache.valueY) &&
                        Number.isFinite(p2_cache.valueX) && Number.isFinite(p2_cache.valueY)) {
                        
                        if (useQuads) {
                            vertices.push(...this.generateQuadVertices(p1_cache.valueX, p1_cache.valueY, p2_cache.valueX, p2_cache.valueY, lineThicknessMath));
                        } else {
                            vertices.push(p1_cache.valueX, p1_cache.valueY, p2_cache.valueX, p2_cache.valueY);
                        }
                    }
                }
            }
            entry.webglVertices = new Float32Array(vertices);
        }

        if (entry.webglVertices && entry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            
            const plotColorArray = this.hsbToRgbaArray(entry.color.h, entry.color.s, entry.color.b, entry.color.a);
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);

            if (useQuads) {
                gl.drawArrays(gl.TRIANGLES, 0, entry.webglVertices.length / 2);
            } else {
                gl.lineWidth(1.5);
                gl.drawArrays(gl.LINES, 0, entry.webglVertices.length / 2);
            }
        }
    }



    createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    updateCategoryButtonIcon() {
        if (this.categoryFilterIcon) {
            this.categoryFilterIcon.src = this.categoryIcons[this.categoryFilterMode];
        }
    }


updateOverlayPositions() {
        if (!this.fpsDisplay || !this.infoDisplay) return;

        this.fpsDisplay.style.display = 'block';

        if (!this.isTransparencyEnabled) {
            this.infoDisplay.style.display = 'none';
            return;
        } else {
            this.infoDisplay.style.display = '';
        }

        const isSidebarHidden = document.body.classList.contains('sidebar-hidden');
        const isPortrait = this.isPortraitMode;
        const sidebarBg = document.getElementById('sidebar-background');
        const isFullscreen = sidebarBg && sidebarBg.classList.contains('fullscreen');

        if (isSidebarHidden || isPortrait || isFullscreen || !sidebarBg) {
            this.infoDisplay.style.left = '10px';
        } else {
            const sidebarRect = sidebarBg.getBoundingClientRect();
            const newLeft = sidebarRect.right + 10;
            this.infoDisplay.style.left = `${newLeft}px`;
        }
    }
getEffectiveVisibility(entry) {
        
        const id = entry.name || entry.expr;
        for (const anno of this.annotations) {
            if (anno.type === 'checkbox' && anno.controlledNames && anno.controlledNames.includes(id)) {
                return anno.checked;
            }
        }
        return entry.visible;
    }
     init() {
    this.initializeAdvancedCalcJSFunctions();
    this.initializeCalcJSBuiltinFunctions();
    this.initWebGL();
    this.clearPlotData();
    this.updateLayout();
    this.centerCanvas();
    

    this.colorInversionToggle = document.getElementById('color-inversion-toggle');
    this.showAxesToggle = document.getElementById('show-axes-toggle');
    this.showAxisNumbersToggle = document.getElementById('show-axis-numbers-toggle');
    this.showPointLabelsToggle = document.getElementById('show-point-labels-toggle');
    this.showHiddenMathToggle = document.getElementById('show-hidden-math-toggle');
    this.showHiddenGeoToggle = document.getElementById('show-hidden-geo-toggle');
    this.geometrySnapToggle = document.getElementById('geometry-snap-toggle');
    this.geometryMeasurementDisplayToggle = document.getElementById('geometry-measurement-display-toggle');
    this.infoDisplay = document.getElementById('info-display');
    this.codePanel = document.getElementById('code-panel');
    this.windowTransparencyToggle = document.getElementById('window-transparency-toggle');
    this.isTransparencyEnabled = true; 
this.annotationMenu = document.getElementById('annotation-menu');
this.variableCardInteraction = { active: false, entryIndex: -1, type: null, offset: { x: 0, y: 0 }, startVal: 0 };
    this.isAnnotationMenuExpanded = false; // 新增状态追踪

    this.penColorSliders.h = new CustomSlider('pen-color-slider-h', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.h, type: 'hue', onInput: e => { this.annotationState.pen.color.h = e.target.options.value; Object.values(this.penColorSliders).forEach(s => { s.options.context = this.annotationState.pen.color; s.draw(); }); } });
    this.penColorSliders.s = new CustomSlider('pen-color-slider-s', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.s, type: 'saturation', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.s = e.target.options.value; } });
    this.penColorSliders.b = new CustomSlider('pen-color-slider-b', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.b, type: 'brightness', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.b = e.target.options.value; } });
    this.penColorSliders.a = new CustomSlider('pen-color-slider-a', { min: 0, max: 100, step: 1, value: this.annotationState.pen.color.a, type: 'alpha', context: this.annotationState.pen.color, onInput: e => { this.annotationState.pen.color.a = e.target.options.value; } });
    
    this.annotationEditTextBtn = document.getElementById('annotation-edit-text-btn');
    this.annotationDeleteBtn = document.getElementById('annotation-delete-btn');
    this.annotationModeSwitchBtns = document.querySelectorAll('.annotation-mode-switch-btn');
    this.annotationColorBtn = document.getElementById('annotation-color-btn'); // 新增颜色按钮引用

    this.penThicknessSlider = new CustomSlider('pen-thickness-slider', { min: 0.01, max: 0.5, step: 0.01, value: 0.05, type: 'default', onInput: e => { this.annotationState.pen.thickness = e.target.options.value; this.requestDraw(); } });
    this.penFontSizeSlider = new CustomSlider('text-size-slider', { min: 0.1, max: 2.0, step: 0.1, value: 0.5, type: 'default', onInput: e => { this.annotationState.pen.fontSize = e.target.options.value; this.requestDraw(); } });

    // 绑定颜色按钮的折叠/展开逻辑
    if (this.annotationColorBtn) {
        this.annotationColorBtn.addEventListener('click', () => {
            this.isAnnotationMenuExpanded = !this.isAnnotationMenuExpanded;
            this.annotationMenu.classList.toggle('expanded', this.isAnnotationMenuExpanded);
            this.annotationColorBtn.classList.toggle('active', this.isAnnotationMenuExpanded);
        });
    }

    this.penThicknessSlider = new CustomSlider('pen-thickness-slider', { min: 0.01, max: 0.5, step: 0.01, value: 0.05, type: 'default', onInput: e => { this.annotationState.pen.thickness = e.target.options.value; this.requestDraw(); } });

    this.penFontSizeSlider = new CustomSlider('text-size-slider', { min: 0.1, max: 2.0, step: 0.1, value: 0.5, type: 'default', onInput: e => { this.annotationState.pen.fontSize = e.target.options.value; this.requestDraw(); } });
    
    if (this.fileNameDisplay) {
        this.fileNameDisplay.textContent = this.filename;
        this.fileNameDisplay.addEventListener('click', () => {
            const newName = prompt("请输入存档名称:", this.filename);
            if (newName && newName.trim() !== "") {
                this.filename = newName.trim();
                this.fileNameDisplay.textContent = this.filename;
            }
        });
    }
    
const viewModeCircle = document.getElementById('view-mode-toggle-circle');
    if (viewModeCircle) {
        viewModeCircle.addEventListener('click', () => {
            if (this.is3DMode) {
                this.is3DMode = false;
                viewModeCircle.textContent = "3D";
                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) navBtnGeometry.style.display = 'flex';
            } else {
                this.is3DMode = true;
                this.stopTracing();
                viewModeCircle.textContent = "2D";
               if (this.currentUIMode === 'geometry') {
                    this.setUIMode('plot');
                    const navBtnGeometry = document.getElementById('nav-btn-geometry');
                    const navBtnPlot = document.getElementById('nav-btn-plot');
                    if (navBtnPlot && navBtnGeometry) {
                        navBtnGeometry.classList.remove('selected');
                        navBtnPlot.classList.add('selected');
                    }
                    if (typeof updateInterfaceState === 'function') {
                        updateInterfaceState();
                    }
                }
                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) navBtnGeometry.style.display = 'none';
                this.recalculate3D();
            }
            this.requestDraw();
            this.updateTopBarLayout(); 
        });
    }

    const resetViewBtn = document.getElementById('reset-view-btn');
    if (resetViewBtn) {
        resetViewBtn.addEventListener('click', () => {
            if (this.is3DMode) {

                this.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
                this.center3D = { x: 0, y: 0, z: 0 };
                this.offset3D = { x: 0, y: 0 };
                this.scale3D = 1.0;
                this.bounds3D = 8;

                this.recalculate3D();
            } else {

                this.scale = 100; 
                this.centerCanvas(); 
            }
            

            this.clearPlotData();
            this.requestDraw();

        });
    }


this.setupEventListeners();
    
this.isAnnotationEditingEnabled = true;
        const annoSplitLeft = document.getElementById('anno-split-left');
        const annoSplitRight = document.getElementById('anno-split-right');
        const iconEditOn = document.getElementById('icon-edit-on');
        const iconEditOff = document.getElementById('icon-edit-off');


        const updateEditIcon = () => {
            if (iconEditOn && iconEditOff) {
                iconEditOn.style.display = this.isAnnotationEditingEnabled ? 'block' : 'none';
                iconEditOff.style.display = this.isAnnotationEditingEnabled ? 'none' : 'block';
            }
        };

        if (annoSplitLeft) {
            updateEditIcon();
            
            annoSplitLeft.addEventListener('click', (e) => {
                e.stopPropagation();
                this.isAnnotationEditingEnabled = !this.isAnnotationEditingEnabled;
                updateEditIcon();
                
                if (!this.isAnnotationEditingEnabled && this.selectedAnnotationIndex !== -1) {
                    this.selectedAnnotationIndex = -1;
                    this.updateAnnotationEditMenu();
                    this.requestDraw();
                }
            });
        }

 if (annoSplitRight) {
            annoSplitRight.addEventListener('click', (e) => {
                e.stopPropagation();
                
                let returnMode = archInstance.currentUIMode;
                
                if (archInstance.currentUIMode === 'plot') {
                    returnMode = 'geometry'; 
                    archInstance.setUIMode('geometry');
                }
                
                archInstance.enterAnnotationMode(returnMode);
            });
        }

    this.applyTransparency(this.isTransparencyEnabled);

    this.updatePrecisionLabels();
    this.updateParametricRangeLabels();
    this.updatePreferredColorValueLabel();
    this.updateIntegralPrecisionLabel();
    this.applyThemeColors();
    
    this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    if (this.overlayDrawingToggle) this.overlayDrawingToggle.checked = this.overlayDrawingEnabled;
    this.lowPrecisionBufferToggle.checked = this.lowPrecisionBufferEnabled;
    this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;

    this.darkModeToggle.checked = this.isDarkModeActive;
    this.applyDarkMode(this.isDarkModeActive);
    this.geometrySnapToggle.checked = this.geometrySnapEnabled;
    this.geometryMeasurementDisplayToggle.checked = this.geometryMeasurementDisplayEnabled;
    this.colorInversionToggle.checked = this.colorInversionEnabled;
    this.showAxesToggle.checked = this.showAxes;
    this.showAxisNumbersToggle.checked = this.showAxisNumbers;
    document.querySelectorAll('#grid-style-buttons button').forEach(b => {
        b.classList.toggle('active', b.dataset.style === this.gridStyle);
    });
    this.showPointLabelsToggle.checked = this.showPointLabels;
    this.showHiddenMathToggle.checked = this.showHiddenMath;
    this.showHiddenGeoToggle.checked = this.showHiddenGeo;
    this.windowTransparencyToggle.checked = this.isTransparencyEnabled;
    document.getElementById('global-script-toggle-btn').addEventListener('click', () => this.toggleGlobalScriptView());
    document.getElementById('global-script-run-btn').addEventListener('click', () => this.executeGlobalScript());
    document.getElementById('global-script-stop-btn').addEventListener('click', () => this.stopGlobalScript());

    this.checkTouchSupport();
    if (this.isTouchDevice) document.body.classList.add('is-touch-device');
    this.smoothPanningEnabled = this.isTouchDevice;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    
    this.updateOverlayPositions();
    this.recalculateAll();
}  

  getRayPlaneIntersection(mouseX, mouseY) {
        const gl = this.gl;
        const canvasHeight = this.canvas.height / window.devicePixelRatio;

        const viewportBottomScreenY = canvasHeight - this.viewport3D.y;

        const viewportTopScreenY = canvasHeight - (this.viewport3D.y + this.viewport3D.h);

        const ndcX = ((mouseX - this.viewport3D.x) / this.viewport3D.w) * 2 - 1;
  
        const ndcY = ((canvasHeight - mouseY - this.viewport3D.y) / this.viewport3D.h) * 2 - 1;

        const aspect = this.viewport3D.w / this.viewport3D.h;
        const proj = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta) + this.center3D.x,
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta) + this.center3D.y,
            z: cam.rho * Math.cos(cam.phi) + this.center3D.z
        };
        const view = Mat4.lookAt(Mat4.create(), eye, this.center3D, {x:0, y:0, z:1});
        
        const vp = Mat4.multiply(Mat4.create(), proj, view);
        const invVP = Mat4.invert(Mat4.create(), vp);
        if (!invVP) return null;

        const near = [ndcX, ndcY, -1];
        const far = [ndcX, ndcY, 1];
        Mat4.transformVec3(near, near, invVP);
        Mat4.transformVec3(far, far, invVP);

        const dirZ = far[2] - near[2];
        if (Math.abs(dirZ) < 1e-6) return null;
        

        const t = (0 - near[2]) / dirZ;
        

        
        return { 
            x: near[0] + t * (far[0] - near[0]), 
            y: near[1] + t * (far[1] - near[1]) 
        };
    }

clearPlotData() {
        this.blocks01.clear();
        this.implictplotindex.length = 0;
        this.implictplotindex.push(0);
        this.implictplotdata.length = 0;
        this.orderedBlocks01ForImplicitProcessing.length = 0;
        if (this.implicitFillData) this.implicitFillData.clear();
        if(this.plottedFunctionPoints) this.plottedFunctionPoints.length = 0;
        this.entries.forEach(entry => {
            entry.webglVertices = null;
            if (entry.plotType === 'parametric') {
                entry.cachedPoints = [];
            }
        });
    }
    updateGeometryMeasurementDisplay() {
    const displayContainer = document.getElementById('geometry-measurement-display');
    if (!displayContainer) return;

    if (!this.geometryMeasurementDisplayEnabled) {
        displayContainer.innerHTML = '';
        displayContainer.style.display = 'none';
        return;
    }

    const measurementEntries = this.entries.filter(e =>
        e.type === 'geometry' &&
        ['length', 'angle', 'area', 'isparallel', 'isperpendicular', 'isconcyclic'].includes(e.geometryType) &&
        e.isMeaningful &&
        e.visible
    );

    if (measurementEntries.length === 0) {
        displayContainer.innerHTML = '';
        displayContainer.style.display = 'none';
        return;
    }

    displayContainer.style.display = 'block';
    displayContainer.innerHTML = measurementEntries
        .map(entry => `<div>${entry.detailsString || ''}</div>`)
        .join('');
}


         updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const sidebar = this.sidebar;
            const sidebarBg = document.getElementById('sidebar-background');

            sidebar.style.width = '';
            sidebar.style.height = '';
            sidebarBg.style.width = '';
            sidebarBg.style.height = '';
            sidebar.style.top = '';
            sidebarBg.style.top = '';

            this.isPortraitMode = w / h < 0.75;
            document.body.classList.toggle('portrait-mode', this.isPortraitMode);

            const infoModes = ['settings', 'file', 'about'];

            if (this.isPortraitMode) {
                sidebar.classList.add('fullscreen');
                sidebarBg.classList.add('fullscreen');
                if (this.currentUIMode === 'plot' || this.currentUIMode === 'geometry') {
                    sidebar.style.height = '50vh';
                    sidebarBg.style.height = '50vh';
                    sidebar.style.top = 'auto';
                    sidebarBg.style.top = 'auto';
                }
            } else {
                if (infoModes.includes(this.currentUIMode)) {
                    sidebar.classList.add('fullscreen');
                    sidebarBg.classList.add('fullscreen');
                } else {
                    sidebar.classList.remove('fullscreen');
                    sidebarBg.classList.remove('fullscreen');
                }
            }
            
if (!this.isPortraitMode) {
                document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
                document.getElementById('keyboard-toggle-container').classList.remove('hidden-by-nav');
                const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
                if (portraitBtn) {
                    portraitBtn.classList.remove('active');
                    portraitBtn.style.display = '';
                }
            }
            this.sidebar.style.cursor = 'default';
            document.body.style.cursor = 'default';
            this.updateOverlayPositions();
const topMask = document.getElementById('top-blur-mask');
        if (topMask) {
           
            const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
            const isMainMode = ['plot', 'geometry', 'code'].includes(this.currentUIMode);
            
            if (isSidebarVisible && !isMainMode && !this.isPortraitMode) {
                topMask.classList.add('hidden');
            } else {
                topMask.classList.remove('hidden');
            }
        }
            this.clearPlotData();
            this.updateCanvasPosition();
            this.updateTopBarLayout();
        }

updateTopBarLayout() {
        const fileName = document.getElementById('file-name-display');
        const resetViewBtn = document.getElementById('reset-view-btn'); 
        const viewToggle = document.getElementById('view-mode-toggle-circle');
        const stageToggle = document.getElementById('stage-mode-toggle-btn');
        const annoSplitBtn = document.getElementById('annotation-split-btn');
        const stopTraceBtn = document.getElementById('stop-trace-btn');
        const sidebarBg = document.getElementById('sidebar-background');

        const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
        const mode = this.currentUIMode;

        if (isSidebarVisible && sidebarBg && !this.isPortraitMode && ['plot', 'geometry', 'code'].includes(mode)) {
            const rect = sidebarBg.getBoundingClientRect();
            this.lastValidSidebarRight = rect.right;
        }

        if (fileName) {
            const showTitle = isSidebarVisible && ['plot', 'geometry', 'code'].includes(mode);
            fileName.style.display = showTitle ? 'block' : 'none';

            if (showTitle && sidebarBg) {
                if (this.isPortraitMode) {
                    fileName.style.left = '20px';
                } else {
                    fileName.style.left = '430px';
                }
            }
        }


        const baseRight = 15;
        const gap = 10;
        const circleBtnWidth = 36;
        const splitBtnWidth = 100; 


        const showAnnoBtn = !this.is3DMode && ['plot', 'geometry'].includes(mode);
        

        let currentRight = baseRight;


        if (annoSplitBtn) {
            if (showAnnoBtn) {
                annoSplitBtn.style.display = 'flex';
                annoSplitBtn.style.right = `${baseRight}px`;

                requestAnimationFrame(() => {
                    annoSplitBtn.style.opacity = '1';
                    annoSplitBtn.style.visibility = 'visible';
                });

                currentRight += splitBtnWidth + gap;
            } else {
                annoSplitBtn.style.opacity = '0';
                annoSplitBtn.style.visibility = 'hidden';
                setTimeout(() => {
                    if (annoSplitBtn.style.opacity === '0') {
                        annoSplitBtn.style.display = 'none';
                    }
                }, 300);

            }
        }


        if (resetViewBtn) {

            const showReset = isSidebarVisible && ['plot', 'geometry'].includes(mode);
            
            if (showReset) {
                resetViewBtn.style.display = 'flex';
                resetViewBtn.style.right = `${currentRight}px`; 
                resetViewBtn.style.zIndex = '101';
                setTimeout(() => {
                    resetViewBtn.style.opacity = '1';
                    resetViewBtn.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                resetViewBtn.style.display = 'none';
            }
        }

        if (viewToggle) {
            const showToggle = isSidebarVisible && ['plot', 'geometry'].includes(mode);
            if (showToggle) {
                viewToggle.style.display = 'flex';
                viewToggle.style.right = `${currentRight}px`; 
                setTimeout(() => {
                    viewToggle.style.opacity = '1';
                    viewToggle.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                viewToggle.style.display = 'none';
            }
        }

        if (stageToggle) {
            const showStageBtn = isSidebarVisible && ['plot', 'geometry'].includes(mode) && !this.isPortraitMode;
            if (showStageBtn) {
                stageToggle.style.display = 'flex';
                stageToggle.style.right = `${currentRight}px`; 
                setTimeout(() => {
                    stageToggle.style.opacity = '1';
                    stageToggle.style.visibility = 'visible';
                }, 10);
                currentRight += circleBtnWidth + gap;
            } else {
                stageToggle.style.opacity = '0';
                stageToggle.style.visibility = 'hidden';
                setTimeout(() => {
                    if (stageToggle.style.opacity === '0') {
                        stageToggle.style.display = 'none';
                    }
                }, 300);
            }
        }

        if (stopTraceBtn && this.traceState.active) {
            stopTraceBtn.style.right = `${currentRight}px`;
        }

if (this.categoryFilterBtn) {
    // 仅通过 display 属性控制显示/隐藏，位置完全交给 CSS Flex
    if (!this.isPortraitMode && ['plot'].includes(mode) && isSidebarVisible) {
        this.categoryFilterBtn.style.display = 'flex';
        // ！！！重要：删除之前所有设置 this.categoryFilterBtn.style.left = ... 的代码！！！
    } else {
        this.categoryFilterBtn.style.display = 'none';
    }
}  }
   
    resizeCanvas() {
        const container = this.canvasContainer;
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();

        const cssWidth = Math.max(1, rect.width);
        const cssHeight = Math.max(1, rect.height);

        if (this.canvas.width !== cssWidth * dpr || this.canvas.height !== cssHeight * dpr) {
            this.canvas.width = cssWidth * dpr;
            this.canvas.height = cssHeight * dpr;
            this.canvas.style.width = `${cssWidth}px`;
            this.canvas.style.height = `${cssHeight}px`;

            this.axisCanvas.width = cssWidth * dpr;
            this.axisCanvas.height = cssHeight * dpr;
            this.axisCanvas.style.width = `${cssWidth}px`;
            this.axisCanvas.style.height = `${cssHeight}px`;

            if (this.gl) {
                this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
            }
        }
         this.requestDraw();
    }

    updateCanvasPosition() {
        const isSidebarHidden = document.body.classList.contains('sidebar-hidden');
        const isPortrait = this.isPortraitMode;
        const sidebarBg = document.getElementById('sidebar-background');

        if (this.isTransparencyEnabled || isSidebarHidden || isPortrait || !sidebarBg) {
            this.canvasContainer.style.left = '0px';
            this.canvasContainer.style.width = '100%';
        } else {
            const sidebarRect = sidebarBg.getBoundingClientRect();
            this.canvasContainer.style.left = `${sidebarRect.right}px`;
            this.canvasContainer.style.width = `${window.innerWidth - sidebarRect.right}px`;
        }
        this.resizeCanvas();
    }

    centerCanvas() {
        const cssWidth = this.canvas.clientWidth;
        const cssHeight = this.canvas.clientHeight;
        if (cssWidth > 0 && cssHeight > 0) {
            this.offset.x = cssWidth / 2;
            this.offset.y = cssHeight / 2;
        }
        this.clearPlotData();
    }


     setupEventListeners() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            archInstance.updateLayout();
        }, 100);
    });

    this.canvas.addEventListener('mousedown', e => this.handleInteractionStart(e));
    window.addEventListener('mousemove', e => this.handleInteractionMove(e));
    window.addEventListener('mouseup', e => this.handleInteractionEnd(e));
    this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    this.canvas.addEventListener('wheel', e => this.onZoom(e), { passive: false });
    this.canvas.addEventListener('touchstart', e => this.handleInteractionStart(e), { passive: false });
    this.canvas.addEventListener('touchmove', e => this.handleInteractionMove(e), { passive: false });
    this.canvas.addEventListener('touchend', e => this.handleInteractionEnd(e));
    this.canvas.addEventListener('touchcancel', e => this.handleInteractionEnd(e));
    this.sidebar.addEventListener('mousedown', e => this.startSidebarResize(e));
    this.sidebar.addEventListener('touchstart', e => this.startSidebarResizeTouch(e), { passive: false });
    window.addEventListener('mousemove', e => {
        if (this.isResizingSidebar) this.doSidebarResize(e);
        else this.updateSidebarCursor(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', () => this.stopSidebarResize());
    window.addEventListener('touchmove', e => { if (this.isResizingSidebarTouch) this.doSidebarResizeTouch(e); }, { passive: false });
    window.addEventListener('touchend', () => this.stopSidebarResizeTouch());
    window.addEventListener('touchcancel', () => this.stopSidebarResizeTouch());
    this.sidebar.addEventListener('mouseleave', () => { if (!this.isResizingSidebar) this.sidebar.style.cursor = 'default'; });
    this.entryList.addEventListener('click', e => this.handleEntryListClick(e));

    this.preferredColorSlider = new CustomSlider('preferred-color-slider-container', { min: 0, max: 100, step: 1, value: this.preferredColorValue, type: 'hue', onInput: e => { this.preferredColorValue = e.target.options.value; this.updatePreferredColorValueLabel(); this.applyThemeColors(); }});
    this.explicitPrecisionSlider = new CustomSlider('explicit-precision-slider-container', { min: 0.5, max: 20, step: 0.1, value: this.explicitPrecisionStep, type: 'default', onInput: e => { this.explicitPrecisionStep = e.target.options.value; if (!this.isZooming || !this.performanceModeEnabled) this.originalExplicitPrecision = this.explicitPrecisionStep; this.updatePrecisionLabels(); this.clearPlotData(); this.requestDraw(); }});
    this.implicitPrecisionSlider = new CustomSlider('implicit-precision-slider-container', { min: 0.5, max: 20, step: 0.1, value: 20 / this.implicitPrecisionStep, type: 'default', onInput: e => { this.implicitPrecisionStep = 20 / e.target.options.value; if (!this.isZooming || !this.performanceModeEnabled) this.originalImplicitPrecision = this.implicitPrecisionStep; this.updatePrecisionLabels(); this.clearPlotData(); this.requestDraw(); }});
    this.integralPrecisionSlider = new CustomSlider('integral-precision-slider-container', { min: 10, max: 1000, step: 10, value: this.integralNumSteps, type: 'default', onInput: e => { this.integralNumSteps = e.target.options.value; this.updateIntegralPrecisionLabel(); }, onChange: () => this.recalculateAll() });

    this.explicitPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.explicitPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.implicitPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.implicitPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.integralPrecisionValueSpan.addEventListener('click', () => { 
        const slider = this.integralPrecisionSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = this._parseOrEvaluateInput(valStr); 
                if (newValue !== null) { 
                    if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                        slider.setValue(newValue, true); 
                    } else { 
                        alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                    } 
                } 
            }); 
        } 
    });
    this.preferredColorValueSpan.addEventListener('click', () => { 
        const slider = this.preferredColorSlider; 
        const { min, max } = slider.options; 
        if(window.globalOpenKeyboardForValue){ 
            window.globalOpenKeyboardForValue(slider.options.value, (valStr) => { 
                const newValue = parseFloat(valStr); 
                if (Number.isFinite(newValue) && newValue >= min && newValue <= max) { 
                    slider.setValue(newValue, true); 
                } else { 
                    alert(`无效值. 请输入一个在 ${min} 和 ${max} 之间的数字。`); 
                } 
            }); 
        } 
    });


    
    document.getElementById('dark-mode-toggle').addEventListener('change', e => this.applyDarkMode(e.target.checked));
    document.getElementById('window-transparency-toggle').addEventListener('change', e => this.applyTransparency(e.target.checked));
    document.getElementById('color-inversion-toggle').addEventListener('change', e => { this.colorInversionEnabled = e.target.checked; this.requestDraw(); });
    this.overlayDrawingToggle.addEventListener('change', e => { 
        this.overlayDrawingEnabled = e.target.checked; 
        this.clearPlotData(); 
        this.recalculateAll();
        this.requestDraw(); 
    });
        this.performanceModeToggle = document.getElementById('performance-mode-toggle');
    if (this.performanceModeToggle) {
        this.performanceModeToggle.checked = this.performanceModeEnabled;
        this.performanceModeToggle.addEventListener('change', e => { 
            this.performanceModeEnabled = e.target.checked; 
            if (!this.performanceModeEnabled && this.isZooming) { 
                this.restoreOriginalPrecisions(); 
                this.isZooming = false; 
                this.clearPlotData(); 
                this.recalculateAll(); 
            } 
        });
    }

    this.lowPrecisionBufferToggle.addEventListener('change', e => { this.lowPrecisionBufferEnabled = e.target.checked; });
    this.highPerformancePlottingToggle.addEventListener('change', e => { this.highPerformancePlottingEnabled = e.target.checked; this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2; this.clearPlotData(); this.requestDraw(); });
    this.tminValueSpan.addEventListener('click', () => this.promptEditParametricRange('tmin'));
    this.tmaxValueSpan.addEventListener('click', () => this.promptEditParametricRange('tmax'));
    document.getElementById('show-axes-toggle').addEventListener('change', e => { this.showAxes = e.target.checked; this.requestDraw(); });
    document.getElementById('show-axis-numbers-toggle').addEventListener('change', e => { this.showAxisNumbers = e.target.checked; this.requestDraw(); });
    document.getElementById('grid-style-buttons').addEventListener('click', e => { const btn = e.target.closest('button'); if(btn){ this.gridStyle = btn.dataset.style; document.querySelectorAll('#grid-style-buttons button').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); this.requestDraw(); }});
    document.getElementById('show-point-labels-toggle').addEventListener('change', e => { this.showPointLabels = e.target.checked; this.requestDraw(); });
    document.getElementById('show-hidden-math-toggle').addEventListener('change', e => { this.showHiddenMath = e.target.checked; this.requestDraw(); });
    document.getElementById('show-hidden-geo-toggle').addEventListener('change', e => { this.showHiddenGeo = e.target.checked; this.requestDraw(); });
    this.autoBreakpointDetectionToggle.addEventListener('change', e => { this.autoBreakpointDetectionEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
        this.adaptiveExtendToggle.addEventListener('change', e => { this.adaptiveExtendEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
    this.geometrySnapToggle.addEventListener('change', e => { this.geometrySnapEnabled = e.target.checked; });
    this.adaptivePlottingToggle.addEventListener('change', e => { this.adaptivePlottingEnabled = e.target.checked; this.clearPlotData(); this.requestDraw(); });
    this.geometryMeasurementDisplayToggle.addEventListener('change', e => { this.geometryMeasurementDisplayEnabled = e.target.checked; this.updateGeometryMeasurementDisplay(); });
    this.smoothPanningToggle.addEventListener('change', e => { this.smoothPanningEnabled = e.target.checked; if (!this.smoothPanningEnabled && this.isSmoothPanningActive) { this.isSmoothPanningActive = false; this.finalizePanInteraction(); }});

    document.getElementById('load-js-op-btn').addEventListener('click', () => this.loadJsOperator());
    document.getElementById('code-new-btn').addEventListener('click', () => this.showCodeEditor(-1));
    document.getElementById('code-upload-btn').addEventListener('click', () => this.loadJsOperator());
    document.getElementById('code-add-btn').addEventListener('click', () => this.saveCodeFromEditor());
    document.getElementById('code-download-btn').addEventListener('click', () => this.downloadCodeFromEditor());
    document.getElementById('code-editor-exit-btn').addEventListener('click', () => this.hideCodeEditor());
    document.getElementById('code-entry-list').addEventListener('click', e => this.handleCodeListClick(e));
    
    
    document.getElementById('annotation-exit-btn').addEventListener('click', () => this.exitAnnotationMode());
    document.getElementById('annotation-pen-btn').addEventListener('click', () => this.setAnnotationMode('pen'));
    document.getElementById('annotation-text-btn').addEventListener('click', () => this.setAnnotationMode('text'));
    document.getElementById('annotation-image-btn').addEventListener('click', () => this.setAnnotationMode('image'));
document.getElementById('annotation-pdf-btn').addEventListener('click', () => this.setAnnotationMode('pdf'));
 document.getElementById('annotation-audio-btn').addEventListener('click', () => this.setAnnotationMode('audio'));
    document.getElementById('annotation-eraser-btn').addEventListener('click', () => this.setAnnotationMode('eraser'));
    
    const stopTraceBtn = document.getElementById('stop-trace-btn');
    const handleStopTrace = (e) => {
        if (e.type === 'touchstart') e.preventDefault();
        this.stopTracing();
    };
    stopTraceBtn.addEventListener('click', handleStopTrace);
    stopTraceBtn.addEventListener('touchstart', handleStopTrace, { passive: false });

    this.canvas.addEventListener('mousemove', (e) => {
        if (this.currentUIMode === 'annotation' && this.annotationState.mode === 'eraser') {
            const coords = this.getEventCoordinates(e);
            this.requestDraw();
        }
    });


    document.addEventListener('keydown', (e) => {
        if (e.key === 'Backspace' && this.selectedAnnotationIndex !== -1) {
            e.preventDefault();
            this.annotations.splice(this.selectedAnnotationIndex, 1);
            this.selectedAnnotationIndex = -1;
            this.requestDraw();
        }
    });
    
    
    
    this.geometryPanel.addEventListener('click', e => {
        const button = e.target.closest('.geo-btn');
        if (button) this.handleGeometryButtonClick(button.dataset.geoType);
    });




    const settingsPanel = document.getElementById('settings-panel');
    if (settingsPanel) {
        settingsPanel.addEventListener('click', e => {
            const navBtn = e.target.closest('.settings-nav-btn');
            if (navBtn && navBtn.parentElement.classList.contains('settings-nav-buttons')) {
                const panelId = navBtn.dataset.panel;
                if (!panelId) return;

                settingsPanel.querySelectorAll('.settings-nav-btn').forEach(btn => btn.classList.remove('active'));
                settingsPanel.querySelectorAll('.settings-panel-content').forEach(panel => panel.classList.remove('active'));
                
                navBtn.classList.add('active');
                const contentPanel = document.getElementById(`settings-panel-${panelId}`);
                if (contentPanel) {
                    contentPanel.classList.add('active');
                }
            }
        });
    }
}



    _parseOrEvaluateInput(inputString) {
        if (inputString === null) return null;
        const trimmedInput = inputString.trim();
        if (trimmedInput === "") return null;

        if (this.calcJSUtils.isNumericString(trimmedInput)) {
            return parseFloat(trimmedInput);
        } else {
            try {
                const result = this.evaluateExpressionWithCalcJS(trimmedInput, {});
                if (Number.isFinite(result)) {
                    return result;
                } else {
                    alert(`表达式 "${trimmedInput}" 的计算结果无效 (NaN or Infinity)。`);
                    return null;
                }
            } catch (e) {
                alert(`计算表达式 "${trimmedInput}" 时出错: ${e.message}`);
                return null;
            }
        }
    }

_rebindAnnotationControlsToGlobalState() {
    const rebindColorSlider = (slider, prop) => {
        if (!slider) return;
        slider.options.context = this.annotationState.pen.color;
        slider.setValue(this.annotationState.pen.color[prop]);
        slider.options.onInput = (e) => {
            this.annotationState.pen.color[prop] = e.target.options.value;
            Object.values(this.penColorSliders).forEach(s => {
                s.options.context = this.annotationState.pen.color;
                s.draw();
            });
        };
        slider.draw();
    };

    if (this.penColorSliders.h) rebindColorSlider(this.penColorSliders.h, 'h');
    if (this.penColorSliders.s) rebindColorSlider(this.penColorSliders.s, 's');
    if (this.penColorSliders.b) rebindColorSlider(this.penColorSliders.b, 'b');
    if (this.penColorSliders.a) rebindColorSlider(this.penColorSliders.a, 'a');

    if (this.penThicknessSlider) {
        this.penThicknessSlider.setValue(this.annotationState.pen.thickness);
        this.penThicknessSlider.options.onInput = (e) => {
            this.annotationState.pen.thickness = e.target.options.value;
            this.requestDraw();
        };
        this.penThicknessSlider.draw();
    }

    if (this.penFontSizeSlider) {
        this.penFontSizeSlider.setValue(this.annotationState.pen.fontSize);
        this.penFontSizeSlider.options.onInput = (e) => {
            this.annotationState.pen.fontSize = e.target.options.value;
        };
        this.penFontSizeSlider.draw();
    }

    const exitBtn = document.getElementById('annotation-exit-btn');
    if (exitBtn) {
        exitBtn.onclick = () => {
            if (this.currentUIMode === 'annotation') {
                this.exitAnnotationMode();
            } else {
                this.selectedAnnotationIndex = -1;
                // 退出编辑模式时，恢复到批注模式的UI状态（可能会折叠）
                if (this.annotationColorBtn) {
                    this.annotationColorBtn.style.display = 'flex';
                }
                this.updateAnnotationEditMenu();
                this.requestDraw();
            }
        };
    }
}
 
    updateSidebarCursor(clientX, clientY) {
        const rect = this.sidebar.getBoundingClientRect();
        let onResizeHandle = false;

        if (this.isPortraitMode) {
             onResizeHandle = clientY <= rect.top + this.resizeHandleWidth && clientY >= rect.top - 3;
        } else {
             onResizeHandle = clientX >= rect.right - this.resizeHandleWidth && clientX <= rect.right + 3;
        }


         if (onResizeHandle) {
             this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
         } else {
              const isOverSidebar = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
              if (isOverSidebar) {
                   this.sidebar.style.cursor = 'default';
              } else {
                    this.sidebar.style.cursor = 'default';
              }
         }
    }


    getEventCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
        } else {
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
    }

    getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    autonameText() {
        let i = 1;
        while (true) {
            const textName = 'text' + i;
            const isNameTaken = this.entries.some(entry =>
                entry.type === 'text' && entry.name === textName
            );

            if (!isNameTaken) {
                return textName;
            }
            i++;
            if (i > 10000) {
                return 'text_error_' + Date.now();
            }
        }
    }
    getPinchCenter(touches) {
        const rect = this.canvas.getBoundingClientRect();
        const x1 = touches[0].clientX - rect.left;
        const y1 = touches[0].clientY - rect.top;
        const x2 = touches[1].clientX - rect.left;
        const y2 = touches[1].clientY - rect.top;
        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
    }

startPerformanceZoom() {
        if (!this.isZooming) {
            this.originalExplicitPrecision = this.explicitPrecisionStep;
            this.originalImplicitPrecision = this.implicitPrecisionStep;
        }
        this.isZooming = true;

        this.explicitPrecisionStep = 0.5;
        this.implicitPrecisionStep = (this.originalImplicitPrecision < 4) ? 7 : 10;


        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep);
        this.updatePrecisionLabels();
    }
restoreOriginalPrecisions() {
        this.explicitPrecisionStep = this.originalExplicitPrecision;
        this.implicitPrecisionStep = this.originalImplicitPrecision;


        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep);
        this.updatePrecisionLabels();
    }

       handleZoomEnd() {
        if (this.isZooming) {
            this.isTransformingCache = false;
            
            this.clearPlotData();
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);

            this.restoreOriginalPrecisions();
            this.isZooming = false;
            this.isUsingLowPrecisionBuffer = false;
            this.entries.forEach(entry => {
                if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                    entry.webglVertices = null;
                }
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            });
            this.clearPlotData();
            this.recalculateAll();
        }
    }
 handleInteractionStart(e) {
        // 1. 3D 模式优先处理
        if (this.is3DMode) {
            this.stopAllAudio();
            if (e.target !== this.canvas && !e.target.closest('#canvas-container')) return;
            if (e.cancelable) e.preventDefault();

            const coords = this.getEventCoordinates(e);
            this.lastMouse3D = coords;

            if (e.touches && e.touches.length === 2) {
                this.isDragging3D = true;
                this.dragMode3D = 'pinch';
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                this.pinchStartDist3D = Math.sqrt(dx * dx + dy * dy);
                this.pinchStartScale3D = this.scale3D;
                return;
            }

            this.isDragging3D = true;

            const hit = this.getRayPlaneIntersection(coords.x, coords.y);
            const b = this.bounds3D;

            if (hit && Math.abs(hit.x) <= b && Math.abs(hit.y) <= b) {
                this.dragMode3D = 'pan';
                this.panStartHit3D = hit;
                this.panStartOffset3D = { ...this.offset3D };
                this.canvas.style.cursor = 'move';
            } else {
                this.dragMode3D = 'rotate';
                this.canvas.style.cursor = 'grabbing';
            }
            return;
        }

        // 2. 复选框交互 (最高优先级：必须在任何其他 2D 交互之前)
        // 这样可以确保开关点击不会被底层的画布拖动或通用批注选中逻辑覆盖
        const coords = this.getEventCoordinates(e);
        
        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const anno = this.annotations[i];
            if (anno.type === 'checkbox') {
                const screenX = this.offset.x + anno.x * this.scale;
                const screenY = this.offset.y - anno.y * this.scale;
                // 使用固定像素尺寸进行判定，与绘制逻辑一致
                const width = 160; 
                const height = 40;

                // 简单的 AABB 碰撞检测
                if (coords.x >= screenX && coords.x <= screenX + width &&
                    coords.y >= screenY && coords.y <= screenY + height) {
                    
                    // 定义右侧开关区域的宽度 (大约 60px)
                    const switchClickAreaWidth = 60;
                    const switchInteractionX = screenX + width - switchClickAreaWidth;

                    if (coords.x >= switchInteractionX) {
 

                        anno.checked = !anno.checked;
                        this.requestDraw(); // 重绘以更新视觉和受控对象的可见性
                        if (e.cancelable) e.preventDefault();
                        return; // 立即返回，阻止所有后续逻辑
                    } else {
                        // --- 情况 B: 点击了左侧标题区域 ---
                        if (this.isAnnotationEditingEnabled) {
                            // 如果开启了编辑模式 -> 触发移动
                            this.selectedAnnotationIndex = i;
                            this.annotationInteraction = {
                                type: 'move',
                                startX: coords.x,
                                startY: coords.y,
                                original: { x: anno.x, y: anno.y }
                            };
                            this.updateAnnotationEditMenu();
                            this.requestDraw();
                            if (e.cancelable) e.preventDefault();
                            return; // 阻止后续逻辑
                        } else {
                            // 如果未开启编辑模式 -> 吞掉事件，防止拖动画布
                            if (e.cancelable) e.preventDefault();
                            return; 
                        }
                    }
                }
            }
        }

        // 3. 批注绘制模式处理 (画笔/文字/橡皮等)
        if (this.currentUIMode === 'annotation') {
            this.handleAnnotationInteractionStart(e);
            return;
        }

        if (this.currentUIMode === 'geometry' || this.currentUIMode === 'plot') {
            const clickCoords = this.getEventCoordinates(e);
            
            // 变量卡片交互
            const clickX = clickCoords.x;
            const clickY = clickCoords.y;
            for (let i = this.entries.length - 1; i >= 0; i--) {
                const entry = this.entries[i];
                if (entry.type === 'variable' && entry.isEditableIndependent && entry.showOnPlot) {
                    const x = this.offset.x + entry.cardX * this.scale;
                    const y = this.offset.y - entry.cardY * this.scale;
                    const w = entry.cardW;
                    const h = entry.cardH;

                    if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
                        const btnX = x + w - 15 - 16;
                        const btnY = y + 15 + 16; 
                        if (Math.hypot(clickX - btnX, clickY - btnY) <= 20) {
                            this.variableCardInteraction = { active: true, entryIndex: i, type: 'play' };
                            entry.playState = entry.playState === 1 ? 0 : 1;
                            if (entry.playState === 1) this.recalculateAll();
                            this.updateGlobalPlayState();
                            this.updateEntryList();
                            this.requestDraw();
                            if (e.cancelable) e.preventDefault();
                            return;
                        }

                        const sliderY = y + 65; 
                        const sliderH = 20; 
                        if (clickY >= sliderY - 10 && clickY <= sliderY + sliderH + 10 && clickX >= x + 15 && clickX <= x + w - 15) {
                            this.variableCardInteraction = { active: true, entryIndex: i, type: 'slider', offset: { x: clickX - x }, startVal: entry.value };
                            this.handleInteractionMove(e);
                            if (e.cancelable) e.preventDefault();
                            return;
                        }

                        this.variableCardInteraction = { active: true, entryIndex: i, type: 'move', offset: { x: clickX - x, y: clickY - y } };
                        if (e.cancelable) e.preventDefault();
                        return;
                    }
                }
            }
            
            // 批注编辑模式下的常规对象选择
            if (this.isAnnotationEditingEnabled) {
                const coordsForSelection = this.getEventCoordinates(e);

                // 处理 PDF/Audio 的特定按钮点击
                if (this.selectedAnnotationIndex !== -1) {
                    const anno = this.annotations[this.selectedAnnotationIndex];
                    if (anno.type !== 'checkbox') { // 跳过 checkbox，上面已处理
                        const screenX = this.offset.x + anno.x * this.scale;
                        const screenY = this.offset.y - anno.y * this.scale;
                        const width = anno.width * anno.scaleX * this.scale;
                        const height = anno.height * anno.scaleY * this.scale;
                        const topY = (anno.type === 'pen' || anno.type === 'text') ? screenY - height : screenY;
                        const bottomY = topY + height;

                        if (anno.type === 'pdf') {
                            const btnSize = 36;
                            const prevX = screenX + width / 2 - 40;
                            const nextX = screenX + width / 2 + 10;
                            const btnY = bottomY + 25; 
                            
                            const distPrev = Math.hypot(coordsForSelection.x - (prevX + btnSize/2), coordsForSelection.y - btnY);
                            const distNext = Math.hypot(coordsForSelection.x - (nextX + btnSize/2), coordsForSelection.y - btnY);
                            const radius = btnSize / 2 + 5; 

                            if (distPrev <= radius) {
                                if (anno.page > 1) {
                                    anno.page--;
                                    this.renderPdfPage(anno);
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                            if (distNext <= radius) {
                                if (anno.page < anno.totalPages) {
                                    anno.page++;
                                    this.renderPdfPage(anno);
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                        } else if (anno.type === 'audio') {
                            const controlsY = bottomY + 20; 
                            const playSize = 24;
                            const playX = screenX + playSize/2;
                            const playRadius = 12 + 5; 

                            if (Math.hypot(coordsForSelection.x - playX, coordsForSelection.y - controlsY) <= playRadius) {
                                if (anno.audioElem.paused) {
                                    anno.audioElem.play();
                                    anno.isPlaying = true;
                                } else {
                                    anno.audioElem.pause();
                                    anno.isPlaying = false;
                                }
                                this.requestDraw();
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                            
                            const barX = playX + 20;
                            const barY = controlsY - 4;
                            const barW = Math.max(120, width - 30);
                            const barH = 8;
                            const barHitPadding = 10;
                            
                            if (coordsForSelection.x >= barX - barHitPadding && 
                                coordsForSelection.x <= barX + barW + barHitPadding &&
                                coordsForSelection.y >= barY - barHitPadding && 
                                coordsForSelection.y <= barY + barH + barHitPadding) {
                                
                                const ratio = Math.max(0, Math.min(1, (coordsForSelection.x - barX) / barW));
                                if (anno.audioElem.duration) {
                                    anno.audioElem.currentTime = ratio * anno.audioElem.duration;
                                    this.requestDraw();
                                }
                                if(e.cancelable) e.preventDefault();
                                return;
                            }
                        }
                    }
                }

                // 查找其他类型的批注
                const hitResult = this.findAnnotationAt(coordsForSelection);
                if (hitResult.index !== -1) {
                    // 如果点到了非 checkbox 的其他批注
                    const selectedAnno = this.annotations[hitResult.index];
                    if (selectedAnno.type !== 'checkbox') {
                         this.selectedAnnotationIndex = hitResult.index;
                        if (selectedAnno.type === 'text' || selectedAnno.type === 'pen') {
                            this.isAnnotationMenuExpanded = false;
                        } else {
                            this.isAnnotationMenuExpanded = true;
                        }

                        this.annotationInteraction.type = hitResult.handle || 'move';
                        this.annotationInteraction.startX = coordsForSelection.x;
                        this.annotationInteraction.startY = coordsForSelection.y;
                        
                        this.annotationInteraction.original = {
                            x: selectedAnno.x,
                            y: selectedAnno.y,
                            width: selectedAnno.width,
                            height: selectedAnno.height,
                            scaleX: selectedAnno.scaleX || 1,
                            scaleY: selectedAnno.scaleY || 1
                        };
                        
                        this.requestDraw();
                        if (e.cancelable) e.preventDefault();
                        this.updateAnnotationEditMenu();
                        return;
                    }
                } else if (this.selectedAnnotationIndex !== -1) {
                    // 点击空白处取消选中
                    this.selectedAnnotationIndex = -1;
                    this._rebindAnnotationControlsToGlobalState();
                    this.requestDraw();
                    this.updateAnnotationEditMenu();
                }
            }
        }

        // 5. 阻止事件冒泡到 UI 元素
        if (e.target.closest('#annotation-edit-toggle-container') || e.target.closest('#main-menu') || e.target.closest('#main-button-container') || e.target.closest('#keyboard') || e.target.closest('#keyboard-toggle-container') || this.isResizingSidebar || this.isResizingSidebarTouch || (e.target !== this.canvas && !e.target.closest('#canvas-container') && !e.target.closest('#fps-display'))) {
            return;
        }

        // 6. 几何交互 (点击创建点等)
        if (this.geometryInteractionState.active) {
            if (e.target === this.canvas) {
                if (e.type === 'mousedown') {
                    this.handleGeometryClick(e);
                } else if (e.type === 'touchstart') {
                    this.touchMoved = false;
                    this.touchStartPos = this.getEventCoordinates(e);
                    if (e.cancelable) e.preventDefault();
                }
            }
            return;
        }

        // 7. 几何点拖动逻辑
        const eventType = e.type;

        const hitRadius = (eventType === 'touchstart') ? this.dragHitboxRadiusTouch : this.dragHitboxRadiusMouse;

        for (let i = this.entries.length - 1; i >= 0; i--) {
            const entry = this.entries[i];
            if (entry.type === 'geometry' && entry.geometryType === 'point' && entry.isMeaningful && entry.visible) {
                const isDraggable = (entry.pointOnObject) ||
                    (entry.x_expr && this.calcJSUtils.isNumericString(entry.x_expr) &&
                        entry.y_expr && this.calcJSUtils.isNumericString(entry.y_expr));

                if (isDraggable) {
                    const pointScreenX = this.offset.x + entry.x_val * this.scale;
                    const pointScreenY = this.offset.y - entry.y_val * this.scale;
                    const dist = Math.sqrt((coords.x - pointScreenX) ** 2 + (coords.y - pointScreenY) ** 2);
                    if (dist <= hitRadius) {
                        this.selectedPointIndex = i;
                        this.draggingPoint = true;
                        this.canvas.style.cursor = 'move';
                        entry.isSelected = true;
                        this.requestDraw();
                        if (e.cancelable) e.preventDefault();
                        if (eventType === 'touchstart') {
                            this.touchMoved = false;
                            this.touchStartPos = this.getEventCoordinates(e);
                        }
                        return;
                    }
                }
            }
        }

        // 8. 平移和缩放逻辑
        clearTimeout(this.zoomEndTimeout);

        if (this.isSmoothPanningActive) {
            this.isSmoothPanningActive = false;
        }

        if (eventType === 'touchstart') {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length === 1 && !this.touchState.pinching) {
                this.interactionWasPinch = false;
                this.isPanning = true;
                this.touchState.panning = true;
                this.touchState.lastPanPos = this.getEventCoordinates(e);
                this.canvas.style.cursor = 'grabbing';
                this.panEventHistory = [];
                this.panEventHistory.push({ x: this.touchState.lastPanPos.x, y: this.touchState.lastPanPos.y, time: performance.now() });
                this.lastPanEventTime = performance.now();
                this.startPanOptimization();
            } else if (e.touches.length === 2) {
                this.interactionWasPinch = true;
                this.isPanning = false;
                this.touchState.panning = false;
                this.touchState.pinching = true;
                this.zoomEventHistory = [];
                if (this.performanceModeEnabled) {
                    this.captureCanvasStateForTransform();
                    this.startPerformanceZoom();
                } else {
                    this.entries.forEach(entry => {
                        if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    });
                    this.clearPlotData();
                }
                this.touchState.initialPinchDist = this.getPinchDistance(e.touches);
                this.touchState.initialPinch.center = this.getPinchCenter(e.touches);
                this.touchState.initialPinch.scale = this.scale;
                this.touchState.initialPinch.offset = { ...this.offset };
                this.canvas.style.cursor = 'move';
            }
        } else if (eventType === 'mousedown') {
            if (e.button !== 0) return;
            if (e.target !== this.canvas) return;
            this.interactionWasPinch = false;
            this.mouseMoved = false;
            this.isPanning = true;
            this.dragging = true;
            this.lastPos = this.getEventCoordinates(e);
            this.canvas.style.cursor = 'grabbing';
            this.panEventHistory = [];
            this.panEventHistory.push({ x: this.lastPos.x, y: this.lastPos.y, time: performance.now() });
            this.lastPanEventTime = performance.now();
            this.startPanOptimization();
        }
    } 
    handleInteractionMove(e) {
        if (this.is3DMode) {
            if (this.isDragging3D) {
                if(e.cancelable) e.preventDefault();
                
                if (this.dragMode3D === 'pinch' && e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (this.pinchStartDist3D > 0) {
                        const scaleFactor = dist / this.pinchStartDist3D;
                
                        this.scale3D = this.pinchStartScale3D / scaleFactor;
                        
                        if (this.scale3D < 0.01) this.scale3D = 0.01;
                        if (this.scale3D > 100.0) this.scale3D = 100.0;
                        this.recalculate3D();
                        this.requestDraw();
                    }
                    return;
                }

                const coords = this.getEventCoordinates(e);
                const dx = coords.x - this.lastMouse3D.x;
                const dy = coords.y - this.lastMouse3D.y;
                this.lastMouse3D = coords;

                if (this.dragMode3D === 'rotate') {
                    this.camera3D.theta -= dx * 0.01;
                    this.camera3D.phi -= dy * 0.01;

                    if (this.camera3D.phi < 0.1) this.camera3D.phi = 0.1;
                    if (this.camera3D.phi > Math.PI - 0.1) this.camera3D.phi = Math.PI - 0.1;
                    this.requestDraw(); 
                } else if (this.dragMode3D === 'pan') {
                    const currentHit = this.getRayPlaneIntersection(coords.x, coords.y);
                    if (currentHit && this.panStartHit3D) {
                        
                        const deltaX = currentHit.x - this.panStartHit3D.x;
                        const deltaY = currentHit.y - this.panStartHit3D.y;
                        
                        this.offset3D.x -= deltaX;
                        this.offset3D.y -= deltaY;
                        
                        this.recalculate3D(); 

                        const newHit = this.getRayPlaneIntersection(coords.x, coords.y);
                        if (newHit) this.panStartHit3D = newHit;
                    }
                    this.requestDraw();
                }
            }
            return;
        }

        if (this.currentUIMode === 'annotation') {
            this.handleAnnotationInteractionMove(e);
            return;
        }

        if (this.annotationInteraction.type) {
            this.handleAnnotationResizeOrMove(e);
            return;
        }
        if (this.variableCardInteraction.active) {
    if (e.cancelable) e.preventDefault();
    const coords = this.getEventCoordinates(e);
    const entry = this.entries[this.variableCardInteraction.entryIndex];

if (this.variableCardInteraction.type === 'move') {
                // 计算新的屏幕坐标
                const newScreenX = coords.x - this.variableCardInteraction.offset.x;
                const newScreenY = coords.y - this.variableCardInteraction.offset.y;
                
                // 将屏幕坐标反算回数学坐标并存储
                entry.cardX = (newScreenX - this.offset.x) / this.scale;
                entry.cardY = (this.offset.y - newScreenY) / this.scale;
     } else if (this.variableCardInteraction.type === 'slider') {
                // 计算当前卡片的屏幕X坐标
                const currentScreenCardX = this.offset.x + entry.cardX * this.scale;
                
                const sliderMargin = 15;
                const sliderW = entry.cardW - sliderMargin * 2;
                // 使用计算出的屏幕坐标
                const relX = Math.max(0, Math.min(1, (coords.x - currentScreenCardX - sliderMargin) / sliderW));

        const min = Number.isFinite(entry.min) ? entry.min : 0;
        const max = Number.isFinite(entry.max) ? entry.max : 10;
        const step = Number.isFinite(entry.step) && entry.step > 0 ? entry.step : 0.01;
        let val = min + relX * (max - min);
        val = Math.round(val / step) * step;
        entry.value = val;
        entry.playDirection = 1;
        this.recalculateForAnimation();
        this.updateEntryVariableValuesDisplay();
    }
    this.requestDraw();
    return;
}
        const eventType = e.type;

         if (eventType === 'mousemove' && this.isResizingSidebar) {
              this.doSidebarResize(e);
              return;
         }
         if (eventType === 'touchmove' && this.isResizingSidebarTouch) {
              this.doSidebarResizeTouch(e);
              return;
         }
         if (eventType === 'touchmove' && (this.geometryInteractionState.active || this.draggingPoint)) {
            if (!this.touchMoved) { 
                const currentPos = this.getEventCoordinates(e);
                const dx = currentPos.x - this.touchStartPos.x;
                const dy = currentPos.y - this.touchStartPos.y;
             
                if (Math.hypot(dx, dy) > 10) {
                    this.touchMoved = true;
                }
            }
        }
 
        if (eventType === 'touchmove' && this.draggingPoint && this.touchMoved) {
            this.dragSelectedPoint(e);
            return;
        }

        if (this.draggingPoint) {
            this.dragSelectedPoint(e);
            return;
        }

        if (eventType === 'touchmove' && (this.touchState.panning || this.touchState.pinching)) {
            if(e.cancelable) e.preventDefault();

            if (this.touchState.pinching && e.touches.length === 2) {
                 clearTimeout(this.zoomEndTimeout);

                if (!this.isZooming) {
                    this.isZooming = true;
                    if (this.performanceModeEnabled) {
                        this.captureCanvasStateForTransform();
                        this.startPerformanceZoom();
                    } else if (this.lowPrecisionBufferEnabled) {
                        if (!this.isUsingLowPrecisionBuffer) {
                            this.originalExplicitPrecision = this.explicitPrecisionStep;
                            this.originalImplicitPrecision = this.implicitPrecisionStep;
                            this.isUsingLowPrecisionBuffer = true;
                        }
                        this.explicitPrecisionStep = 1;
                        this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
                        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
                        this.implicitPrecisionSlider.setValue(this.implicitPrecisionStep);
                        this.updatePrecisionLabels();
                    }
                }
                
                if (!this.performanceModeEnabled) {
                    this.clearPlotData();
                    this.entries.forEach(entry => {
                        if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                            entry.webglVertices = null;
                            if (entry.plotType === 'parametric') entry.cachedPoints = [];
                        }
                    });
                }

                this.zoomEndTimeout = setTimeout(() => this.handleZoomEnd(), 300);
                
                const currentDist = this.getPinchDistance(e.touches);
                const currentCenter = this.getPinchCenter(e.touches);

                if (this.touchState.initialPinchDist <= 0) return;

                const zoomFactor = currentDist / this.touchState.initialPinchDist;
                this.zoomEventHistory.push({ factor: zoomFactor, time: performance.now() });
                if (this.zoomEventHistory.length > 10) this.zoomEventHistory.shift();

                const initialScale = this.touchState.initialPinch.scale;
                let newScale = initialScale * zoomFactor;
                newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));

                const initialOffset = this.touchState.initialPinch.offset;
                const initialCenterMathX = (this.touchState.initialPinch.center.x - initialOffset.x) / initialScale;
                const initialCenterMathY = (initialOffset.y - this.touchState.initialPinch.center.y) / initialScale;

                this.offset.x = currentCenter.x - initialCenterMathX * newScale;
                this.offset.y = currentCenter.y + initialCenterMathY * newScale;

                this.scale = newScale;
                this.requestDraw();

            } else if (this.touchState.panning && e.touches.length === 1) {
                const currentPos = this.getEventCoordinates(e);
                this.offset.x += currentPos.x - this.touchState.lastPanPos.x;
                this.offset.y += currentPos.y - this.touchState.lastPanPos.y;
                this.touchState.lastPanPos = currentPos;
                const currentTime = performance.now();
                this.panEventHistory.push({ x: currentPos.x, y: currentPos.y, time: currentTime });
                if (this.panEventHistory.length > 10) this.panEventHistory.shift();
                this.lastPanEventTime = currentTime;

                this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') {
                            entry.cachedPoints = [];
                        }
                    }
                });
                this.requestDraw();
            }
        }
        else if (eventType === 'mousemove') {
            if (this.dragging) {
                const currentPos = this.getEventCoordinates(e);
                if (!this.mouseMoved) {
                    const dx = currentPos.x - this.lastPos.x;
                    const dy = currentPos.y - this.lastPos.y;
                    if (Math.hypot(dx, dy) > 5) {
                        this.mouseMoved = true;
                    }
                }
                this.offset.x += currentPos.x - this.lastPos.x;
                this.offset.y += currentPos.y - this.lastPos.y;
                this.lastPos = currentPos;

                const currentTime = performance.now();
                this.panEventHistory.push({ x: currentPos.x, y: currentPos.y, time: currentTime });
                if (this.panEventHistory.length > 10) this.panEventHistory.shift();
                this.lastPanEventTime = currentTime;

                this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') {
                            entry.cachedPoints = [];
                        }
                    }
                });
                this.requestDraw();
            } else {
                this.updateSidebarCursor(e.clientX, e.clientY);
            }
        }
    }

 

handleInteractionEnd(e) {
    if (this.is3DMode) {
        this.isDragging3D = false;
        this.dragMode3D = 'none';
        return;
    }

    if (this.currentUIMode === 'annotation') {
        this.handleAnnotationInteractionEnd(e);
        return;
    }

    if (this.annotationInteraction.type) {
        this.annotationInteraction.type = null;
        return;
    }
    if (this.variableCardInteraction.active) {
    if (this.variableCardInteraction.type === 'slider') {
         this.recalculateAll();
    }
    this.variableCardInteraction = { active: false, entryIndex: -1, type: null, offset: { x: 0, y: 0 } };
    return;
}
    if (e.type === 'touchend' && this.geometryInteractionState.active && !this.touchMoved) {
        this.handleGeometryClick(e);
    }

    if (this.draggingPoint) {
        if (e.type === 'mouseup' || (e.type === 'touchend' && this.touchMoved)) {
            const pointEntry = this.entries[this.selectedPointIndex];
            if (pointEntry) {
                pointEntry.isSelected = false;
            }
            this.draggingPoint = false;
            this.selectedPointIndex = -1;
            this.canvas.style.cursor = 'grab';
            this.hideInfoMessage();
            this.snapTargetObject = null;
            this.recalculateAll();
        }
        this.dragging = false;
        this.isPanning = false;
        this.touchState.panning = false;
        this.touchMoved = false;
        this.interactionWasPinch = false;
        return;
    }

    const eventType = e.type;
    let wasPanning = this.isPanning;
    let wasPinching = this.touchState.pinching;

    if (eventType === 'touchend' || eventType === 'touchcancel') {
        const endedPinch = this.touchState.pinching && e.touches.length < 2;

if (endedPinch) {
            clearTimeout(this.zoomEndTimeout);
            if (this.smoothPanningEnabled && this.performanceModeEnabled && this.globalPlayState === 0) {
                const history = this.zoomEventHistory;
                if (history.length >= 2) {
                    const last = history[history.length - 1];
                    let prev = history[history.length - 2];

                    const MAX_FLICK_DURATION_MS = 100;
                    for (let i = history.length - 2; i >= 0; i--) {
                        if (last.time - history[i].time > MAX_FLICK_DURATION_MS) break;
                        prev = history[i];
                    }

                    const dt = (last.time - prev.time) / 1000.0;
                    if (dt > 0.001) {
                        const dFactor = last.factor / prev.factor;
                        let velocityFactor = 1.0 + (dFactor - 1.0) * (16.67 / (last.time - prev.time));
                        velocityFactor = Math.max(0.7, Math.min(1.3, velocityFactor));

                        if (Math.abs(velocityFactor - 1) > 0.005) {
                            const lastCenter = e.touches.length > 0 ? this.getPinchCenter(e.touches) : this.touchState.initialPinch.center;
                            this.startSmoothZooming(velocityFactor, lastCenter, 'touch');
                        } else {
                            this.handleZoomEnd();
                        }
                    } else {
                         this.handleZoomEnd();
                    }
                } else {
                    this.handleZoomEnd();
                }
                 this.zoomEventHistory = [];
            } else {
                this.handleZoomEnd();
            }
        }

        if (e.touches.length === 0) {
            const wasActuallyPanning = this.touchState.panning;
            const isTouchTap = !this.touchMoved;

            if (isTouchTap && !this.draggingPoint && !this.geometryInteractionState.active) {
                const coords = this.getEventCoordinates(e);
                const clickedObject = this.findObjectNearClick(coords);
                if (this.geometrySnapEnabled && clickedObject) {
                    clearTimeout(this.highlightTimeout);
                    if (this.highlightedObject !== clickedObject) {
                        this.highlightedObject = clickedObject;
                        this.requestDraw();
                    }
                    this.highlightTimeout = setTimeout(() => {
                        if (this.highlightedObject === clickedObject) {
                            this.highlightedObject = null;
                            this.requestDraw();
                        }
                    }, 2000);
                }
                if (clickedObject) {
                    this.showInfoMessage(`点按：${clickedObject.name}`, 2000);
                }
            }

            this.isPanning = false;
            this.touchState.panning = false;
            this.touchState.pinching = false;

            const rect = this.canvas.getBoundingClientRect();
            const lastTouch = e.changedTouches[0];
            if (lastTouch && lastTouch.clientX >= rect.left && lastTouch.clientX <= rect.right &&
                lastTouch.clientY >= rect.top && lastTouch.clientY <= rect.bottom) {
                this.canvas.style.cursor = 'grab';
            } else {
                this.canvas.style.cursor = 'default';
            }
            this.stopSidebarResizeTouch();

            if (wasActuallyPanning) {
                if (this.smoothPanningEnabled && this.globalPlayState === 0 && !this.interactionWasPinch) {
                    this.startSmoothPanning();
                } else {
                    this.finalizePanInteraction();
                }
            } else if (wasPinching && !this.isZooming && !this.isSmoothZoomingActive) {
                this.clearPlotData();
                 this.entries.forEach(entry => {
                    if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    }
                });
                this.recalculateAll();
            } else if (!wasActuallyPanning && !wasPinching && isKeyboardOpen && lastTouch) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const isTapOnCanvas = lastTouch.clientX >= canvasRect.left && lastTouch.clientX <= canvasRect.right &&
                    lastTouch.clientY >= canvasRect.top && lastTouch.clientY <= canvasRect.bottom;
                const mainMenuElement = document.getElementById('main-menu');
                if (isTapOnCanvas && (!mainMenuElement || !mainMenuElement.classList.contains('open'))) {
                    closeKeyboard(false);
                }
            } else {
                 if (!this.isZooming && !this.isSmoothZoomingActive) this.requestDraw();
            }

            this.interactionWasPinch = false;

        } else if (e.touches.length === 1 && wasPinching) {
            this.isPanning = true;
            this.touchState.pinching = false;
            this.touchState.panning = true;
            this.touchState.lastPanPos = this.getEventCoordinates({
                touches: e.touches
            });
            this.panEventHistory = [];
            this.panEventHistory.push({
                x: this.touchState.lastPanPos.x,
                y: this.touchState.lastPanPos.y,
                time: performance.now()
            });
            this.lastPanEventTime = performance.now();
        }
    } else if (eventType === 'mouseup') {
        const isMouseTap = !this.mouseMoved;
        if (isMouseTap && !this.draggingPoint && !this.geometryInteractionState.active) {
            const coords = this.getEventCoordinates(e);
            const clickedObject = this.findObjectNearClick(coords);
            if (this.geometrySnapEnabled && clickedObject) {
                clearTimeout(this.highlightTimeout);
                if (this.highlightedObject !== clickedObject) {
                    this.highlightedObject = clickedObject;
                    this.requestDraw();
                }
                this.highlightTimeout = setTimeout(() => {
                    if (this.highlightedObject === clickedObject) {
                        this.highlightedObject = null;
                        this.requestDraw();
                    }
                }, 2000);
            }
            if (clickedObject) {
                this.showInfoMessage(`点按：${clickedObject.name}`, 2000);
            }
        }

        if (this.dragging) {
            this.isPanning = false;
            this.dragging = false;
            const rect = this.canvas.getBoundingClientRect();
            const isOverCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom;
            this.canvas.style.cursor = isOverCanvas ? 'grab' : 'default';

            if (this.isZooming) {
                clearTimeout(this.zoomEndTimeout);
                this.handleZoomEnd();
            } else if (this.smoothPanningEnabled && this.globalPlayState === 0) {
                this.startSmoothPanning();
            } else {
                this.finalizePanInteraction();
            }
        }
        this.interactionWasPinch = false;
        this.stopSidebarResize();
    }
}



  dragSelectedPoint(e) {
    if (this.selectedPointIndex === -1 || !this.draggingPoint) return;

    const entry = this.entries[this.selectedPointIndex];
    if (!entry || entry.type !== 'geometry' || entry.geometryType !== 'point') return;
    
    if (e.cancelable) e.preventDefault();
    
    const coords = this.getEventCoordinates(e);
    const mouseMathX = (coords.x - this.offset.x) / this.scale;
    const mouseMathY = (this.offset.y - coords.y) / this.scale;

const objectMap = new Map();
        this.entries.forEach(e => {
            if (e.name) objectMap.set(e.name.toLowerCase(), e);
        });

        if (entry.pointOnObject) {
            const onObject = objectMap.get(entry.onObjectName.toLowerCase());
            if (!onObject || !onObject.isMeaningful) return;

            let newParam = 0;
            const isLineLike = (t) => ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'].includes(t);

            if (isLineLike(onObject.geometryType)) {
                const { x_val: p1x, y_val: p1y } = onObject.p1;
            const dir_vec = onObject.dir_vec || onObject.dir;
            const {x: dx, y: dy} = dir_vec;
            const lenSq = dx * dx + dy * dy;
            if (lenSq > 1e-9) {
                newParam = ((mouseMathX - p1x) * dx + (mouseMathY - p1y) * dy) / lenSq;
            }
            
            if (onObject.geometryType === 'segment' || onObject.geometryType === 'vector') {
                newParam = Math.max(0, Math.min(1, newParam));
            } else if (onObject.geometryType === 'ray') {
                newParam = Math.max(0, newParam);
            }
        } else if (onObject.geometryType === 'circle') {
            const { x_val: cx, y_val: cy } = onObject.center;
            let angle = Math.atan2(mouseMathY - cy, mouseMathX - cx);
            if (angle < 0) angle += 2 * Math.PI;
            newParam = angle / (2 * Math.PI);
} else if (onObject.geometryType === 'ellipse' || onObject.geometryType === 'ellipse_ab') {
                 const { center, rotation, a, b } = onObject;
                 const relX = mouseMathX - center.x;
                 const relY = mouseMathY - center.y;
                 const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                 const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                 let angle = Math.atan2(localY / b, localX / a);
                 if (angle < 0) angle += 2 * Math.PI;
  newParam = angle / (2 * Math.PI);
        } else if (onObject.geometryType === 'hyperbola') {
            const { center, a, b, rotation, f1, f2 } = onObject;
            
            const d1 = Math.hypot(mouseMathX - f1.x_val, mouseMathY - f1.y_val);
            const d2 = Math.hypot(mouseMathX - f2.x_val, mouseMathY - f2.y_val);
            const branch_sign = Math.sign(d1 - d2) || 1;

            const relY = mouseMathY - center.y;
            const localY = (mouseMathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
            let t = Math.asinh(localY / b);
            
            const magic_offset = 100000;
            let param_to_store = t;
            if (branch_sign === -1) {
                param_to_store = t - magic_offset;
            }
            newParam = param_to_store;

        } else if (onObject.geometryType === 'parabola') {
            const { vertex, rotation } = onObject;
            const relX = mouseMathX - vertex.x;
            const relY = mouseMathY - vertex.y;
            const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
            const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
            newParam = localY;
        } else if (onObject.geometryType === 'circulararc') {
            if (!onObject.center || onObject.radius === undefined) return;
            const { center } = onObject;
            let angle = Math.atan2(mouseMathY - center.y_val, mouseMathX - center.x_val);
            let { startAngle, endAngle } = onObject;
            
            if (endAngle < startAngle) endAngle += 2 * Math.PI;
            

            let angleDiff = angle - startAngle;
            while (angleDiff < 0) angleDiff += 2 * Math.PI;
            while (angleDiff >= 2 * Math.PI) angleDiff -= 2 * Math.PI;
            
            const arcSpan = endAngle - startAngle;
            

            if (angleDiff <= arcSpan) {
                newParam = angleDiff / arcSpan;
            } else {

                const distToStart = angleDiff; 
                const distToEnd = (2 * Math.PI) - angleDiff + arcSpan;
                const distStart = Math.min(angleDiff, 2 * Math.PI - angleDiff);

                let diffToEnd = Math.abs(angleDiff - arcSpan);
                if (diffToEnd > Math.PI) diffToEnd = 2 * Math.PI - diffToEnd;
                
                newParam = (distStart < diffToEnd) ? 0 : 1;
            }
        }

        entry.parameter_expr = newParam.toPrecision(8);
        entry.expr = `point(${entry.name},${entry.onObjectName},${entry.parameter_expr})`;

          } else {
        let finalX = mouseMathX;
        let finalY = mouseMathY;
        
      if (this.geometrySnapEnabled) {
            this.snapTargetObject = null;
            const snapTolerancePixels = 12;
            let bestSnap = { dist: snapTolerancePixels, point: null };

            const gridStepInfo = this.calculateGridStep(this.canvas.clientWidth, this.canvas.clientHeight);
                if (gridStepInfo.unitStep > 0) {
                    const unitStep = gridStepInfo.unitStep;


                    const gridX = Math.round(mouseMathX / unitStep) * unitStep;
                    const distPixelX = Math.abs(mouseMathX - gridX) * this.scale;
                    
                    if (distPixelX < snapTolerancePixels) {
                        finalX = gridX;

                    }


                    const gridY = Math.round(mouseMathY / unitStep) * unitStep;
                    const distPixelY = Math.abs(mouseMathY - gridY) * this.scale;

                    if (distPixelY < snapTolerancePixels) {
                        finalY = gridY;
                    }

                    if (finalX !== mouseMathX || finalY !== mouseMathY) {
                         const distToSnap = Math.hypot((finalX - mouseMathX)*this.scale, (finalY - mouseMathY)*this.scale);
                         if (distToSnap < bestSnap.dist) {
                             bestSnap = { dist: distToSnap, point: { x: finalX, y: finalY }, object: { name: "网格" } };
                         }
                    }
                }
            
            // 批注吸附
            this.annotations.forEach(anno => {
                if (anno.type !== 'pen') return;
                const scaleX = anno.scaleX || 1;
                const scaleY = anno.scaleY || 1;
                
                for (let i = 0; i < anno.path.length - 1; i++) {
                    const p1Local = anno.path[i];
                    const p2Local = anno.path[i+1];
                    const p1 = { x: anno.x + p1Local.x * scaleX, y: anno.y + p1Local.y * scaleY };
                    const p2 = { x: anno.x + p2Local.x * scaleX, y: anno.y + p2Local.y * scaleY };
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const lenSq = dx*dx + dy*dy;
                    let t = 0;
                    if (lenSq > 1e-12) {
                        t = ((mouseMathX - p1.x) * dx + (mouseMathY - p1.y) * dy) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                    }
                    const closestX = p1.x + t * dx;
                    const closestY = p1.y + t * dy;
                    
                    const dist = Math.hypot(mouseMathX - closestX, mouseMathY - closestY) * this.scale;
                    if (dist < bestSnap.dist) {
                         bestSnap = { dist: dist, point: { x: closestX, y: closestY }, object: { name: "手绘笔迹" } };
                    }
                }
            });
            this.entries.forEach(entry => {
                if (entry.type !== 'point_list' || !entry.visible) return;
                
                for (const segment of entry.segments) {
                    for (let i = 0; i < segment.length - 1; i++) {
                        const idx1 = segment[i];
                        const idx2 = segment[i+1];
                        const p1Cache = entry.pointCache[idx1];
                        const p2Cache = entry.pointCache[idx2];
                        
                        if (Number.isFinite(p1Cache.valueX) && Number.isFinite(p1Cache.valueY) && 
                            Number.isFinite(p2Cache.valueX) && Number.isFinite(p2Cache.valueY)) {
                                
                            const p1 = { x: p1Cache.valueX, y: p1Cache.valueY };
                            const p2 = { x: p2Cache.valueX, y: p2Cache.valueY };
                            
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const lenSq = dx*dx + dy*dy;
                            let t = 0;
                            if (lenSq > 1e-12) {
                                t = ((mouseMathX - p1.x) * dx + (mouseMathY - p1.y) * dy) / lenSq;
                                t = Math.max(0, Math.min(1, t));
                            }
                            const closestX = p1.x + t * dx;
                            const closestY = p1.y + t * dy;
                            
                            const dist = Math.hypot(mouseMathX - closestX, mouseMathY - closestY) * this.scale;
                            if (dist < bestSnap.dist) {
                                bestSnap = { dist: dist, point: { x: closestX, y: closestY }, object: { name: entry.name || "点列" } };
                            }
                        }
                    }
                }
            });

this.entries.forEach(geo => {
                if (!geo.isMeaningful || !geo.visible || geo.type !== 'geometry' || geo === entry || (geo.dependencies && geo.dependencies.includes(entry.name.toLowerCase()))) return;
                let closestPointOnObject = null;
                const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                if (lineLike.includes(geo.geometryType) && geo.p1 && geo.dir) {
                    const { x_val: x1, y_val: y1 } = geo.p1;
                    const { x: dx, y: dy } = geo.dir;
                    let t = (mouseMathX - x1) * dx + (mouseMathY - y1) * dy;
                    if (geo.geometryType === 'segment' || geo.geometryType === 'vector') {
                        const len = Math.hypot(geo.p2.x_val - x1, geo.p2.y_val - y1);
                        t = Math.max(0, Math.min(len, t));
                    } else if (geo.geometryType === 'ray') {
                        t = Math.max(0, t);
                    }
                    closestPointOnObject = { x: x1 + t * dx, y: y1 + t * dy };
                } else if (geo.geometryType === 'circle' && geo.center && geo.radius) {
                    const distToCenter = Math.hypot(mouseMathX - geo.center.x_val, mouseMathY - geo.center.y_val);
                    if (distToCenter > 1e-9) {
                        const scaleFactor = geo.radius / distToCenter;
                        closestPointOnObject = { x: geo.center.x_val + (mouseMathX - geo.center.x_val) * scaleFactor, y: geo.center.y_val + (mouseMathY - geo.center.y_val) * scaleFactor };
                    }
                } else if (['ellipse', 'hyperbola', 'parabola'].includes(geo.geometryType)) {
                    const { center, a, b, rotation, vertex, p } = geo;
                    const c = center || vertex;
                    const r = rotation || 0;
                    if (c) {
                        const relX = mouseMathX - c.x;
                        const relY = mouseMathY - c.y;
                        const localX = relX * Math.cos(-r) - relY * Math.sin(-r);
                        const localY = relX * Math.sin(-r) + relY * Math.cos(-r);
                        let snapped_local_x, snapped_local_y;
                        if (geo.geometryType === 'ellipse' && a && b) {
                            let t = Math.atan2(localY / b, localX / a);
                            snapped_local_x = a * Math.cos(t);
                            snapped_local_y = b * Math.sin(t);
                        } else if (geo.geometryType === 'hyperbola' && a && b) {
                            let t = Math.asinh(localY / b);
                            snapped_local_x = (Math.sign(localX) || 1) * a * Math.cosh(t);
                            snapped_local_y = b * Math.sinh(t);
                        } else if (geo.geometryType === 'parabola' && p) {
                            snapped_local_x = localY * localY / (4 * p);
                            snapped_local_y = localY;
                        }
                        if (snapped_local_x !== undefined) {
                            closestPointOnObject = {
                                x: c.x + snapped_local_x * Math.cos(r) - snapped_local_y * Math.sin(r),
                                y: c.y + snapped_local_x * Math.sin(r) + snapped_local_y * Math.cos(r)
                            };
                        }
                    }
                }
                if (closestPointOnObject) {
                    const dist = Math.hypot(mouseMathX - closestPointOnObject.x, mouseMathY - closestPointOnObject.y) * this.scale;
                   if (dist < bestSnap.dist) {
bestSnap = { dist: dist, point: closestPointOnObject, object: geo };
}
                }
            });
            if (this.plottedFunctionPoints && this.plottedFunctionPoints.length > 0) {
                for (const p of this.plottedFunctionPoints) {
                    if (!p) continue;
                    const dist = Math.hypot(mouseMathX - p.x, mouseMathY - p.y) * this.scale;
                    if (dist < bestSnap.dist) {
bestSnap = { dist, point: { x: p.x, y: p.y }, object: null };
}
                }
            }
if (bestSnap.point) {
finalX = bestSnap.point.x;
finalY = bestSnap.point.y;
this.snapTargetObject = bestSnap.object;
}
if (this.snapTargetObject) {
this.showInfoMessage(`吸附：${this.snapTargetObject.name}`);
} else {
this.hideInfoMessage();
}
        } else {
            this.hideInfoMessage();
            this.snapTargetObject = null;
        }

        entry.x_val = finalX;
        entry.y_val = finalY;
        entry.x_expr = finalX.toPrecision(8);
        entry.y_expr = finalY.toPrecision(8);
        entry.expr = `point(${entry.name},${entry.x_expr},${entry.y_expr})`;
    }

    this.recalculateForGeometryDrag(entry);
}

    _isBreakPoint(y_next, y_curr, y_prev, y_prev2) {
        const scale = this.scale;
        let bpfactor = 0.25;
     
        const explicitPrecisionValue = this.explicitPrecisionSlider ? this.explicitPrecisionSlider.options.value : 2;
        const term1 = Math.abs(y_next - y_curr) > 500 / (scale * bpfactor * explicitPrecisionValue); 
        const term21 = Math.abs(y_next - y_curr) > 4 / (scale * bpfactor * explicitPrecisionValue);
        const term22 = Math.abs(y_curr - y_prev) < 0.005 / (scale * bpfactor * explicitPrecisionValue);
        const term2 = term21 && term22; 
        const term3 = Math.abs(y_curr - y_prev) > 500 / (scale * bpfactor * explicitPrecisionValue);
        
        return term1 || term2 || term3;
    }

          _isAdaptiveBreakPoint(points, i, dependentAxis = 'y') {
        if (i <= 1 || i >= points.length - 1) return false;

        const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
        const p_prev2 = points[i - 2];
        const p_prev = points[i - 1];
        const p_curr = points[i];
        const p_next = points[i + 1];

        if (!p_prev.valid || !p_curr.valid || !p_prev2.valid || !p_next || !p_next.valid) return false;

        const value_prev2 = p_prev2[dependentAxis];
        const value_prev = p_prev[dependentAxis];
        const value_curr = p_curr[dependentAxis];
        const value_next = p_next[dependentAxis];
        const tolerance = 1e-9;
        if (
            Math.abs(value_prev2 - value_prev) < tolerance &&
            Math.abs(value_prev - value_curr) > tolerance &&
            Math.abs(value_curr - value_next) < tolerance
        ) {
            return 'step';
        }
        
        const jumpThreshold = (dependentAxis === 'y' ? this.canvas.clientHeight : this.canvas.clientWidth) / this.scale * 0.5;
        if (p_curr[dependentAxis] * p_next[dependentAxis] < 0 && Math.abs(p_curr[dependentAxis] - p_next[dependentAxis]) > jumpThreshold) {
            return true;
        }

        const ZERO_DERIVATIVE_THRESHOLD = 1e-3;
        const slope1 = (p_prev[dependentAxis] - p_prev2[dependentAxis]) / (p_prev[independentAxis] - p_prev2[independentAxis]);
        const slope2 = (p_curr[dependentAxis] - p_prev[dependentAxis]) / (p_curr[independentAxis] - p_prev[independentAxis]);
        const slope3 = (p_next[dependentAxis] - p_curr[dependentAxis]) / (p_next[independentAxis] - p_curr[independentAxis]);

        if (
            isFinite(slope1) && isFinite(slope2) && isFinite(slope3) &&
            Math.abs(slope1) > ZERO_DERIVATIVE_THRESHOLD &&
            Math.sign(slope1) === Math.sign(slope3) &&
            Math.sign(slope1) !== Math.sign(slope2)
        ) {
            return true;
        }

        return false;
    }


    startSmoothPanning() {
        const history = this.panEventHistory;
        const historyLength = history.length;

        if (historyLength < 2) {
            this.finalizePanInteraction();
            return;
        }
        const lastRecordedEvent = history[historyLength - 1]; 
        let firstRelevantEventForFlick = null;
        const MAX_FLICK_DURATION_MS = 100; 
        const MAX_FLICK_SAMPLES_LOOKBACK = 5;  
        const MIN_FLICK_SAMPLES_FOR_VELOCITY = 1; 

        for (let i = historyLength - 2; i >= 0; i--) {
            const currentEventCandidate = history[i];
            const timeDiff = lastRecordedEvent.time - currentEventCandidate.time;
            const samplesBehind = (historyLength - 1) - i;

            if (timeDiff > MAX_FLICK_DURATION_MS && samplesBehind > MIN_FLICK_SAMPLES_FOR_VELOCITY) {
                break;
            }
            
            firstRelevantEventForFlick = currentEventCandidate; 

            if (samplesBehind >= MAX_FLICK_SAMPLES_LOOKBACK) {
                break;
            }
        }

        if (!firstRelevantEventForFlick) {
            if (historyLength >=2) {
                firstRelevantEventForFlick = history[historyLength - 2];
            } else {
                this.finalizePanInteraction();
                return;
            }
        }

        const dt = (lastRecordedEvent.time - firstRelevantEventForFlick.time) / 1000.0; 

        if (dt < 0.001) {
            this.finalizePanInteraction();
            return;
        }

        const dx = lastRecordedEvent.x - firstRelevantEventForFlick.x;
        const dy = lastRecordedEvent.y - firstRelevantEventForFlick.y;
        
        const MIN_FLICK_DISTANCE_THRESHOLD = 5; 
        if (Math.sqrt(dx*dx + dy*dy) < MIN_FLICK_DISTANCE_THRESHOLD && dt < 0.05 ) {
            this.finalizePanInteraction();
            return;
        }

        this.smoothPanVelocity.x = dx / dt;
        this.smoothPanVelocity.y = dy / dt;

        const velocityMagnitude = Math.sqrt(this.smoothPanVelocity.x**2 + this.smoothPanVelocity.y**2);

        if (velocityMagnitude < this.minFlickVelocityMagnitude) {
            this.finalizePanInteraction();
            return;
        }

        let calculatedAccsmooth = this.baseAccsmooth + velocityMagnitude * this.accsmoothVelocityFactor;
        this.accsmooth = Math.min(calculatedAccsmooth, this.maxAccsmooth);
        this.accsmooth = Math.max(this.accsmooth, this.baseAccsmooth);

        this.isSmoothPanningActive = true;
        this.lastSmoothPanTime = performance.now();
        this.requestDraw();
    }

    finalizePanInteraction() {
        this.isUsingPanOptimization = false;
        if (this.globalPlayState === 0) {
            const cssWidth = this.canvasContainer.clientWidth;
            const cssHeight = this.canvasContainer.clientHeight;
            this.processImplicitBlocksOnGrid(cssWidth, cssHeight);

            if (this.performanceModeEnabled) {
                this.cleanupUnusedCache(cssWidth, cssHeight);
            }
        }
        this.recalculateAll();
    }
startSmoothZooming(velocityFactor, target, source = 'mouse') {
    if (!this.smoothPanningEnabled || !this.performanceModeEnabled || this.globalPlayState !== 0) {
        this.handleZoomEnd();
        return;
    }
    clearTimeout(this.zoomEndTimeout);
    this.isSmoothPanningActive = false;
    this.isSmoothZoomingActive = true;
    
    const inertiaScale = (source === 'touch') ? this.touchZoomInertiaScale : this.mouseZoomInertiaScale;
    this.smoothZoomVelocity = 1.0 + (velocityFactor - 1.0) * inertiaScale;
    
    this.smoothZoomTarget = target;
    this.lastSmoothPanTime = performance.now();

    if (!this.isZooming && this.performanceModeEnabled) {
        this.captureCanvasStateForTransform();
        this.startPerformanceZoom();
    }
    this.requestDraw();
}

captureCanvasStateForTransform() {
    if (this.globalPlayState !== 0) return;
    this.isTransformingCache = true;
    this.transformInitialState = { offset: { ...this.offset }, scale: this.scale };

    const wasTransforming = this.isTransformingCache;
    this.isTransformingCache = false;
    this.draw();
    this.isTransformingCache = wasTransforming;

    this.offscreenCanvas.width = this.canvas.width;
    this.offscreenCanvas.height = this.canvas.height;
    const ctx = this.offscreenCtx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.drawImage(this.canvas, 0, 0);
    ctx.drawImage(this.axisCanvas, 0, 0);
}

onZoom(e) {
        e.preventDefault();
        
        if (this.is3DMode) {
            const zoomIntensity = -0.1;
            const delta = e.deltaY > 0 ? -1 : 1; 
            this.scale3D *= (1 + delta * zoomIntensity); 
            if (this.scale3D < 0.001) this.scale3D = 0.001;
            if (this.scale3D > 100.0) this.scale3D = 100.0;
            this.recalculate3D();
            this.requestDraw();
            return;
        }


        const zoomIntensity = 0.1;
        const delta = e.deltaY > 0 ? -1 : 1;
        const effectiveIntensity = e.ctrlKey ? zoomIntensity * 0.5 : zoomIntensity;
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (this.smoothPanningEnabled && this.performanceModeEnabled && this.globalPlayState === 0) {
            const velocityFactor = 1 + delta * effectiveIntensity * 3;
            this.startSmoothZooming(velocityFactor, { x: mouseX, y: mouseY }, 'mouse');
        } else {
            clearTimeout(this.zoomEndTimeout);
            if (!this.isZooming) {
                this.isZooming = true;
                if (this.performanceModeEnabled) {
                    this.captureCanvasStateForTransform();
                    this.startPerformanceZoom();
                } else if (this.lowPrecisionBufferEnabled) {
                    if (!this.isUsingLowPrecisionBuffer) {
                        this.originalExplicitPrecision = this.explicitPrecisionStep;
                        this.originalImplicitPrecision = this.implicitPrecisionStep;
                        this.isUsingLowPrecisionBuffer = true;
                    }
                    this.explicitPrecisionStep = 1;
                    this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
                    this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep);
                    this.implicitPrecisionSlider.setValue(this.implicitPrecisionStep);
                    this.updatePrecisionLabels();
                }
            }

            if (!this.performanceModeEnabled) {
                this.clearPlotData();
                this.entries.forEach(entry => {
                    if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') {
                        entry.webglVertices = null;
                        if (entry.plotType === 'parametric') entry.cachedPoints = [];
                    }
                });
            }
            
            const zoomFactor = 1 + delta * effectiveIntensity;
            const mouseXMath = (mouseX - this.offset.x) / this.scale;
            const mouseYMath = (this.offset.y - mouseY) / this.scale;
            let newScale = this.scale * zoomFactor;
            newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));
            this.offset.x = mouseX - mouseXMath * newScale;
            this.offset.y = mouseY + mouseYMath * newScale;
            this.scale = newScale;

            this.zoomEndTimeout = setTimeout(() => this.handleZoomEnd(), 300);
            this.requestDraw();
        }
    }

    startPanOptimization() {
        if (this.globalPlayState === 0) {
            this.isUsingPanOptimization = true;
            this.panStartOffset = { ...this.offset };

            const wasOptimizing = this.isUsingPanOptimization;
            this.isUsingPanOptimization = false;
            this.draw();
            this.isUsingPanOptimization = wasOptimizing;

            this.offscreenCanvas.width = this.canvas.width;
            this.offscreenCanvas.height = this.canvas.height;
            const ctx = this.offscreenCtx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.drawImage(this.canvas, 0, 0);
            ctx.drawImage(this.axisCanvas, 0, 0);
        } else {
            this.isUsingPanOptimization = false;
        }
    }

             startSidebarResize(e) {
        const infoModes = ['settings', 'file', 'about'];
        if (this.isPortraitMode && infoModes.includes(this.currentUIMode)) {
            return;
        }
        if (e.type !== 'mousedown' || e.button !== 0) return;
        const rect = this.sidebar.getBoundingClientRect();
        let onResizeHandle = false;

        if (this.isPortraitMode) {
             onResizeHandle = e.clientY <= rect.top + this.resizeHandleWidth && e.clientY >= rect.top - 3;
        } else {
             onResizeHandle = e.clientX >= rect.right - this.resizeHandleWidth && e.clientX <= rect.right + 3;
        }


        if (onResizeHandle) {
          document.body.classList.add('sidebar-resizing');
            this.isResizingSidebar = true;
            this.initialResizeX = e.clientX;
            this.initialResizeY = e.clientY;
            this.initialSidebarWidth = this.sidebar.offsetWidth;
            document.body.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
            this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
            e.preventDefault();
        }
    }

doSidebarResize(e) {
    if (!this.isResizingSidebar || e.type !== 'mousemove') return;

    const background = document.getElementById('sidebar-background');
    const computedStyle = window.getComputedStyle(this.sidebar);

    if (this.isPortraitMode) {
        const dy = e.clientY - this.initialResizeY;
        const currentRect = this.sidebar.getBoundingClientRect();
        let newTop = currentRect.top + dy;
        
        const bottomStyle = parseFloat(window.getComputedStyle(this.sidebar).bottom);
        const minH = parseInt(computedStyle.minHeight, 10) || 150;
        const maxH = Math.max(minH, window.innerHeight * 0.6);

        const minTop = window.innerHeight - bottomStyle - maxH;
        const maxTop = window.innerHeight - bottomStyle - minH;
        
        newTop = Math.max(minTop, Math.min(newTop, maxTop));
        
        this.sidebar.style.height = 'auto';
        this.sidebar.style.top = `${newTop}px`;
        if (background) {
            background.style.height = 'auto';
            background.style.top = `${newTop - 5}px`;
        }
        
        this.initialResizeY = e.clientY;
   } else {
            const dx = e.clientX - this.initialResizeX;
            let newWidth = this.initialSidebarWidth + dx;

            const minW = parseInt(computedStyle.minWidth, 10) || 250;
            const maxW = Math.max(minW, window.innerWidth * 0.8);

newWidth = Math.max(minW, Math.min(newWidth, maxW));

            this.sidebar.style.width = `${newWidth}px`;
            if (background) {
                background.style.width = `${newWidth}px`;
                this.lastValidSidebarRight = background.getBoundingClientRect().right;
            }
            

            this.updateTopBarLayout();
        }
    }

    stopSidebarResize() {
        if (this.isResizingSidebar) {
          document.body.classList.remove('sidebar-resizing'); 
            this.isResizingSidebar = false;
            this.sidebar.style.cursor = 'default';
            document.body.style.cursor = 'default';
            this.clearPlotData();
            this.entries.forEach(entry => {
                if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
            });

            setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
            }, 350);

            setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
            }, 1000);

             this.updateSidebarCursor(this.lastPos.x + this.canvas.getBoundingClientRect().left, this.lastPos.y + this.canvas.getBoundingClientRect().top);
        }
    }

         startSidebarResizeTouch(e) {
        const infoModes = ['settings', 'file', 'about'];
        if (this.isPortraitMode && infoModes.includes(this.currentUIMode)) {
            return;
        }
        if (e.touches.length !== 1 || this.touchState.panning || this.touchState.pinching) return;

         const rect = this.sidebar.getBoundingClientRect();
         const touchX = e.touches[0].clientX;
         const touchY = e.touches[0].clientY;
         let onResizeHandle = false;

         if (this.isPortraitMode) {
              onResizeHandle = touchY >= rect.top - this.touchResizePadding && touchY <= rect.top + this.touchResizePadding;
         } else {
              onResizeHandle = touchX >= rect.right - this.touchResizePadding && touchX <= rect.right + this.touchResizePadding;
         }


         if (onResizeHandle) {
          document.body.classList.add('sidebar-resizing');
             this.isResizingSidebarTouch = true;
             this.initialResizeTouchX = touchX;
             this.initialResizeTouchY = touchY;
             this.initialSidebarWidth = this.sidebar.offsetWidth;
             this.sidebar.style.cursor = this.isPortraitMode ? 'row-resize' : 'col-resize';
             e.preventDefault(); 
             e.stopPropagation(); 
         }
     }

doSidebarResizeTouch(e) {
    if (!this.isResizingSidebarTouch || e.touches.length !== 1) return;
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    const computedStyle = window.getComputedStyle(this.sidebar);
    const background = document.getElementById('sidebar-background');

    if (this.isPortraitMode) {
        const dy = touchY - this.initialResizeTouchY;
        const currentRect = this.sidebar.getBoundingClientRect();
        let newTop = currentRect.top + dy;
        
        const bottomStyle = parseFloat(window.getComputedStyle(this.sidebar).bottom);
        const minH = parseInt(computedStyle.minHeight, 10) || 150;
        const maxH = Math.max(minH, window.innerHeight * 0.6);

        const minTop = window.innerHeight - bottomStyle - maxH;
        const maxTop = window.innerHeight - bottomStyle - minH;
        
        newTop = Math.max(minTop, Math.min(newTop, maxTop));
        
        this.sidebar.style.height = 'auto';
        this.sidebar.style.top = `${newTop}px`;
        if (background) {
            background.style.height = 'auto';
            background.style.top = `${newTop - 5}px`;
        }
        
        this.initialResizeTouchY = touchY;
    } else {
        const dx = touchX - this.initialResizeTouchX;
        let newWidth = this.initialSidebarWidth + dx;

        const minW = parseInt(computedStyle.minWidth, 10) || 250;
        const maxW = Math.max(minW, window.innerWidth * 0.8);

        newWidth = Math.max(minW, Math.min(newWidth, maxW));
        this.sidebar.style.width = `${newWidth}px`;
        if (background) background.style.width = `${newWidth}px`;
    }
    e.preventDefault();
    e.stopPropagation();
}

     stopSidebarResizeTouch() {
         if (this.isResizingSidebarTouch) {
          document.body.classList.remove('sidebar-resizing'); 
             this.isResizingSidebarTouch = false;
             this.sidebar.style.cursor = 'default';
             this.clearPlotData();
             this.entries.forEach(entry => {
                 if (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y') entry.webglVertices = null;
             });

             setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
             }, 350);
             
             setTimeout(() => {
                this.updateOverlayPositions();
                this.updateCanvasPosition();
                this.updateTopBarLayout();
             }, 1000);
         }
     }


addEntry(rawInputFromUI) {
        const rawInputTrimmed = (typeof rawInputFromUI === 'string' && rawInputFromUI.trim() !== '')
            ? rawInputFromUI.trim()
            : prompt('请输入表达式 (例: y=x^2, f(x)=x^2, x^2+y^2=4, x=cos(t),y=sin(t), a=2):');

        if (rawInputTrimmed === null || rawInputTrimmed === "") return;

        const lowercaseInput = rawInputTrimmed.toLowerCase();
        try {
            const funcDefMatch = rawInputTrimmed.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
            let handledByParseInternal = false;

            if (funcDefMatch) {
                const funcName = funcDefMatch[1];
                const funcNameLower = funcName.toLowerCase();

                const isBuiltInMath = this.calcJSUtils.calc1.includes(funcNameLower);
                const isExistingSimpleCustom = this.calcJSUtils.customFunctions.hasOwnProperty(funcNameLower);
                const isExistingAdvancedCustom = this.calcJSUtils.advancedCustomFunctions.hasOwnProperty(funcNameLower);
                const isExistingConstant = this.calcJSUtils.constants.hasOwnProperty(funcNameLower);
                const isPredefined = isBuiltInMath || isExistingSimpleCustom || isExistingAdvancedCustom || isExistingConstant;


                if (isPredefined && funcNameLower !== 'x' && funcNameLower !== 'y' && funcNameLower !== 't') {
                    const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                    if (entryData) {
                         const existingIndex = this.entries.findIndex(e => e.expr === entryData.expr && e.type === entryData.type);
                         if (existingIndex === -1) this.entries.push(entryData);
                         else this.entries[existingIndex] = entryData;
                    }
                    handledByParseInternal = true;
                } else if (funcNameLower === 'x' || funcNameLower === 'y' || funcNameLower === 't') {
                    const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                     if (entryData) {
                        if (entryData.type === 'variable') { 
                            const existingIndex = this.entries.findIndex(e => e.type === 'variable' && e.key === entryData.key);
                            if (existingIndex > -1) {
                                 if (this.entries[existingIndex].isEditableIndependent && entryData.isEditableIndependent) {
                                    entryData.sliderActive = this.entries[existingIndex].sliderActive;
                                    entryData.playState = this.entries[existingIndex].playState;
                                    entryData.playDirection = this.entries[existingIndex].playDirection;
                                    if (!Number.isFinite(entryData.value)) {
                                        if (Number.isFinite(this.entries[existingIndex].value)) {
                                            entryData.value = this.entries[existingIndex].value;
                                        } else {
                                            entryData.value = Number.isFinite(entryData.min) ? entryData.min : 0;
                                        }
                                    }
                                     if (! /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(entryData.expr.split('=')[1]?.trim() || '')) {
                                         entryData.min = this.entries[existingIndex].min;
                                         entryData.max = this.entries[existingIndex].max;
                                         entryData.step = this.entries[existingIndex].step;
                                     }
                                }
                                this.entries[existingIndex] = entryData;
                            } else {
                                this.entries.push(entryData);
                            }
                        } else { 
                            this.entries.push(entryData);
                        }
                    }
                    handledByParseInternal = true;
                } else {
                    const definedFuncData = this.defineCalcJSFunction(rawInputTrimmed, false); 

                    if (definedFuncData) {
                        let definitionEntry;
                        if (definedFuncData.type === 'custom_function_definition') {
                            definitionEntry = {
                                type: 'custom_function_definition',
                                name: definedFuncData.name,
                                params: definedFuncData.params,
                                body: definedFuncData.rawBodyString, 
                                expr: definedFuncData.originalExpression, 
                                dependencies: this._extractDependenciesFromTokensWithLargeOps(
                                    definedFuncData.bodyTokens, 
                                    definedFuncData.params,
                                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames
                                ),
                                compilationError: undefined
                            };

                 
                            if (this.is3DMode && definedFuncData.params.length === 2) {
                                const p1 = definedFuncData.params[0].toLowerCase();
                                const p2 = definedFuncData.params[1].toLowerCase();
                                const funcCall = `${definedFuncData.name}(${definedFuncData.params[0]},${definedFuncData.params[1]})`;
                                let autoAddedExpr = null;
                                if ((p1 === 'x' && p2 === 'y') || (p1 === 'y' && p2 === 'x')) autoAddedExpr = `z=${funcCall}`;
                                else if ((p1 === 'y' && p2 === 'z') || (p1 === 'z' && p2 === 'y')) autoAddedExpr = `x=${funcCall}`;
                                else if ((p1 === 'x' && p2 === 'z') || (p1 === 'z' && p2 === 'x')) autoAddedExpr = `y=${funcCall}`;

                                if (autoAddedExpr) {
                                    const normalizedAutoExpr = autoAddedExpr.replace(/\s+/g, '').toLowerCase();
                                    const exists = this.entries.some(e => 
                                        e.type === 'function' && 
                                        e.expr.replace(/\s+/g, '').toLowerCase() === normalizedAutoExpr
                                    );
                                    
                                    if (!exists) {
                                        const parsedAutoEntry = this.parseInputInternal(autoAddedExpr.toLowerCase(), autoAddedExpr);
                                        if (parsedAutoEntry && parsedAutoEntry.type === 'function') {
                                            this.entries.push(parsedAutoEntry);
                                        }
                                    }
                                }
                            } else if (definedFuncData.params.length === 1) {
                                const paramNameLower = definedFuncData.params[0].toLowerCase();
                                const funcCall = `${definedFuncData.name}(${definedFuncData.params[0]})`;
                                let autoAddedExpr = null;
                                if (paramNameLower === 'x') autoAddedExpr = `y=${funcCall}`;
                                else if (paramNameLower === 'y') autoAddedExpr = `x=${funcCall}`;

                                if (autoAddedExpr) {
                                    const normalizedAutoExpr = autoAddedExpr.replace(/\s+/g, '').toLowerCase();
                                    const exists = this.entries.some(e => 
                                        e.type === 'function' && 
                                        e.expr.replace(/\s+/g, '').toLowerCase() === normalizedAutoExpr
                                    );
                                    
                                    if (!exists) {
                                        const parsedAutoEntry = this.parseInputInternal(autoAddedExpr.toLowerCase(), autoAddedExpr);
                                        if (parsedAutoEntry && parsedAutoEntry.type === 'function') {
                                            this.entries.push(parsedAutoEntry);
                                        }
                                    }
                                }
                            }
                        } else if (definedFuncData.type === 'advanced_custom_function_definition') {
                            definitionEntry = {
                                type: 'advanced_custom_function_definition',
                                name: definedFuncData.name,
                                params: definedFuncData.params,
                                bodyJs: definedFuncData.bodyJs,
                                expr: `${definedFuncData.name}(${definedFuncData.params.join(',')}) { /* JS body */ }`,
                                dependencies: [], 
                                compilationError: undefined
                            };
                        }

                        if (definitionEntry) {
                             const existingDefIndex = this.entries.findIndex(e => e.type === definitionEntry.type && e.name === definitionEntry.name);
                             if (existingDefIndex > -1) {
                                this.entries[existingDefIndex] = definitionEntry; 
                             } else {
                                this.entries.push(definitionEntry);
                             }
                        }
                    }
                    handledByParseInternal = true;
                }
            }

            if (!handledByParseInternal) {
                const entryData = this.parseInputInternal(lowercaseInput, rawInputTrimmed);
                if (entryData) {
                    if (entryData.type === 'variable') {
                        const existingIndex = this.entries.findIndex(e => e.type === 'variable' && e.key === entryData.key);
                        if (existingIndex > -1) {
                             if (this.entries[existingIndex].isEditableIndependent && entryData.isEditableIndependent) {
                                entryData.sliderActive = this.entries[existingIndex].sliderActive;
                                entryData.playState = this.entries[existingIndex].playState;
                                entryData.playDirection = this.entries[existingIndex].playDirection;
                                if (!Number.isFinite(entryData.value)) { 
                                    if (Number.isFinite(this.entries[existingIndex].value)) {
                                        entryData.value = this.entries[existingIndex].value; 
                                    } else { 
                                        entryData.value = Number.isFinite(entryData.min) ? entryData.min : 0; 
                                    }
                                }
                                 if (! /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(entryData.expr.split('=')[1]?.trim() || '')) {
                                     entryData.min = this.entries[existingIndex].min;
                                     entryData.max = this.entries[existingIndex].max;
                                     entryData.step = this.entries[existingIndex].step;
                                 }
                            }
                            this.entries[existingIndex] = entryData;
                        } else {
                            this.entries.push(entryData);
                        }
                    } else if (entryData.type === 'constant') {
                        const existingIndex = this.entries.findIndex(e => e.type === 'constant' && e.name === entryData.name);
                        if (existingIndex > -1) {
                            this.entries[existingIndex] = entryData;
                        } else {
                            this.entries.push(entryData);
                        }
                    }
                    else { 
                        const existingFuncIndex = this.entries.findIndex(e => e.type === 'function' && e.expr.toLowerCase() === entryData.expr.toLowerCase());
                        if (existingFuncIndex === -1) {
                            this.entries.push(entryData);
                        } else {
                            this.entries[existingFuncIndex] = entryData;
                        }
                    }
                }
            }
            this.recalculateAll();
            this.updateGlobalPlayState();

        } catch (e) {
            alert(`解析表达式出错: ${e.message}`);
        }
    }

async handleEntryListClick(e) {
        // 点击列表时，如果有选中的批注，立即取消选中并刷新UI
        if (this.selectedAnnotationIndex !== -1) {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        }

        const item = e.target.closest('.entry-item');
        if (!item) return;

        const framePlayBtn = e.target.closest('.frame-play-toggle-btn');
        const frameCurrentVal = e.target.closest('.frame-current-value');
        const frameTotalVal = e.target.closest('.frame-total-value');
        const frameFpsVal = e.target.closest('.frame-fps-value');

        if (item.classList.contains('playback-control-card')) {
            if (framePlayBtn) {
                this.isFramePlaying = !this.isFramePlaying;
                this.frameAccumulator = 0; 
                this.lastAnimationTime = performance.now();
                this.updateGlobalPlayState();
                this.updateEntryList();
                return;
            }

            if (frameCurrentVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.currentFrame, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal >= 0 && newVal <= this.totalFrames) {
                            this.currentFrame = newVal;
                            this.updateEntryList();
                            this.requestDraw();
                        }
                    });
                }
                return;
            }
            if (frameTotalVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.totalFrames, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal > 0) {
                            this.totalFrames = newVal;
                            if (this.currentFrame > this.totalFrames) this.currentFrame = this.totalFrames;
                            this.updateEntryList();
                            this.requestDraw();
                        }
                    });
                }
                return;
            }
            if (frameFpsVal) {
                if (window.globalOpenKeyboardForValue) {
                    window.globalOpenKeyboardForValue(this.playbackFPS, (newValStr) => {
                        const newVal = parseInt(newValStr, 10);
                        if (!isNaN(newVal) && newVal > 0) {
                            this.playbackFPS = newVal;
                            this.updateEntryList();
                        }
                    });
                }
                return;
            }
            return;
        }

        const index = parseInt(item.dataset.index, 10);
        if (isNaN(index) || index < 0 || index >= this.entries.length) return;
        const entry = this.entries[index];

        const colorToggleBtn = e.target.closest('.color-toggle-btn');
        const settingsToggleBtn = e.target.closest('.settings-toggle-btn');
        const visibilityToggleBtn = e.target.closest('.visibility-toggle-btn');
        const playToggleBtn = e.target.closest('.play-toggle-btn');
        const editBtn = e.target.closest('.edit-btn');
        const deleteBtn = e.target.closest('.delete-btn');
        const textArea = e.target.closest('.entry-text-area');
        const sliderPropsSpan = e.target.closest('.slider-props span');
        const displayFrameVal = e.target.closest('.display-frame-value');
        const extend3DToggle = e.target.closest('.extend-3d-toggle');
        const sliceAxisVal = e.target.closest('.slice-axis-value');
        const sliceValVal = e.target.closest('.slice-val-value');
        const playModeVal = e.target.closest('.play-mode-value');
        const togglePlotCardBtn = e.target.closest('.toggle-plot-card-btn');

        if (displayFrameVal) {
            if (window.globalOpenKeyboardForValue) {
                window.globalOpenKeyboardForValue(entry.displayFrame, (newValStr) => {
                    const newVal = parseInt(newValStr, 10);
                    if (!isNaN(newVal) && newVal >= 0) {
                        entry.displayFrame = newVal;
                        this.updateEntryList();
                        this.requestDraw();
                    }
                });
            }
            return;
        }

        if (extend3DToggle) {
            entry.extendTo3D = extend3DToggle.checked;
            this.recalculate3D();
            this.requestDraw();
            return;
        }

        if (sliceAxisVal) {
            const axes = ['none', 'x', 'y', 'z'];
            let currentIdx = axes.indexOf(entry.sliceAxis);
            if (currentIdx === -1) currentIdx = 0;
            entry.sliceAxis = axes[(currentIdx + 1) % axes.length];
            this.updateEntryList();
            this.recalculate3D();
            this.requestDraw();
            return;
        }

        if (sliceValVal) {
            if (window.globalOpenKeyboardForValue) {
                window.globalOpenKeyboardForValue(entry.sliceVal, (newValStr) => {
                    const newVal = parseFloat(newValStr);
                    if (!isNaN(newVal)) {
                        entry.sliceVal = newVal;
                        this.updateEntryList();
                        this.recalculate3D();
                        this.requestDraw();
                    }
                });
            }
            return;
        }

        if (playModeVal && entry.type === 'variable' && entry.isEditableIndependent) {
            entry.playMode = ((entry.playMode || 0) + 1) % 5;
            this.updateEntryList();
            return;
        }
if (togglePlotCardBtn && entry.type === 'variable' && entry.isEditableIndependent) {
            entry.showOnPlot = togglePlotCardBtn.checked;
            if (entry.showOnPlot) {
                const cssWidth = this.canvas.clientWidth;
                const cssHeight = this.canvas.clientHeight;
                const centerX = (cssWidth / 2 - this.offset.x) / this.scale;
                const centerY = (this.offset.y - cssHeight / 2) / this.scale;

                if (entry.cardX === undefined) entry.cardX = centerX;
                if (entry.cardY === undefined) entry.cardY = centerY;
                if (entry.cardW === undefined) entry.cardW = 220;
                if (entry.cardH === undefined) entry.cardH = 75;
            }
            
            setTimeout(() => {
                this.updateEntryList();
                this.requestDraw();
            }, 0);
            return;
        }
        const toggleExpansion = () => {
            const shouldBeExpanded = !entry.expanded;
            entry.expanded = shouldBeExpanded;
            item.classList.toggle('expanded', shouldBeExpanded);

            if (shouldBeExpanded) {
                this.entries.forEach((otherEntry, otherIndex) => {
                    if (index !== otherIndex && otherEntry.expanded) {
                        otherEntry.expanded = false;
                        const otherItem = this.entryList.querySelector(`.entry-item[data-index="${otherIndex}"]`);
                        if (otherItem) otherItem.classList.remove('expanded');
                    }
                });
            }

            if (entry.expanded) {
                setTimeout(() => {
                    if (entry.expanded) {
                        this.updateEntryList();
                    }
                }, 250);
            }
        };

        if (editBtn) {
            this.startEditEntry(index);
            return;
        }
        if (deleteBtn) {
            this._handleCascadingDelete(index);
            return;
        }
        if (visibilityToggleBtn) {
            entry.visible = !entry.visible;
            this.recalculateAll();
            return;
        }
        if (playToggleBtn) {
            if (entry.type === 'variable' && entry.isEditableIndependent) {
                entry.playState = entry.playState === 1 ? 0 : 1;

                if (entry.playState === 1) {
                    this.recalculateAll(); 
                }
                this.updateGlobalPlayState();
                this.updateEntryList();
            }
            return;
        }
        if (sliderPropsSpan && entry.type === 'variable' && entry.isEditableIndependent) {
            if (sliderPropsSpan.classList.contains('slider-min-value')) this.promptEditSliderProperty(index, 'min', entry.min);
            else if (sliderPropsSpan.classList.contains('slider-max-value')) this.promptEditSliderProperty(index, 'max', entry.max);
            else if (sliderPropsSpan.classList.contains('slider-step-value')) this.promptEditSliderProperty(index, 'step', entry.step);
            return;
        }

        if (colorToggleBtn || settingsToggleBtn) {
            toggleExpansion();
            return;
        }
        
        const isTouch = document.body.classList.contains('is-touch-device');
        const isSliderArea = e.target.closest('.entry-expandable-content') || e.target.closest('.variable-slider-wrapper');

        if (textArea || (isTouch && !isSliderArea)) {
            toggleExpansion();
            return;
        }
    }
  promptEditVariableValue(index) {
         const entry = this.entries[index];
         if (!entry || entry.type !== 'variable' || !entry.isEditableIndependent) return;

         const newValueString = prompt(`请输入变量 "${entry.name.toUpperCase()}" 的新值:`, String(entry.value));
         if (newValueString === null) return;

         const parsedValue = this._parseOrEvaluateInput(newValueString);
         if (parsedValue === null) {
              alert('输入的值无效。');
              return;
         }

         let tempNewValue = parsedValue;

         const editProps = prompt(`是否更改变量 "${entry.name.toUpperCase()}" 的滑杆参数 (最小值, 最大值, 步长)?\n输入 空/no/不/否/0 跳过, 输入其他继续:`, '');

         if (editProps !== null && editProps.trim().toLowerCase() !== '' && editProps.trim().toLowerCase() !== 'no' && editProps.trim() !== '不' && editProps.trim() !== '否' && editProps.trim() !== '0') {

              const newMinString = prompt(`请输入新的最小值 (当前: ${Number.isFinite(entry.min) ? entry.min : 'NaN'}):`, String(entry.min));
              const newMin = this._parseOrEvaluateInput(newMinString);
              if (newMin !== null) {
                  if (Number.isFinite(entry.max) && newMin >= entry.max) {
                      alert('最小值必须小于当前或新设定的最大值。 跳过更新最小值。');
                  } else {
                       entry.min = newMin;
                  }
              }

              const newMaxString = prompt(`请输入新的最大值 (当前: ${Number.isFinite(entry.max) ? entry.max : 'NaN'}):`, String(entry.max));
              const newMax = this._parseOrEvaluateInput(newMaxString);
              if (newMax !== null) {
                   if (Number.isFinite(entry.min) && newMax <= entry.min) {
                        alert('最大值必须大于当前或新设定的最小值。 跳过更新最大值。');
                   } else {
                        entry.max = newMax;
                   }
              }

              const newStepString = prompt(`请输入新的步长 (必须大于0, 当前: ${Number.isFinite(entry.step) ? entry.step : 'NaN'}):`, String(entry.step));
              const newStep = this._parseOrEvaluateInput(newStepString);
              if (newStep !== null) {
                  if (newStep > 0) {
                      entry.step = newStep;
                  } else {
                       alert('步长必须大于零。 跳过更新步长。');
                  }
              }
         }

         if (Number.isFinite(entry.min) && tempNewValue < entry.min) {
             tempNewValue = entry.min;
         }
         if (Number.isFinite(entry.max) && tempNewValue > entry.max) {
             tempNewValue = entry.max;
         }

         if (entry.value !== tempNewValue) {
            entry.value = tempNewValue;
            entry.playDirection = 1;
         }

         this.recalculateAll();
    }

 promptEditSliderProperty(index, property, currentValue) {
         const entry = this.entries[index];
         if (!entry || entry.type !== 'variable' || !entry.isEditableIndependent) return;

         if (window.globalOpenKeyboardForValue) {
             window.globalOpenKeyboardForValue(currentValue, (newValueString) => {
                 const newValue = this._parseOrEvaluateInput(newValueString);
                 if (newValue !== null) {
                     if (property === 'step' && newValue <= 0) {
                          alert('步长必须大于 0。');
                          return;
                     }
                     if (property === 'min' && Number.isFinite(entry.max) && newValue >= entry.max) {
                         alert('最小值必须小于最大值。');
                         return;
                     }
                     if (property === 'max' && Number.isFinite(entry.min) && newValue <= entry.min) {
                          alert('最大值必须大于最小值。');
                         return;
                     }

                    entry[property] = newValue;

                    if (Number.isFinite(entry.min) && Number.isFinite(entry.value) && entry.value < entry.min) entry.value = entry.min;
                    if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;

                    this.recalculateAll();
                }
             });
         }
    }


promptEditParametricRange(param) {
    const currentValue = param === 'tmin' ? this.tmin : this.tmax;
    

    if (window.globalOpenKeyboardForValue) {
        window.globalOpenKeyboardForValue(currentValue, (newValueString) => {
            const parsedValue = this._parseOrEvaluateInput(newValueString);
            if (parsedValue === null) return;

            if (param === 'tmin') {
               if (parsedValue >= this.tmax) {
                   alert('tmin 必须小于 tmax。');
                   return;
               }
               this.tmin = parsedValue;
            } else {
               if (parsedValue <= this.tmin) {
                   alert('tmax 必须大于 tmin。');
                   return;
               }
               this.tmax = parsedValue;
            }

            this.updateParametricRangeLabels();
            this.entries.forEach(entry => {
               if (entry.plotType === 'parametric') {
                   entry.cachedPoints = [];
                   entry.webglVertices = null;
               }
            });
            this.requestDraw();
        });
    }
}


handleVariableSliderChange(e) {
}

handleColorSliderChange(e) {
}

hsbToRgba(h_100, s_100, b_100, a_100) {
let h = h_100 * 3.6;
let s = s_100 / 100;
let v = b_100 / 100;
let alpha = 1.0 - (a_100 / 100);

let i = Math.floor(h / 60);
let f = (h / 60) - i;
let p = v * (1 - s);
let q = v * (1 - f * s);
let t = v * (1 - (1 - f) * s);

let r, g, b;
switch (i % 6) {
   case 0: r = v; g = t; b = p; break;
   case 1: r = q; g = v; b = p; break;
   case 2: r = p; g = v; b = t; break;
   case 3: r = p; g = q; b = v; break;
   case 4: r = t; g = p; b = v; break;
   case 5: r = v; g = p; b = q; break;
   default: r = 0; g = 0; b = 0; break;
}
return `rgba(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)}, ${alpha})`;
}

hsbToRgbaArray(h_100, s_100, b_100, a_100) {
    const alpha = 1.0 - (a_100 / 100);
    if (this.isDarkModeActive && b_100 === 0) {
        return [1.0, 1.0, 1.0, alpha];
    }

    let temp_h_100 = h_100;
    let temp_s_100 = s_100;
    let temp_b_100 = b_100;

    if (this.isDarkModeActive) {
        if (temp_b_100 < 35) temp_b_100 = 35;
    } else {
        if (temp_s_100 < 15 && temp_b_100 > 85) temp_b_100 = 85;
    }
    
    let h = temp_h_100 * 3.6;
    let s = temp_s_100 / 100;
    let v = temp_b_100 / 100;

    let i = Math.floor(h / 60);
    let f = (h / 60) - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);

    let r, g, b_val;
    switch (i % 6) {
       case 0: r = v; g = t; b_val = p; break;
       case 1: r = q; g = v; b_val = p; break;
       case 2: r = p; g = v; b_val = t; break;
       case 3: r = p; g = q; b_val = v; break;
       case 4: r = t; g = p; b_val = v; break;
       case 5: r = v; g = p; b_val = q; break;
       default: r = 0; g = 0; b_val = 0; break;
    }

    if (this.colorInversionEnabled && this.isDarkModeActive) {
        r = 1.0 - r;
        g = 1.0 - g;
        b_val = 1.0 - b_val;
    }

    return [r, g, b_val, alpha];
}


hsbToHex(h_100, s_100, b_100) {
const rgba = this.hsbToRgba(h_100, s_100, b_100, 0);
const parts = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
if (!parts) return '#000000';

const toHex = (c) => {
    const hex = parseInt(c, 10).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
};

return `#${toHex(parts[1])}${toHex(parts[2])}${toHex(parts[3])}`;
}
parseInputInternal(lowercaseInput, originalInput, ignoreIndex = -1, existingUserSymbolNames = new Set()) {
        if (originalInput.trim().startsWith('//')) {
            return { type: 'text', name: this.autonameText(), content: originalInput.trim().substring(2).trim(), expr: originalInput.trim(), color: { h: 0, s: 0, b: 60, a: 0 }, expanded: false };
        }
        originalInput = originalInput.replace(/\s+/g, '');
        lowercaseInput = originalInput.toLowerCase();

        if (originalInput.startsWith('/-/')) return this.parsePointList(originalInput, ignoreIndex);

        const keywordMatch = originalInput.match(/^([a-zA-Z_][\w]*)\(/);
        if (keywordMatch && this.geometryKeywords.has(keywordMatch[1].toLowerCase())) {
            return this.parseGeometryDefinition(originalInput, ignoreIndex);
        }

        const currentExistingSymbols = new Set([
            ...this.calcJSUtils.calc1, ...this.calcJSUtils.calc3, ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex).map(e => (e.key || e.name)?.toLowerCase()).filter(Boolean),
            ...existingUserSymbolNames
        ]);
        
        let entryData = { 
            type: null, expr: originalInput, dependencies: [], hasLargeOps: false, 
            webglVertices: null, compilationError: undefined, extendTo3D: false, sliceAxis: 'none', sliceVal: 0
        };
        let rawExprForParsing = "";
        let potentialNewVariables = [];
        let excludeParamsForDepExtraction = [];

        const logicMatch = originalInput.match(/^(.*?)(>=|<=|>|<|=)(.*)$/s);

        if (logicMatch) {
            const lhsRaw = logicMatch[1].trim();
            const operator = logicMatch[2].trim();
            const rhsRaw = logicMatch[3].trim();
            const param3DMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+?)\s*,\s*z\s*=\s*(.+)\s*$/i);
            const parametricMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+)\s*$/i);

            if (param3DMatch && operator === '=') {
                entryData.type = 'function'; entryData.plotType = 'parametric3d'; excludeParamsForDepExtraction = ['t'];
            } else if (parametricMatch && operator === '=') {
                entryData.type = 'function'; entryData.plotType = 'parametric'; excludeParamsForDepExtraction = ['t'];
            } else {
                const isVariableNaming = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(lhsRaw) && operator === '=';
                const isReservedPlotVar = ['x', 'y', 'z', 't'].includes(lhsRaw.toLowerCase());
                const isKnownFunction = this.calcJSUtils.calc1.includes(lhsRaw.toLowerCase()) || this.calcJSUtils.constants.hasOwnProperty(lhsRaw.toLowerCase()) || this.disallowedVariableKeys.has(lhsRaw.toLowerCase());

                if (isVariableNaming && !isReservedPlotVar && !isKnownFunction) {
                    entryData.type = 'variable'; entryData.name = lhsRaw; entryData.key = lhsRaw.toLowerCase();
                    rawExprForParsing = rhsRaw; excludeParamsForDepExtraction = [];
                    entryData.isEditableIndependent = /^-?\d+(\.\d*)?([eE][-+]?\d+)?$/.test(rhsRaw);
                    if (entryData.isEditableIndependent) {
                        const initialValue = parseFloat(rhsRaw);
                        entryData.value = Number.isFinite(initialValue) ? initialValue : 0;
                        const absValue = Math.abs(entryData.value);
                        let defaultMin, defaultMax;
                        if (entryData.value === 0) { defaultMin = -10; defaultMax = 10;} 
                        else { defaultMin = -2 * absValue; defaultMax = 2 * absValue; }
                        if (defaultMin >= defaultMax) { defaultMin = defaultMax - 100; if (defaultMin >= defaultMax) defaultMax = defaultMin + 200; }
                        entryData.min = defaultMin; entryData.max = defaultMax; entryData.step = 0.02;
                        entryData.playState = 0; entryData.playDirection = 1; entryData.playMode = 0;
                    }
                } else if (lhsRaw.endsWith(')') && operator === '=') {
                    const funcDefMatch = originalInput.match(/^([a-zA-Z_][\w]*)\s*\(([^)]*)\)\s*=\s*(.+)$/s);
                    if (funcDefMatch) {
                        const definedFuncData = this.defineCalcJSFunction(originalInput, true);
                        if (definedFuncData) {
                            if (definedFuncData.type === 'custom_function_definition') {
                                entryData = {
                                    type: 'custom_function_definition', name: definedFuncData.name, params: definedFuncData.params,
                                    body: definedFuncData.rawBodyString, expr: definedFuncData.originalExpression, compilationError: undefined,
                                    hasLargeOps: definedFuncData.bodyTokens.some(t => ['sum', 'prod', 'int'].includes(t))
                                };
                                entryData.dependencies = this._extractDependenciesFromTokensWithLargeOps(
                                    definedFuncData.bodyTokens, definedFuncData.params,
                                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames, currentExistingSymbols
                                );
                                return entryData;
                            } else {
                                return { type: 'advanced_custom_function_definition', name: definedFuncData.name, params: definedFuncData.params, bodyJs: definedFuncData.bodyJs, expr: `${definedFuncData.name}(${definedFuncData.params.join(',')}) { /* JS body */ }`, dependencies: [], compilationError: undefined };
                            }
                        }
                    }
                }
                
                if (!entryData.type) {
                    const rhsTokens = this.improvedTokenize(rhsRaw, currentExistingSymbols);
                    if (lhsRaw.toLowerCase() === 'y' && operator === '=') {
                        // 修复 Bug 3：检测右侧是否包含 y，如果是，强制转为隐函数
                        if (rhsTokens.includes('y')) { 
                            entryData.type = 'function'; entryData.plotType = 'implicit'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y']; 
                        } else { 
                            entryData.type = 'function'; 
                            if (rhsRaw.includes('z')) { entryData.plotType = 'y3d'; excludeParamsForDepExtraction = ['x', 'z']; } 
                            else { entryData.plotType = 'y'; excludeParamsForDepExtraction = ['x']; } 
                            rawExprForParsing = rhsRaw; 
                        }
                    } else if (lhsRaw.toLowerCase() === 'x' && operator === '=') {
                        if (rhsTokens.includes('x')) { 
                            entryData.type = 'function'; entryData.plotType = 'implicit'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y']; 
                        } else { 
                            entryData.type = 'function'; 
                            if (rhsRaw.includes('z')) { entryData.plotType = 'x3d'; excludeParamsForDepExtraction = ['y', 'z']; } 
                            else { entryData.plotType = 'x'; excludeParamsForDepExtraction = ['y']; } 
                            rawExprForParsing = rhsRaw; 
                        }
                    } else if (lhsRaw.toLowerCase() === 'z' && operator === '=') {
                        // 修复 Bug 3：检测右侧是否包含 z，如果是，强制转为隐函数
                        if (rhsTokens.includes('z')) {
                            entryData.type = 'function'; entryData.plotType = 'implicit3d'; entryData.sign = '='; 
                            rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`; excludeParamsForDepExtraction = ['x', 'y', 'z']; 
                        } else {
                            entryData.type = 'function'; entryData.plotType = 'z'; excludeParamsForDepExtraction = ['x', 'y']; rawExprForParsing = rhsRaw;
                        }
                    } else {
                        entryData.type = 'function';
                        const tempTokens = this.improvedTokenize(originalInput, currentExistingSymbols);
                        const hasZ = tempTokens.includes('z');
                        if (hasZ) { entryData.plotType = 'implicit3d'; excludeParamsForDepExtraction = ['x', 'y', 'z']; } 
                        else { entryData.plotType = 'implicit'; excludeParamsForDepExtraction = ['x', 'y']; }
                        entryData.sign = operator; rawExprForParsing = `(${lhsRaw})-(${rhsRaw})`;
                    }
                }
            }
        } else {
            // 没有等号的情况
            const tempTokens = this.improvedTokenize(originalInput, currentExistingSymbols);
            const hasX = tempTokens.includes('x'), hasY = tempTokens.includes('y'), hasZ = tempTokens.includes('z');

            if (hasX && hasY && hasZ) {
                entryData.type = 'function'; entryData.plotType = 'implicit3d'; entryData.sign = '='; rawExprForParsing = `(${originalInput})-(0)`; excludeParamsForDepExtraction = ['x', 'y', 'z']; entryData.expr = `${originalInput}=0`;
            } else if (hasX && hasY) {
                entryData.type = 'function';
                if (this.is3DMode) { entryData.plotType = 'z'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `z=${originalInput}`; } 
                else { entryData.plotType = 'implicit'; entryData.sign = '='; rawExprForParsing = `(${originalInput})-(0)`; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `${originalInput}=0`; }
            } else if (hasX && hasZ) { entryData.type = 'function'; entryData.plotType = 'y3d'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'z']; entryData.expr = `y=${originalInput}`;
            } else if (hasY && hasZ) { entryData.type = 'function'; entryData.plotType = 'x3d'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['y', 'z']; entryData.expr = `x=${originalInput}`;
            } else if (hasZ) { entryData.type = 'function'; entryData.plotType = 'z'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x', 'y']; entryData.expr = `z=${originalInput}`;
            } else if (hasX) { entryData.type = 'function'; entryData.plotType = 'y'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['x']; entryData.expr = `y=${originalInput}`;
            } else if (hasY) { entryData.type = 'function'; entryData.plotType = 'x'; rawExprForParsing = originalInput; excludeParamsForDepExtraction = ['y']; entryData.expr = `x=${originalInput}`;
            } else {
                entryData.type = 'variable'; entryData.name = this.autonameConstant(); entryData.key = entryData.name.toLowerCase();
                entryData.expr = `${entryData.name}=${originalInput}`; rawExprForParsing = originalInput; excludeParamsForDepExtraction = []; entryData.isEditableIndependent = false;
            }
        }

        if (entryData.plotType === 'parametric' || entryData.plotType === 'parametric3d') {
            const processComponent = (rawExpr, componentSuffix) => {
                let tokens = this.improvedTokenize(rawExpr, currentExistingSymbols);
                
                let expanded = this.calcJSUtils.expandCustomFunctions.call(this.calcJSUtils, tokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
                let fullyExpanded = this.calcJSUtils.expandDiffOperations.call(this.calcJSUtils, expanded, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
                
                let hasLargeOps = fullyExpanded.some(t => ['sum', 'prod', 'int'].includes(t));

                const deps = this._extractDependenciesFromTokensWithLargeOps(fullyExpanded, excludeParamsForDepExtraction, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames, currentExistingSymbols);
                deps.forEach(dep => potentialNewVariables.push(dep));
                
                // 修复 Bug 1：强制保存 token 列表，无论是否有 large ops
                entryData[`largeOpTokens${componentSuffix}`] = fullyExpanded;
                if (!hasLargeOps) {
                    entryData[`processedExpr${componentSuffix}`] = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, fullyExpanded).join('');
                }
                entryData[`expr${componentSuffix}_raw`] = rawExpr;
                return hasLargeOps;
            };

            const param3DMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+?)\s*,\s*z\s*=\s*(.+)\s*$/i);
            const parametricMatch = lowercaseInput.match(/^\s*x\s*=\s*(.+?)\s*,\s*y\s*=\s*(.+)\s*$/i);

            if (param3DMatch) {
                const hasX = processComponent(param3DMatch[1].trim(), 'X');
                const hasY = processComponent(param3DMatch[2].trim(), 'Y');
                const hasZ = processComponent(param3DMatch[3].trim(), 'Z');
                entryData.hasLargeOps = hasX || hasY || hasZ;
            } else if (parametricMatch) {
                const hasX = processComponent(parametricMatch[1].trim(), 'X');
                const hasY = processComponent(parametricMatch[2].trim(), 'Y');
                entryData.hasLargeOps = hasX || hasY;
            }
            entryData.dependencies = Array.from(new Set(potentialNewVariables));
        } else if (rawExprForParsing) {
            let tokens = this.improvedTokenize(rawExprForParsing, currentExistingSymbols);
            let expandedCustomFuncTokens = this.calcJSUtils.expandCustomFunctions.call(this.calcJSUtils, tokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
            let fullyExpandedTokens = this.calcJSUtils.expandDiffOperations.call(this.calcJSUtils, expandedCustomFuncTokens, this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, this.calcJSUtils.constants, this.calcJSUtils.calc1, this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames);
            
            potentialNewVariables.push(...this._extractDependenciesFromTokensWithLargeOps(
                fullyExpandedTokens, excludeParamsForDepExtraction,
                this.calcJSUtils.customFunctions, this.calcJSUtils.calc3, 
                this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                currentExistingSymbols
            ));
            
            entryData.hasLargeOps = fullyExpandedTokens.some(t => ['sum', 'prod', 'int'].includes(t));
            if (entryData.hasLargeOps) { 
                entryData.largeOpTokens = fullyExpandedTokens;
            } else {
                entryData.processedExpr = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, fullyExpandedTokens).join('');
            }
            entryData.dependencies = Array.from(new Set(potentialNewVariables));
        }

        const blockingSymbols = new Set([
            ...this.calcJSUtils.calc1, ...this.calcJSUtils.calc3, ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex && (e.type === 'variable' || e.type === 'constant' || e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition')).map(e => e.key || e.name).filter(Boolean).map(k => k.toLowerCase())
        ]);

        entryData.dependencies.forEach(depKey => {
            if (depKey.length === 1 && this.allowedVariableKeys.has(depKey) && !blockingSymbols.has(depKey)) {
                const initialValueForNewVar = 1;
                this.entries.push({
                   type: 'variable', name: depKey, key: depKey,
                   expr: `${depKey}=${initialValueForNewVar}`,
                   processedExpr: String(initialValueForNewVar), 
                   hasLargeOps: false, largeOpTokens: null,
                   dependencies: [], isEditableIndependent: true,
                   value: initialValueForNewVar, min: -2, max: 2, step: 0.05,
                   sliderActive: false, playState: 0, playDirection: 1, playMode: 0,
                   compilationError: undefined
               });
               blockingSymbols.add(depKey);
            }
        });

        if (entryData.type !== 'variable' && entryData.type !== 'text' && entryData.type !== 'point_list') {
           entryData.color = { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
           entryData.thickness = 3; entryData.displayFrame = 0; entryData.expanded = false; entryData.visible = true;
        }

        return entryData;
    }

            improvedTokenize(expression, knownSymbolsSet) {
        if (!expression) return [];
        let expr = expression.toLowerCase().replace(/\s+/g, '');

                const staticTokens = ['sum', 'prod', 'int', 'diff', 'diffat', 'x', 'y', 'z', 't'];
        const allSymbols = Array.from(new Set([...knownSymbolsSet, ...staticTokens]));
        
        allSymbols.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length;
            return a.localeCompare(b);
        });

        
        let segments = [expr];

        for (const sym of allSymbols) {
            const newSegments = [];
            for (const seg of segments) {
                if (typeof seg !== 'string') {
                    newSegments.push(seg);                    continue;
                }
                
                let remaining = seg;
                                while (true) {
                    const idx = remaining.indexOf(sym);
                    if (idx === -1) {
                        if (remaining.length > 0) newSegments.push(remaining);
                        break;
                    }
                    
                                        if (idx > 0) {
                        newSegments.push(remaining.substring(0, idx));
                    }
                                    newSegments.push({ type: 'token', value: sym });
                    
                                        remaining = remaining.substring(idx + sym.length);
                }
            }
            segments = newSegments;
        }

        
        const finalTokens = [];
        
        for (const seg of segments) {
            if (typeof seg !== 'string') {
                            finalTokens.push(seg.value);
                continue;
            }

                        let i = 0;
            const len = seg.length;
            while (i < len) {
                const char = seg[i];

                if (/[0-9.]/.test(char)) {
                    let numStr = char;
                    let j = i + 1;
                    while (j < len && /[0-9.]/.test(seg[j])) {
                        numStr += seg[j];
                        j++;
                    }
                                        if ((numStr.match(/\./g) || []).length > 1) {
                         finalTokens.push(char);
                         i++;
                         continue;
                    }
                    finalTokens.push(numStr);
                    i = j;
                } 
else if (['+', '-', '*', '/', '^', ',', '(', ')', '=', '<', '>'].includes(char)) {
                    finalTokens.push(char);
                    i++;
                } 
                else if (/[a-z_]/.test(char)) {
                    let id = char;
                    let j = i + 1;
                    while (j < len && /[a-z0-9_]/.test(seg[j])) {
                        id += seg[j];
                        j++;
                    }
                    finalTokens.push(id);
                    i = j;
                }
                else {
                    
                    finalTokens.push(char);
                    i++;
                }
            }
        }

        return finalTokens;
    }


    parseGeometryDefinition(originalInput, ignoreIndex = -1) {
        const firstParen = originalInput.indexOf('(');
        const lastParen = originalInput.lastIndexOf(')');
        if (firstParen === -1 || lastParen === -1 || lastParen < firstParen) {
            throw new Error("几何对象定义格式错误: 括号不匹配。");
        }
        
        const keyword = originalInput.substring(0, firstParen).trim().toLowerCase();
        const paramString = originalInput.substring(firstParen + 1, lastParen).trim();
        
        const params = [];
        let parenLevel = 0;
        let lastSplit = 0;
        for (let i = 0; i < paramString.length; i++) {
            if (paramString[i] === '(') parenLevel++;
            else if (paramString[i] === ')') parenLevel--;
            else if (paramString[i] === ',' && parenLevel === 0) {
                params.push(paramString.substring(lastSplit, i).trim());
                lastSplit = i + 1;
            }
        }
        params.push(paramString.substring(lastSplit).trim());
        
        if (params.length === 1 && params[0] === "") {
            params.length = 0;
        }

        const name = params.length > 0 ? params[0] : this.autonameText();
        const isNameTaken = this.entries.some((e, i) => 
            i !== ignoreIndex && e.name && e.name.toLowerCase() === name.toLowerCase() && e.type !== 'variable' && e.type !== 'constant'
        );
        if (isNameTaken) {
            throw new Error(`创建或编辑失败：几何或函数名称 "${name}" 已被占用。`);
        }

const entry = {
            type: 'geometry',
            geometryType: keyword,
            expr: originalInput,
            name: name,
            dependencies: [],
            variableDependencies: [],
            objectDependencies: [],
            isMeaningful: false,
            visible: true,
            color: this.isDarkModeActive ? { h: 0, s: 0, b: 100, a: 0 } : { h: 0, s: 0, b: 0, a: 0 },
            thickness: 3,
            displayFrame: 0,
            webglVertices: null,
            webglFillVertices: null,
            compilationError: undefined
        };
        
        const allVarDeps = new Set();
        const allObjDeps = new Set();
        const existingSymbolNames = new Set(
            this.entries
                .filter((e, i) => i !== ignoreIndex)
                .map(e => (e.key || e.name)?.toLowerCase())
                .filter(Boolean)
        );
        
        const geometryObjectMapForParsing = new Map();
        this.entries.forEach((e, i) => {
            if (i !== ignoreIndex && e.type === 'geometry' && e.name) {
                geometryObjectMapForParsing.set(e.name.toLowerCase(), e);
            }
        });

        const parseAndAddExpressionDeps = (exprStr) => {
            if (!exprStr || typeof exprStr !== 'string') return;
            try {
                const tokens = this.calcJSUtils.tokenize(exprStr);
                const exprDeps = this._extractDependenciesFromTokensWithLargeOps(
                    tokens, [],
                    this.calcJSUtils.customFunctions, this.calcJSUtils.calc3,
                    this.calcJSUtils.constants, this.calcJSUtils.calc1, this.allowedVariableKeys,
                    this.calcJSUtils.advancedCustomFunctions, this.calcJSUtils.advancedCustomFunctionNames,
                    existingSymbolNames
                );
                exprDeps.forEach(dep => allVarDeps.add(dep));
            } catch (e) {}
        };

        const addObjectNameDep = (nameStr) => {
            if (nameStr && typeof nameStr === 'string') {
                allObjDeps.add(nameStr.toLowerCase());
            }
        };

        switch(keyword) {
            case 'point': {
                if (params.length !== 3) throw new Error("point 定义需要3个参数: point(名称, x/对象, y/参数)");
                const potentialObjectName = params[1].toLowerCase();
                const potentialObject = geometryObjectMapForParsing.get(potentialObjectName);
                if (potentialObject && !['point', 'midpoint', 'intercept'].includes(potentialObject.geometryType)) {
                    entry.pointOnObject = true;
                    entry.onObjectName = params[1];
                    entry.parameter_expr = params[2];
                    addObjectNameDep(entry.onObjectName);
                    parseAndAddExpressionDeps(entry.parameter_expr);
                } else {
                    entry.pointOnObject = false;
                    entry.x_expr = params[1];
                    entry.y_expr = params[2];
                    parseAndAddExpressionDeps(entry.x_expr);
                    parseAndAddExpressionDeps(entry.y_expr);
                }
                break;
            }
            case 'midpoint':
                if (params.length !== 3) throw new Error("midpoint 定义需要3个参数: midpoint(名称, 点1名称, 点2名称)");
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'intercept':
                if (params.length < 3 || params.length > 4) throw new Error("intercept 定义需要3或4个参数: intercept(名称, 对象1, 对象2, [符号])");
                entry.obj1Name = params[1];
                entry.obj2Name = params[2];
                entry.sign = params.length === 4 ? parseFloat(params[3]) : 1;
                if (isNaN(entry.sign) || (entry.sign !== 1 && entry.sign !== -1)) throw new Error("intercept 的第四个参数 (符号) 必须是 1 或 -1");
                addObjectNameDep(entry.obj1Name);
                addObjectNameDep(entry.obj2Name);
                break;
            case 'segment': case 'ray': case 'line': case 'vector':
                if (params.length !== 3) throw new Error(`${keyword} 定义需要3个参数: ${keyword}(名称, 起始点, 结束点)`);
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'perpendicularline':
                if (params.length !== 3) throw new Error("perpendicularline 定义需要3个参数: perpendicularline(名称, 线, 点)");
                entry.lineName = params[1];
                entry.pointName = params[2];
                addObjectNameDep(entry.lineName);
                addObjectNameDep(entry.pointName);
                break;
            case 'parallelline':
                if (params.length !== 3) throw new Error("parallelline 定义需要3个参数: parallelline(名称, 线, 点)");
                entry.lineName = params[1];
                entry.pointName = params[2];
                addObjectNameDep(entry.lineName);
                addObjectNameDep(entry.pointName);
                break;
            case 'anglebisector':
                if (params.length !== 4) throw new Error("anglebisector 定义需要4个参数: anglebisector(名称, 点1, 顶点, 点3)");
                entry.p1Name = params[1];
                entry.vertexName = params[2];
                entry.p3Name = params[3];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.vertexName);
                addObjectNameDep(entry.p3Name);
                break;
            case 'circle':
                if (params.length !== 3) throw new Error("circle 定义需要3个参数: circle(名称, 圆心, 半径或点)");
                entry.centerName = params[1];
                addObjectNameDep(entry.centerName);
                const radiusOrPoint = params[2];
                if (geometryObjectMapForParsing.has(radiusOrPoint.toLowerCase())) {
                    entry.pointOnCircleName = radiusOrPoint;
                    addObjectNameDep(entry.pointOnCircleName);
                } else {
                    entry.radius_expr = radiusOrPoint;
                    parseAndAddExpressionDeps(entry.radius_expr);
                }
                break;
case 'ellipse':
            if (params.length === 4) {
                entry.f1Name = params[1];
                entry.f2Name = params[2];
                entry.pName = params[3];
                addObjectNameDep(entry.f1Name);
                addObjectNameDep(entry.f2Name);
                addObjectNameDep(entry.pName);
            } else if (params.length === 3) {
                entry.geometryType = 'ellipse_ab';
                entry.a_expr = params[1];
                entry.b_expr = params[2];
                parseAndAddExpressionDeps(entry.a_expr);
                parseAndAddExpressionDeps(entry.b_expr);
            } else {
                throw new Error("ellipse 定义需要3个参数 ellipse(名称, a, b) 或4个参数 ellipse(名称, 焦点1, 焦点2, 点)");
            }
            break;
        case 'hyperbola':
            if (params.length !== 4) throw new Error(`${keyword} 定义需要4个参数: ${keyword}(名称, 焦点1, 焦点2, 点)`);
            entry.f1Name = params[1];
            entry.f2Name = params[2];
            entry.pName = params[3];
            addObjectNameDep(entry.f1Name);
            addObjectNameDep(entry.f2Name);
            addObjectNameDep(entry.pName);
            break;
            case 'parabola':
                if (params.length !== 3) throw new Error("parabola 定义需要3个参数: parabola(名称, 焦点, 准线)");
                entry.focusName = params[1];
                entry.directrixName = params[2];
                addObjectNameDep(entry.focusName);
                addObjectNameDep(entry.directrixName);
                break;
            case 'polygon':
                if (params.length < 2) throw new Error("polygon 定义至少需要2个参数: polygon(名称, 顶点数, ...顶点名称)");
                const numVertices = parseInt(params[1], 10);
                if (isNaN(numVertices) || numVertices < 3) throw new Error("polygon 第2个参数必须是大于等于3的整数 (顶点数)");
                if (params.length !== numVertices + 2) throw new Error(`polygon 顶点数量与声明不符: 期望 ${numVertices}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
                case 'length':
                if (params.length !== 3) throw new Error("length 定义需要3个参数: length(名称, 点1, 点2)");
                entry.p1Name = params[1];
                entry.p2Name = params[2];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                break;
            case 'angle':
                if (params.length !== 4) throw new Error("angle 定义需要4个参数: angle(名称, 点1, 顶点, 点3)");
                entry.p1Name = params[1];
                entry.vertexName = params[2];
                entry.p3Name = params[3];
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.vertexName);
                addObjectNameDep(entry.p3Name);
                break;
            case 'area':
                if (params.length < 2) throw new Error("area 定义至少需要2个参数: area(名称, 顶点数, ...顶点名称)");
                const numAreaVertices = parseInt(params[1], 10);
                if (isNaN(numAreaVertices) || numAreaVertices < 3) throw new Error("area 第2个参数必须是大于等于3的整数 (顶点数)");
                if (params.length !== numAreaVertices + 2) throw new Error(`area 顶点数量与声明不符: 期望 ${numAreaVertices}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
                            case 'isparallel':
                if (params.length === 2) {
                    entry.name = this.autonameByPrefix('isparallel');
                    entry.l1Name = params[0];
                    entry.l2Name = params[1];
                } else if (params.length === 3) {
                    entry.name = params[0];
                    entry.l1Name = params[1];
                    entry.l2Name = params[2];
                } else {
                    throw new Error("isparallel 定义需要2或3个参数: isparallel(线1, 线2) 或 isparallel(名称, 线1, 线2)");
                }
                addObjectNameDep(entry.l1Name);
                addObjectNameDep(entry.l2Name);
                break;
            case 'isperpendicular':
                if (params.length === 2) {
                    entry.name = this.autonameByPrefix('isperp');
                    entry.l1Name = params[0];
                    entry.l2Name = params[1];
                } else if (params.length === 3) {
                    entry.name = params[0];
                    entry.l1Name = params[1];
                    entry.l2Name = params[2];
                } else {
                    throw new Error("isperpendicular 定义需要2或3个参数: isperpendicular(线1, 线2) 或 isperpendicular(名称, 线1, 线2)");
                }
                addObjectNameDep(entry.l1Name);
                addObjectNameDep(entry.l2Name);
                break;
            case 'isconcyclic':
                if (params.length === 4) {
                    entry.name = this.autonameByPrefix('isconcyclic');
                    entry.p1Name = params[0]; entry.p2Name = params[1]; entry.p3Name = params[2]; entry.p4Name = params[3];
                } else if (params.length === 5) {
                    entry.name = params[0];
                    entry.p1Name = params[1]; entry.p2Name = params[2]; entry.p3Name = params[3]; entry.p4Name = params[4];
                } else {
                    throw new Error("isconcyclic 定义需要4或5个参数: isconcyclic(点1, 点2, 点3, 点4) 或 isconcyclic(名称, ...)");
                }
                addObjectNameDep(entry.p1Name);
                addObjectNameDep(entry.p2Name);
                addObjectNameDep(entry.p3Name);
                addObjectNameDep(entry.p4Name);
                break;
                            case 'rotate':
                if (params.length !== 4) throw new Error("rotate 定义需要4个参数: rotate(新点名, 旋转中心, 旋转点, 角度)");
                entry.centerName = params[1];
                entry.rotatedPointName = params[2];
                entry.angle_expr = params[3];
                addObjectNameDep(entry.centerName);
                addObjectNameDep(entry.rotatedPointName);
                parseAndAddExpressionDeps(entry.angle_expr);
                break;
            case 'reflect':
                if (params.length !== 3) throw new Error("reflect 定义需要3个参数: reflect(新点名, 对称轴/点, 作用点)");
                entry.axisName = params[1];
                entry.reflectedPointName = params[2];
                addObjectNameDep(entry.axisName);
                addObjectNameDep(entry.reflectedPointName);
                break;
            case 'translate':
                if (params.length === 3) {
                    entry.vectorName = params[1];
                    entry.translatedPointName = params[2];
                    addObjectNameDep(entry.vectorName);
                    addObjectNameDep(entry.translatedPointName);
                } else if (params.length === 4) {
                    entry.translatedPointName = params[1];
                    entry.dx_expr = params[2];
                    entry.dy_expr = params[3];
                    addObjectNameDep(entry.translatedPointName);
                    parseAndAddExpressionDeps(entry.dx_expr);
                    parseAndAddExpressionDeps(entry.dy_expr);
                } else {
                    throw new Error("translate 定义需要3或4个参数: translate(新点名, 向量, 作用点) 或 translate(新点名, 作用点, dx, dy)");
                }
                break;
                case 'fitline':
                if (params.length < 2) throw new Error("fitline 定义至少需要2个参数: fitline(名称, 顶点数, ...顶点名称)");
                const numFitPoints = parseInt(params[1], 10);
                if (isNaN(numFitPoints) || numFitPoints < 2) throw new Error("fitline 第2个参数必须是大于等于2的整数 (点数)");
                if (params.length !== numFitPoints + 2) throw new Error(`fitline 点数量与声明不符: 期望 ${numFitPoints}, 得到 ${params.length - 2}`);
                entry.pointNames = params.slice(2);
                entry.pointNames.forEach(pName => addObjectNameDep(pName));
                break;
 case 'circulararc':
                if (params.length !== 4) throw new Error("circulararc 定义需要4个参数: circulararc(名称, 圆心, 起始点, 终点)");
                entry.centerName = params[1];
                entry.startPointName = params[2];
                entry.endPointName = params[3];
                addObjectNameDep(entry.centerName);
                addObjectNameDep(entry.startPointName);
                addObjectNameDep(entry.endPointName);
                break;
            case 'tangent':
                if (params.length !== 4) throw new Error("tangent 定义需要4个参数: tangent(名称, 圆锥曲线, 点, 符号)");
                entry.conicName = params[1];
                entry.pointName = params[2];
                entry.sign = parseInt(params[3], 10);
                if (isNaN(entry.sign) || (entry.sign !== 1 && entry.sign !== -1)) throw new Error("tangent 的第四个参数 (符号) 必须是 1 或 -1");
                addObjectNameDep(entry.conicName);
                addObjectNameDep(entry.pointName);
                break;
            default:
                throw new Error(`未知的几何对象类型: ${keyword}`);
        }

entry.variableDependencies = Array.from(allVarDeps);
        entry.objectDependencies = Array.from(allObjDeps);
        entry.dependencies = Array.from(new Set([...allVarDeps, ...allObjDeps]));
        
        const blockingSymbols = new Set([
            ...this.calcJSUtils.calc1,
            ...this.calcJSUtils.calc3,
            ...this.calcJSUtils.advancedCustomFunctionNames,
            ...Object.keys(this.calcJSUtils.constants),
            ...this.entries.filter((e, i) => i !== ignoreIndex && (e.type === 'variable' || e.type === 'constant' || e.type === 'custom_function_definition' || e.type === 'advanced_custom_function_definition')).map(e => e.key || e.name).filter(Boolean).map(k => k.toLowerCase())
        ]);

        entry.variableDependencies.forEach(depKey => { 
           if (depKey.length === 1 && this.allowedVariableKeys.has(depKey) && !blockingSymbols.has(depKey)) {
               const initialValueForNewVar = 1;
               const newVarEntry = {
                   type: 'variable', name: depKey, key: depKey,
                   expr: `${depKey}=${initialValueForNewVar}`,
                   processedExpr: String(initialValueForNewVar), 
                   hasLargeOps: false, largeOpTokens: null,
                   dependencies: [], isEditableIndependent: true,
                   value: initialValueForNewVar, min: -2, max: 2, step: 0.05,
                   sliderActive: false, playState: 0, playDirection: 1,
                   compilationError: undefined
               };
               this.entries.push(newVarEntry);
               blockingSymbols.add(depKey);
           }
        });

        return entry;
    }

    recalculateVariableValues() {
        const maxIterations = 20;
        let iteration = 0;
        let changedInTotal = true;

        const independentVariableEntries = this.entries.filter(e => e.type === 'variable' && e.isEditableIndependent);
        const dependentVariableEntries = this.entries.filter(e => e.type === 'variable' && !e.isEditableIndependent);

        this.variables.clear();
        independentVariableEntries.forEach(entry => {
            if (Number.isFinite(entry.value)) {
                this.variables.set(entry.key, entry.value);
                entry.expr = `${entry.name}=${entry.value}`;
            } else {
                this.variables.set(entry.key, NaN);
            }
        });

        while (changedInTotal && iteration < maxIterations) {
           changedInTotal = false;

           for (const entry of dependentVariableEntries) {
               const allDependenciesDefined = entry.dependencies && Array.isArray(entry.dependencies) && entry.dependencies.every(depKey => this.variables.has(depKey) && Number.isFinite(this.variables.get(depKey)));

               let newValue = NaN;
               delete entry.compilationError;
               if (allDependenciesDefined || (entry.dependencies && entry.dependencies.length === 0)) {
                   try {
                        let exprToEval;
                        let tokensToUse;
                        if (entry.hasLargeOps) {
                             tokensToUse = entry.largeOpTokens;
                             exprToEval = null;
                        } else {
                             tokensToUse = null;
                             exprToEval = entry.processedExpr;
                        }

                        if (tokensToUse) {
                            newValue = this.evaluateExpressionWithCalcJS(tokensToUse, Object.fromEntries(this.variables));
                        } else if (exprToEval) {
                           const funcArgs = ['variables', 'Math', '__advanced__'];
                           const varDeclarations = Array.from(this.variables.keys()).map(depKey =>
                               `const ${depKey} = variables.has('${depKey}') ? variables.get('${depKey}') : NaN;`
                           ).join(' ');
                           const funcBody = `try { const variables = arguments[0]; const Math = arguments[1]; const __advanced__ = arguments[2]; ${varDeclarations} return (${exprToEval}); } catch(e) { return NaN; }`;
                           const expressionFunc = new Function(...funcArgs, funcBody);
                           newValue = expressionFunc(this.variables, Math, this.calcJSUtils.getAdvancedFuncsMap());
                        } else {
                            newValue = NaN;
                            entry.compilationError = "无有效表达式可求值";
                        }

                   } catch (e) {
                        newValue = NaN;
                        entry.compilationError = e.message;
                   }
               } else {
                    newValue = NaN;
                    if (entry.dependencies && entry.dependencies.length > 0) {
                        const missingDeps = entry.dependencies.filter(depKey => !this.variables.has(depKey) || !Number.isFinite(this.variables.get(depKey)));
                        if (missingDeps.length > 0) {
                             entry.compilationError = `依赖未定义: ${missingDeps.join(', ')}`;
                        }
                    }
               }

               const currentKeyForMap = entry.key;
               const oldValueInMap = this.variables.has(currentKeyForMap) ? this.variables.get(currentKeyForMap) : undefined;
               const valuesAreEqual = (v1, v2) => (Number.isNaN(v1) && Number.isNaN(v2)) || Math.abs(v1 - v2) < 1e-9;
                if (!valuesAreEqual(newValue, oldValueInMap)) {
                    this.variables.set(currentKeyForMap, newValue);
                    entry.value = newValue;
                    changedInTotal = true;
                } else {
                     entry.value = oldValueInMap;
                }
           }
           iteration++;
        }
        if (iteration === maxIterations && changedInTotal) {
           dependentVariableEntries.forEach(entry => {
                if(!entry.compilationError) entry.compilationError = "可能存在循环依赖";
           });
        }
    }

    recalculateGeometryObjects() {
    const geometryEntries = this.entries.filter(e => e.type === 'geometry');
    if (geometryEntries.length === 0) return;

    const objectMap = new Map();
    this.entries.forEach(e => {
        if (e.type === 'geometry' && e.name) {
            objectMap.set(e.name.toLowerCase(), e);
        }
    });

    const maxIterations = 20;
    let iteration = 0;
    let changedInIteration = true;

    while(changedInIteration && iteration < maxIterations) {
        changedInIteration = false;
        iteration++;

        for (const entry of geometryEntries) {
            const oldMeaningful = entry.isMeaningful;
            const oldValues = {x: entry.x_val, y: entry.y_val, r: entry.radius};

            let depsMeaningful = true;
            if (entry.variableDependencies) {
                for (const depName of entry.variableDependencies) {
                    if (!this.variables.has(depName) || !Number.isFinite(this.variables.get(depName))) {
                        depsMeaningful = false; 
                        break;
                    }
                }
            }
            if (depsMeaningful && entry.objectDependencies) {
                for (const depName of entry.objectDependencies) {
                    const depObj = objectMap.get(depName);
                    if (!depObj || !depObj.isMeaningful) {
                        depsMeaningful = false; 
                        break;
                    }
                }
            }

            if (!depsMeaningful) {
                entry.isMeaningful = false;
                if(oldMeaningful) changedInIteration = true;
                continue;
            }

            let newMeaningful = true;
            entry.compilationError = undefined;
            
            try {
                switch(entry.geometryType) {
                    case 'point': {
                        if (entry.pointOnObject) {
                            const onObject = objectMap.get(entry.onObjectName.toLowerCase());
                            if (!onObject || !onObject.isMeaningful) { newMeaningful = false; break; }
                            
                            const param = this.evaluateExpressionWithCalcJS(entry.parameter_expr, Object.fromEntries(this.variables));
                            if (!Number.isFinite(param)) { newMeaningful = false; break; }

                            const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);

                            if (isLineLike(onObject.geometryType)) {
                                if (['segment', 'vector'].includes(onObject.geometryType) && (param < 0 || param > 1)) {
                                    newMeaningful = false;
                                } else if (onObject.geometryType === 'ray' && param < 0) {
                                    newMeaningful = false;
                                }
                                
                                if (newMeaningful) {
                                    let p1_base, dir_to_use;
                                    if (onObject.p1 && (onObject.dir_vec || onObject.dir)) {
                                        p1_base = onObject.p1;
                                        dir_to_use = onObject.dir_vec || onObject.dir; 
                                        entry.x_val = p1_base.x_val + param * dir_to_use.x;
                                        entry.y_val = p1_base.y_val + param * dir_to_use.y;
                                    } else {
                                        newMeaningful = false;
                                    }
                                }

                            } else if (onObject.geometryType === 'circle') {
                                const angle = param * 2 * Math.PI;
                                entry.x_val = onObject.center.x_val + onObject.radius * Math.cos(angle);
                                entry.y_val = onObject.center.y_val + onObject.radius * Math.sin(angle);

                           } else if (onObject.geometryType === 'ellipse' || onObject.geometryType === 'ellipse_ab') {
                                if (!onObject.center || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const t = param * 2 * Math.PI;
                                const localX = onObject.a * Math.cos(t);
                                const localY = onObject.b * Math.sin(t);
                                entry.x_val = onObject.center.x + localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                entry.y_val = onObject.center.y + localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);

                            } else if (onObject.geometryType === 'hyperbola') {
                                if (!onObject.center || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const magic_offset = 100000;
                                let branch_sign = 1;
                                let t = param;

                                if (param < -magic_offset / 2) {
                                    branch_sign = -1;
                                    t = param + magic_offset;
                                }
                                
                                const localX = branch_sign * onObject.a * Math.cosh(t);
                                const localY = onObject.b * Math.sinh(t);
                                entry.x_val = onObject.center.x + localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                entry.y_val = onObject.center.y + localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);

                            } else if (onObject.geometryType === 'parabola') {
                                if (!onObject.vertex || onObject.rotation === undefined) { newMeaningful = false; break; }
                                const t = param;
                                const localX = (t * t) / (4 * onObject.p);
                                const localY = t;
                                const rotatedLocalX = localX * Math.cos(onObject.rotation) - localY * Math.sin(onObject.rotation);
                                const rotatedLocalY = localX * Math.sin(onObject.rotation) + localY * Math.cos(onObject.rotation);
                                entry.x_val = onObject.vertex.x + rotatedLocalX;
                                entry.y_val = onObject.vertex.y + rotatedLocalY;
                            } else if (onObject.geometryType === 'circulararc') {
                                if (!onObject.center || onObject.radius === undefined) { newMeaningful = false; break; }
                                let { startAngle, endAngle } = onObject;
                                if (endAngle < startAngle) endAngle += 2 * Math.PI;
                                
                                const angle = startAngle + param * (endAngle - startAngle);
                                entry.x_val = onObject.center.x_val + onObject.radius * Math.cos(angle);
                                entry.y_val = onObject.center.y_val + onObject.radius * Math.sin(angle);
                            }

                        } else {
                            const x = this.evaluateExpressionWithCalcJS(entry.x_expr, Object.fromEntries(this.variables));
                            const y = this.evaluateExpressionWithCalcJS(entry.y_expr, Object.fromEntries(this.variables));
                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                entry.x_val = x; entry.y_val = y;
                            } else newMeaningful = false;
                        }
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'midpoint': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        if (!p1 || !p2) { newMeaningful = false; break; }
                        entry.x_val = (p1.x_val + p2.x_val) / 2;
                        entry.y_val = (p1.y_val + p2.y_val) / 2;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                                        case 'rotate': {
                        const center = objectMap.get(entry.centerName.toLowerCase());
                        const p = objectMap.get(entry.rotatedPointName.toLowerCase());
                        if (!center || !p) { newMeaningful = false; break; }
                        const angle_deg = this.evaluateExpressionWithCalcJS(entry.angle_expr, Object.fromEntries(this.variables));
                        if (!Number.isFinite(angle_deg)) { newMeaningful = false; break; }
                        const angle_rad = angle_deg * (Math.PI / 180);
                        const cos_a = Math.cos(angle_rad);
                        const sin_a = Math.sin(angle_rad);
                        const rel_x = p.x_val - center.x_val;
                        const rel_y = p.y_val - center.y_val;
                        entry.x_val = center.x_val + rel_x * cos_a - rel_y * sin_a;
                        entry.y_val = center.y_val + rel_x * sin_a + rel_y * cos_a;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'reflect': {
                        const axis = objectMap.get(entry.axisName.toLowerCase());
                        const p = objectMap.get(entry.reflectedPointName.toLowerCase());
                        if (!axis || !p) { newMeaningful = false; break; }
                        
                        if (['point', 'midpoint', 'intercept'].includes(axis.geometryType)) {
                            entry.x_val = 2 * axis.x_val - p.x_val;
                            entry.y_val = 2 * axis.y_val - p.y_val;
                        } else {
                            const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                            if (!lineLike.includes(axis.geometryType) || !axis.p1 || !axis.dir) { newMeaningful = false; break; }
                            const {x_val: p1x, y_val: p1y} = axis.p1;
                            const {x: dirx, y: diry} = axis.dir;
                            const vec_ap = { x: p.x_val - p1x, y: p.y_val - p1y };
                            const t = vec_ap.x * dirx + vec_ap.y * diry;
                            const proj_x = p1x + t * dirx;
                            const proj_y = p1y + t * diry;
                            entry.x_val = 2 * proj_x - p.x_val;
                            entry.y_val = 2 * proj_y - p.y_val;
                        }
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                    case 'translate': {
                        const p = objectMap.get(entry.translatedPointName.toLowerCase());
                        if (!p) { newMeaningful = false; break; }
                        let dx = 0, dy = 0;
                        if (entry.vectorName) {
                            const v = objectMap.get(entry.vectorName.toLowerCase());
                            if (!v || !v.p1 || !v.p2) { newMeaningful = false; break; }
                            dx = v.p2.x_val - v.p1.x_val;
                            dy = v.p2.y_val - v.p1.y_val;
                        } else {
                            dx = this.evaluateExpressionWithCalcJS(entry.dx_expr, Object.fromEntries(this.variables));
                            dy = this.evaluateExpressionWithCalcJS(entry.dy_expr, Object.fromEntries(this.variables));
                            if (!Number.isFinite(dx) || !Number.isFinite(dy)) { newMeaningful = false; break; }
                        }
                        entry.x_val = p.x_val + dx;
                        entry.y_val = p.y_val + dy;
                        if (newMeaningful) {
                            entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                        }
                        break;
                    }
                 case 'intercept': {
                        const obj1 = objectMap.get(entry.obj1Name.toLowerCase());
                        const obj2 = objectMap.get(entry.obj2Name.toLowerCase());
                        if (!obj1 || !obj2 || !obj1.isMeaningful || !obj2.isMeaningful) { newMeaningful = false; break; }
                        
                        const type1 = obj1.geometryType;
                        const type2 = obj2.geometryType;
                        const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);
                        const isCircle = (t) => ['circle', 'circulararc'].includes(t);
                        const isConic = (t) => ['ellipse', 'hyperbola', 'parabola', 'ellipse_ab'].includes(t);
                        let intersectResult = null;

                        if (isLineLike(type1) && isLineLike(type2)) {
                            const {x_val: x1, y_val: y1} = obj1.p1;
                            const {x:dx1, y:dy1} = obj1.dir;
                            const {x_val: x2, y_val: y2} = obj2.p1;
                            const {x:dx2, y:dy2} = obj2.dir;
                            const det = dx1 * dy2 - dx2 * dy1;
                            if (Math.abs(det) < 1e-9) { newMeaningful = false; break; }
                            const t = ((x2 - x1) * dy2 - (y2 - y1) * dx2) / det;
                            intersectResult = { x: x1 + t * dx1, y: y1 + t * dy1 };
                        } else if ((isLineLike(type1) && isCircle(type2)) || (isCircle(type1) && isLineLike(type2))) {
                            const line = isLineLike(type1) ? obj1 : obj2;
                            const circle = isCircle(type1) ? obj1 : obj2;
                            const {x_val: lx, y_val: ly} = line.p1;
                            const {x:dx, y:dy} = line.dir;
                            const {x_val: cx, y_val: cy} = circle.center;
                            const r = circle.radius;
                            const A = dx*dx + dy*dy;
                            const B = 2 * (dx * (lx - cx) + dy * (ly - cy));
                            const C = (lx - cx)**2 + (ly - cy)**2 - r*r;
                            const discriminant = B*B - 4*A*C;
                            if (discriminant < -1e-9) { newMeaningful = false; break; }
                            const t = (-B + entry.sign * Math.sqrt(Math.max(0, discriminant))) / (2*A);
                            intersectResult = { x: lx + t * dx, y: ly + t * dy };
                        } else if (isCircle(type1) && isCircle(type2)) {
                            const {x_val: cx1, y_val: cy1} = obj1.center; const r1 = obj1.radius;
                            const {x_val: cx2, y_val: cy2} = obj2.center; const r2 = obj2.radius;
                            const d_sq = (cx1 - cx2)**2 + (cy1 - cy2)**2;
                            const d = Math.sqrt(d_sq);
                            if (d > r1 + r2 + 1e-9 || d < Math.abs(r1 - r2) - 1e-9 || d < 1e-9) { newMeaningful = false; break; }
                            const a = (r1*r1 - r2*r2 + d_sq) / (2*d);
                            const h = Math.sqrt(Math.max(0, r1*r1 - a*a));
                            const x_mid = cx1 + a * (cx2 - cx1) / d;
                            const y_mid = cy1 + a * (cy2 - cy1) / d;
                            intersectResult = { x: x_mid + entry.sign * h * (cy2 - cy1) / d, y: y_mid - entry.sign * h * (cx2 - cx1) / d };
                        } else if ((isLineLike(type1) && isConic(type2)) || (isConic(type1) && isLineLike(type2))) {
                            const line = isLineLike(type1) ? obj1 : obj2;
                            const conic = isConic(type1) ? obj1 : obj2;
                            const {x_val: x1, y_val: y1} = line.p1;
                            const {x:dx, y:dy} = line.dir;
                            let A=0, B=0, C=0;

                            if (conic.geometryType === 'ellipse' || conic.geometryType === 'hyperbola' || conic.geometryType === 'ellipse_ab') {
                                const {x: h, y: k} = conic.center;
                                const {a, b, rotation: r} = conic;
                                const cos_r = Math.cos(r), sin_r = Math.sin(r);
                                const x1_h = x1 - h, y1_k = y1 - k;
                                const T1 = cos_r * dx + sin_r * dy;
                                const T2 = -sin_r * dx + cos_r * dy;
                                const C1 = cos_r * x1_h + sin_r * y1_k;
                                const C2 = -sin_r * x1_h + cos_r * y1_k;
                                const sign = (conic.geometryType === 'ellipse' || conic.geometryType === 'ellipse_ab') ? 1 : -1;
                                A = T1*T1/(a*a) + sign*T2*T2/(b*b);
                                B = 2*C1*T1/(a*a) + 2*sign*C2*T2/(b*b);
                                C = C1*C1/(a*a) + sign*C2*C2/(b*b) - 1;
                            } else if (conic.geometryType === 'parabola') {
                                const {x_val: fx, y_val: fy} = conic.focus;
                                const {x_val: dpx, y_val: dpy} = conic.directrix.p1;
                                const {x: ddx, y: ddy} = conic.directrix.dir;
                                const A_par = 1, B_par = 0, C_par = -2*fx, D_par = -2*fy, E_par = fx*fx+fy*fy;
                                const A_dir = -ddy, B_dir = ddx, C_dir = ddy*dpx - ddx*dpy;
                                const F_dir = A_dir*A_dir + B_dir*B_dir;
                                const t_sq_coeff = A_par*dx*dx + B_par*dx*dy + ddx*ddx*dy*dy - 2*ddx*ddy*dx*dy + ddy*ddy*dx*dx;
                                const t_coeff = C_par*dx + D_par*dy + 2*A_par*x1*dx + B_par*(x1*dy+y1*dx) - 2*(A_dir*(x1*dx+A_dir) + B_dir*(y1*dy+B_dir) + C_dir*(A_dir*dx+B_dir*dy));
                                const const_coeff = A_par*x1*x1 + B_par*x1*y1 + C_par*x1 + D_par*y1 + E_par - (A_dir*x1+B_dir*y1+C_dir)**2;
                                A = t_sq_coeff/F_dir - 1;
                                B = t_coeff/F_dir;
                                C = const_coeff/F_dir;
                            }
                            
                            const discriminant = B*B - 4*A*C;
                            if (discriminant < -1e-9) { newMeaningful = false; break; }
                            const t = (-B + entry.sign * Math.sqrt(Math.max(0, discriminant))) / (2*A);
                            intersectResult = {x: x1 + t*dx, y: y1 + t*dy};

                        } else if ((isCircle(type1) && isConic(type2)) || (isConic(type1) && isCircle(type2)) || (isConic(type1) && isConic(type2))) {
                             entry.compilationError = "交点求解复杂"; newMeaningful = false; break;
                        }

                        if (intersectResult && Number.isFinite(intersectResult.x) && Number.isFinite(intersectResult.y)) {
                            const inBounds = (obj, pt) => {
                                if (['line', 'perpendicularline', 'parallelline', 'anglebisector', 'circle', 'ellipse', 'hyperbola', 'parabola', 'fitline', 'tangent', 'ellipse_ab'].includes(obj.geometryType)) return true;
                                if (obj.geometryType === 'circulararc') {
                                    const {x:px, y:py} = pt;
                                    const {x_val: cx, y_val: cy} = obj.center;
                                    let angle = Math.atan2(py - cy, px - cx);
                                    let sA = obj.startAngle;
                                    let eA = obj.endAngle;
                                    if (eA < sA) eA += 2 * Math.PI;
                                    
                                    let checkAngle = angle;
                                    while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
                                    while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;

                                    return checkAngle <= eA + 1e-9;
                                }
                                if (!obj.p1 || !obj.p2) return false;
                                const {x:px, y:py} = pt;
                                const {x_val: x1, y_val: y1} = obj.p1;
                                const {x_val: x2, y_val: y2} = obj.p2;
                                const dot = (px - x1) * (x2 - x1) + (py - y1) * (y2 - y1);
                                if (['ray', 'vector'].includes(obj.geometryType)) return dot >= -1e-9;
                                if (obj.geometryType === 'segment') {
                                    const len_sq = (x2-x1)**2 + (y2-y1)**2;
                                    return dot >= -1e-9 && dot <= len_sq + 1e-9;
                                }
                                return true;
                            };
                            if (!inBounds(obj1, intersectResult) || !inBounds(obj2, intersectResult)) {
                                newMeaningful = false;
                            } else {
                                entry.x_val = intersectResult.x;
                                entry.y_val = intersectResult.y;
                                entry.detailsString = `(${entry.x_val.toPrecision(4)}, ${entry.y_val.toPrecision(4)})`;
                            }
                        } else {
                             newMeaningful = false;
                        }
                        break;
                    }
                    case 'segment': case 'ray': case 'line': case 'vector':
                    case 'perpendicularline': case 'parallelline': case 'anglebisector': {
                        let p1, p2, dir;
                        let isPointToPointLine = false;

                        if (['segment','ray','line','vector'].includes(entry.geometryType)) {
                            p1 = objectMap.get(entry.p1Name.toLowerCase());
                            p2 = objectMap.get(entry.p2Name.toLowerCase());
                            if (!p1 || !p2) { newMeaningful = false; break; }
                            dir = { x: p2.x_val - p1.x_val, y: p2.y_val - p1.y_val };
                            isPointToPointLine = true;
                        } else if (entry.geometryType === 'perpendicularline') {
                            const line = objectMap.get(entry.lineName.toLowerCase());
                            p1 = objectMap.get(entry.pointName.toLowerCase());
                            if (!line || !p1 || !line.dir) { newMeaningful = false; break; }
                            dir = { x: -line.dir.y, y: line.dir.x };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        } else if (entry.geometryType === 'parallelline') {
                            const line = objectMap.get(entry.lineName.toLowerCase());
                            p1 = objectMap.get(entry.pointName.toLowerCase());
                            if (!line || !p1 || !line.dir) { newMeaningful = false; break; }
                            dir = { ...line.dir };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        } else if (entry.geometryType === 'anglebisector') {
                            const pa = objectMap.get(entry.p1Name.toLowerCase());
                            p1 = objectMap.get(entry.vertexName.toLowerCase());
                            const pc = objectMap.get(entry.p3Name.toLowerCase());
                            if (!pa || !p1 || !pc) { newMeaningful = false; break; }
                            const ba = { x: pa.x_val - p1.x_val, y: pa.y_val - p1.y_val };
                            const bc = { x: pc.x_val - p1.x_val, y: pc.y_val - p1.y_val };
                            const len_ba = Math.sqrt(ba.x*ba.x + ba.y*ba.y);
                            const len_bc = Math.sqrt(bc.x*bc.x + bc.y*bc.y);
                            if(len_ba < 1e-9 || len_bc < 1e-9) { newMeaningful = false; break; }
                            dir = { x: ba.x/len_ba + bc.x/len_bc, y: ba.y/len_ba + bc.y/len_bc };
                            p2 = { x_val: p1.x_val + dir.x, y_val: p1.y_val + dir.y };
                        }

                        entry.p1 = p1; 
                        entry.p2 = p2;
                        if (isPointToPointLine) {
                            entry.dir_vec = dir;
                        }

                        const dirLen = Math.sqrt(dir.x*dir.x + dir.y*dir.y);
                        if (dirLen < 1e-9) { newMeaningful = false; break; }
                        entry.dir = { x: dir.x / dirLen, y: dir.y / dirLen };
                        
                        if (newMeaningful) {
                            const p1_val = entry.p1;
                            const dir_val = entry.dir;
                            if (Math.abs(dir_val.x) < 1e-9) {
                                entry.detailsString = `x = ${p1_val.x_val.toPrecision(4)}`;
                            } else {
                                const m = dir_val.y / dir_val.x;
                                const b = p1_val.y_val - m * p1_val.x_val;
                                entry.detailsString = `y = ${m.toPrecision(3)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toPrecision(3)}`;
                            }
                        }
                        break;
                    }
                    case 'circle': {
                        entry.center = objectMap.get(entry.centerName.toLowerCase());
                        if (!entry.center) { newMeaningful = false; break; }
                        if (entry.pointOnCircleName) {
                            const pOn = objectMap.get(entry.pointOnCircleName.toLowerCase());
                            if (!pOn) { newMeaningful = false; break; }
                            entry.radius = Math.sqrt((pOn.x_val - entry.center.x_val)**2 + (pOn.y_val - entry.center.y_val)**2);
                        } else {
                            entry.radius = this.evaluateExpressionWithCalcJS(entry.radius_expr, Object.fromEntries(this.variables));
                        }
                        if (!Number.isFinite(entry.radius) || entry.radius <= 1e-9) newMeaningful = false;
                        if (newMeaningful) {
                            const h = entry.center.x_val;
                            const k = entry.center.y_val;
                            const r2 = entry.radius * entry.radius;
                            const x_part = `(x ${h > 0 ? '-' : '+'} ${Math.abs(h).toPrecision(3)})²`;
                            const y_part = `(y ${k > 0 ? '-' : '+'} ${Math.abs(k).toPrecision(3)})²`;
                            entry.detailsString = `${x_part} + ${y_part} = ${r2.toPrecision(3)}`;
                        }
                        break;
                    }
                    case 'ellipse_ab': {
                        const a = this.evaluateExpressionWithCalcJS(entry.a_expr, Object.fromEntries(this.variables));
                        const b = this.evaluateExpressionWithCalcJS(entry.b_expr, Object.fromEntries(this.variables));

                        if (!Number.isFinite(a) || !Number.isFinite(b) || a <= 0 || b <= 0) {
                            newMeaningful = false;
                            break;
                        }

                        entry.a = a;
                        entry.b = b;
                        entry.center = { x: 0, y: 0 };
                        entry.rotation = 0;

                        const c = Math.sqrt(Math.abs(a * a - b * b));
                        if (a > b) {
                            entry.f1 = { x_val: -c, y_val: 0 };
                            entry.f2 = { x_val: c, y_val: 0 };
                        } else {
                            entry.f1 = { x_val: 0, y_val: -c };
                            entry.f2 = { x_val: 0, y_val: c };
                        }

                        if (newMeaningful) {
                            const a2 = (a * a).toPrecision(3);
                            const b2 = (b * b).toPrecision(3);
                            entry.detailsString = `x²/${a2} + y²/${b2} = 1`;
                        }
                        break;
                    }
                    case 'ellipse': {
                        entry.f1 = objectMap.get(entry.f1Name.toLowerCase());
                        entry.f2 = objectMap.get(entry.f2Name.toLowerCase());
                        entry.p = objectMap.get(entry.pName.toLowerCase());
                        if (!entry.f1 || !entry.f2 || !entry.p) { newMeaningful = false; break; }
                        entry.dist_sum = Math.sqrt((entry.p.x_val-entry.f1.x_val)**2 + (entry.p.y_val-entry.f1.y_val)**2) + Math.sqrt((entry.p.x_val-entry.f2.x_val)**2 + (entry.p.y_val-entry.f2.y_val)**2);
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2)/2;
                        if (entry.dist_sum <= 2*c + 1e-9) { newMeaningful = false; break; }
                        entry.center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        entry.a = entry.dist_sum / 2;
                        entry.b = Math.sqrt(entry.a*entry.a - c*c);
                        entry.rotation = Math.atan2(f2y-f1y, f2x-f1x);
                        if (newMeaningful) {
                            const {a, b, rotation: r, center} = entry;
                            const cos_r = Math.cos(r), sin_r = Math.sin(r);
                            const h = center.x, k = center.y;
                            const a2 = a*a, b2 = b*b;
                            
                            const term1_A = cos_r*cos_r/a2 + sin_r*sin_r/b2;
                            const term1_B = 2*cos_r*sin_r/a2 - 2*cos_r*sin_r/b2;
                            const term1_C = sin_r*sin_r/a2 + cos_r*cos_r/b2;

                            const term2_D = -2*h*term1_A - k*term1_B;
                            const term2_E = -2*k*term1_C - h*term1_B;
                            
                            const term3_F = h*h*term1_A + k*k*term1_C + h*k*term1_B - 1;
                            
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'hyperbola': {
                        entry.f1 = objectMap.get(entry.f1Name.toLowerCase());
                        entry.f2 = objectMap.get(entry.f2Name.toLowerCase());
                        entry.p = objectMap.get(entry.pName.toLowerCase());
                        if (!entry.f1 || !entry.f2 || !entry.p) { newMeaningful = false; break; }
                        entry.dist_diff = Math.abs(Math.sqrt((entry.p.x_val-entry.f1.x_val)**2 + (entry.p.y_val-entry.f1.y_val)**2) - Math.sqrt((entry.p.x_val-entry.f2.x_val)**2 + (entry.p.y_val-entry.f2.y_val)**2));
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2) / 2;
                        if (entry.dist_diff >= 2*c - 1e-9 || entry.dist_diff < 1e-9) { newMeaningful = false; break; }
                        entry.center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        entry.a = entry.dist_diff / 2;
                        entry.b = Math.sqrt(c*c - entry.a*entry.a);
                        entry.rotation = Math.atan2(f2y-f1y, f2x-f1x);
                        if (newMeaningful) {
                            const {a, b, rotation: r, center} = entry;
                            const cos_r = Math.cos(r), sin_r = Math.sin(r);
                            const h = center.x, k = center.y;
                            const a2 = a*a, b2 = b*b;

                            const term1_A = cos_r*cos_r/a2 - sin_r*sin_r/b2;
                            const term1_B = 2*cos_r*sin_r/a2 + 2*cos_r*sin_r/b2;
                            const term1_C = sin_r*sin_r/a2 - cos_r*cos_r/b2;

                            const term2_D = -2*h*term1_A - k*term1_B;
                            const term2_E = -2*k*term1_C - h*term1_B;
                            
                            const term3_F = h*h*term1_A + k*k*term1_C + h*k*term1_B - 1;
                           
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'parabola': {
                        entry.focus = objectMap.get(entry.focusName.toLowerCase());
                        entry.directrix = objectMap.get(entry.directrixName.toLowerCase());
                        if (!entry.focus || !entry.directrix || !entry.directrix.dir) { newMeaningful = false; break; }
                        const {x_val: fx, y_val: fy} = entry.focus;
                        const {x_val: p1x, y_val: p1y} = entry.directrix.p1;
                        const {x: dirx, y: diry} = entry.directrix.dir;
                        const p2x = p1x + dirx, p2y = p1y + diry;
                        const k = ((p2y-p1y)*(fx-p1x) - (p2x-p1x)*(fy-p1y)) / ((p2y-p1y)**2 + (p2x-p1x)**2);
                        const proj_x = fx - k*(p2y-p1y), proj_y = fy + k*(p2x-p1x);
                        entry.vertex = {x: (fx+proj_x)/2, y: (fy+proj_y)/2};
                        entry.p = Math.sqrt((fx-entry.vertex.x)**2 + (fy-entry.vertex.y)**2);
                        entry.rotation = Math.atan2(fy-proj_y, fx-proj_x);
                        if (newMeaningful) {
                            const {x: h, y: v_k} = entry.vertex;
                            const {p, rotation: r} = entry;
                            const c = Math.cos(r), s = Math.sin(r);
                            const term1_A = s*s;
                            const term1_B = -2*c*s;
                            const term1_C = c*c;
                            const term2_D = -4*p*c - 2*h*s*s + 2*v_k*c*s;
                            const term2_E = -4*p*s + 2*h*c*s - 2*v_k*c*c;
                            const term3_F = h*h*s*s + v_k*v_k*c*c - 2*h*v_k*c*s + 4*p*h*c + 4*p*v_k*s;
                            entry.detailsString = this.formatConicEquation(term1_A, term1_B, term1_C, term2_D, term2_E, term3_F);
                        }
                        break;
                    }
                    case 'polygon': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) newMeaningful = false;
                        entry.detailsString = "";
                        break;
                    }
                    case 'length': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        if (!p1 || !p2) { newMeaningful = false; break; }
                        entry.value = Math.hypot(p2.x_val - p1.x_val, p2.y_val - p1.y_val);
                        entry.detailsString = `l(${entry.p1Name}, ${entry.p2Name}) = ${entry.value.toPrecision(4)}`;
                        break;
                    }
                    case 'angle': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const vertex = objectMap.get(entry.vertexName.toLowerCase());
                        const p3 = objectMap.get(entry.p3Name.toLowerCase());
                        if (!p1 || !vertex || !p3) { newMeaningful = false; break; }

                        const v_BA = { x: p1.x_val - vertex.x_val, y: p1.y_val - vertex.y_val };
                        const v_BC = { x: p3.x_val - vertex.x_val, y: p3.y_val - vertex.y_val };
                        const len_BA = Math.hypot(v_BA.x, v_BA.y);
                        const len_BC = Math.hypot(v_BC.x, v_BC.y);

                        if (len_BA < 1e-9 || len_BC < 1e-9) { newMeaningful = false; break; }
                        
                        const dot = v_BA.x * v_BC.x + v_BA.y * v_BC.y;
                        const cos_theta = dot / (len_BA * len_BC);
                        entry.value = Math.acos(Math.max(-1, Math.min(1, cos_theta))) * (180 / Math.PI);
                        entry.detailsString = `∠(${entry.p1Name}, ${entry.vertexName}, ${entry.p3Name}) = ${entry.value.toPrecision(3)}°`;
                        break;
                    }
                    case 'area': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) { newMeaningful = false; break; }
                        let area_val = 0;
                        const n = entry.points.length;
                        for (let i = 0; i < n; i++) {
                            const p1 = entry.points[i];
                            const p2 = entry.points[(i + 1) % n];
                            area_val += (p1.x_val * p2.y_val - p2.x_val * p1.y_val);
                        }
                        entry.value = Math.abs(area_val) / 2.0;
                        entry.detailsString = `S(${entry.pointNames.join(', ')}) = ${entry.value.toPrecision(4)}`;
                        break;
                    }
                                        case 'isparallel': {
                        const l1 = objectMap.get(entry.l1Name.toLowerCase());
                        const l2 = objectMap.get(entry.l2Name.toLowerCase());
                        if (!l1 || !l2 || !l1.dir || !l2.dir) { newMeaningful = false; break; }
                        const cross_product_z = l1.dir.x * l2.dir.y - l1.dir.y * l2.dir.x;
                        entry.value = Math.abs(cross_product_z) < 1e-9 ? 1 : 0;
                        entry.detailsString = `${entry.name}(${entry.l1Name}, ${entry.l2Name}) = ${entry.value}`;
                        break;
                    }
                    case 'isperpendicular': {
                        const l1 = objectMap.get(entry.l1Name.toLowerCase());
                        const l2 = objectMap.get(entry.l2Name.toLowerCase());
                        if (!l1 || !l2 || !l1.dir || !l2.dir) { newMeaningful = false; break; }
                        const dot_product = l1.dir.x * l2.dir.x + l1.dir.y * l2.dir.y;
                        entry.value = Math.abs(dot_product) < 1e-9 ? 1 : 0;
                        entry.detailsString = `${entry.name}(${entry.l1Name}, ${entry.l2Name}) = ${entry.value}`;
                        break;
                    }
                    case 'isconcyclic': {
                        const p1 = objectMap.get(entry.p1Name.toLowerCase());
                        const p2 = objectMap.get(entry.p2Name.toLowerCase());
                        const p3 = objectMap.get(entry.p3Name.toLowerCase());
                        const p4 = objectMap.get(entry.p4Name.toLowerCase());
                        if (!p1 || !p2 || !p3 || !p4) { newMeaningful = false; break; }
                        
                        const {x_val: x1, y_val: y1} = p1;
                        const {x_val: x2, y_val: y2} = p2;
                        const {x_val: x3, y_val: y3} = p3;
                        const {x_val: x4, y_val: y4} = p4;

                        const ax = x2 - x1, ay = y2 - y1;
                        const bx = x3 - x1, by = y3 - y1;
                        const D = 2 * (ax * by - ay * bx);

                        if (Math.abs(D) < 1e-9) {
                            const a = {x: x2-x1, y: y2-y1};
                            const b = {x: x3-x1, y: y3-y1};
                            const c = {x: x4-x1, y: y4-y1};
                            const cross_ab = a.x * b.y - a.y * b.x;
                            const cross_ac = a.x * c.y - a.y * c.x;
                            entry.value = Math.abs(cross_ab) < 1e-9 && Math.abs(cross_ac) < 1e-9 ? 1 : 0;
                        } else {
                            const sqA = ax*ax + ay*ay;
                            const sqB = bx*bx + by*by;
                            const center_x = x1 + (sqA * by - sqB * ay) / D;
                            const center_y = y1 + (sqB * ax - sqA * bx) / D;
                            const radius_sq = (x1 - center_x)**2 + (y1 - center_y)**2;
                            const dist_p4_sq = (x4 - center_x)**2 + (y4 - center_y)**2;
                            
                            entry.value = Math.abs(dist_p4_sq - radius_sq) < 1e-7 ? 1 : 0;
                        }
                        entry.detailsString = `${entry.name}(${entry.p1Name}, ${entry.p2Name}, ${entry.p3Name}, ${entry.p4Name}) = ${entry.value}`;
                        break;
                    }                    case 'fitline': {
                        entry.points = entry.pointNames.map(name => objectMap.get(name.toLowerCase()));
                        if (entry.points.some(p => !p)) { newMeaningful = false; break; }
                        const n = entry.points.length;
                        if (n < 2) { newMeaningful = false; break; }

                        let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
                        for (const p of entry.points) {
                            sum_x += p.x_val;
                            sum_y += p.y_val;
                            sum_xy += p.x_val * p.y_val;
                            sum_x2 += p.x_val * p.x_val;
                        }

                        const denominator = n * sum_x2 - sum_x * sum_x;
                        if (Math.abs(denominator) < 1e-9) {
                            const avg_x = sum_x / n;
                            entry.p1 = { x_val: avg_x, y_val: 0 };
                            entry.p2 = { x_val: avg_x, y_val: 1 };
                            entry.dir = { x: 0, y: 1 };
                            entry.detailsString = `x = ${avg_x.toPrecision(4)}`;
                        } else {
                            const m = (n * sum_xy - sum_x * sum_y) / denominator;
                            const b = (sum_y - m * sum_x) / n;
                            entry.p1 = { x_val: 0, y_val: b };
                            entry.p2 = { x_val: 1, y_val: m + b };
                            const dir = { x: 1, y: m };
                            const dirLen = Math.hypot(dir.x, dir.y);
                            entry.dir = { x: dir.x / dirLen, y: dir.y / dirLen };
                            entry.detailsString = `y = ${m.toPrecision(3)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toPrecision(3)}`;
                        }
                        break;
                        
                    }
case 'circulararc': {
                        if (!entry.centerName || !entry.startPointName || !entry.endPointName) { newMeaningful = false; break; }
                        const center = objectMap.get(entry.centerName.toLowerCase());
                        const startPoint = objectMap.get(entry.startPointName.toLowerCase());
                        const endPoint = objectMap.get(entry.endPointName.toLowerCase());
                        if (!center || !startPoint || !endPoint) { newMeaningful = false; break; }
                        
                        entry.center = center;
                        entry.radius = Math.hypot(startPoint.x_val - center.x_val, startPoint.y_val - center.y_val);
                        if (entry.radius < 1e-9) { newMeaningful = false; break; }
                        
                        entry.startAngle = Math.atan2(startPoint.y_val - center.y_val, startPoint.x_val - center.x_val);
                        
                        const dir_vec_x = endPoint.x_val - center.x_val;
                        const dir_vec_y = endPoint.y_val - center.y_val;
                        const len = Math.hypot(dir_vec_x, dir_vec_y);
                        if (len < 1e-9) { newMeaningful = false; break; }

                        entry.endAngle = Math.atan2(dir_vec_y, dir_vec_x);
                        if (newMeaningful) {
                             entry.detailsString = `圆心: ${entry.centerName}, 半径: ${entry.radius.toPrecision(4)}`;
                        }
                        break;
                    }
                  case 'tangent': {
    if (!entry.conicName || !entry.pointName) { newMeaningful = false; break; }
    const conic = objectMap.get(entry.conicName.toLowerCase());
    const point = objectMap.get(entry.pointName.toLowerCase());
    if (!conic || !point || !conic.isMeaningful || !point.isMeaningful) { newMeaningful = false; break; }

    const { x_val: x0, y_val: y0 } = point;
    let A = 0, B = 0, C = 0, D = 0, E = 0, F = 0;
    let isValidConic = false;

    if (conic.geometryType === 'circle' || conic.geometryType === 'circulararc') {
        const { x_val: cx, y_val: cy } = conic.center;
        const r = conic.radius;
        A = 1;
        B = 1;
        C = 0;
        D = -2 * cx;
        E = -2 * cy;
        F = cx * cx + cy * cy - r * r;
        isValidConic = true;
    }else if (conic.geometryType === 'ellipse' || conic.geometryType === 'hyperbola' || conic.geometryType === 'ellipse_ab') { const { x: h, y: k } = conic.center; const { a, b, rotation: rot } = conic; const cos_r = Math.cos(rot), sin_r = Math.sin(rot); const sign = (conic.geometryType === 'ellipse' || conic.geometryType === 'ellipse_ab') ? 1 : -1;
        
        const Qu = 1/(a*a);
        const Qv = sign/(b*b);
        
        A = Qu * cos_r * cos_r + Qv * sin_r * sin_r;
        B = Qu * sin_r * sin_r + Qv * cos_r * cos_r;
        C = 2 * (Qu - Qv) * sin_r * cos_r;
        
        const U0 = -h * cos_r - k * sin_r;
        const V0 = h * sin_r - k * cos_r;
        
        D = 2 * Qu * cos_r * U0 - 2 * Qv * sin_r * V0;
        E = 2 * Qu * sin_r * U0 + 2 * Qv * cos_r * V0;
        F = Qu * U0 * U0 + Qv * V0 * V0 - 1;
        isValidConic = true;
    } else if (conic.geometryType === 'parabola') {
        const { x: h, y: k } = conic.vertex;
        const { p, rotation: rot } = conic;
        const c = Math.cos(rot);
        const s = Math.sin(rot);

        const V0 = h * s - k * c;
        const U0 = -h * c - k * s;
        
        A = s * s;
        B = c * c;
        C = -2 * s * c;
        D = -2 * s * V0 - 4 * p * c;
        E = 2 * c * V0 - 4 * p * s;
        F = V0 * V0 - 4 * p * U0;
        isValidConic = true;
    }

    if (!isValidConic) { newMeaningful = false; break; }

    const m11 = A, m12 = C/2, m13 = D/2;
    const m21 = C/2, m22 = B, m23 = E/2;
    const m31 = D/2, m32 = E/2, m33 = F;

    const S11 = m22 * m33 - m23 * m32;
    const S22 = m11 * m33 - m13 * m31;
    const S33 = m11 * m22 - m12 * m21;
    const S12 = -(m21 * m33 - m23 * m31); 
    const S13 = m21 * m32 - m22 * m31;    
    const S23 = -(m11 * m32 - m12 * m31); 
    
    const aq = S11 + S33 * x0 * x0 - 2 * S13 * x0;
    const bq = -2 * S12 + 2 * S13 * y0 + 2 * S23 * x0 - 2 * S33 * x0 * y0;
    const cq = S22 + S33 * y0 * y0 - 2 * S23 * y0;

    const epsilon = 1e-9;
    let solutions = [];


    if (Math.abs(aq) < epsilon) {
        const disc_vert = (C * x0 + E) * (C * x0 + E) - 4 * B * (A * x0 * x0 + D * x0 + F);
        if (Math.abs(disc_vert) < 1e-7) {
             solutions.push({ isVertical: true });
        }

        if (Math.abs(bq) > epsilon) {
            solutions.push({ isVertical: false, k: -cq / bq });
        }
    } else {
        const delta = bq * bq - 4 * aq * cq;
        if (delta >= -epsilon) {
            const sqrtDelta = Math.sqrt(Math.max(0, delta));
            const k1 = (-bq + sqrtDelta) / (2 * aq);
            solutions.push({ isVertical: false, k: k1 });
            
            if (delta > epsilon) {
                const k2 = (-bq - sqrtDelta) / (2 * aq);
                solutions.push({ isVertical: false, k: k2 });
            }
        }
    }

    if (solutions.length === 0) {
        newMeaningful = false;
    } else {
        let selectedSol;
        if (solutions.length === 1) {
            selectedSol = solutions[0];
        } else {
            if (entry.sign === 1) selectedSol = solutions[0];
            else selectedSol = solutions[1];
        }
        
        if (conic.geometryType === 'circulararc') {
             let touchX, touchY;
             const { x_val: cx, y_val: cy } = conic.center;
             
             if (selectedSol.isVertical) {
                 touchX = x0;
                 touchY = cy; 
             } else {
                 const k_sol = selectedSol.k;
                 const m = k_sol;
                 const b_line = y0 - m * x0;
                 
                 touchX = (cx + m * (cy - b_line)) / (1 + m * m);
                 touchY = m * touchX + b_line;
             }
             
             let angle = Math.atan2(touchY - cy, touchX - cx);
             let sA = conic.startAngle;
             let eA = conic.endAngle;
             if (eA < sA) eA += 2 * Math.PI;
             
             let checkAngle = angle;
             while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
             while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;
             
             if (!(checkAngle <= eA + 1e-9)) {
                 newMeaningful = false;
                 entry.compilationError = "切点不在圆弧范围内";
             }
        }

        if (newMeaningful) {
            if (selectedSol.isVertical) {
                entry.p1 = { x_val: x0, y_val: y0 };
                entry.p2 = { x_val: x0, y_val: y0 + 1 };
                entry.dir = { x: 0, y: 1 };
                entry.detailsString = `x = ${x0.toPrecision(4)}`;
            } else {
                const k_val = selectedSol.k;
                entry.p1 = { x_val: x0, y_val: y0 };
                entry.p2 = { x_val: x0 + 1, y_val: y0 + k_val };
                const len = Math.sqrt(1 + k_val * k_val);
                entry.dir = { x: 1 / len, y: k_val / len };
                const b_val = y0 - k_val * x0;
                entry.detailsString = `y = ${k_val.toPrecision(3)}x ${b_val >= 0 ? '+' : '-'} ${Math.abs(b_val).toPrecision(3)}`;
            }
        }
    }
    break;
}


                }
                entry.isMeaningful = newMeaningful;
            } catch (e) {
                entry.isMeaningful = false;
                entry.compilationError = e.message;
            }
            if (entry.isMeaningful !== oldMeaningful) changedInIteration = true;
            else if(entry.isMeaningful) {
                if ((entry.geometryType === 'point' || entry.geometryType === 'midpoint' || entry.geometryType === 'intercept') && (Math.abs(entry.x_val - oldValues.x) > 1e-9 || Math.abs(entry.y_val - oldValues.y) > 1e-9)) {
                    changedInIteration = true;
                } else if(entry.geometryType === 'circle' && Math.abs(entry.radius - oldValues.r) > 1e-9) {
                    changedInIteration = true;
                }
            }
        }
    }
}

    formatConicEquation(A,B,C,D,E,F) {
        const formatTerm = (val, termStr, isFirst = false) => {
            if (Math.abs(val) < 1e-7) return "";
            const sign = val > 0 ? (isFirst ? "" : "+ ") : "- ";
            const absVal = Math.abs(val);
            const numStr = Math.abs(absVal - 1) < 1e-7 ? "" : absVal.toPrecision(3);
            return `${sign}${numStr}${termStr} `;
        };

        let equation = formatTerm(A, "x²", true) +
                       formatTerm(B, "xy") +
                       formatTerm(C, "y²") +
                       formatTerm(D, "x") +
                       formatTerm(E, "y") +
                       formatTerm(F, "");
        
        return equation.trim() + " = 0";
    }
// --- 新增：将数学 Token 转译为原生 JS 代码字符串 (核心优化) ---
    _transpileTokensToJs(tokens) {
        let result = '';
        let i = 0;

        while (i < tokens.length) {
            const token = tokens[i];

            if (['sum', 'prod', 'int'].includes(token)) {
                // 1. 检查语法结构 sum(...)
                if (i + 1 >= tokens.length || tokens[i+1] !== '(') {
                    result += token; i++; continue;
                }
                const openParenIdx = i + 1;
                // 使用现有的工具查找匹配括号
                const closeParenIdx = this.calcJSUtils.findMatchingParen(tokens, openParenIdx);
                
                if (closeParenIdx === -1) {
                    result += token; i++; continue;
                }

                // 2. 提取4个参数：表达式、变量名、起始值、终止值
                // 注意：extractArguments 返回的是 token 数组的数组
                const args = this.calcJSUtils.extractArguments(tokens, openParenIdx, closeParenIdx, 4);
                
                // 3. 递归转译参数（支持嵌套，如 sum 里套 sum）
                const bodyJs = this._transpileTokensToJs(args[0]);
                const varName = args[1][0]; // 变量名通常是单个字符
                const startJs = this._transpileTokensToJs(args[2]);
                const endJs = this._transpileTokensToJs(args[3]);

                // 4. 生成 IIFE (立即执行函数) 形式的循环代码
                if (token === 'sum') {
                    result += `((() => { 
                        let __res = 0; 
                        let __s = Math.round(${startJs}); 
                        let __e = Math.round(${endJs});
                        // 防止死循环，限制最大迭代次数(可选)
                        if(Math.abs(__e - __s) > 100000) return NaN;
                        for(let ${varName} = __s; ${varName} <= __e; ${varName}++) {
                            __res += (${bodyJs});
                        }
                        return __res; 
                    })())`;
                } else if (token === 'prod') {
                    result += `((() => { 
                        let __res = 1; 
                        let __s = Math.round(${startJs}); 
                        let __e = Math.round(${endJs});
                        if(Math.abs(__e - __s) > 100000) return NaN;
                        for(let ${varName} = __s; ${varName} <= __e; ${varName}++) {
                            __res *= (${bodyJs});
                        }
                        return __res; 
                    })())`;
                } else if (token === 'int') {
                    // 积分：使用梯形法则
                    const steps = this.integralNumSteps || 100;
                    result += `((() => { 
                        let __sum = 0; 
                        let __a = (${startJs}); 
                        let __b = (${endJs});
                        let __n = ${steps};
                        let __h = (__b - __a) / __n;
                        if (Math.abs(__h) < 1e-15) return 0;
                        
                        // 首项 f(a) * 0.5
                        let ${varName} = __a;
                        let __val = (${bodyJs});
                        if (!Number.isFinite(__val)) __val = 0;
                        __sum += 0.5 * __val;

                        // 中间项
                        for(let __i = 1; __i < __n; __i++) {
                            ${varName} = __a + __i * __h;
                            __val = (${bodyJs});
                            if (!Number.isFinite(__val)) __val = 0;
                            __sum += __val;
                        }

                        // 尾项 f(b) * 0.5
                        ${varName} = __b;
                        __val = (${bodyJs});
                        if (!Number.isFinite(__val)) __val = 0;
                        __sum += 0.5 * __val;

                        return __sum * __h; 
                    })())`;
                }

                // 跳过已处理的 token 部分
                i = closeParenIdx + 1; 
            } else {
                // 普通 Token 直接拼接
                result += token;
                i++;
            }
        }
        return result;
    }

recompileFunctions() {
        const functionEntries = this.entries.filter(e => e.type === 'function');
        const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();

        const compileTokensToJs = (tokens) => {
            if (!tokens || !Array.isArray(tokens)) return "NaN";
            
            const placeholders = new Map();
            let placeholderCounter = 0;

            const transpileRecursive = (inputTokens) => {
                let outputTokens = [];
                let i = 0;
                while (i < inputTokens.length) {
                    const token = inputTokens[i];
                    if (['sum', 'prod', 'int'].includes(token)) {
                        if (i + 1 >= inputTokens.length || inputTokens[i+1] !== '(') { outputTokens.push(token); i++; continue; }
                        const openParenIdx = i + 1;
                        const closeParenIdx = this.calcJSUtils.findMatchingParen(inputTokens, openParenIdx);
                        if (closeParenIdx === -1) { outputTokens.push(token); i++; continue; }
                        const args = this.calcJSUtils.extractArguments(inputTokens, openParenIdx, closeParenIdx, 4);
                        if (args.length !== 4) { outputTokens.push("NaN"); i = closeParenIdx + 1; continue; }

                        const bodyJs = compileInternal(args[0]);
                        const varName = args[1][0];
                        const startJs = compileInternal(args[2]);
                        const endJs = compileInternal(args[3]);

                        let loopCode = "";
                        if (token === 'sum') {
                            loopCode = `((() => { let __res = 0; let __s = Math.round(${startJs}); let __e = Math.round(${endJs}); if(Math.abs(__e - __s) > 50000) return 0; for(let ${varName} = __s; ${varName} <= __e; ${varName}++) { __res += (${bodyJs}); } return __res; })())`;
                        } else if (token === 'prod') {
                            loopCode = `((() => { let __res = 1; let __s = Math.round(${startJs}); let __e = Math.round(${endJs}); if(Math.abs(__e - __s) > 50000) return 0; for(let ${varName} = __s; ${varName} <= __e; ${varName}++) { __res *= (${bodyJs}); } return __res; })())`;
                        } else if (token === 'int') {
                            const steps = this.integralNumSteps || 100;
                            loopCode = `((() => { let __sum = 0; let __a = (${startJs}); let __b = (${endJs}); let __n = ${steps}; let __h = (__b - __a) / __n; if (Math.abs(__h) < 1e-15) return 0; let ${varName} = __a; let __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += 0.5 * __val; for(let __i = 1; __i < __n; __i++) { ${varName} = __a + __i * __h; __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += __val; } ${varName} = __b; __val = (${bodyJs}); if(!Number.isFinite(__val)) __val=0; __sum += 0.5 * __val; return __sum * __h; })())`;
                        }
                        const key = `__ARCH_MACRO_${placeholderCounter++}__`;
                        placeholders.set(key, loopCode);
                        outputTokens.push(key);
                        i = closeParenIdx + 1;
                    } else { outputTokens.push(token); i++; }
                }
                return outputTokens;
            };

            const compileInternal = (ts) => {
                const tokensWithPlaceholders = transpileRecursive(ts);
                const processed = this.calcJSUtils.processTokensForEval.call(this.calcJSUtils, tokensWithPlaceholders);
                let str = processed.join('');
                if (placeholders.size > 0) { placeholders.forEach((val, key) => { str = str.split(key).join(val); }); }
                return str;
            };

            return compileInternal(tokens);
        };

        for (const entry of functionEntries) {
            delete entry.func; delete entry.funcX; delete entry.funcY; delete entry.funcZ; delete entry.compilationError;
            entry.webglVertices = null;

            // 检查依赖有效性（不阻断编译，因为有可能是内部变量）
            const allValid = !entry.dependencies || entry.dependencies.every(k => this.variables.has(k) && Number.isFinite(this.variables.get(k)));
            if (!allValid && !entry.dependencies.some(d => ['x','y','z','t'].includes(d))) {
                // 仅当确实缺少全局变量时标记，但我们继续尝试编译，因为可能是参数
            }

            const makeFunc = (args, bodyStr) => {
                if (!bodyStr) return () => NaN;
                
                // 核心修复：过滤掉已经是函数参数(args)的变量名，防止重复声明错误
                // 这确保了如果 args=['a'] 且 dependencies=['a', 'b']，只有 'b' 会被从全局变量中获取
                const validDependencies = (entry.dependencies || []).filter(k => !args.includes(k));
                
                const varDecls = validDependencies.map(k => `const ${k} = variables.has('${k}') ? variables.get('${k}') : NaN;`).join(' ');

                // 生成源码。注意这里不需要再手动从 arguments 映射 args，因为 new Function 的签名已经包含了它们
                const src = `try { 
                    ${varDecls} 
                    return (${bodyStr}); 
                } catch(e) { return NaN; }`;

                return new Function(...args, 'variables', 'Math', '__advanced__', src);
            };

            try {
                if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                    entry.funcX = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensX));
                    entry.funcY = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensY));
                    if (entry.plotType === 'parametric3d') {
                        entry.funcZ = makeFunc(['t'], compileTokensToJs(entry.largeOpTokensZ));
                    }
                } else {
                    let args = [];
                    if (['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType)) args = ['x', 'y', 'z'];
                    else if (entry.plotType === 'y') args = ['x'];
                    else if (entry.plotType === 'x') args = ['y'];
                    else args = ['x', 'y'];

                    if (entry.hasLargeOps) {
                        entry.func = makeFunc(args, compileTokensToJs(entry.largeOpTokens));
                    } else {
                        entry.func = makeFunc(args, entry.processedExpr);
                    }
                    
                    // 简单的测试运行以捕获运行时错误（可选）
                    if (entry.plotType !== 'parametric' && entry.plotType !== 'parametric3d') {
                         // entry.func(...args.map(_=>0), this.variables, Math, advancedFuncsMap);
                    }
                }
            } catch (e) {
                console.warn("Recompile error:", e);
                entry.compilationError = "编译错误: " + e.message;
                entry.func = () => NaN;
            }
        }
    }

recalculateForGeometryDrag(draggedEntry) {
    this.recalculateGeometryObjects();


    this.recompileFunctions();


    this.clearPlotData();


    this.updateEntryVariableValuesDisplay();
    this.updateGeometryMeasurementDisplay();


    this.requestDraw();
}

     recalculateAll() {
        
        this.restoreOriginalPrecisions();
        this.isAnimatingWithPerformanceMode = false;
        this.isZooming = false;
        this.isSmoothPanningActive = false;

        this.recalculateVariableValues();
        this.recalculatePointLists();
        this.recalculateGeometryObjects();
        this.recompileFunctions();
        if (this.is3DMode) {
            this.recalculate3D();
        }

        this.entries.forEach(entry => {
            if (entry.type === 'function' && (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y')) {
                entry.webglVertices = null;
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            }
            if (entry.type === 'geometry') {
                entry.webglVertices = null;
            }
        });

if (this.traceState.active && this.traceState.targetName) {
            const targetEntry = this.entries.find(e => e.name === this.traceState.targetName);
            if (targetEntry && targetEntry.isMeaningful) {
                const newPoint = {x: targetEntry.x_val, y: targetEntry.y_val};
                const lastPoint = this.traceState.path[this.traceState.path.length - 1];
                if (!lastPoint || Math.hypot(newPoint.x - lastPoint.x, newPoint.y - lastPoint.y) > 1e-9) {
                    this.traceState.path.push(newPoint);
                }
            }
        }

        this.updateEntryList();
        this.clearPlotData();
        this.requestDraw();
    }

recalculateForAnimation() {
        if (this.lowPrecisionBufferEnabled && this.globalPlayState === 1 && !this.isZooming && !this.isPanning && !this.isSmoothPanningActive) {
            if (!this.isUsingLowPrecisionBuffer) {
                this.originalExplicitPrecision = this.explicitPrecisionStep;
                this.originalImplicitPrecision = this.implicitPrecisionStep;
                this.isUsingLowPrecisionBuffer = true;
            }
            this.explicitPrecisionStep = 1;
            this.implicitPrecisionStep = (this.originalImplicitPrecision < 10) ? 10 : this.originalImplicitPrecision;
        } else if (this.isUsingLowPrecisionBuffer && this.globalPlayState === 0) {
            this.restoreOriginalPrecisions();
            this.isUsingLowPrecisionBuffer = false;
        } else if (this.isAnimatingWithPerformanceMode && this.globalPlayState === 0) {
            this.restoreOriginalPrecisions();
            this.isAnimatingWithPerformanceMode = false;
        }

        this.recalculateVariableValues();
         this.recalculatePointLists();
        this.recalculateGeometryObjects();
        this.recompileFunctions();

        if (this.is3DMode) {
            this.recalculate3D();
        }

        this.entries.forEach(entry => {
            if (entry.type === 'function' && (entry.plotType === 'parametric' || entry.plotType === 'x' || entry.plotType === 'y')) {
                entry.webglVertices = null;
                if (entry.plotType === 'parametric') entry.cachedPoints = [];
            }
            if (entry.type === 'geometry') {
                entry.webglVertices = null;
                entry.webglFillVertices = null;
            }
        });
        this.updateEntryVariableValuesDisplay();
        this.clearPlotData();
        this.requestDraw();
    }

recalculate3D() {
        if (!this.is3DMode) return;
        
        this.cache3D.meshes.clear();
        this.cache3D.lines.clear();
        
        const baseMap = this.calcJSUtils.getAdvancedFuncsMap();
        const advancedFuncsMap = { ...baseMap };
        const originalPow = advancedFuncsMap.pow;
        advancedFuncsMap.pow = (a, b) => {
            if (a < 0 && Math.abs(b - Math.round(b)) > 1e-10) return NaN;
            return originalPow(a, b);
        };

        const range = this.bounds3D; 
    
    this.entries.forEach((entry, index) => {
        const isVisible = this.getEffectiveVisibility(entry); if ((!isVisible && !this.showHiddenMath && !this.showHiddenGeo) || entry.compilationError) return; 
        if (this.showPlaybackControls && this.currentFrame !== 0 && entry.displayFrame !== 0 && entry.displayFrame !== this.currentFrame) return;
        if (entry.type !== 'function') return;

        const is2D = ['y', 'x', 'parametric', 'implicit'].includes(entry.plotType);
        const is3D = ['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType);
        
        if (is2D && !this.overlayDrawingEnabled && !entry.extendTo3D) return;

        if (is3D && entry.sliceAxis !== 'none') {

            const axis = entry.sliceAxis;
            const k = entry.sliceVal;
            const vertices = [];
            
            const mcRes = Math.max(10, Math.min(200, Math.floor(250 / this.implicitPrecisionStep)));
            const step = (range * 2) / mcRes;
            const values = new Float32Array((mcRes + 1) * (mcRes + 1));
            let vIdx = 0;

            
            for (let v = 0; v <= mcRes; v++) {
                const fv_screen = -range + v * step;
                const fv_math = fv_screen * this.scale3D; 
                for (let u = 0; u <= mcRes; u++) {
                    const fu_screen = -range + u * step;
                    const fu_math = fu_screen * this.scale3D;
                    
                    let x_math, y_math, z_math;
                    if (axis === 'x') { x_math = k; y_math = fu_math + this.offset3D.y*this.scale3D; z_math = fv_math; } 
                    else if (axis === 'y') { x_math = fu_math + this.offset3D.x*this.scale3D; y_math = k; z_math = fv_math; } 
                    else { x_math = fu_math + this.offset3D.x*this.scale3D; y_math = fv_math + this.offset3D.y*this.scale3D; z_math = k; } 

                    let val = NaN;
                    try {
                        if (entry.plotType === 'z') {
                            val = entry.func(x_math, y_math, 0, this.variables, Math, advancedFuncsMap) - z_math;
                        } else if (entry.plotType === 'x3d') {
                            val = entry.func(0, y_math, z_math, this.variables, Math, advancedFuncsMap) - x_math;
                        } else if (entry.plotType === 'y3d') {
                            val = entry.func(x_math, 0, z_math, this.variables, Math, advancedFuncsMap) - y_math;
                        } else {
                            val = entry.func(x_math, y_math, z_math, this.variables, Math, advancedFuncsMap);
                        }
                    } catch (e) {}
                    values[vIdx++] = Number.isFinite(val) ? val : NaN;
                }
            }

            const getOffset2D = (v1, v2) => {
                 const delta = v2 - v1;
                 if (Math.abs(delta) < 1e-9) return 0.5;
                 return Math.max(0, Math.min(1, (0 - v1) / delta));
            };
            
            const N = mcRes + 1;
            const lineVerts = [];
            
            const pushSliceSegment = (u1, v1, u2, v2) => {
            
                let x1, y1, z1, x2, y2, z2;
              
                const k_screen = k / this.scale3D;
          
                
                let s1_x, s1_y, s1_z, s2_x, s2_y, s2_z;
                
                if (axis === 'x') {
                    s1_x = k_screen - this.offset3D.x; s1_y = u1; s1_z = v1;
                    s2_x = k_screen - this.offset3D.x; s2_y = u2; s2_z = v2;
                } else if (axis === 'y') {
                    s1_x = u1; s1_y = k_screen - this.offset3D.y; s1_z = v1;
                    s2_x = u2; s2_y = k_screen - this.offset3D.y; s2_z = v2;
                } else {
                    s1_x = u1; s1_y = v1; s1_z = k_screen;
                    s2_x = u2; s2_y = v2; s2_z = k_screen;
                }
                

                const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useThickLines = entryThickness > 1.5;
                
                if (!useThickLines) {
                    lineVerts.push(s1_x, s1_y, s1_z, s2_x, s2_y, s2_z);
                } else {
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z,  1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z,  1.0);
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z, -1.0);
                    
                    lineVerts.push(s1_x,s1_y,s1_z, s2_x,s2_y,s2_z, -1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z,  1.0);
                    lineVerts.push(s2_x,s2_y,s2_z, s1_x,s1_y,s1_z, -1.0);
                }
            };

            for (let v = 0; v < mcRes; v++) {
                for (let u = 0; u < mcRes; u++) {
                    const idx = u + v * N;
                    const v0 = values[idx], v1 = values[idx + 1], v2 = values[idx + 1 + N], v3 = values[idx + N];
                    if (Number.isNaN(v0) || Number.isNaN(v1) || Number.isNaN(v2) || Number.isNaN(v3)) continue;
                    
                    let sqIdx = 0;
                    if (v0 < 0) sqIdx |= 8; if (v1 < 0) sqIdx |= 4; if (v2 < 0) sqIdx |= 2; if (v3 < 0) sqIdx |= 1;
                    if (sqIdx === 0 || sqIdx === 15) continue;
                    
                    const fu = -range + u * step, fv = -range + v * step;
                    const pT = {u: fu + step * getOffset2D(v0, v1), v: fv};
                    const pR = {u: fu + step, v: fv + step * getOffset2D(v1, v2)};
                    const pB = {u: fu + step * getOffset2D(v3, v2), v: fv + step};
                    const pL = {u: fu, v: fv + step * getOffset2D(v0, v3)};

                    switch(sqIdx) {
                        case 1: case 14: pushSliceSegment(pL.u, pL.v, pB.u, pB.v); break;
                        case 2: case 13: pushSliceSegment(pB.u, pB.v, pR.u, pR.v); break;
                        case 3: case 12: pushSliceSegment(pL.u, pL.v, pR.u, pR.v); break;
                        case 4: case 11: pushSliceSegment(pT.u, pT.v, pR.u, pR.v); break;
                        case 5: pushSliceSegment(pT.u, pT.v, pL.u, pL.v); pushSliceSegment(pB.u, pB.v, pR.u, pR.v); break;
                        case 6: case 9: pushSliceSegment(pT.u, pT.v, pB.u, pB.v); break;
                        case 7: case 8: pushSliceSegment(pT.u, pT.v, pL.u, pL.v); break;
                        case 10: pushSliceSegment(pT.u, pT.v, pR.u, pR.v); pushSliceSegment(pB.u, pB.v, pL.u, pL.v); break;
                    }
                }
            }
            
            const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
            const useThickLines = entryThickness > 1.5;
            const count = lineVerts.length / (useThickLines ? 7 : 3);
            
            if (count > 0) {
                this.cache3D.lines.set(index, { 
                    vbo: this.createBuffer(lineVerts), 
                    count: count,
                    color: entry.color,
                    mode: useThickLines ? this.gl.TRIANGLES : this.gl.LINES,
                    thickness: entryThickness,
                    isThick: useThickLines
                });
            }

        } else if (is2D && entry.extendTo3D) {

            const isImplicitExtrusion = (entry.plotType === 'implicit');
            const isExplicitExtrusionX = (entry.plotType === 'x');
            const isExplicitExtrusionY = (entry.plotType === 'y');

            if (isExplicitExtrusionX || isExplicitExtrusionY) {

                const vertices = [];
                const normals = [];
                const resolution = Math.max(10, Math.floor(15 * this.explicitPrecisionStep));
                const step = (range * 2) / resolution;
                const grid = [];
                

                for(let i=0; i<=resolution; i++) {
                    for(let j=0; j<=resolution; j++) {
                        let u_screen = -range + i * step;
                        let v_screen = -range + j * step; 
                        let x_screen, y_screen, z_screen;
                        

                        
                        try {
                            if (isExplicitExtrusionY) {

                                x_screen = u_screen;
                                const x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                const y_math = entry.func(x_math, this.variables, Math, advancedFuncsMap);
                                y_screen = y_math / this.scale3D - this.offset3D.y;
                                z_screen = v_screen;
                            } else {

                                y_screen = u_screen;
                                const y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                const x_math = entry.func(y_math, this.variables, Math, advancedFuncsMap);
                                x_screen = x_math / this.scale3D - this.offset3D.x;
                                z_screen = v_screen;
                            }
                        } catch(e) { x_screen = NaN; }

                        if (Number.isFinite(x_screen) && Number.isFinite(y_screen) && Number.isFinite(z_screen)) {
                            grid.push({x: x_screen, y: y_screen, z: z_screen});
                        } else {
                            grid.push(null);
                        }
                    }
                }
                
                const N = resolution + 1;
                for(let i=0; i<resolution; i++) {
                    for(let j=0; j<resolution; j++) {
                        const idx = i * N + j;
                        const p1 = grid[idx]; const p2 = grid[idx+1]; const p3 = grid[idx+N]; const p4 = grid[idx+N+1];
                        if (p1 && p2 && p3) vertices.push(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z, p2.x, p2.y, p2.z);
                        if (p2 && p3 && p4) vertices.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z, p4.x, p4.y, p4.z);
                    }
                }
                
          
                 for(let k=0; k<vertices.length; k+=9) {
                     const ux = vertices[k+3] - vertices[k], uy = vertices[k+4] - vertices[k+1], uz = vertices[k+5] - vertices[k+2];
                     const vx = vertices[k+6] - vertices[k], vy = vertices[k+7] - vertices[k+1], vz = vertices[k+8] - vertices[k+2];
                     let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                     const len = Math.sqrt(nx*nx+ny*ny+nz*nz);
                     if (len > 0) { nx/=len; ny/=len; nz/=len; } else { nx=0; ny=0; nz=1; }
                     normals.push(nx,ny,nz, nx,ny,nz, nx,ny,nz); 
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else if (isImplicitExtrusion) {

                const vertices = [];
                const normals = [];
                const mcRes = Math.max(10, Math.min(160, Math.floor(200 / this.implicitPrecisionStep)));
                const step = (range * 2) / mcRes;
                const values = new Float32Array((mcRes + 1) * (mcRes + 1) * (mcRes + 1));
                
                let vIdx = 0;

                const layerValues = new Float32Array((mcRes + 1) * (mcRes + 1));
                
                for (let y = 0; y <= mcRes; y++) {
                    const fy_screen = -range + y * step;
                    const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                    for (let x = 0; x <= mcRes; x++) {
                        const fx_screen = -range + x * step;
                        const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                        let val = NaN;
                        try {
        
                            val = entry.func(fx_math, fy_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) {}
                         layerValues[y * (mcRes + 1) + x] = Number.isFinite(val) ? Math.max(-1e6, Math.min(1e6, val)) : NaN;
                    }
                }

                for (let z = 0; z <= mcRes; z++) {
                    values.set(layerValues, vIdx);
                    vIdx += layerValues.length;
                }

                const getOffset = (v1, v2) => {
                    const delta = v2 - v1;
                    if (Math.abs(delta) < 1e-9) return 0.5;
                    return Math.max(0, Math.min(1, (0 - v1) / delta));
                };

                 const getGradient = (x, y) => {
                    const h = 0.001 * this.scale3D;
                    let valMinusX, valPlusX, valMinusY, valPlusY;
                    try {
                        valMinusX = entry.func(x - h, y, this.variables, Math, advancedFuncsMap);
                        valPlusX = entry.func(x + h, y, this.variables, Math, advancedFuncsMap);
                        valMinusY = entry.func(x, y - h, this.variables, Math, advancedFuncsMap);
                        valPlusY = entry.func(x, y + h, this.variables, Math, advancedFuncsMap);
                    } catch(e) { return [0,1,0]; }

                    const dx = valPlusX - valMinusX;
                    const dy = valPlusY - valMinusY;
                    const dz = 0;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len > 1e-9) return [-dx/len, -dy/len, 0];
                    return [0, 1, 0];
                };

                const N = mcRes + 1;
                const NN = N * N;

                for (let z = 0; z < mcRes; z++) {
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N + z * NN;
                            if (Number.isNaN(values[idx])) continue; 
                            let cubeIndex = 0;
                            if (values[idx] < 0) cubeIndex |= 1;
                            if (values[idx + 1] < 0) cubeIndex |= 2;
                            if (values[idx + 1 + N] < 0) cubeIndex |= 4;
                            if (values[idx + N] < 0) cubeIndex |= 8;
                            if (values[idx + NN] < 0) cubeIndex |= 16;
                            if (values[idx + 1 + NN] < 0) cubeIndex |= 32;
                            if (values[idx + 1 + N + NN] < 0) cubeIndex |= 64;
                            if (values[idx + N + NN] < 0) cubeIndex |= 128;
                            if (edgeTable[cubeIndex] === 0) continue;

                            const fx = -range + x * step;
                            const fy = -range + y * step;
                            const fz = -range + z * step;
                            const vertList = new Array(12);

                            const v0=values[idx], v1=values[idx+1], v2=values[idx+1+N], v3=values[idx+N];
                            const v4=values[idx+NN], v5=values[idx+1+NN], v6=values[idx+1+N+NN], v7=values[idx+N+NN];
                            
                            if (edgeTable[cubeIndex] & 1) vertList[0] = [fx + step * getOffset(v0, v1), fy, fz];
                            if (edgeTable[cubeIndex] & 2) vertList[1] = [fx + step, fy + step * getOffset(v1, v2), fz];
                            if (edgeTable[cubeIndex] & 4) vertList[2] = [fx + step * (1 - getOffset(v2, v3)), fy + step, fz];
                            if (edgeTable[cubeIndex] & 8) vertList[3] = [fx, fy + step * (1 - getOffset(v3, v0)), fz];
                            if (edgeTable[cubeIndex] & 16) vertList[4] = [fx + step * getOffset(v4, v5), fy, fz + step];
                            if (edgeTable[cubeIndex] & 32) vertList[5] = [fx + step, fy + step * getOffset(v5, v6), fz + step];
                            if (edgeTable[cubeIndex] & 64) vertList[6] = [fx + step * (1 - getOffset(v6, v7)), fy + step, fz + step];
                            if (edgeTable[cubeIndex] & 128) vertList[7] = [fx, fy + step * (1 - getOffset(v7, v4)), fz + step];
                            if (edgeTable[cubeIndex] & 256) vertList[8] = [fx, fy, fz + step * getOffset(v0, v4)];
                            if (edgeTable[cubeIndex] & 512) vertList[9] = [fx + step, fy, fz + step * getOffset(v1, v5)];
                            if (edgeTable[cubeIndex] & 1024) vertList[10] = [fx + step, fy + step, fz + step * getOffset(v2, v6)];
                            if (edgeTable[cubeIndex] & 2048) vertList[11] = [fx, fy + step, fz + step * getOffset(v3, v7)];

                            for (let k = 0; triTable[cubeIndex][k] !== -1; k += 3) {
                                const p1 = vertList[triTable[cubeIndex][k]];
                                const p2 = vertList[triTable[cubeIndex][k + 1]];
                                const p3 = vertList[triTable[cubeIndex][k + 2]];
                                if (p1 && p2 && p3) {
                                    const n1 = getGradient((p1[0] + this.offset3D.x) * this.scale3D, (p1[1] + this.offset3D.y) * this.scale3D);
                                    const n2 = getGradient((p2[0] + this.offset3D.x) * this.scale3D, (p2[1] + this.offset3D.y) * this.scale3D);
                                    const n3 = getGradient((p3[0] + this.offset3D.x) * this.scale3D, (p3[1] + this.offset3D.y) * this.scale3D);
                                    vertices.push(...p1, ...p2, ...p3);
                                    normals.push(...n1, ...n2, ...n3);
                                }
                            }
                        }
                    }
                }
                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }
            }

        } else {

            if (entry.plotType === 'z' || entry.plotType === 'x3d' || entry.plotType === 'y3d') {
                const vertices = [];
                const normals = [];
                const resolution = Math.max(10, Math.floor(15 * this.explicitPrecisionStep));
                const step = (range * 2) / resolution;
                const grid = [];
                
                for(let i=0; i<=resolution; i++) {
                    for(let j=0; j<=resolution; j++) {
                        let u_screen = -range + i * step;
                        let v_screen = -range + j * step;
                        let x_math, y_math, z_math;
                        let x_screen, y_screen, z_screen;
                        
                        try {
                            if (entry.plotType === 'z') {
                                x_screen = u_screen; y_screen = v_screen;
                                x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                z_math = entry.func(x_math, y_math, 0, this.variables, Math, advancedFuncsMap);
                                z_screen = z_math / this.scale3D;
                            } else if (entry.plotType === 'x3d') {
                                y_screen = u_screen; z_screen = v_screen;
                                y_math = (y_screen + this.offset3D.y) * this.scale3D;
                                z_math = z_screen * this.scale3D; 
                                x_math = entry.func(0, y_math, z_math, this.variables, Math, advancedFuncsMap);
                                x_screen = x_math / this.scale3D - this.offset3D.x;
                            } else { 
                                x_screen = u_screen; z_screen = v_screen;
                                x_math = (x_screen + this.offset3D.x) * this.scale3D;
                                z_math = z_screen * this.scale3D;
                                y_math = entry.func(x_math, 0, z_math, this.variables, Math, advancedFuncsMap);
                                y_screen = y_math / this.scale3D - this.offset3D.y;
                            }
                        } catch(e) { z_math = NaN; }

                        if (Number.isFinite(x_screen) && Number.isFinite(y_screen) && Number.isFinite(z_screen)) {
                            grid.push({x: x_screen, y: y_screen, z: z_screen});
                        } else {
                            grid.push(null);
                        }
                    }
                }
                
                const N = resolution + 1;
                for(let i=0; i<resolution; i++) {
                    for(let j=0; j<resolution; j++) {
                        const idx = i * N + j;
                        const p1 = grid[idx];
                        const p2 = grid[idx+1]; 
                        const p3 = grid[idx+N]; 
                        const p4 = grid[idx+N+1];
                        
                        if (p1 && p2 && p3) vertices.push(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z, p2.x, p2.y, p2.z);
                        if (p2 && p3 && p4) vertices.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z, p4.x, p4.y, p4.z);
                    }
                }
                
                for(let k=0; k<vertices.length; k+=9) {
                     const ux = vertices[k+3] - vertices[k], uy = vertices[k+4] - vertices[k+1], uz = vertices[k+5] - vertices[k+2];
                     const vx = vertices[k+6] - vertices[k], vy = vertices[k+7] - vertices[k+1], vz = vertices[k+8] - vertices[k+2];
                     let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                     const len = Math.sqrt(nx*nx+ny*ny+nz*nz);
                     if (len > 0) { nx/=len; ny/=len; nz/=len; } else { nx=0; ny=0; nz=1; }
                     normals.push(nx,ny,nz, nx,ny,nz, nx,ny,nz); 
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else if (entry.plotType === 'implicit3d') {

                const vertices = [];
                const normals = [];
                const mcRes = Math.max(10, Math.min(160, Math.floor(200 / this.implicitPrecisionStep)));
                const step = (range * 2) / mcRes;
                const values = new Float32Array((mcRes + 1) * (mcRes + 1) * (mcRes + 1));
                
                let vIdx = 0;
                for (let z = 0; z <= mcRes; z++) {
                    const fz_screen = -range + z * step;
                    const fz_math = fz_screen * this.scale3D;
                    for (let y = 0; y <= mcRes; y++) {
                        const fy_screen = -range + y * step;
                        const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                        for (let x = 0; x <= mcRes; x++) {
                            const fx_screen = -range + x * step;
                            const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                            let val = NaN;
                            try {
                                val = entry.func(fx_math, fy_math, fz_math, this.variables, Math, advancedFuncsMap);
                            } catch (e) {}
                            values[vIdx++] = Number.isFinite(val) ? Math.max(-1e6, Math.min(1e6, val)) : NaN;
                        }
                    }
                }
                
                const getOffset = (v1, v2) => {
                    const delta = v2 - v1;
                    if (Math.abs(delta) < 1e-9) return 0.5;
                    return Math.max(0, Math.min(1, (0 - v1) / delta));
                };

                const getGradient = (x, y, z) => {
                    const h = 0.001 * this.scale3D;
                    let valMinusX, valPlusX, valMinusY, valPlusY, valMinusZ, valPlusZ;
                    try {
                        valMinusX = entry.func(x - h, y, z, this.variables, Math, advancedFuncsMap);
                        valPlusX = entry.func(x + h, y, z, this.variables, Math, advancedFuncsMap);
                        valMinusY = entry.func(x, y - h, z, this.variables, Math, advancedFuncsMap);
                        valPlusY = entry.func(x, y + h, z, this.variables, Math, advancedFuncsMap);
                        valMinusZ = entry.func(x, y, z - h, this.variables, Math, advancedFuncsMap);
                        valPlusZ = entry.func(x, y, z + h, this.variables, Math, advancedFuncsMap);
                    } catch(e) { return [0,1,0]; }

                    const dx = valPlusX - valMinusX;
                    const dy = valPlusY - valMinusY;
                    const dz = valPlusZ - valMinusZ;
                    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (len > 1e-9) return [-dx/len, -dy/len, -dz/len];
                    return [0, 1, 0];
                };

                const N = mcRes + 1;
                const NN = N * N;

                for (let z = 0; z < mcRes; z++) {
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N + z * NN;
                            const val0 = values[idx];
                            if (Number.isNaN(val0)) continue; 

                            let cubeIndex = 0;
                            if (values[idx] < 0) cubeIndex |= 1;
                            if (values[idx + 1] < 0) cubeIndex |= 2;
                            if (values[idx + 1 + N] < 0) cubeIndex |= 4;
                            if (values[idx + N] < 0) cubeIndex |= 8;
                            if (values[idx + NN] < 0) cubeIndex |= 16;
                            if (values[idx + 1 + NN] < 0) cubeIndex |= 32;
                            if (values[idx + 1 + N + NN] < 0) cubeIndex |= 64;
                            if (values[idx + N + NN] < 0) cubeIndex |= 128;
                            
                            if (edgeTable[cubeIndex] === 0) continue;
                            
                            const fx = -range + x * step;
                            const fy = -range + y * step;
                            const fz = -range + z * step;
                            
                            const vertList = new Array(12);
                            const v0=values[idx], v1=values[idx+1], v2=values[idx+1+N], v3=values[idx+N];
                            const v4=values[idx+NN], v5=values[idx+1+NN], v6=values[idx+1+N+NN], v7=values[idx+N+NN];
                            
                            if (edgeTable[cubeIndex] & 1) vertList[0] = [fx + step * getOffset(v0, v1), fy, fz];
                            if (edgeTable[cubeIndex] & 2) vertList[1] = [fx + step, fy + step * getOffset(v1, v2), fz];
                            if (edgeTable[cubeIndex] & 4) vertList[2] = [fx + step * (1 - getOffset(v2, v3)), fy + step, fz];
                            if (edgeTable[cubeIndex] & 8) vertList[3] = [fx, fy + step * (1 - getOffset(v3, v0)), fz];
                            if (edgeTable[cubeIndex] & 16) vertList[4] = [fx + step * getOffset(v4, v5), fy, fz + step];
                            if (edgeTable[cubeIndex] & 32) vertList[5] = [fx + step, fy + step * getOffset(v5, v6), fz + step];
                            if (edgeTable[cubeIndex] & 64) vertList[6] = [fx + step * (1 - getOffset(v6, v7)), fy + step, fz + step];
                            if (edgeTable[cubeIndex] & 128) vertList[7] = [fx, fy + step * (1 - getOffset(v7, v4)), fz + step];
                            if (edgeTable[cubeIndex] & 256) vertList[8] = [fx, fy, fz + step * getOffset(v0, v4)];
                            if (edgeTable[cubeIndex] & 512) vertList[9] = [fx + step, fy, fz + step * getOffset(v1, v5)];
                            if (edgeTable[cubeIndex] & 1024) vertList[10] = [fx + step, fy + step, fz + step * getOffset(v2, v6)];
                            if (edgeTable[cubeIndex] & 2048) vertList[11] = [fx, fy + step, fz + step * getOffset(v3, v7)];
                            
                            for (let k = 0; triTable[cubeIndex][k] !== -1; k += 3) {
                                const p1 = vertList[triTable[cubeIndex][k]];
                                const p2 = vertList[triTable[cubeIndex][k + 1]];
                                const p3 = vertList[triTable[cubeIndex][k + 2]];
                                
                                if (p1 && p2 && p3) {
                                    const n1 = getGradient((p1[0] + this.offset3D.x) * this.scale3D, (p1[1] + this.offset3D.y) * this.scale3D, p1[2] * this.scale3D);
                                    const n2 = getGradient((p2[0] + this.offset3D.x) * this.scale3D, (p2[1] + this.offset3D.y) * this.scale3D, p2[2] * this.scale3D);
                                    const n3 = getGradient((p3[0] + this.offset3D.x) * this.scale3D, (p3[1] + this.offset3D.y) * this.scale3D, p3[2] * this.scale3D);
                                    
                                    vertices.push(...p1, ...p2, ...p3);
                                    normals.push(...n1, ...n2, ...n3);
                                }
                            }
                        }
                    }
                }

                if (vertices.length > 0) {
                    const vbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                    
                    const nbo = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, nbo);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);

                    this.cache3D.meshes.set(index, { vbo, nbo, count: vertices.length / 3, color: entry.color });
                }

            } else {

                const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useThickLines = entryThickness > 1.5;
                const lineVerts = [];

                const pushSegment = (x1, y1, z1, x2, y2, z2) => {
                    if (!useThickLines) {
                        lineVerts.push(x1, y1, z1, x2, y2, z2);
                    } else {

                        lineVerts.push(x1,y1,z1, x2,y2,z2,  1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1,  1.0);
                        lineVerts.push(x1,y1,z1, x2,y2,z2, -1.0);
                        
                        lineVerts.push(x1,y1,z1, x2,y2,z2, -1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1,  1.0);
                        lineVerts.push(x2,y2,z2, x1,y1,z1, -1.0);
                    }
                };

                if (entry.plotType === 'parametric3d' || entry.plotType === 'parametric') {
                    const numSteps = Math.max(100, Math.floor(this.explicitPrecisionStep * 200));
                    const tStep = (this.tmax - this.tmin) / numSteps;
                    let lastP = null;
                    
                    for (let i = 0; i <= numSteps; i++) {
                       const t = this.tmin + i * tStep;
                       let x_math, y_math, z_math;
                       try {
                           x_math = entry.funcX(t, this.variables, Math, advancedFuncsMap);
                           y_math = entry.funcY(t, this.variables, Math, advancedFuncsMap);
                           if (entry.plotType === 'parametric3d') z_math = entry.funcZ(t, this.variables, Math, advancedFuncsMap);
                           else z_math = 0;
                       } catch(e) { x_math=NaN; }
                       
                       if (Number.isFinite(x_math) && Number.isFinite(y_math) && Number.isFinite(z_math)) {
                           const currentP = {
                               x: x_math / this.scale3D - this.offset3D.x,
                               y: y_math / this.scale3D - this.offset3D.y,
                               z: z_math / this.scale3D
                           };
                           if (Math.abs(currentP.x) <= range && Math.abs(currentP.y) <= range && Math.abs(currentP.z) <= range) {
                               if (lastP) pushSegment(lastP.x, lastP.y, lastP.z, currentP.x, currentP.y, currentP.z);
                               lastP = currentP;
                           } else {
                               lastP = null;
                           }
                       } else {
                           lastP = null;
                       }
                    }
                } else if (entry.plotType === 'y' || entry.plotType === 'x') {
                    const numSteps = Math.max(100, Math.floor(this.explicitPrecisionStep * 200));
                    const rangeX = this.bounds3D; 
                    const step = (rangeX * 2) / numSteps;
                    let lastP = null;
                    for (let i = 0; i <= numSteps; i++) {
                        const val1 = -rangeX + i * step;
                        let x_math, y_math;
                        try {
                            if (entry.plotType === 'y') {
                                x_math = (val1 + this.offset3D.x) * this.scale3D;
                                y_math = entry.func(x_math, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_math = (val1 + this.offset3D.y) * this.scale3D;
                                x_math = entry.func(y_math, this.variables, Math, advancedFuncsMap);
                            }
                        } catch(e) { x_math=NaN; y_math=NaN; }
                        if (Number.isFinite(x_math) && Number.isFinite(y_math)) {
                             const currentP = {
                               x: x_math / this.scale3D - this.offset3D.x,
                               y: y_math / this.scale3D - this.offset3D.y,
                               z: 0
                           };
                           if (Math.abs(currentP.x) <= range && Math.abs(currentP.y) <= range) {
                               if (lastP) pushSegment(lastP.x, lastP.y, lastP.z, currentP.x, currentP.y, currentP.z);
                               lastP = currentP;
                           } else { lastP = null; }
                        } else lastP = null;
                    }
                } else if (entry.plotType === 'implicit') {
                    const mcRes = Math.max(10, Math.min(200, Math.floor(250 / this.implicitPrecisionStep)));
                    const step = (range * 2) / mcRes;
                    const values = new Float32Array((mcRes + 1) * (mcRes + 1));
                    let vIdx = 0;
                    for (let y = 0; y <= mcRes; y++) {
                        const fy_screen = -range + y * step;
                        const fy_math = (fy_screen + this.offset3D.y) * this.scale3D;
                        for (let x = 0; x <= mcRes; x++) {
                            const fx_screen = -range + x * step;
                            const fx_math = (fx_screen + this.offset3D.x) * this.scale3D;
                            let val = NaN;
                            try { val = entry.func(fx_math, fy_math, this.variables, Math, advancedFuncsMap); } catch (e) {}
                            values[vIdx++] = Number.isFinite(val) ? val : NaN;
                        }
                    }
                    const getOffset2D = (v1, v2) => {
                         const delta = v2 - v1;
                         if (Math.abs(delta) < 1e-9) return 0.5;
                         return Math.max(0, Math.min(1, (0 - v1) / delta));
                    };
                    const N = mcRes + 1;
                    for (let y = 0; y < mcRes; y++) {
                        for (let x = 0; x < mcRes; x++) {
                            const idx = x + y * N;
                            const v0 = values[idx], v1 = values[idx + 1], v2 = values[idx + 1 + N], v3 = values[idx + N];
                            if (Number.isNaN(v0) || Number.isNaN(v1) || Number.isNaN(v2) || Number.isNaN(v3)) continue;
                            let sqIdx = 0;
                            if (v0 < 0) sqIdx |= 8; if (v1 < 0) sqIdx |= 4; if (v2 < 0) sqIdx |= 2; if (v3 < 0) sqIdx |= 1;
                            if (sqIdx === 0 || sqIdx === 15) continue;
                            const fx = -range + x * step, fy = -range + y * step;
                            const pT = {x: fx + step * getOffset2D(v0, v1), y: fy, z: 0};
                            const pR = {x: fx + step, y: fy + step * getOffset2D(v1, v2), z: 0};
                            const pB = {x: fx + step * getOffset2D(v3, v2), y: fy + step, z: 0};
                            const pL = {x: fx, y: fy + step * getOffset2D(v0, v3), z: 0};
                            switch(sqIdx) {
                                case 1: case 14: pushSegment(pL.x, pL.y, 0, pB.x, pB.y, 0); break;
                                case 2: case 13: pushSegment(pB.x, pB.y, 0, pR.x, pR.y, 0); break;
                                case 3: case 12: pushSegment(pL.x, pL.y, 0, pR.x, pR.y, 0); break;
                                case 4: case 11: pushSegment(pT.x, pT.y, 0, pR.x, pR.y, 0); break;
                                case 5: pushSegment(pT.x, pT.y, 0, pL.x, pL.y, 0); pushSegment(pB.x, pB.y, 0, pR.x, pR.y, 0); break;
                                case 6: case 9: pushSegment(pT.x, pT.y, 0, pB.x, pB.y, 0); break;
                                case 7: case 8: pushSegment(pT.x, pT.y, 0, pL.x, pL.y, 0); break;
                                case 10: pushSegment(pT.x, pT.y, 0, pR.x, pR.y, 0); pushSegment(pB.x, pB.y, 0, pL.x, pL.y, 0); break;
                            }
                        }
                    }
                }
                
                const count = lineVerts.length / (useThickLines ? 7 : 3);
                
                this.cache3D.lines.set(index, { 
                    vbo: this.createBuffer(lineVerts), 
                    count: count,
                    color: entry.color,
                    mode: useThickLines ? this.gl.TRIANGLES : this.gl.LINES,
                    thickness: entryThickness,
                    isThick: useThickLines
                });
            }
        }
    });
    this.calculateAuxiliary3D();
}


    createBuffer(data) {
        const buf = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buf);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
        return buf;
    }

draw3D() {
        const gl = this.gl;
        const width = this.canvas.width; 
        const height = this.canvas.height; 
        const dpr = window.devicePixelRatio || 1;
        
        const sidebar = document.getElementById('sidebar-background');

        const isSidebarVisible = !document.body.classList.contains('sidebar-hidden') && sidebar && (this.isTransparencyEnabled || this.isPortraitMode);
        
        let viewX = 0;
        let viewY = 0;
        let viewW = width;
        let viewH = height;
        
        if (isSidebarVisible) {
            const rect = sidebar.getBoundingClientRect();
            if (this.isPortraitMode) {
                const sidebarHeightPhysical = rect.height * dpr;
                viewH = height - sidebarHeightPhysical;
                viewY = sidebarHeightPhysical; 
            } else {
                const sidebarWidthPhysical = rect.width * dpr;
                viewX = sidebarWidthPhysical;
                viewW = width - sidebarWidthPhysical;
            }
        }
        
        this.viewport3D = {
            x: viewX / dpr,
            y: viewY / dpr, 
            w: viewW / dpr,
            h: viewH / dpr
        };

        gl.viewport(viewX, viewY, viewW, viewH);
        
        const isDark = this.isDarkModeActive;
        
        if (isDark) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0); 
        } else {
            const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
            let r = 1.0, g = 1.0, b_val = 1.0;
            const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
            if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255; }
            gl.clearColor(r, g, b_val, 1.0);
        }

        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const aspect = viewW / viewH;
        const projection = Mat4.perspective(Mat4.create(), Math.PI / 4, aspect, 0.1, 1000.0);
        
        const cam = this.camera3D;
        const eye = {
            x: cam.rho * Math.sin(cam.phi) * Math.cos(cam.theta),
            y: cam.rho * Math.sin(cam.phi) * Math.sin(cam.theta),
            z: cam.rho * Math.cos(cam.phi)
        };
        
        const view = Mat4.lookAt(Mat4.create(), eye, {x:0, y:0, z:0}, {x:0, y:0, z:1});
        const mvp = Mat4.multiply(Mat4.create(), projection, view);
        
        const lightDir = [eye.x, eye.y, eye.z];

        gl.useProgram(this.shaderProgram3D);
        gl.uniformMatrix4fv(this.uniformLoc3D.mvp, false, mvp);
        gl.uniformMatrix4fv(this.uniformLoc3D.normalMat, false, Mat4.create()); 
        gl.uniform3fv(this.uniformLoc3D.lightDir, lightDir);
        gl.uniform1f(this.uniformLoc3D.bounds, this.bounds3D);

this.cache3D.meshes.forEach((mesh, idx) => {
            const entry = this.entries[idx];
            if (!entry || !entry.visible) return;
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.position);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.nbo);
            gl.vertexAttribPointer(this.attribLoc3D.normal, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.normal);
            
            const col = this.hsbToRgbaArray(mesh.color.h, mesh.color.s, mesh.color.b, mesh.color.a);
            gl.uniform4fv(this.uniformLoc3D.color, col);
            
            gl.drawArrays(gl.TRIANGLES, 0, mesh.count);
        });
        
        if (this.showAxes && this.cache3D.axes) {
             gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.axes.vbo);
             gl.vertexAttribPointer(this.attribLoc3D.position, 3, gl.FLOAT, false, 24, 0);
             gl.enableVertexAttribArray(this.attribLoc3D.position);
             gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.axes.vbo); 
             gl.vertexAttribPointer(this.attribLoc3D.normal, 3, gl.FLOAT, false, 24, 12); 
             gl.enableVertexAttribArray(this.attribLoc3D.normal);
             
             gl.uniform4f(this.uniformLoc3D.color, 0.8, 0.1, 0.1, 1.0); 
             gl.drawArrays(gl.TRIANGLES, 0, this.cache3D.axes.count / 3);
             gl.uniform4f(this.uniformLoc3D.color, 0.1, 0.1, 0.8, 1.0);
             gl.drawArrays(gl.TRIANGLES, this.cache3D.axes.count / 3, this.cache3D.axes.count / 3);
             gl.uniform4f(this.uniformLoc3D.color, 0.1, 0.8, 0.1, 1.0);
             gl.drawArrays(gl.TRIANGLES, 2 * this.cache3D.axes.count / 3, this.cache3D.axes.count / 3);
        }

        gl.useProgram(this.shaderProgram3DLine);
        gl.uniformMatrix4fv(this.uniformLoc3D.lineMvp, false, mvp);
        gl.uniform1f(this.uniformLoc3D.lineBounds, this.bounds3D);
        
        if (this.gridStyle !== 'hidden' && this.cache3D.grid) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.grid.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc3D.linePos);
            const gridCol = isDark ? 0.3 : 0.7;
            gl.uniform4f(this.uniformLoc3D.lineColor, gridCol, gridCol, gridCol, 1.0);
            gl.drawArrays(gl.LINES, 0, this.cache3D.grid.count);
        }

        if (this.cache3D.box) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.box.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cache3D.box.ibo);
            const boxCol = isDark ? 0.6 : 0.5;
            gl.uniform4f(this.uniformLoc3D.lineColor, boxCol, boxCol, boxCol, 1.0);
            gl.drawElements(gl.LINES, this.cache3D.box.count, gl.UNSIGNED_SHORT, 0);
        }
        
        if (this.showAxes && this.cache3D.ticks) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cache3D.ticks.vbo);
            gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
            const tickCol = isDark ? 0.9 : 0.2;
            gl.uniform4f(this.uniformLoc3D.lineColor, tickCol, tickCol, tickCol, 1.0);
            gl.drawArrays(gl.LINES, 0, this.cache3D.ticks.count);
        }

this.cache3D.lines.forEach((line, idx) => {
            const entry = this.entries[idx];
            if (!entry || !entry.visible) return;
            
            if (line.isThick) {
                gl.useProgram(this.shaderProgram3DThick);
                gl.uniformMatrix4fv(this.uniformLoc3D.thickMvp, false, mvp);
                gl.uniform2f(this.uniformLoc3D.thickViewport, viewW, viewH);
                gl.uniform1f(this.uniformLoc3D.thickThickness, line.thickness);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
                
                const stride = 28; 
                gl.vertexAttribPointer(this.attribLoc3D.thickPos, 3, gl.FLOAT, false, stride, 0);
                gl.enableVertexAttribArray(this.attribLoc3D.thickPos);
                
                gl.vertexAttribPointer(this.attribLoc3D.thickOther, 3, gl.FLOAT, false, stride, 12);
                gl.enableVertexAttribArray(this.attribLoc3D.thickOther);
                
                gl.vertexAttribPointer(this.attribLoc3D.thickSide, 1, gl.FLOAT, false, stride, 24);
                gl.enableVertexAttribArray(this.attribLoc3D.thickSide);
                
                const col = this.hsbToRgbaArray(line.color.h, line.color.s, line.color.b, line.color.a);
                gl.uniform4fv(this.uniformLoc3D.thickColor, col);
                
                gl.drawArrays(gl.TRIANGLES, 0, line.count);
                
            } else {
                gl.useProgram(this.shaderProgram3DLine);
                gl.uniformMatrix4fv(this.uniformLoc3D.lineMvp, false, mvp);
                gl.uniform1f(this.uniformLoc3D.lineBounds, this.bounds3D);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
                gl.vertexAttribPointer(this.attribLoc3D.linePos, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.attribLoc3D.linePos);
                
                const col = this.hsbToRgbaArray(line.color.h, line.color.s, line.color.b, line.color.a);
                gl.uniform4fv(this.uniformLoc3D.lineColor, col);
                
                gl.drawArrays(gl.LINES, 0, line.count);
            }
        });
        

this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        if (this.showAxes && this.showAxisNumbers) {
            this.draw3DLabels(mvp, viewW, viewH, viewX, viewY);
        }
    }



 draw3DLabels(mvp, width, height, viewX, viewY) {
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        
        ctx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        
        if (!this.cache3D.labels) return;

        ctx.save();
        ctx.scale(dpr, dpr);
        
        ctx.beginPath();
        ctx.rect(viewX / dpr, (this.canvas.height - viewY - height) / dpr, width / dpr, height / dpr);
        ctx.clip();

        ctx.font = "16px 'HarmonyOS_SC', Arial";
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const cssViewWidth = width / dpr;
        const cssViewHeight = height / dpr;
        const cssViewX = viewX / dpr;

        const cssViewY = (this.canvas.height - viewY - height) / dpr;

        this.cache3D.labels.forEach(lbl => {
            const pos = [lbl.x, lbl.y, lbl.z];
            Mat4.transformVec3(pos, pos, mvp);
            
            if (pos[2] > 1.0 || pos[2] < -1.0) return;
            
            const x_rel = (pos[0] + 1) * 0.5 * cssViewWidth;
            const y_rel = (1 - pos[1]) * 0.5 * cssViewHeight;
            
            const x = cssViewX + x_rel;
            const y = cssViewY + y_rel;
            
            ctx.fillText(lbl.text, x, y);
        });
        
        ctx.restore();
    }


evaluateExpression(processedExprString) {
try {
    const funcArgs = ['variables', 'Math', '__advanced__'];
    const varDeclarations = Array.from(this.variables.keys()).map(depKey =>
       `const ${depKey} = variables.has('${depKey}') ? variables.get('${depKey}') : NaN;`
    ).join(' ');
     const mathDeclaration = 'const Math = arguments[1];';
     const advancedDeclaration = 'const __advanced__ = arguments[2];';
    const funcBody = `try { const variables = arguments[0]; ${mathDeclaration} ${advancedDeclaration} ${varDeclarations} return (${processedExprString}); } catch(e) { return NaN; }`;
    const expressionFunc = new Function(...funcArgs, funcBody);
    const result = expressionFunc(this.variables, Math, this.calcJSUtils.getAdvancedFuncsMap());
    return (typeof result === 'number' && !Number.isFinite(result) && !Number.isNaN(result)) ? NaN : result;
} catch (e) {
    throw new Error(`在 evaluateExpression 中求值错误: ${e.message} 表达式: ${processedExprString}`);
}
}

substituteVariablesForEvaluation(exprString) {
let result = exprString;
const sortedVariableKeys = Array.from(this.variables.keys()).sort((a, b) => b.length - a.length);
for (const varKey of sortedVariableKeys) {
   const value = this.variables.get(varKey);
   const valueString = Number.isFinite(value) ? String(value) : 'NaN';
   const regex = new RegExp(`\\b${varKey}\\b`, 'gi');
   result = result.replace(regex, `(${valueString})`);
}
return result;
}

substituteVariables(exprString) {
let substituted = exprString;
const sortedVariableEntries = this.entries.filter(e => e.type === 'variable').sort((a, b) => b.name.length - a.name.length);
for (const entry of sortedVariableEntries) {
    const varName = entry.name;
    const varKey = entry.key;
    const value = this.variables.get(varKey);
     const valueString = Number.isFinite(value) ? String(value) : 'NaN';
    const regex = new RegExp(`\\b${varName}\\b`, 'gi');
    substituted = substituted.replace(regex, `(${valueString})`);
}
return substituted;
}

      toggleGlobalScriptView() {
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        const scriptView = document.getElementById('global-script-view');
        const toggleBtn = document.getElementById('global-script-toggle-btn');
        
        if (scriptView.style.display === 'none') {

            listView.style.display = 'none';
            editorView.style.display = 'none';
            scriptView.style.display = 'flex';
            toggleBtn.textContent = '退出编辑';
            document.getElementById('main-content-title').textContent = "全局脚本";
        } else {

            scriptView.style.display = 'none';
            listView.style.display = 'flex';
            toggleBtn.textContent = '全局脚本';
            document.getElementById('main-content-title').textContent = "代码";
        }
    }

    stopGlobalScript() {
        if (this.globalScriptIntervalId) {
            clearInterval(this.globalScriptIntervalId);
            this.globalScriptIntervalId = null;
        }
        this.pen.segments = [];
        this.requestDraw();
    }





     deleteEntryByIdentifier(identifier, allowedTypes) {
        const lowerIdentifier = identifier.toLowerCase();

        const indexToDelete = this.entries.findIndex(e =>
            allowedTypes.includes(e.type) &&
            ((e.name && e.name.toLowerCase() === lowerIdentifier) ||
             (e.key && e.key === lowerIdentifier) ||
             (e.expr && e.expr.toLowerCase() === lowerIdentifier))
        );

        if (indexToDelete !== -1) {
            this._handleCascadingDelete(indexToDelete);
        }
    }



        _handleCascadingDelete(startIndex) {
        if (startIndex < 0 || startIndex >= this.entries.length) return;

        const initialEntry = this.entries[startIndex];
        const isInitialEntryGeometric = initialEntry.type === 'geometry';

        const itemsToDeleteIndices = new Set([startIndex]);
        const queue = [];
        const initialIdentifier = (initialEntry.name || initialEntry.key || '').toLowerCase();
        if (initialIdentifier) queue.push(initialIdentifier);

        const processedInQueue = new Set(queue);

        while (queue.length > 0) {
            const currentId = queue.shift();
            for (let i = 0; i < this.entries.length; i++) {
                if (itemsToDeleteIndices.has(i)) continue;
                const dependentEntry = this.entries[i];

                if (dependentEntry.dependencies && dependentEntry.dependencies.includes(currentId)) {
                    const isDependentEntryGeometric = dependentEntry.type === 'geometry';
                    

                    if (isInitialEntryGeometric === isDependentEntryGeometric) {
                        itemsToDeleteIndices.add(i);
                        const dependentId = (dependentEntry.name || dependentEntry.key || '').toLowerCase();
                        if (dependentId && !processedInQueue.has(dependentId)) {
                            queue.push(dependentId);
                            processedInQueue.add(dependentId);
                        }
                    }
                }
            }
        }

        const sortedIndices = Array.from(itemsToDeleteIndices).sort((a, b) => b - a);
        sortedIndices.forEach(idx => {
            const entryToDelete = this.entries[idx];
            if (entryToDelete) {
                if (entryToDelete.type === 'custom_function_definition') {
                    delete this.calcJSUtils.customFunctions[entryToDelete.name];
                    this.calcJSUtils.calc3 = this.calcJSUtils.calc3.filter(n => n !== entryToDelete.name);
                } else if (entryToDelete.type === 'advanced_custom_function_definition') {
                    delete this.calcJSUtils.advancedCustomFunctions[entryToDelete.name];
                    this.calcJSUtils.advancedCustomFunctionNames = this.calcJSUtils.advancedCustomFunctionNames.filter(n => n !== entryToDelete.name);
                }
                this.entries.splice(idx, 1);
            }
        });

        this.annotations.forEach(anno => {
            if (anno.type === 'checkbox' && anno.controlledNames) {

                anno.controlledNames = anno.controlledNames.filter(savedId => 
                    this.entries.some(entry => (entry.name || entry.expr) === savedId)
                );
            }
        });
 
        this.recalculateAll();
        this.updateGlobalPlayState();
    }

      deleteEntryByIndex(index) {
        const adjustedIndex = index - 1;
        if (adjustedIndex < 0 || adjustedIndex >= this.entries.length) {
            console.warn(`deleteindex: Invalid index ${index}.`);
            return;
        }
        this._handleCascadingDelete(adjustedIndex);
    }

    clearAllEntries() {
        this.entries = [];
        this.categoryFilterMode = 0;
        this.updateCategoryButtonIcon();
        this.variables.clear();
        this.calcJSUtils.customFunctions = {};
        this.calcJSUtils.calc3 = [];
        
const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        for (let i = ADVANCED_FUNCTION_DEFINITIONS.length - 1; i >= 0; i--) {
            if (!defaultAdvancedFunctionNames.has(ADVANCED_FUNCTION_DEFINITIONS[i].name)) {
                ADVANCED_FUNCTION_DEFINITIONS.splice(i, 1);
            }
        }
        
        this.initializeAdvancedCalcJSFunctions();
        this.initializeCalcJSBuiltinFunctions();
        this.pen.segments = [];
this.annotations = [];
        this.recalculateAll();
    }


       executeGlobalScript() {
        this.stopGlobalScript();
        this.globalScript = document.getElementById('global-script-input').value;

        this.performanceModeEnabled = false;
        this.smoothPanningEnabled = false;
        this.lowPrecisionBufferEnabled = false;
        if (this.performanceModeToggle) this.performanceModeToggle.checked = false;
        if (this.smoothPanningToggle) this.smoothPanningToggle.checked = false;
        if (this.lowPrecisionBufferToggle) this.lowPrecisionBufferToggle.checked = false;

        const archProxy = {
            create: (expr) => {
                setTimeout(() => this.addEntry(expr), 0);
            },
            createfunc: (expr, h, s, b, a, visible) => {
                setTimeout(() => {
                    const initialLength = this.entries.length;
                    this.addEntry(expr);
                    if (this.entries.length > initialLength) {
                        const newEntry = this.entries[this.entries.length - 1];
                        if (newEntry.type === 'function') {
                            newEntry.color = { h: h || 0, s: s || 100, b: b || 85, a: a || 0 };
                            newEntry.visible = (visible === 1);
                            this.recalculateAll();
                        }
                    }
                }, 0);
            },
            creategeo: (expr, h, s, b, a, visible) => {
                setTimeout(() => {
                    const initialLength = this.entries.length;
                    this.addEntry(expr);
                    if (this.entries.length > initialLength) {
                        const newEntry = this.entries[this.entries.length - 1];
                        if (newEntry.type === 'geometry') {
                            newEntry.color = { h: h || 0, s: s || 0, b: this.isDarkModeActive ? 100 : 0, a: a || 0 };
                            newEntry.visible = (visible === 1);
                            this.recalculateAll();
                        }
                    }
                }, 0);
            },
            deletegeo: (name) => {
                setTimeout(() => this.deleteEntryByIdentifier(name, ['geometry']), 0);
            },
            deletefunc: (identifier) => {
                setTimeout(() => this.deleteEntryByIdentifier(identifier, ['function', 'variable', 'constant', 'custom_function_definition', 'advanced_custom_function_definition']), 0);
            },
            deleteindex: (index) => {
                 setTimeout(() => this.deleteEntryByIndex(index), 0);
            },
            clearall: () => {
                setTimeout(() => this.clearAllEntries(), 0);
            },
            calc: (expr) => {
                return this.evaluateExpressionWithCalcJS(expr, {});
            },
            coordinate: (pointName, axis) => {
                if (pointName === 0) {
                    const cssWidth = this.canvas.clientWidth;
                    const cssHeight = this.canvas.clientHeight;
                    if (axis === 'x') {
                        return (cssWidth / 2 - this.offset.x) / this.scale;
                    } else if (axis === 'y') {
                        return (this.offset.y - cssHeight / 2) / this.scale;
                    }
                    return NaN;
                }
                const p = this.entries.find(e => e.name === pointName && e.type === 'geometry' && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(e.geometryType));
                if (!p || !p.isMeaningful) return NaN;
                return axis === 'x' ? p.x_val : (axis === 'y' ? p.y_val : NaN);
            },
            setcanvas: (x, y, zoom) => {
                if (typeof x === 'number' && typeof y === 'number' && typeof zoom === 'number' && zoom > 0) {
                    const cssWidth = this.canvas.clientWidth;
                    const cssHeight = this.canvas.clientHeight;
                    this.scale = Math.min(this.maxScale, Math.max(this.minScale, zoom));
                    this.offset.x = cssWidth / 2 - x * this.scale;
                    this.offset.y = cssHeight / 2 + y * this.scale;
                    this.recalculateAll();
                }
            },
            valuesetting: (varName, value, max, min, step) => {
                const entry = this.entries.find(e => e.type === 'variable' && e.isEditableIndependent && e.name === varName);
                if (entry) {
                    if (typeof value === 'number') entry.value = value;
                    if (typeof max === 'number') entry.max = max;
                    if (typeof min === 'number') entry.min = min;
                    if (typeof step === 'number' && step > 0) entry.step = step;

                    if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
                    if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
                    
                    this.recalculateAll();
                }
            },
            message: (text, time) => {
                this.showInfoMessage(String(text), (typeof time === 'number' && time > 0) ? time * 1000 : 3000);
            },
            pencolor: (h, s, b, a) => {
                this.pen.color = this.hsbToRgbaArray(h, s, b, a === undefined ? 0 : a);
            },
            penthickness: (t) => { this.pen.thickness = t; },
            pendown: () => { this.pen.isDown = true; },
            penup: () => { this.pen.isDown = false; },
            penposition: (x, y) => {
                if (this.pen.isDown && Number.isFinite(this.pen.x) && Number.isFinite(this.pen.y)) {
                    this.pen.segments.push({
                        p1: { x: this.pen.x, y: this.pen.y },
                        p2: { x, y },
                        color: [...this.pen.color],
                        thickness: this.pen.thickness
                    });
                    this.requestDraw();
                }
                this.pen.x = x;
                this.pen.y = y;
            }
        };

        try {
            const sandboxedFunc = new Function('arch', 'setInterval', 'clearInterval', `'use strict';\n${this.globalScript}`);
            
            sandboxedFunc(
                archProxy,
                (fn, delay) => { this.globalScriptIntervalId = setInterval(fn, delay); },
                (id) => clearInterval(id || this.globalScriptIntervalId)
            );
        } catch (e) {
            alert(`全局脚本错误: ${e.message}`);
            this.stopGlobalScript();
        }
    }
    
drawPenStrokesGL() {
        if (this.pen.segments.length === 0) return;
        const gl = this.gl;
        gl.useProgram(this.shaderProgramLines);

        this.pen.segments.forEach(seg => {

            const vertices = this.generateQuadVertices(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y, seg.thickness);
            if (vertices.length > 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
                gl.uniform4fv(this.uniformLocations.color, seg.color);
                gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
            }
        });
    }
generateHighlightedText(entry) {
        const text = entry.expr;
        if (!text) return '';

       
        const C_RED = '#ff0000';     
        const C_ORANGE = '#bf6f00';  
        const C_BLUE = '#0099ff';    
        const C_PURPLE = '#b300ff';   
        const C_GRAY = '#8c8c8c';    
        const C_GREEN = '#00bf39';    

        const isParametric = ['parametric', 'parametric3d'].includes(entry.plotType);
        const isImplicit = ['implicit', 'implicit3d'].includes(entry.plotType);
        
        const regex = /([a-zA-Z_][\w]*)|([0-9]+(?:\.[0-9]+)?)|([=<>]=?|!=)|([+\-*/^(),])|(\s+)|(.)/g;
        
        let html = '';
        let match;
        
        while ((match = regex.exec(text)) !== null) {
            const fullMatch = match[0];
            const identifier = match[1];
            const number = match[2];
            const relation = match[3];
            const punctuation = match[4];
            const whitespace = match[5];
            
            if (whitespace) {
                html += whitespace;
                continue;
            }
            
            let color = ''; 
            
            if (relation) {

                if (entry.type === 'function' && (isParametric || isImplicit)) {
                    color = C_RED;
                } else {
                    color = C_GRAY;
                }
            } else if (punctuation) {
                color = C_GRAY;
            } else if (identifier) {
                const lowerId = identifier.toLowerCase();
                

                const remaining = text.substring(match.index + fullMatch.length);
                const nextCharIsEquals = remaining.trim().startsWith('=');
                

                const isParametricHeader = isParametric && ['x', 'y', 'z'].includes(lowerId) && nextCharIsEquals;

                if (entry.type === 'geometry') {
                    if (lowerId === entry.geometryType.toLowerCase()) {
                         color = C_BLUE;
                    } else if (lowerId === entry.name?.toLowerCase()) {
                         color = C_GREEN;
                    } else if (entry.objectDependencies && entry.objectDependencies.map(d=>d.toLowerCase()).includes(lowerId)) {
                         color = C_GREEN;
                    } else if (this.calcJSUtils.calc1.includes(lowerId) || this.builtinFuncNames.includes(lowerId)) {
                        color = C_PURPLE;
                    } else {
                        color = C_ORANGE;
                    }
                } else {
                    if (isParametricHeader) {
                        color = C_RED;
                    } else if (this.calcJSUtils.calc1.includes(lowerId) || this.builtinFuncNames.includes(lowerId)) {
                        color = C_PURPLE;
                    } else if (
                        this.calcJSUtils.calc3.includes(lowerId) || 
                        this.calcJSUtils.advancedCustomFunctionNames.includes(lowerId) ||
                        (entry.type.includes('function_definition') && identifier === entry.name)
                    ) {
                        color = C_BLUE;
                    } else {
                        color = C_ORANGE;
                    }
                }
            } else if (number) {
                 color = '';
            } else {
                 color = '';
            }
            
            if (color) {
                html += `<span style="color:${color}">${fullMatch}</span>`;
            } else {
                html += fullMatch;
            }
        }
        return html;
    }


updateEntryList() {
        if (this.activeSliders) {
            this.activeSliders.forEach(slider => slider.disconnect());
        }
        this.activeSliders = [];

        let playbackCardHtml = '';
        if (this.showPlaybackControls) {
            const isPlaying = this.isFramePlaying;
            const playPauseIcon = isPlaying
  ? '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU4OTY5IiBoZWlnaHQ9IjkuNzc0MDIiIHZpZXdCb3g9IjAsMCw3LjU4OTY5LDkuNzc0MDIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMjA1MTYsLTE3NS4xMTI5OSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjQ1NTE2LDE3Ni4zNjI5OWwwLjAyMDM1LDcuMTY2MjgiLz48cGF0aCBkPSJNMjQyLjU0NDg0LDE4My42MzcwMWwtMC4wMjAzNiwtNy4xNjYyNiIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjc5NDg0NDk5OTk5OTk4MTo0Ljg4NzAxMDAwMDAwMDAwNC0tPg==" style="width:18px; height:18px;">'
                    : '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU2MDYzIiBoZWlnaHQ9IjEwLjAzNzIiIHZpZXdCb3g9IjAsMCw3LjU2MDYzLDEwLjAzNzIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMzAwNzEsLTE3NC45ODE0KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjgwMDczLDE4Mi45NDQxNHYtNi4xNzU1MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuOTQ0MzIsMTc2LjQ4MTRsNC40MTcwMiwzLjkyNjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS45NjU1OSwxODAuNjQ2MjZsLTQuMTY0ODgsMi44NzIzNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNjM4NjcsMTc5Ljg5NzE2YzAsLTEuMDQ0OTcgMC44NDcxMiwtMS44OTIxMSAxLjg5MjExLC0xLjg5MjExYzEuMDQ0OTcsMCAxLjg5MjExLDAuODQ3MTIgMS44OTIxMSwxLjg5MjExYzAsMS4wNDQ5NyAtMC44NDcxMiwxLjg5MjExIC0xLjg5MjExLDEuODkyMTFjLTEuMDQ0OTcsMCAtMS44OTIxMSwtMC44NDcxMiAtMS44OTIxMSwtMS44OTIxMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjY5OTI5NDk5OTk5OTk3ODo1LjAxODYwMDAwMDAwMDAyMS0tPg==" style="width:18px; height:18px;">';
            
playbackCardHtml = `
                <div class="entry-item playback-control-card" style="border: 1px solid var(--text-color-accent); background-color: var(--entry-item-bg-color);">
                    <div class="entry-main-row" style="justify-content: space-between; font-weight: bold; color: var(--text-color-accent);">
                        播控中心
                        <div class="entry-actions-new" style="opacity: 1; pointer-events: auto; display: flex; position: static;">
                             <span class="action-btn frame-play-toggle-btn" title="播放/暂停">${playPauseIcon}</span>
                        </div>
                    </div>
                    <div class="entry-expandable-content" style="max-height: none; opacity: 1; padding-top: 5px; display: block;">
                        <div class="variable-slider-wrapper">
                            <div id="frame-slider-container" class="custom-slider-container"></div>
                        </div>
                        <div class="slider-props" style="display: flex; justify-content: space-between; font-size: 0.9em; color: var(--text-color-subtle);">
                            <span>当前帧: <span class="frame-current-value" style="text-decoration: underline dotted; cursor: pointer;">${this.currentFrame}</span></span>
                            <span>总帧数: <span class="frame-total-value" style="text-decoration: underline dotted; cursor: pointer;">${this.totalFrames}</span></span>
                            <span>FPS: <span class="frame-fps-value" style="text-decoration: underline dotted; cursor: pointer;">${this.playbackFPS}</span></span>
                        </div>
                    </div>
                </div>`;
        }

this.entryList.innerHTML = playbackCardHtml + this.entries.map((entry, index) => {
                if (this.categoryFilterMode === 1) { 
                if (entry.type !== 'variable' && entry.type !== 'constant') return '';
            } else if (this.categoryFilterMode === 2) { 
                if (entry.type !== 'function') return '';
            } else if (this.categoryFilterMode === 3) { 
                if (entry.type !== 'geometry') return '';
            }
            let mainContentHtml = '';
            let actionsHtml = '';
            let expandableContentHtml = '';
            let alwaysVisibleContentHtml = '';
            
            let classes = ['entry-item'];
            let style = '';
            let title = entry.expr || '';

            if (entry.type === 'variable') {
                classes.push('variable-item');
                if (entry.isEditableIndependent) {
                    classes.push('independent-variable-item');
                    style = `--variable-indicator-color: ${entry.playState === 1 ? 'var(--variable-indicator-independent-playing-color)' : 'var(--variable-indicator-independent-paused-color)'};`;
                } else {
                    style = `--variable-indicator-color: var(--variable-indicator-dependent-color);`;
                }
            } else if (['function', 'geometry', 'text'].includes(entry.type)) {
                const color = this.hsbToHex(entry.color.h, entry.color.s, entry.color.b);
                const entryColorForBar = entry.visible ? color : 'rgba(128,128,128,0.4)';
                const entryVisibleOpacity = entry.visible ? 1 : 0.3;
                style = `--entry-color: ${entryColorForBar}; --entry-visible-opacity: ${entryVisibleOpacity};`;
                if (!entry.visible) classes.push('function-hidden');
            } else if (['custom_function_definition', 'advanced_custom_function_definition'].includes(entry.type)) {
                classes.push(entry.type.replace(/_/g, '-') + '-item');
                style = `--variable-indicator-color: var(--text-color-subtle);`;
            } else if (entry.type === 'constant') {
                classes.push('constant-item');
                style = `--variable-indicator-color: var(--variable-indicator-dependent-color);`;
            }
            
            if (entry.expanded) {
                classes.push('expanded');
            }
            

            let formattedExpr = this.generateHighlightedText(entry);

            if (entry.type === 'function' || entry.type === 'geometry' || entry.type === 'text' || entry.type === 'point_list') {

                let textDisplayHTML = formattedExpr;
                
                if (entry.type === 'text') {

                     textDisplayHTML = `<span style="color:var(--text-color-subtle)">// ${entry.content}</span>`;
                }
                
                if (entry.type === 'geometry' && entry.detailsString) {
                    textDisplayHTML += `<div style="font-style: italic; color: var(--text-color-subtle); font-size: 0.9em; word-break: normal; padding-top: 2px;">${entry.detailsString}</div>`;
                }

mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>${textDisplayHTML}</div>
                        ${entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : ''}
                    </div>`;
                
                actionsHtml = `
                    <div class="entry-actions-new">
                     <span class="action-btn color-toggle-btn" title="颜色设置"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC45OTQ1OSIgaGVpZ2h0PSIxMS4wMzEyMyIgdmlld0JveD0iMCwwLDEwLjk5NDU5LDExLjAzMTIzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjUwMjcsLTE3NC40ODQzOCkiPjxnIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjM3Ljk4NDMzLDE4MC45ODk1M2MtMC4xNTU3NiwwIC0wLjMwMjM1LDAuMDM2NjUgLTAuNDMwNjIsMC4xMDA3OGMtMC4xMjgyNywwLjA2NDEzIC0wLjI2NTcsMC4xMzc0MyAtMC4zOTM5NywwLjIxMDczYy0wLjEyODI3LDAuMDczMyAtMC4yNjU3LDAuMTQ2NTkgLTAuMzkzOTgsMC4yMTA3M2MtMC4xMjgyNywwLjA2NDEzIC0wLjI4NDAyLDAuMTAwNzggLTAuNDQ4OTQsMC4xMDA3OGMtMC4yMjkwNiwwIC0wLjQzOTc5LC0wLjA1NDk3IC0wLjYzMjE5LC0wLjE2NDkyYy0wLjE5MjQsLTAuMTA5OTQgLTAuMzc1NjQsLTAuMjI5MDYgLTAuNTQwNTcsLTAuMzY2NDljLTAuMjE5ODksLTAuMTkyNCAtMC4zODQ4MSwtMC40MDMxMyAtMC40NzY0MywtMC42NTA1MWMtMC4wOTE2MiwtMC4yNDczOCAtMC4xNjQ5MiwtMC41MTMwOCAtMC4xNjQ5MiwtMC43OTcxMWMwLC0wLjI4NDAzIDAuMDM2NjUsLTAuNTc3MjIgMC4xMTkxMSwtMC44NTIwOGMwLjA4MjQ2LC0wLjI3NDg3IDAuMTc0MDgsLTAuNTQ5NzMgMC4yOTMxOSwtMC44MTU0M2MwLjI1NjU0LC0wLjU2ODA1IDAuNTc3MjIsLTEuMDgxMTMgMC45NzExOSwtMS41NTc1NmMwLjE3NDA4LC0wLjIxMDczIDAuMzU3MzIsLTAuNDIxNDYgMC41NTg4OSwtMC42MTM4N2MwLjIwMTU3LC0wLjE5MjQgMC40MTIzLC0wLjM2NjQ4IDAuNjUwNTEsLTAuNTEzMDhjMC40MTIzLC0wLjI2NTcgMC44NDI5MiwtMC40NTgxMSAxLjI5MTg3LC0wLjU5NTU0YzAuNDQ4OTQsLTAuMTM3NDMgMC45MTYyMSwtMC4yMDE1NyAxLjQxMDk3LC0wLjIwMTU3YzAuNDU4MTEsMCAwLjkwNzA1LDAuMDY0MTQgMS4zMzc2OCwwLjE4MzI1YzAuNDMwNjIsMC4xMTkxMSAwLjg2MTI0LDAuMjg0MDMgMS4yNjQzOCwwLjUwMzkyYzAuNDk0NzYsMC4yNjU3IDAuOTM0NTQsMC41NzcyMiAxLjMxOTM0LDAuOTM0NTRjMC4zODQ4MSwwLjM1NzMyIDAuNzA1NDksMC43NTEzIDAuOTcxMTksMS4xOTEwOGMwLjI2NTcsMC40Mzk3OSAwLjQ2NzI3LDAuOTA3MDUgMC42MDQ3LDEuNDEwOTdjMC4xMzc0MywwLjUwMzkyIDAuMjAxNTcsMS4wMzUzMiAwLjIwMTU3LDEuNTk0MjFjMCwwLjQxMjMgLTAuMDM2NjUsMC44MjQ1OSAtMC4xMDk5NSwxLjI0NjA1Yy0wLjA3MzMsMC40MjE0NiAtMC4xOTI0LDAuODI0NTkgLTAuMzQ4MTYsMS4yMTg1N2MtMC4xNTU3NiwwLjM5Mzk4IC0wLjM0ODE2LDAuNzYwNDYgLTAuNTg2MzgsMS4xMTc3OGMtMC4yMzgyMSwwLjM1NzMyIC0wLjUyMjI1LDAuNjU5NjcgLTAuODQyOTIsMC45MTYyMWMtMC4yNjU3LDAuMjE5ODkgLTAuNTU4ODksMC4zOTM5OCAtMC44NzA0LDAuNTIyMjVjLTAuMzExNTEsMC4xMjgyNyAtMC42NDEzNCwwLjE5MjQgLTAuOTk4NjcsMC4xOTI0Yy0wLjMxMTUxLDAgLTAuNjMyMTksLTAuMDU0OTcgLTAuOTQzNywtMC4xNjQ5MmMtMC4zMTE1MSwtMC4xMDk5NCAtMC41NzcyMiwtMC4yNDczOCAtMC44MDYyNywtMC40MTIzYy0wLjIyOTA2LC0wLjE2NDkyIC0wLjQxMjMsLTAuMzU3MzIgLTAuNTY4MDUsLTAuNTc3MjJjLTAuMTU1NzYsLTAuMjE5ODkgLTAuMjY1NywtMC40NjcyNyAtMC4zNDgxNiwtMC43NDIxM2MtMC4wODI0NiwtMC4yNzQ4NyAtMC4xMjgyNiwtMC41NjgwNiAtMC4xNDY1OSwtMC44ODg3M2MtMC4wMDkxNiwtMC4xMDk5NCAtMC4wMDkxNiwtMC4yMTk4OSAtMC4wMTgzMiwtMC4zMjk4M2MtMC4wMDkxNiwtMC4xMDk5NCAtMC4wMDkxNiwtMC4yMTk4OSAtMC4wMTgzMiwtMC4zMjk4M2MwLC0wLjA2NDEzIC0wLjAwOTE2LC0wLjEyODI3IC0wLjAxODMyLC0wLjIxMDczYy0wLjAwOTE2LC0wLjA4MjQ2IC0wLjAxODMyLC0wLjE1NTc2IC0wLjAzNjY1LC0wLjIyOTA2Yy0wLjAxODMyLC0wLjA3MzMgLTAuMDM2NjUsLTAuMTU1NzUgLTAuMDY0MTMsLTAuMjE5ODljLTAuMDI3NDksLTAuMDY0MTMgLTAuMDU0OTcsLTAuMTI4MjcgLTAuMDkxNjIsLTAuMTgzMjVjLTAuMDM2NjUsLTAuMDQ1ODEgLTAuMDczMywtMC4wODI0NSAtMC4xMzc0MywtMC4xMDk5NGMtMC4wNjQxMywtMC4wMjc0OSAtMC4xMTkxMSwtMC4wNTQ5NyAtMC4xOTI0LC0wLjA3MzNjLTAuMDczMywtMC4wMTgzMiAtMC4xMzc0MywtMC4wMjc0OCAtMC4yMDE1NywtMC4wMzY2NWMtMC4wNjQxMywtMC4wMDkxNiAtMC4xMDk5NSwtMC4wMTgzMiAtMC4xNjQ5MiwtMC4wMTgzMnpNMjQwLjQzMDYxLDE3Ny4wNTg5NGMwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzMgLTAuMTkyNCwwLjEyODI3Yy0wLjA1NDk3LDAuMDU0OTcgLTAuMTAwNzgsMC4xMTkxMSAtMC4xMjgyNywwLjE5MjRjLTAuMDI3NDksMC4wNzMzIC0wLjA0NTgxLDAuMTU1NzYgLTAuMDQ1ODEsMC4yMjkwNmMwLDAuMDczMyAwLjAxODMyLDAuMTU1NzUgMC4wNDU4MSwwLjIyOTA1YzAuMDI3NDksMC4wNzMzIDAuMDczMywwLjEzNzQzIDAuMTI4MjcsMC4xOTI0YzAuMDU0OTcsMC4wNTQ5NyAwLjExOTExLDAuMTAwNzggMC4xOTI0LDAuMTI4MjdjMC4wNzMzLDAuMDI3NDkgMC4xNTU3NiwwLjA0NTgxIDAuMjI5MDYsMC4wNDU4MWMwLjA3MzMsMCAwLjE1NTc2LC0wLjAxODMyIDAuMjI5MDYsLTAuMDQ1ODFjMC4wNzMzLC0wLjAyNzQ5IDAuMTM3NDMsLTAuMDczMyAwLjE5MjQsLTAuMTI4MjdjMC4wNTQ5NywtMC4wNTQ5NyAwLjEwMDc4LC0wLjExOTExIDAuMTI4MjcsLTAuMTkyNGMwLjAyNzQ5LC0wLjA3MzMgMC4wNTQ5NywtMC4xMzc0MyAwLjA1NDk3LC0wLjIxOTg5ek0yNDIuMzE4MDUsMTgyLjczMDMyYzAsLTAuMTc0MDggLTAuMDU0OTcsLTAuMzExNTEgLTAuMTc0MDgsLTAuNDMwNjJjLTAuMTE5MTEsLTAuMTE5MTEgLTAuMjU2NTQsLTAuMTc0MDggLTAuNDMwNjIsLTAuMTc0MDhjLTAuMDgyNDYsMCAtMC4xNTU3NSwwLjAxODMyIC0wLjIyOTA1LDAuMDQ1ODFjLTAuMDczMywwLjAyNzQ5IC0wLjEzNzQzLDAuMDczMyAtMC4xOTI0LDAuMTI4MjdjLTAuMDU0OTcsMC4wNTQ5NyAtMC4xMDA3OCwwLjExOTExIC0wLjEyODI3LDAuMTkyNGMtMC4wMjc0OSwwLjA3MzMgLTAuMDQ1ODEsMC4xNTU3NiAtMC4wNDU4MSwwLjIyOTA2YzAsMC4wNzMzIDAuMDE4MzIsMC4xNTU3NSAwLjA0NTgxLDAuMjI5MDVjMC4wMjc0OSwwLjA3MzMgMC4wNzMzLDAuMTM3NDMgMC4xMjgyNywwLjE5MjRjMC4wNTQ5NywwLjA1NDk3IDAuMTE5MTEsMC4xMDA3OCAwLjE5MjQsMC4xMjgyN2MwLjA3MzMsMC4wMjc0OSAwLjE1NTc1LDAuMDQ1ODEgMC4yMjkwNSwwLjA0NTgxYzAuMDczMywwIDAuMTU1NzYsLTAuMDE4MzIgMC4yMjkwNiwtMC4wNDU4MWMwLjA3MzMsLTAuMDI3NDkgMC4xMzc0MywtMC4wNzMzIDAuMTkyNCwtMC4xMjgyN2MwLjA1NDk3LC0wLjA1NDk3IDAuMTAwNzgsLTAuMTE5MTEgMC4xMjgyNywtMC4xOTI0YzAuMDI3NDksLTAuMDczMyAwLjA1NDk3LC0wLjEzNzQzIDAuMDU0OTcsLTAuMjE5ODl6TTI0Mi40OTIxMiwxNzcuNzQ2MTZjMCwtMC4xNzQwOCAtMC4wNTQ5NywtMC4zMTE1MSAtMC4xNzQwOCwtMC40MzA2MmMtMC4xMTkxMSwtMC4xMTkxMSAtMC4yNTY1NCwtMC4xNzQwOCAtMC40MzA2MiwtMC4xNzQwOGMtMC4wODI0NiwwIC0wLjE1NTc2LDAuMDE4MzIgLTAuMjI5MDYsMC4wNDU4MWMtMC4wNzMzLDAuMDI3NDkgLTAuMTM3NDMsMC4wNzMzIC0wLjE5MjQsMC4xMjgyN2MtMC4wNTQ5NywwLjA1NDk3IC0wLjEwMDc4LDAuMTE5MTEgLTAuMTI4MjcsMC4xOTI0Yy0wLjAyNzQ5LDAuMDczMyAtMC4wNDU4MSwwLjE1NTc2IC0wLjA0NTgxLDAuMjI5MDZjMCwwLjA3MzMgMC4wMTgzMiwwLjE1NTc2IDAuMDQ1ODEsMC4yMjkwNmMwLjAyNzQ5LDAuMDczMyAwLjA3MzMsMC4xMzc0MyAwLjEyODI3LDAuMTkyNGMwLjA1NDk3LDAuMDU0OTcgMC4xMTkxMSwwLjEwMDc4IDAuMTkyNCwwLjEyODI3YzAuMDczMywwLjAyNzQ5IDAuMTU1NzYsMC4wNDU4MSAwLjIyOTA2LDAuMDQ1ODFjMC4wNzMzLDAgMC4xNTU3NiwtMC4wMTgzMiAwLjIyOTA2LC0wLjA0NTgxYzAuMDczMywtMC4wMjc0OSAwLjEzNzQzLC0wLjA3MzMgMC4xOTI0LC0wLjEyODI3YzAuMDU0OTcsLTAuMDU0OTcgMC4xMDA3OCwtMC4xMTkxMSAwLjEyODI3LC0wLjE5MjRjMC4wMjc0OSwtMC4wNzMzIDAuMDU0OTcsLTAuMTM3NDMgMC4wNTQ5NywtMC4yMTk4OXpNMjQzLjY5MjM0LDE3OS4yOTQ1MmMwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzI5IC0wLjE5MjQsMC4xMjgyNmMtMC4wNTQ5NywwLjA1NDk3IC0wLjEwMDc4LDAuMTE5MTEgLTAuMTI4MjcsMC4xOTI0Yy0wLjAyNzQ5LDAuMDczMyAtMC4wNDU4MSwwLjE1NTc2IC0wLjA0NTgxLDAuMjI5MDZjMCwwLjA3MzMgMC4wMTgzMiwwLjE1NTc2IDAuMDQ1ODEsMC4yMjkwNmMwLjAyNzQ5LDAuMDczMyAwLjA3MzMsMC4xMzc0MyAwLjEyODI3LDAuMTkyNGMwLjA1NDk3LDAuMDU0OTcgMC4xMTkxMSwwLjEwMDc4IDAuMTkyNCwwLjEyODI3YzAuMDczMywwLjAyNzQ5IDAuMTU1NzYsMC4wNDU4MSAwLjIyOTA2LDAuMDQ1ODFjMC4wNzMzLDAgMC4xNTU3NSwtMC4wMTgzMiAwLjIyOTA1LC0wLjA0NTgxYzAuMDczMywtMC4wMjc0OSAwLjEzNzQzLC0wLjA3MzMgMC4xOTI0LC0wLjEyODI3YzAuMDU0OTcsLTAuMDU0OTcgMC4xMDA3OCwtMC4xMTkxMSAwLjEyODI3LC0wLjE5MjRjMC4wMjc0OSwtMC4wNzMzIDAuMDU0OTcsLTAuMTM3NDMgMC4wNTQ5NywtMC4yMTk4OXpNMjQzLjY5MjM0LDE4MS4zNTYwM2MwLC0wLjE3NDA4IC0wLjA1NDk3LC0wLjMxMTUxIC0wLjE3NDA4LC0wLjQzMDYyYy0wLjExOTExLC0wLjExOTExIC0wLjI1NjU0LC0wLjE3NDA4IC0wLjQzMDYyLC0wLjE3NDA4Yy0wLjA4MjQ2LDAgLTAuMTU1NzYsMC4wMTgzMiAtMC4yMjkwNiwwLjA0NTgxYy0wLjA3MzMsMC4wMjc0OSAtMC4xMzc0MywwLjA3MzMgLTAuMTkyNCwwLjEyODI3Yy0wLjA1NDk3LDAuMDU0OTcgLTAuMTAwNzgsMC4xMTkxMSAtMC4xMjgyNywwLjE5MjRjLTAuMDI3NDksMC4wNzMzIC0wLjA0NTgxLDAuMTU1NzYgLTAuMDQ1ODEsMC4yMjkwNmMwLDAuMDczMyAwLjAxODMyLDAuMTU1NzUgMC4wNDU4MSwwLjIyOTA1YzAuMDI3NDksMC4wNzMzIDAuMDczMywwLjEzNzQzIDAuMTI4MjcsMC4xOTI0YzAuMDU0OTcsMC4wNTQ5NyAwLjExOTExLDAuMTAwNzggMC4xOTI0LDAuMTI4MjdjMC4wNzMzLDAuMDI3NDkgMC4xNTU3NiwwLjA0NTgxIDAuMjI5MDYsMC4wNDU4MWMwLjA3MzMsMCAwLjE1NTc1LC0wLjAxODMyIDAuMjI5MDUsLTAuMDQ1ODFjMC4wNzMzLC0wLjAyNzQ5IDAuMTM3NDMsLTAuMDczMyAwLjE5MjQsLTAuMTI4MjdjMC4wNTQ5NywtMC4wNTQ5NyAwLjEwMDc4LC0wLjExOTExIDAuMTI4MjcsLTAuMTkyNGMwLjAyNzQ5LC0wLjA3MzMgMC4wNTQ5NywtMC4xMzc0MyAwLjA1NDk3LC0wLjIxOTg5eiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuNDk3Mjk1MDAwMDAwMDA4OjUuNTE1NjE0OTk5OTk5OTk3LS0+" style="width:18px; height:18px;"></span>
                        ${entry.type !== 'text' ? `<span class="action-btn visibility-toggle-btn" title="显示/隐藏"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC44MDg2OCIgaGVpZ2h0PSIxMC44MDg2OCIgdmlld0JveD0iMCwwLDEwLjgwODY4LDEwLjgwODY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0LjY1NjMsLTE3NC41OTU2NikiPjxnIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTIzNS40MDYzLDE4MGMwLC0yLjU3MDUyIDIuMDgzODIsLTQuNjU0MzQgNC42NTQzNCwtNC42NTQzNGMyLjU3MDUxLDAgNC42NTQzNCwyLjA4MzgyIDQuNjU0MzQsNC42NTQzNGMwLDIuNTcwNTIgLTIuMDgzODIsNC42NTQzNCAtNC42NTQzNCw0LjY1NDM0Yy0yLjU3MDUxLDAgLTQuNjU0MzQsLTIuMDgzODIgLTQuNjU0MzQsLTQuNjU0MzR6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzYuNDAyODQsMTgyLjUxMTMxbDcuMDc2NywtNS40NDkwNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTIzNS41MTMzLDE3OS42MDk4OGMwLC0wLjEyNTY0IDAuMDMwOTcsLTAuMjQ0MDQgMC4wODU3LC0wLjM0Nzk5bDAuMzQyNTksLTAuNjg1MThjMS4xNjU5MiwtMi41NDQxMSAzLjM1NjE4LC0zLjI4NTQxIDUuODkyMTIsLTIuMzY1NDdjMC4xODgzNywtMC4wNTc0NCAwLjY2NjQsLTAuMTM5MjkgMC45MTE1LDAuMzk5OTVjMC4zMDk1NCwwLjY4MDk4IC0wLjM3MTQ0LDAuOTkwNTIgLTAuMzcxNDQsMC45OTA1MmMtMC40Mjc0LDAuMTkyMiAtMC44NTkzMSwwLjQyNDI3IC0xLjI5MDQ1LDAuNjg0NThjMC4xNTM3NSwwLjM4NTA1IC0wLjE0Mjg1LDAuNzQwOTYgLTAuMTQyODUsMC43NDA5NmwtMC4zNjU1MywwLjQzODMxYy0wLjg1MzM3LDAuOTc1MjcgLTEuNjAzNTcsMS43MDg4NyAtMi43NzYwNCwyLjI5OTQ5YzAsMCAtMC42MDM2MSwwLjMwMTggLTAuOTUwODQsLTAuMjQxMjVjLTAuMDc5NDksMC4wNjkyNiAtMC4xNTgwNywwLjEzNzk0IC0wLjIzNTY4LDAuMjA1OWwtMC4wMzQ0MSwwLjAzNjc1YzAsMCAtMC41Mjg5NCwwLjUyODk0IC0xLjA1Nzg3LDBjLTAuNTI4OTQsLTAuNTI4OTQgMCwtMS4wNTc4NyAwLC0xLjA1Nzg3bDAuMTA3MTIsLTAuMTA0NzhjMC4xMTQxNSwtMC4wOTk4IDAuMjMwMTUsLTAuMjAwNzggMC4zNDc4NiwtMC4zMDI2MmMtMC4yNzEwOSwtMC4xMTIzOCAtMC40NjE3NywtMC4zNzk1NyAtMC40NjE3NywtMC42OTEzeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4zNDM2OTc3Nzc3Nzc3Nzc6NS40MDQzNDAwMDAwMDAwMTktLT4=" style="width:18px; height:18px;"></span>` : ''}
                        <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                      </div>`;
                
const sliceAxisMap = {'none': '无', 'x': 'X轴', 'y': 'Y轴', 'z': 'Z轴'};
                const is3DModeAndFunc = this.is3DMode;
                const is2DType = ['x', 'y', 'implicit', 'parametric'].includes(entry.plotType);
                const is3DType = ['z', 'x3d', 'y3d', 'implicit3d'].includes(entry.plotType);

                let extra3DControls = '';
                if (is3DModeAndFunc) {
                    if (is2DType) {
                        extra3DControls = `
                        <div class="settings-item-row" style="margin-top: 5px; justify-content: space-between; font-size: 0.9em; color: var(--text-color-subtle);">
                            <label for="extend-3d-toggle-${index}">延伸到3D</label>
                            <label class="custom-switch-container">
                                <input type="checkbox" id="extend-3d-toggle-${index}" class="extend-3d-toggle" ${entry.extendTo3D ? 'checked' : ''}>
                                <span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span>
                            </label>
                        </div>`;
                    } else if (is3DType) {
                        extra3DControls = `
                        <div class="slider-group" style="margin-top: 5px; font-size: 0.9em; color: var(--text-color-subtle); display: flex; justify-content: space-between;">
                            <span>切片方向: <span class="slice-axis-value" style="text-decoration: underline dotted; cursor: pointer; font-weight: bold;">${sliceAxisMap[entry.sliceAxis] || '无'}</span></span>
                            ${entry.sliceAxis !== 'none' ? `<span>数值: <span class="slice-val-value" style="text-decoration: underline dotted; cursor: pointer;">${entry.sliceVal}</span></span>` : ''}
                        </div>`;
                    }
                }

expandableContentHtml = `
                    <div class="function-controls">
                       <div class="slider-group"><label>颜色:</label><div id="color-slider-h-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>饱和度:</label><div id="color-slider-s-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>亮度:</label><div id="color-slider-b-${index}" class="custom-slider-container"></div></div>
                        <div class="slider-group"><label>透明度:</label><div id="color-slider-a-${index}" class="custom-slider-container"></div></div>
                   
                     <div class="slider-group"><label>粗细:</label><div id="thickness-slider-${index}" class="custom-slider-container"></div></div>
                     <div class="slider-group" style="margin-top: 5px; font-size: 0.9em; color: var(--text-color-subtle);">
                        显示帧: <span class="display-frame-value" style="text-decoration: underline dotted; cursor: pointer;">${entry.displayFrame}</span>
                     </div>
                     ${extra3DControls}
                   </div>`;

            } else if (entry.type === 'variable' && entry.isEditableIndependent) {
const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : '...';
                
 
                const varNameHtml = `<span style="color:#ffaa00; font-weight:bold;">${entry.name.toUpperCase()}</span>`;
                const eqHtml = `<span style="color:#ff0000">=</span>`;
                
                mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>${varNameHtml} ${eqHtml} <span class="entry-value">${displayValue}</span></div>
                    </div>`;

                const playPauseIcon = entry.playState === 1
                     ? '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU4OTY5IiBoZWlnaHQ9IjkuNzc0MDIiIHZpZXdCb3g9IjAsMCw3LjU4OTY5LDkuNzc0MDIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMjA1MTYsLTE3NS4xMTI5OSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjQ1NTE2LDE3Ni4zNjI5OWwwLjAyMDM1LDcuMTY2MjgiLz48cGF0aCBkPSJNMjQyLjU0NDg0LDE4My42MzcwMWwtMC4wMjAzNiwtNy4xNjYyNiIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjc5NDg0NDk5OTk5OTk4MTo0Ljg4NzAxMDAwMDAwMDAwNC0tPg==" style="width:18px; height:18px;">'
                    : '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjU2MDYzIiBoZWlnaHQ9IjEwLjAzNzIiIHZpZXdCb3g9IjAsMCw3LjU2MDYzLDEwLjAzNzIiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuMzAwNzEsLTE3NC45ODE0KSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48Zz48cGF0aCBkPSJNMjM3LjgwMDczLDE4Mi45NDQxNHYtNi4xNzU1MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuOTQ0MzIsMTc2LjQ4MTRsNC40MTcwMiwzLjkyNjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0MS45NjU1OSwxODAuNjQ2MjZsLTQuMTY0ODgsMi44NzIzNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzcuNjM4NjcsMTc5Ljg5NzE2YzAsLTEuMDQ0OTcgMC44NDcxMiwtMS44OTIxMSAxLjg5MjExLC0xLjg5MjExYzEuMDQ0OTcsMCAxLjg5MjExLDAuODQ3MTIgMS44OTIxMSwxLjg5MjExYzAsMS4wNDQ5NyAtMC44NDcxMiwxLjg5MjExIC0xLjg5MjExLDEuODkyMTFjLTEuMDQ0OTcsMCAtMS44OTIxMSwtMC44NDcxMiAtMS44OTIxMSwtMS44OTIxMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjozLjY5OTI5NDk5OTk5OTk3ODo1LjAxODYwMDAwMDAwMDAyMS0tPg==" style="width:18px; height:18px;">';

                actionsHtml = `
                    <div class="entry-actions-new">
                         <span class="action-btn play-toggle-btn" title="播放/暂停">${playPauseIcon}</span>
                        <span class="action-btn settings-toggle-btn" title="滑块设置"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC42MDcwOSIgaGVpZ2h0PSI5Ljk1NDg5IiB2aWV3Qm94PSIwLDAsMTAuNjA3MDksOS45NTQ4OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNC42OTY3OCwtMTc1LjAzMDMxKSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjM5LjcwNDUsMTgzLjY1OTRjLTAuMTAxNzcsMC4wNTkyMiAtMC4xODM1OSwwLjEzNjAyIC0wLjI1Njk1LDAuMjI3MzdjLTAuMDczMzcsMC4wOTEzNCAtMC4xNDI0OCwwLjE4OTk1IC0wLjIyMzExLDAuMjg1NTNjLTAuMDgwNjMsMC4wOTU1NiAtMC4xNDI0OCwwLjE4OTk1IC0wLjIyMzExLDAuMjg1NTNjLTAuMDgwNjMsMC4wOTU1NiAtMC4xNjI0NCwwLjE3MjM3IC0wLjI1Njk1LDAuMjI3MzdjLTAuMDg3MjQsMC4wNTA3NiAtMC4xNjgzOSwwLjA3ODUyIC0wLjI2MjI1LDAuMDg0NDdjLTAuMDkzODUsMC4wMDU5NiAtMC4xODg4OSwtMC4wMDY4NiAtMC4yNzc4NCwtMC4wNDI2OWMtMC4wNjE3MiwtMC4wMjI0NyAtMC4xMzkxOSwtMC4wNTUyNCAtMC4yMjgxNSwtMC4wOTEwNmMtMC4wODg5NiwtMC4wMzU4MiAtMC4xOTA2MSwtMC4wOTM0NSAtMC4yODgwMywtMC4xNDM4Yy0wLjA5NzQyLC0wLjA1MDM2IC0wLjIxMDU2LC0wLjExMTAyIC0wLjMxNjQ1LC0wLjE3NTkzYy0wLjEwNTg5LC0wLjA2NDkgLTAuMjExNzUsLTAuMTI5NzkgLTAuMzA2MTQsLTAuMTkxNjVjLTAuMDk0MzcsLTAuMDYxODYgLTAuMTc0MjIsLTAuMTMyMTcgLTAuMjQ5ODMsLTAuMTk1MjJjLTAuMDc1NjIsLTAuMDYzMDQgLTAuMTIwOTUsLTAuMTI0MjUgLTAuMTU0NzksLTAuMTgyNDFjLTAuMDU5MjIsLTAuMTAxNzcgLTAuMDg1MTIsLTAuMjEzMiAtMC4wODA3OCwtMC4zMjI3OWMwLjAwNDM2LC0wLjEwOTU4IDAuMDI3NDksLTAuMjIwMzUgMC4wNjIxMSwtMC4zMjgwOGMwLjAzNDYzLC0wLjEwNzczIDAuMDgzNzksLTAuMjIzOTIgMC4xMzcxOSwtMC4zMzI4M2MwLjA1MzM5LC0wLjEwODkyIDAuMTAyNTcsLTAuMjI1MSAwLjEzNzE5LC0wLjMzMjgzYzAuMDM0NjMsLTAuMTA3NzMgMC4wNTc3NiwtMC4yMTg1IDAuMDY2MzQsLTAuMzIwODFjMC4wMDg1OSwtMC4xMDIzMSAtMC4wMTMwOSwtMC4yMDY0NyAtMC4wNzIzMSwtMC4zMDgyNGMtMC4wNTUsLTAuMDk0NTEgLTAuMTM0ODQsLTAuMTY0ODMgLTAuMjMyMjUsLTAuMjE1MThjLTAuMDk3NDIsLTAuMDUwMzYgLTAuMjAwOTIsLTAuMDc3NzEgLTAuMzE1OTEsLTAuMTA4MTJjLTAuMTE1LC0wLjAzMDQgLTAuMjM2MDgsLTAuMDM3OCAtMC4zNjEzOCwtMC4wNTI0NmMtMC4xMjUzMSwtMC4wMTQ2NyAtMC4yNDMzNSwtMC4wMzM1NyAtMC4zNjEzOCwtMC4wNTI0NmMtMC4xMTgwNCwtMC4wMTg5IC0wLjIyMjczLC0wLjA2NTAyIC0wLjMyMDE0LC0wLjExNTM5Yy0wLjA5NzQyLC0wLjA1MDM2IC0wLjE3NzI2LC0wLjEyMDY3IC0wLjI0MDcxLC0wLjIyOTczYy0wLjAyOTYxLC0wLjA1MDg5IC0wLjA1MzE1LC0wLjEyNDc4IC0wLjA3MDYsLTAuMjIxNjZjLTAuMDE3NDUsLTAuMDk2ODkgLTAuMDM5MTMsLTAuMjAxMDUgLTAuMDQ2MjgsLTAuMzEzNjZjLTAuMDA3MTUsLTAuMTEyNjEgLTAuMDExMjQsLTAuMjM2NzUgLTAuMDE1MzUsLTAuMzYwODZjLTAuMDA0MSwtMC4xMjQxMyAtMC4wMDA5NCwtMC4yNTI0NiAwLjAwNjQ2LC0wLjM3MzU1YzAuMDA3NCwtMC4xMjEwOCAwLjAxMTc1LC0wLjIzMDY1IDAuMDIwMzQsLTAuMzMyOTZjMC4wMDg1OSwtMC4xMDIzMSAwLjAyMjYxLC0wLjE3ODU4IDAuMDMzNTcsLTAuMjQzMzVjMC4wMjAwOSwtMC4wOTkyNyAwLjA2MDEzLC0wLjE4MDk1IDAuMTExNjgsLTAuMjU5NjFjMC4wNTE1NSwtMC4wNzg2NSAwLjEyMzA1LC0wLjEzOTcyIDAuMjAzMDIsLTAuMTg2MjVjMC4xMDE3NywtMC4wNTkyMiAwLjIwODk3LC0wLjA5MjQgMC4zMjQ2NCwtMC4xMTEwNGMwLjExNTY2LC0wLjAxODY1IDAuMjM1NTQsLTAuMDMwMDEgMC4zNTU0MywtMC4wNDEzOWMwLjExOTg5LC0wLjAxMTM4IDAuMjM5NzcsLTAuMDIyNzQgMC4zNTU0MywtMC4wNDEzOWMwLjExNTY2LC0wLjAxODY1IDAuMjIyODUsLTAuMDUxODIgMC4zMjQ2NCwtMC4xMTEwNGMwLjEzMDg2LC0wLjA3NjE0IDAuMjE4NzYsLTAuMTc1OTQgMC4yNTk0NiwtMC4zMDY2N2MwLjA0MDcxLC0wLjEzMDczIDAuMDQ2OTEsLTAuMjcwNTggLTAuMDAzMTksLTAuNDA2ODVjLTAuMDUxMjksLTAuMTU1MDUgLTAuMTA5ODUsLTAuMzA1ODcgLTAuMTYxMTUsLTAuNDYwOTFjLTAuMDUxMjksLTAuMTU1MDUgLTAuMTA5ODUsLTAuMzA1ODcgLTAuMTYxMTUsLTAuNDYwOTFjLTAuMDQ1ODgsLTAuMTI5MDEgLTAuMDU0MiwtMC4yNjA0IC0wLjAxNjU0LC0wLjM3OTYzYzAuMDM3NjcsLTAuMTE5MjMgMC4xMDk4NCwtMC4yMjkzNCAwLjIwOTIzLC0wLjMyNjFjMC4xMDM2MywtMC4wODk0OSAwLjIwNDIyLC0wLjE2NzQ4IDAuMzE2MzEsLTAuMjQyNDNjMC4xMTIwOSwtMC4wNzQ5NSAwLjIyODQsLTAuMTQyNjMgMC4zMzc0NiwtMC4yMDYwOWMwLjExNjMyLC0wLjA2NzY4IDAuMjQ0MTMsLTAuMTMyMzIgMC4zNjQ2OCwtMC4xOTI3NGMwLjEyMDU1LC0wLjA2MDQxIDAuMjUyNTksLTAuMTE3NzkgMC4zODE2LC0wLjE2MzY2YzAuMTI5MDEsLTAuMDQ1ODggMC4yNjA0LC0wLjA1NDIgMC4zNzk2MywtMC4wMTY1NGMwLjExOTIzLDAuMDM3NjcgMC4yMjUxLDAuMTAyNTcgMC4zMjE4NywwLjIwMTk2YzAuMTA5NDYsMC4xMjEyIDAuMjExNjQsMC4yNDY2NCAwLjMxMzgxLDAuMzcyMDhjMC4xMDIxOCwwLjEyNTQ0IDAuMjA0MzYsMC4yNTA4OCAwLjMxMzgxLDAuMzcyMDhjMC4wOTM3MiwwLjExMDg5IDAuMjExMSwwLjE3ODgzIDAuMzUyMTQsMC4yMDM4MWMwLjE0MTA1LDAuMDI0OTcgMC4yNzEyNCwtMC4wMDIxMiAwLjM5NDgyLC0wLjA3NDAzYzAuMTAxNzcsLTAuMDU5MjIgMC4xODM1OSwtMC4xMzYwMiAwLjI1Njk1LC0wLjIyNzM3YzAuMDczMzcsLTAuMDkxMzQgMC4xNDI0OCwtMC4xODk5NSAwLjIyMzExLC0wLjI4NTUzYzAuMDgwNjMsLTAuMDk1NTYgMC4xNDI0OCwtMC4xODk5NSAwLjIyMzExLC0wLjI4NTUzYzAuMDgwNjMsLTAuMDk1NTYgMC4xNjI0NCwtMC4xNzIzNyAwLjI1Njk1LC0wLjIyNzM3YzAuMDg3MjQsLTAuMDUwNzYgMC4xNzU2NiwtMC4wODI3NSAwLjI2OTUyLC0wLjA4ODdjMC4wOTM4NSwtMC4wMDU5NiAwLjE4MTYyLDAuMDExMDkgMC4yNzc4NCwwLjA0MjY5YzAuMDYxNzIsMC4wMjI0NyAwLjEzOTE5LDAuMDU1MjQgMC4yMjgxNSwwLjA5MTA2YzAuMDg4OTYsMC4wMzU4MiAwLjE5MDYxLDAuMDkzNDUgMC4yODgwMywwLjE0MzhjMC4wOTc0MiwwLjA1MDM2IDAuMjEwNTYsMC4xMTEwMiAwLjMxNjQ1LDAuMTc1OTNjMC4xMDU4OSwwLjA2NDkgMC4yMTE3NSwwLjEyOTc5IDAuMzA2MTQsMC4xOTE2NWMwLjA5NDM3LDAuMDYxODYgMC4xNzQyMiwwLjEzMjE3IDAuMjQ5ODMsMC4xOTUyMmMwLjA3NTYyLDAuMDYzMDQgMC4xMjA5NSwwLjEyNDI1IDAuMTU0NzksMC4xODI0MWMwLjA1OTIyLDAuMTAxNzcgMC4wODUxMiwwLjIxMzIgMC4wODA3OCwwLjMyMjc5Yy0wLjAwNDM2LDAuMTA5NTggLTAuMDI3NDksMC4yMjAzNSAtMC4wNjIxMSwwLjMyODA4Yy0wLjAzNDYzLDAuMTA3NzMgLTAuMDgzNzksMC4yMjM5MiAtMC4xMzcxOSwwLjMzMjgzYy0wLjA1MzM5LDAuMTA4OTIgLTAuMTAyNTcsMC4yMjUxIC0wLjEzNzE5LDAuMzMyODNjLTAuMDM0NjMsMC4xMDc3MyAtMC4wNTc3NiwwLjIxODUgLTAuMDY2MzQsMC4zMjA4MWMtMC4wMDg1OSwwLjEwMjMxIDAuMDEzMDksMC4yMDY0NyAwLjA3MjMxLDAuMzA4MjRjMC4wNTUsMC4wOTQ1MSAwLjEzNDg0LDAuMTY0ODMgMC4yMzIyNSwwLjIxNTE4YzAuMDk3NDIsMC4wNTAzNiAwLjIwMDkyLDAuMDc3NzEgMC4zMTU5MSwwLjEwODEyYzAuMTE1LDAuMDMwNCAwLjIzNjA4LDAuMDM3OCAwLjM2MTM4LDAuMDUyNDZjMC4xMjUzMSwwLjAxNDY3IDAuMjQzMzUsMC4wMzM1NyAwLjM2MTM4LDAuMDUyNDZjMC4xMTgwNCwwLjAxODkgMC4yMjI3MywwLjA2NTAyIDAuMzIwMTQsMC4xMTUzOWMwLjA5NzQyLDAuMDUwMzYgMC4xNzcyNiwwLjEyMDY3IDAuMjQwNzEsMC4yMjk3M2MwLjAzMzg0LDAuMDU4MTYgMC4wNTczNywwLjEzMjA0IDAuMDc0ODMsMC4yMjg5NGMwLjAxNzQ1LDAuMDk2ODkgMC4wMzQ5LDAuMTkzNzggMC4wNDYyOCwwLjMxMzY2YzAuMDExMzgsMC4xMTk4OSAwLjAxMTI0LDAuMjM2NzUgMC4wMTUzNSwwLjM2MDg2YzAuMDA0MSwwLjEyNDEzIC0wLjAwMzI5LDAuMjQ1MiAtMC4wMTA2OSwwLjM2NjI4Yy0wLjAwNzQsMC4xMjEwOCAtMC4wMTU5OCwwLjIyMzM4IC0wLjAyNDU3LDAuMzI1N2MtMC4wMDg1OSwwLjEwMjMxIC0wLjAxODM3LDAuMTg1ODUgLTAuMDMzNTcsMC4yNDMzNWMtMC4wMjAwOSwwLjA5OTI3IC0wLjA2MDEzLDAuMTgwOTUgLTAuMTA0NDEsMC4yNTUzOGMtMC4wNDQyOCwwLjA3NDQyIC0wLjExNTc5LDAuMTM1NDkgLTAuMTk1NzUsMC4xODIwMmMtMC4wOTQ1MSwwLjA1NSAtMC4yMDE3LDAuMDg4MTcgLTAuMzI0NjQsMC4xMTEwNGMtMC4xMjI5MiwwLjAyMjg3IC0wLjI0MjgxLDAuMDM0MjQgLTAuMzYyNywwLjA0NTYyYy0wLjExOTg5LDAuMDExMzggLTAuMjQ3MDQsMC4wMjY5NyAtMC4zNjI3LDAuMDQ1NjJjLTAuMTE1NjYsMC4wMTg2NSAtMC4yMjI4NSwwLjA1MTgyIC0wLjMxNzM3LDAuMTA2ODFjLTAuMTIzNTgsMC4wNzE5MSAtMC4yMDExNywwLjE1NTk5IC0wLjI0NDI2LDAuMjQ5MTdjLTAuMDQzMDksMC4wOTMxOSAtMC4wNTU5LDAuMTg4MjMgLTAuMDQ1NzMsMC4yODkzNGMwLjAxMDE5LDAuMTAxMTIgMC4wMzE4NiwwLjIwNTI4IDAuMDc2NTUsMC4zMTU1MmMwLjA0NDY4LDAuMTEwMjMgMC4wODA5LDAuMjA1OTMgMC4xMTQwOCwwLjMxMzE0YzAuMDI3NzYsMC4wODExNiAwLjA1NTUyLDAuMTYyMzIgMC4wODMyOSwwLjI0MzQ3YzAuMDI3NzYsMC4wODExNiAwLjA1MTI5LDAuMTU1MDUgMC4wODMyOSwwLjI0MzQ3YzAuMDUwMSwwLjEzNjI3IDAuMDU0MiwwLjI2MDQgMC4wMjA3NywwLjM4NjljLTAuMDMzNDQsMC4xMjY1IC0wLjEwOTg0LDAuMjI5MzQgLTAuMjIwNzMsMC4zMjMwNmMtMC4xMDM2MywwLjA4OTQ5IC0wLjIwNDIyLDAuMTY3NDggLTAuMzE2MzEsMC4yNDI0M2MtMC4xMTIwOSwwLjA3NDk1IC0wLjIyODQsMC4xNDI2MyAtMC4zNDQ3MiwwLjIxMDMxYy0wLjExNjMyLDAuMDY3NjggLTAuMjQ0MTMsMC4xMzIzMiAtMC4zNjQ2OCwwLjE5Mjc0Yy0wLjEyMDU1LDAuMDYwNDEgLTAuMjUyNTksMC4xMTc3OSAtMC4zODE2LDAuMTYzNjZjLTAuMTI5MDEsMC4wNDU4OCAtMC4yNjA0LDAuMDU0MiAtMC4zNzk2MywwLjAxNjU0Yy0wLjExOTIzLC0wLjAzNzY3IC0wLjIyNTEsLTAuMTAyNTcgLTAuMzI2MSwtMC4yMDkyM2MtMC4xMDk0NiwtMC4xMjEyIC0wLjIxMTY0LC0wLjI0NjY0IC0wLjMxMzgxLC0wLjM3MjA4Yy0wLjEwMjE4LC0wLjEyNTQ0IC0wLjIwNDM2LC0wLjI1MDg4IC0wLjMxMzgxLC0wLjM3MjA4Yy0wLjA5MzcyLC0wLjExMDg5IC0wLjIxMTEsLTAuMTc4ODMgLTAuMzUyMTQsLTAuMjAzODFjLTAuMTQxMDUsLTAuMDI0OTcgLTAuMjYzOTYsLTAuMDAyMTEgLTAuMzg3NTUsMC4wNjk4ek0yNDIuNzg3NjMsMTgzLjQyMjQxYy0wLjAyMzUzLC0wLjA3Mzg5IC0wLjA1ODU3LC0wLjE1MDgyIC0wLjA5OTAyLC0wLjI1Mzc4Yy0wLjA0MDQ2LC0wLjEwMjk3IC0wLjA4MDksLTAuMjA1OTMgLTAuMTIxMzYsLTAuMzA4OWMtMC4wNDA0NiwtMC4xMDI5NyAtMC4wNzM2MywtMC4yMTAxNiAtMC4xMDI1OCwtMC4zMTAxYy0wLjAyODk1LC0wLjA5OTkzIC0wLjA1NjcyLC0wLjE4MTA4IC0wLjA2NDUxLC0wLjI0NDY3Yy0wLjA0MjcxLC0wLjI1NzM2IC0wLjAxMzM3LC0wLjUwNzk3IDAuMDg5MTksLTAuNzMzMDljMC4xMDI1NywtMC4yMjUxIDAuMjY4MDUsLTAuNDA4OTggMC41MDA2OSwtMC41NDQzNGMwLjA3OTk3LC0wLjA0NjUzIDAuMTc1NjYsLTAuMDgyNzUgMC4yOTQzNywtMC4xMTI5YzAuMTE4NywtMC4wMzAxMyAwLjIzNzQsLTAuMDYwMjggMC4zNjc2LC0wLjA4NzM4YzAuMTMwMTksLTAuMDI3MSAwLjI1MzEzLC0wLjA0OTk4IDAuMzczMDIsLTAuMDYxMzRjMC4xMTk4OSwtMC4wMTEzOCAwLjIzMTMxLC0wLjAzNzI4IDAuMzIwOTMsLTAuMDUwNTFjMC4wMzc4LC0wLjIzNjA4IDAuMDY0MDksLTAuNDc1MTkgMC4wNjQzNSwtMC43MDg4OWMwLjAwMDI1LC0wLjIzMzY5IC0wLjAyMjQ5LC0wLjQ3MzQ3IC0wLjA1MjUsLTAuNzA5MDJsLTAuMDA0MjMsLTAuMDA3MjdsLTAuOTc1NzcsLTAuMTcxNzljLTAuMTc1NTQsLTAuMDM0MDkgLTAuMzM3NzMsLTAuMDk1NDIgLTAuNDg3NzYsLTAuMjAyNzVjLTAuMTUwMDMsLTAuMTA3MzMgLTAuMjYzNzIsLTAuMjM1OCAtMC4zNTI1NSwtMC4zODg0N2MtMC4wODg4MywtMC4xNTI2NyAtMC4xNDEzMiwtMC4zMjY0OCAtMC4xNjA0OSwtMC41MDk5NWMtMC4wMTkxNywtMC4xODM0NyAwLjAwNzY1LC0wLjM1NDc3IDAuMDY0NzUsLTAuNTI0MjRsMC4zMjY3MiwtMC45MTAyMWwtMC4wMDQyMywtMC4wMDcyN2MwLDAgLTAuMDE5OTYsLTAuMDE3NTggLTAuMDQ0MTUsLTAuMDQyNDNjLTAuMDI0MTksLTAuMDI0ODYgLTAuMDQ3MTgsLTAuMDMwOTMgLTAuMDUxNDIsLTAuMDM4MmMtMC4xNjY5NSwtMC4xMzY0IC0wLjM1MTQ4LC0wLjI1Mjg1IC0wLjUzOTA1LC0wLjM1Nzc5Yy0wLjE4NzU4LC0wLjEwNDk0IC0wLjM4NTQ1LC0wLjE5NDE2IC0wLjU5MDYsLTAuMjc5MTVsLTAuMDA3MjcsMC4wMDQyM2wtMC42MzA0NywwLjc1NjFjLTAuMDk1MTcsMC4xMDQwMyAtMC4xOTg3OSwwLjE5MzUyIC0wLjMxNTEsMC4yNjEyYy0wLjE5NjI4LDAuMTE0MjEgLTAuMzk2MTMsMC4xNzIxMiAtMC42MTEwNywwLjE3MDY3Yy0wLjE4NDY2LDAuMDAwNCAtMC4zNTI5MywtMC4wMzc5MyAtMC41MTkzNSwtMC4xMDY1MmMtMC4xNjY0MiwtMC4wNjg1OSAtMC4zMDE5MSwtMC4xODQzOSAtMC40MTk4MiwtMC4zMjAxM2wtMC42Mjc2MywtMC43NDQxNmMtMC4yMjQ3MSwwLjA4MjEgLTAuNDM2NzMsMC4xODYgLTAuNjQ3NTUsMC4zMDg2N2MtMC4xMDE3NywwLjA1OTIyIC0wLjIwMzU2LDAuMTE4NDQgLTAuMzAxMSwwLjE4NDkzYy0wLjA5NzU1LDAuMDY2NDkgLTAuMTk1MSwwLjEzMjk4IC0wLjI4ODQxLDAuMjA2NzVjMC4wNTU1MiwwLjE2MjMyIDAuMTE0MDgsMC4zMTMxNCAwLjE3MjY1LDAuNDYzOTZjMC4wNTg1NywwLjE1MDgyIDAuMTA5ODUsMC4zMDU4NyAwLjE2MTE1LDAuNDYwOTFjMC4wNDI4MiwwLjE0MDUxIDAuMDY2ODksMC4yODIyIDAuMDcyMTgsMC40MjUwOWMwLjAwNTI5LDAuMTQyODkgLTAuMDE5NjgsMC4yODM5MyAtMC4wNjAzOSwwLjQxNDY2Yy0wLjA0MDcxLDAuMTMwNzMgLTAuMTE1OTEsMC4yNTIzNCAtMC4xOTk1OCwwLjM1OTQyYy0wLjA4MzY3LDAuMTA3MDYgLTAuMTk0NTYsMC4yMDA3OSAtMC4zMjU0MiwwLjI3Njk0Yy0wLjEzMDg2LDAuMDc2MTQgLTAuMjU5ODYsMC4xMjIwMSAtMC40MDE1NywwLjE0NjA4bC0wLjAwNzI3LDAuMDA0MjNsLTAuOTU0MzQsMC4xNjYwNWwtMC4wMDcyNywwLjAwNDIzYy0wLjAzNzgsMC4yMzYwOCAtMC4wNTY4MiwwLjQ3MDk2IC0wLjA2NDM1LDAuNzA4ODljLTAuMDA3NTIsMC4yMzc5MiAwLjAxMSwwLjQ3MDQzIDAuMDUyNSwwLjcwOTAybDAuMDA0MjMsMC4wMDcyN2wwLjk3NTc3LDAuMTcxNzljMC4xNzU1NCwwLjAzNDA5IDAuMzM3NzMsMC4wOTU0MiAwLjQ4Nzc2LDAuMjAyNzVjMC4xNTAwMywwLjEwNzMzIDAuMjYzNzIsMC4yMzU4IDAuMzUyNTUsMC4zODg0N2MwLjA4ODgzLDAuMTUyNjcgMC4xNTU4NiwwLjMxODAyIDAuMTcwOCwwLjQ5NDIyYzAuMDE0OTQsMC4xNzYyIC0wLjAwNzY1LDAuMzU0NzcgLTAuMDY0NzUsMC41MjQyNGwtMC4zMjY3MiwwLjkxMDIxbDAuMDA0MjMsMC4wMDcyN2MwLDAgMC4wMTk5NiwwLjAxNzU4IDAuMDQ0MTUsMC4wNDI0M2MwLjAyNDE5LDAuMDI0ODYgMC4wNDcxOCwwLjAzMDkzIDAuMDUxNDIsMC4wMzgyYzAuMTY2OTUsMC4xMzY0IDAuMzUxNDgsMC4yNTI4NSAwLjUzOTA1LDAuMzU3NzljMC4xODc1OCwwLjEwNDk0IDAuMzg1NDUsMC4xOTQxNiAwLjU5MDYsMC4yNzkxNWwwLjAwNzI3LC0wLjAwNDIzbDAuNjMwNDcsLTAuNzU2MWMwLjA5NTE3LC0wLjEwNDAzIDAuMTk4NzksLTAuMTkzNTIgMC4zMTUxLC0wLjI2MTJjMC4xOTYyOCwtMC4xMTQyMSAwLjM5NjEzLC0wLjE3MjEyIDAuNjExMDcsLTAuMTcwNjdjMC4xODQ2NiwtMC4wMDA0IDAuMzUyOTMsMC4wMzc5MyAwLjUxOTM1LDAuMTA2NTJjMC4xNjY0MiwwLjA2ODU5IDAuMzAxOTEsMC4xODQzOSAwLjQxOTgyLDAuMzIwMTNsMC42Mjc2MywwLjc0NDE2YzAuMjI0NzEsLTAuMDgyMSAwLjQzNjczLC0wLjE4NiAwLjY0NzU1LC0wLjMwODY3YzAuMTAxNzcsLTAuMDU5MjIgMC4yMDM1NiwtMC4xMTg0NCAwLjMwMTEsLTAuMTg0OTNjMC4wOTc1NSwtMC4wNjY0OSAwLjE4MzU5LC0wLjEzNjAyIDAuMjY5NjUsLTAuMjA1NTV6TTIzOC4zNTMxMSwxODAuOTUyMjRjLTAuMTMxMTMsLTAuMjI1MzcgLTAuMjE0NDIsLTAuNDY4ODQgLTAuMjQxMzksLTAuNzE1ODhjLTAuMDI2OTcsLTAuMjQ3MDQgLTAuMDEyMTcsLTAuNDg5MiAwLjA0ODYxLC0wLjcxOTJjMC4wNjA4LC0wLjIzIDAuMTY3NTksLTAuNDQ3ODMgMC4zMTMxMiwtMC42NDkyOGMwLjE0NTUyLC0wLjIwMTQ1IDAuMzM4MjMsLTAuMzcxOTcgMC41NjM2LC0wLjUwMzExYzAuMjI1MzcsLTAuMTMxMTMgMC40Njg4NCwtMC4yMTQ0MiAwLjcxNTg4LC0wLjI0MTM5YzAuMjQ3MDQsLTAuMDI2OTcgMC40ODkyLC0wLjAxMjE3IDAuNzE5MiwwLjA0ODYxYzAuMjMsMC4wNjA4IDAuNDQ3ODMsMC4xNjc1OSAwLjY0OTI4LDAuMzEzMTJjMC4yMDE0NSwwLjE0NTUyIDAuMzcxOTcsMC4zMzgyMyAwLjUwMzExLDAuNTYzNmMwLjEzMTEzLDAuMjI1MzcgMC4yMTQ0MiwwLjQ2ODg0IDAuMjQxMzksMC43MTU4OGMwLjAyNjk3LDAuMjQ3MDQgMC4wMTIxNywwLjQ4OTIgLTAuMDQ4NjEsMC43MTkyYy0wLjA2MDgsMC4yMyAtMC4xNjc1OSwwLjQ0NzgzIC0wLjMxMzEyLDAuNjQ5MjhjLTAuMTQ1NTIsMC4yMDE0NSAtMC4zMzgyMywwLjM3MTk3IC0wLjU2MzYsMC41MDMxMWMtMC4yMjUzNywwLjEzMTEzIC0wLjQ2ODg0LDAuMjE0NDIgLTAuNzE1ODgsMC4yNDEzOWMtMC4yNDcwNCwwLjAyNjk3IC0wLjQ4OTIsMC4wMTIxNyAtMC43MTkyLC0wLjA0ODYxYy0wLjIzLC0wLjA2MDggLTAuNDQ3ODMsLTAuMTY3NTkgLTAuNjQ5MjgsLTAuMzEzMTJjLTAuMjAxNDUsLTAuMTQ1NTIgLTAuMzcxOTcsLTAuMzM4MjMgLTAuNTAzMTEsLTAuNTYzNnpNMjQxLjA3OTMsMTc5LjM2NTk2Yy0wLjA4ODgzLC0wLjE1MjY3IC0wLjE5ODI5LC0wLjI3Mzg3IC0wLjMzMjU4LC0wLjM3MDg5Yy0wLjEzNDMsLTAuMDk3MDIgLTAuMjgxOTUsLTAuMTY2OCAtMC40MzU2OCwtMC4yMTM1OGMtMC4xNTM3MywtMC4wNDY3OCAtMC4zMTk2MiwtMC4wNDc1NyAtMC40ODQzMSwtMC4wMjk1OWMtMC4xNjQ3LDAuMDE3OTggLTAuMzI3MDIsMC4wNzM1MSAtMC40NzI0MSwwLjE1ODExYy0wLjE0NTQsMC4wODQ2IC0wLjI3Mzg3LDAuMTk4MjkgLTAuMzcwODksMC4zMzI1OGMtMC4wOTcwMiwwLjEzNDMgLTAuMTY2OCwwLjI4MTk1IC0wLjIxMzU4LDAuNDM1NjhjLTAuMDQ2NzgsMC4xNTM3MyAtMC4wNDc1NywwLjMxOTYyIC0wLjAyOTU5LDAuNDg0MzFjMC4wMTc5OCwwLjE2NDcgMC4wNzM1MSwwLjMyNzAyIDAuMTU4MTEsMC40NzI0MWMwLjA4NDYsMC4xNDU0IDAuMTk4MjksMC4yNzM4NyAwLjMzMjU4LDAuMzcwODljMC4xMzQzLDAuMDk3MDIgMC4yODE5NSwwLjE2NjggMC40MzU2OCwwLjIxMzU4YzAuMTUzNzMsMC4wNDY3OCAwLjMxOTYyLDAuMDQ3NTcgMC40ODQzMSwwLjAyOTU5YzAuMTY0NywtMC4wMTc5OCAwLjMyNzAyLC0wLjA3MzUxIDAuNDcyNDEsLTAuMTU4MTFjMC4xNDU0LC0wLjA4NDYgMC4yNzM4NywtMC4xOTgyOSAwLjM3MDg5LC0wLjMzMjU4YzAuMDk3MDIsLTAuMTM0MyAwLjE2NjgsLTAuMjgxOTUgMC4yMTM1OCwtMC40MzU2OGMwLjA0Njc4LC0wLjE1MzczIDAuMDQ3NTcsLTAuMzE5NjIgMC4wMjk1OSwtMC40ODQzMWMtMC4wMTc5OCwtMC4xNjQ3IC0wLjA3MzUxLC0wLjMyNzAyIC0wLjE1ODExLC0wLjQ3MjQxeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMzAzMjI0NjMwMjQ4MTk1OjQuOTY5Njg4NDU4NTg4MDI0LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                      </div>`;

                alwaysVisibleContentHtml = `
                    <div class="variable-slider-wrapper">
                        <div id="variable-slider-${index}" class="custom-slider-container"></div>
                    </div>`;
                    const playModeNames = ['往返', '正向', '反向', '单次递增', '单次递减'];
                expandableContentHtml = `
                    <div class="variable-controls">
                        <div class="slider-props">
                            Min: <span class="slider-min-value">${Number.isFinite(entry.min) ? entry.min : 'NaN'}</span>
                            Max: <span class="slider-max-value">${Number.isFinite(entry.max) ? entry.max : 'NaN'}</span>
                            Step: <span class="slider-step-value">${Number.isFinite(entry.step) ? entry.step : 'NaN'}</span>
                        </div>
                        <div class="settings-item-row" style="margin-bottom: 8px;">
                            <span class="slider-props" style="margin-bottom: 0;">播放模式: <span class="play-mode-value" style="cursor:pointer; text-decoration: underline dotted #888;">${playModeNames[entry.playMode || 0]}</span></span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 0.9em; color: var(--text-color-subtle);">在坐标系显示</span>
                                <label class="custom-switch-container">
                                    <input type="checkbox" class="toggle-plot-card-btn" ${entry.showOnPlot ? 'checked' : ''}>
                                    <span class="custom-switch"><span class="custom-switch-track"></span><span class="custom-switch-handle"></span></span>
                                </label>
                            </div>
                        </div>
                    </div>`;

} else if ((entry.type === 'variable' && !entry.isEditableIndependent) || entry.type === 'constant') {
                const displayValue = Number.isFinite(entry.value) ? `→ ${entry.value.toPrecision(4)}` : (entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : '...');
                

                mainContentHtml = `
                    <div class="entry-text-area" data-index="${index}">
                        <div>
                            ${formattedExpr}
                            <span style="color: var(--text-color-subtle); margin-left: 5px;">${displayValue}</span>
                        </div>
                    </div>`;
                
                actionsHtml = `
                    <div class="entry-actions-new">
 <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                   
                    </div>`;
            
} else if (entry.type === 'custom_function_definition' || entry.type === 'advanced_custom_function_definition') {

                const formattedExpr = this.generateHighlightedText(entry);
                mainContentHtml = `<div class="entry-text-area" data-index="${index}"><div>${formattedExpr}</div></div>`;
                actionsHtml = `
                    <div class="entry-actions-new">
 <span class="action-btn edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODQsMTc1LjgzNTc5Yy0wLjEyMDU4LDAuMDE0NjcgLTAuMjQ4NzcsMC4wNTA2NyAtMC4zNTMxOCwwLjExNDM2Yy0wLjEwNDQyLDAuMDYzNjkgLTAuMjA2MzksMC4xNDc0OCAtMC4yODU4MywwLjI0ODkybC00LjU1MDQxLDUuODQ2MDhjLTAuMDQ0MTIsMC4wNTYzNiAtMC4wNjY5NCwwLjEyMDMxIC0wLjA3OTY5LDAuMTgzMDVsLTAuMjI1NDQsMS43NTA3N2wxLjY2NjkzLC0wLjYzMTEyYzAuMDY3ODksLTAuMDI4NjUgMC4xMTQ0NywtMC4wNjQ5MiAwLjE2ODY0LC0wLjEyMjVsNC41NTI4NCwtNS44MjU5OGMwLjA3OTQzLC0wLjEwMTQ0IDAuMTM3NTQsLTAuMjEwNDggMC4xNzMxMSwtMC4zMzcxN2MwLjAzNTU3LC0wLjEyNjY5IDAuMDQwOTksLTAuMjQ5NzMgMC4wMjYzMiwtMC4zNzAzYy0wLjAxNTksLTAuMTMwNjMgLTAuMDUwNjYsLTAuMjQ4NzYgLTAuMTE1NTgsLTAuMzYzMjRjLTAuMDY0OTIsLTAuMTE0NDcgLTAuMTQ3NDgsLTAuMjA2MzkgLTAuMjM3NjUsLTAuMjc3Yy0wLjA5MDE3LC0wLjA3MDYxIC0wLjIwOTI3LC0wLjEyNzQ5IC0wLjMyNzE0LC0wLjE3NDMzYy0wLjExNzg3LC0wLjA0Njg0IC0wLjI4MjMxLC0wLjA1NzQyIC0wLjQxMjk0LC0wLjA0MTUzeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjQuMzk0ODc3OTg0NTUyNjA4OjUuMjE1NjEwNDM1NjA4NTY4LS0+" style="width:18px; height:18px;"></span>
                        <span class="action-btn delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3MiwxNzYuODQxMDloLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5NSwxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxLDE3Ni4yMDg0NWgxLjc4ODI0Yy0wLjAzMzc0LC0wLjA5Mjc4IC0wLjA3NTkyLC0wLjE4NTU3IC0wLjEzNDk2LC0wLjI2MTQ5Yy0wLjA1OTA0LC0wLjA3NTkxIC0wLjEyNjUyLC0wLjE0MzM5IC0wLjIxMDg4LC0wLjIwMjQ0Yy0wLjA4NDM2LC0wLjA1OTA0IC0wLjE2ODcsLTAuMTAxMjIgLTAuMjUzMDYsLTAuMTI2NTNjLTAuMDg0MzYsLTAuMDI1MzEgLTAuMTg1NTcsLTAuMDQyMTcgLTAuMjk1MjMsLTAuMDQyMTdjLTAuMTA5NjUsMCAtMC4yMDI0NCwwLjAxNjg3IC0wLjI5NTIzLDAuMDQyMTdjLTAuMDkyNzksMC4wMjUzMSAtMC4xNzcxMywwLjA3NTkxIC0wLjI1MzA2LDAuMTI2NTNjLTAuMDc1OTIsMC4wNTA2MSAtMC4xNTE4NCwwLjEyNjUyIC0wLjIxMDg4LDAuMjAyNDRjLTAuMDU5MDQsMC4wNzU5MSAtMC4xMDEyMiwwLjE2MDI3IC0wLjEzNDk2LDAuMjYxNDl6TTI0MC42MzY4MywxODIuMjE0MjF2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzUsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTUsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NS4wMDMxNzk5OTk5OTk5NTg6NS4zMDY4Mzk5OTk5OTk5OTQtLT4=" style="width:18px; height:18px;"></span>
                    </div>`;
            }

return `
                <div class="${classes.join(' ')}" style="${style}" title="${title}" data-index="${index}">
                    <div class="entry-main-row">
                        ${mainContentHtml}
                        ${actionsHtml}
                    </div>
                    ${alwaysVisibleContentHtml}
                    ${expandableContentHtml ? `<div class="entry-expandable-content">${expandableContentHtml}</div>` : ''}
                </div>`;
        }).join('');
        
          this.entries.forEach((entry, index) => {
            if (entry.type === 'variable' && entry.isEditableIndependent) {
                const containerId = `variable-slider-${index}`;
                if (document.getElementById(containerId)) {
                    const slider = new CustomSlider(containerId, {
                        min: Number.isFinite(entry.min) ? entry.min : 0,
                        max: Number.isFinite(entry.max) ? entry.max : 10,
                        step: Number.isFinite(entry.step) && entry.step > 0 ? entry.step : 0.01,
                        value: Number.isFinite(entry.value) ? entry.value : 0,
                        onInput: (e) => {
                            entry.value = e.target.options.value;
                            this.recalculateForAnimation();
                        },
                        onChange: () => {
                            entry.playDirection = 1;
                            this.recalculateAll();
                        }
                    });
                    this.activeSliders.push(slider);
                    document.getElementById(containerId).sliderInstance = slider;
                }
} else if (['function', 'geometry', 'text', 'point_list'].includes(entry.type) && entry.expanded) {
                const sliderInstances = {};
                const createColorSlider = (prop, type) => {
                    const containerId = `color-slider-${prop}-${index}`;
                    if(document.getElementById(containerId)) {
                        const slider = new CustomSlider(containerId, {
                            min: 0, max: 100, step: 1, value: entry.color[prop], type: type,
                            context: entry.color, 
                            onInput: (e) => {
                                entry.color[prop] = e.target.options.value;
                                this.updateEntryColorDisplay(index);

                                Object.values(sliderInstances).forEach(s => {
                                    if (s !== slider) {
                                        s.options.context = entry.color;
                                        s.draw();
                                    }
                                });
                                this.requestDraw();
                            },
                            onChange: () => {
                                if (entry.type === 'geometry') {
                                    entry.webglVertices = null;
                                    entry.webglFillVertices = null;
                                }
                                this.requestDraw();
                            }
                        });
                        this.activeSliders.push(slider);
                        sliderInstances[prop] = slider;
                    }
                };
                createColorSlider('h', 'hue');
                createColorSlider('s', 'saturation');
                createColorSlider('b', 'brightness');
                createColorSlider('a', 'alpha');

                const thicknessContainerId = `thickness-slider-${index}`;
                if (document.getElementById(thicknessContainerId)) {
                    const tSlider = new CustomSlider(thicknessContainerId, {
                        min: 1, max: 20, step: 1, value: entry.thickness, type: 'default',
                        onInput: (e) => {
                            entry.thickness = e.target.options.value;
                            if (entry.type === 'function' && (entry.plotType === 'x' || entry.plotType === 'y' || entry.plotType === 'parametric')) {
                                entry.webglVertices = null; 
                            }
                            if (entry.type === 'geometry') {
                                entry.webglVertices = null;
                            }
                            this.requestDraw();
                        },
                        onChange: () => {
                            this.clearPlotData(); 
                            this.recalculateAll(); 
                        }
                    });
this.activeSliders.push(tSlider);
                }
            }
        });

        if (this.showPlaybackControls) {
            const frameSliderContainer = document.getElementById('frame-slider-container');
            if (frameSliderContainer) {
                const frameSlider = new CustomSlider('frame-slider-container', {
                    min: 0,
                    max: this.totalFrames,
                    step: 1,
                    value: this.currentFrame,
                    type: 'default',
                    onInput: (e) => {
                        this.currentFrame = Math.round(e.target.options.value);
                        const valSpan = document.querySelector('.frame-current-value');
                        if (valSpan) valSpan.textContent = this.currentFrame;
                        this.requestDraw();
                    },
                    onChange: (e) => {
                        this.currentFrame = Math.round(e.target.options.value);
                        this.requestDraw();
                    }
                });
                this.activeSliders.push(frameSlider);
                frameSliderContainer.sliderInstance = frameSlider;
            }
        }

        this.updateEntryVariableValuesDisplay();
        this.updateGeometryMeasurementDisplay();
    }


updateEntryColorDisplay(index) {
        const itemElement = this.entryList.querySelector(`.entry-item[data-index="${index}"]`);
        if (!itemElement) return;

        const entry = this.entries[index];
        if (!entry || (entry.type !== 'function' && entry.type !== 'text' && entry.type !== 'geometry' && entry.type !== 'point_list') || !entry.color) return;

        const entryColor = entry.color;
        
        if (entry.type === 'function' || entry.type === 'geometry' || entry.type === 'text' || entry.type === 'point_list') {
            const hexColor = this.hsbToHex(entryColor.h, entryColor.s, entryColor.b);
            itemElement.style.setProperty('--entry-color', entry.visible ? hexColor : 'rgba(128,128,128,0.4)');
            itemElement.style.setProperty('--entry-visible-opacity', entry.visible ? 1 : 0.3);
        }

        const colorSliders = itemElement.querySelectorAll('.color-slider');
        colorSliders.forEach(slider => {
           const colorProp = slider.dataset.colorProp;
           if (colorProp && entryColor[colorProp] !== undefined) {
               slider.value = entryColor[colorProp];
           }
        });
    }


updateEntryVariableValuesDisplay() {
    this.entries.forEach((entry, index) => {
        const itemElement = this.entryList.querySelector(`.entry-item[data-index="${index}"]`);
        if (!itemElement) return;

        if (entry.type === 'variable' || entry.type === 'constant') {
            const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : (Number.isNaN(entry.value) ? 'NaN' : '计算中...');
            
            if (entry.isEditableIndependent) {
                const valueSpan = itemElement.querySelector('.entry-value');
                if (valueSpan) valueSpan.textContent = displayValue;
            } else {
                const textDivs = itemElement.querySelectorAll('.entry-text-area div');
                if (textDivs.length > 1) {
                     textDivs[1].innerHTML = Number.isFinite(entry.value) ? `→ ${entry.value.toPrecision(4)}` : (entry.compilationError ? `<span style="color: var(--text-color-error); font-size: 0.8em;">(${entry.compilationError})</span>` : '...');
                }
            }

            let varIndicatorColor = '';
            if (entry.type === 'variable') {
                varIndicatorColor = entry.isEditableIndependent ? (entry.playState === 1 ? 'var(--variable-indicator-independent-playing-color)' : 'var(--variable-indicator-independent-paused-color)') : 'var(--variable-indicator-dependent-color)';
            } else if (entry.type === 'constant') {
                varIndicatorColor = 'var(--variable-indicator-dependent-color)';
            }
            itemElement.style.setProperty('--variable-indicator-color', varIndicatorColor);

            if (entry.isEditableIndependent) {
                const sliderContainer = itemElement.querySelector('.custom-slider-container');
                if (sliderContainer && sliderContainer.sliderInstance) {
                    sliderContainer.sliderInstance.setValue(entry.value);
                }

                if (itemElement.classList.contains('expanded')) {
                    const minSpan = itemElement.querySelector('.slider-min-value');
                    const maxSpan = itemElement.querySelector('.slider-max-value');
                    const stepSpan = itemElement.querySelector('.slider-step-value');
                    const step = entry.step;
                    let propPrecision = 4;
                    if (Number.isFinite(step) && step !== 0) propPrecision = Math.max(0, -Math.floor(Math.log10(Math.abs(step) + 1e-9)));
                    else if (Number.isFinite(entry.max) && Number.isFinite(entry.min)) propPrecision = Math.max(0, -Math.floor(Math.log10(Math.abs(entry.max - entry.min) / 100 + 1e-9)));
                    
                    if (minSpan) minSpan.textContent = Number.isFinite(entry.min) ? entry.min.toFixed(propPrecision) : 'NaN';
                    if (maxSpan) maxSpan.textContent = Number.isFinite(entry.max) ? entry.max.toFixed(propPrecision) : 'NaN';
                    if (stepSpan) stepSpan.textContent = Number.isFinite(entry.step) ? entry.step.toFixed(propPrecision) : 'NaN';
                }
            }
        }
         const errorSpan = itemElement.querySelector('span[style*="color: var(--text-color-error)"]');
         if (errorSpan) {
              if (entry.compilationError) { errorSpan.textContent = `(${entry.compilationError})`; errorSpan.style.display = 'inline';} 
              else {errorSpan.style.display = 'none';}
         }
    });
}


calculateGridStep(cssWidth, cssHeight) {
 const targetPixelStep = 75;
 const minUnits = targetPixelStep / this.scale;
 const exponent = Math.floor(Math.log10(minUnits));
 const magnitude = Math.pow(10, exponent);
 const normalizedMinUnits = minUnits / magnitude;
 let unitStep;
 if (normalizedMinUnits < 1.5) unitStep = 1 * magnitude;
 else if (normalizedMinUnits < 3.5) unitStep = 2 * magnitude;
 else if (normalizedMinUnits < 7.5) unitStep = 5 * magnitude;
 else unitStep = 10 * magnitude;
 const minPixelDist = 15;
 if (unitStep * this.scale < minPixelDist) {
     const requiredMagnitude = minPixelDist / this.scale;
     const exponentAdj = Math.floor(Math.log10(requiredMagnitude));
     const magnitudeAdj = Math.pow(10, exponentAdj);
     const normalizedAdj = requiredMagnitude / magnitudeAdj;
     if (normalizedAdj < 1.5) unitStep = 1 * magnitudeAdj;
     else if (normalizedAdj < 3.5) unitStep = 2 * magnitudeAdj;
     else if (normalizedAdj < 7.5) unitStep = 5 * magnitudeAdj;
     else unitStep = 10 * magnitudeAdj;
 }
 if (unitStep === 0) unitStep = magnitude > 0 ? magnitude : 1e-6;
 const log10Step = Math.log10(Math.abs(unitStep));
 const precision = Math.max(0, -Math.floor(log10Step + 1e-9));
 const maxDisplayPrecision = 6;
 const finalPrecision = Math.min(precision, maxDisplayPrecision);
 return { unitStep, precision: finalPrecision };
}


calculateAuxiliary3D() {
        const b = this.bounds3D;
        
        const boxV = [ -b,-b,-b, b,-b,-b, b,b,-b, -b,b,-b, -b,-b,b, b,-b,b, b,b,b, -b,b,b ];
        const boxI = [ 0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 0,4, 1,5, 2,6, 3,7 ];
        this.cache3D.box = { 
            vbo: this.createBuffer(boxV), 
            ibo: this.gl.createBuffer(), 
            count: boxI.length 
        };
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.cache3D.box.ibo);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boxI), this.gl.STATIC_DRAW);

        const axesV = [];
        const ox = -this.offset3D.x;
        const oy = -this.offset3D.y;

        this.pushBox(axesV, -b, oy, 0, b, oy, 0);
        this.pushBox(axesV, ox, -b, 0, ox, b, 0);
        this.pushBox(axesV, ox, oy, -b, ox, oy, b);
        this.cache3D.axes = { vbo: this.createBuffer(axesV), count: axesV.length / 6 };

        const tickV = [], gridV = [];
        this.cache3D.labels = [];
        
        const visibleMathRange = (b * 2) * this.scale3D; 
        const { step, precision } = this.getAdaptiveStep3D(visibleMathRange);
        const formatNum = (num) => parseFloat(num.toFixed(precision)).toString();
        const tickLen = 0.2;

        const minXMath = this.scale3D * (-b + this.offset3D.x);
        const maxXMath = this.scale3D * (b + this.offset3D.x);
        const startIdxX = Math.ceil(minXMath / step);
        const endIdxX = Math.floor(maxXMath / step);

        if (Math.abs(oy) <= b) {
            for(let i = startIdxX; i <= endIdxX; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D - this.offset3D.x;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(valScreen, oy, 0, valScreen, oy - tickLen, 0);
                 this.cache3D.labels.push({x: valScreen, y: oy - tickLen*1.8, z: 0, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: b+0.5, y:oy, z:0, text: "X"});
        }
        
        for(let i = startIdxX; i <= endIdxX; i++) {
             const valMath = i * step;
             if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
             const valScreen = valMath / this.scale3D - this.offset3D.x;
             gridV.push(valScreen, -b, 0, valScreen, b, 0);
        }
        
        const minYMath = this.scale3D * (-b + this.offset3D.y);
        const maxYMath = this.scale3D * (b + this.offset3D.y);
        const startIdxY = Math.ceil(minYMath / step);
        const endIdxY = Math.floor(maxYMath / step);

        if (Math.abs(ox) <= b) {
            for(let i = startIdxY; i <= endIdxY; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D - this.offset3D.y;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(ox, valScreen, 0, ox - tickLen, valScreen, 0);
                 this.cache3D.labels.push({x: ox - tickLen*1.8, y: valScreen, z: 0, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: ox, y:b+0.5, z:0, text: "Y"});
        }
        
        for(let i = startIdxY; i <= endIdxY; i++) {
             const valMath = i * step;
             if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
             const valScreen = valMath / this.scale3D - this.offset3D.y;
             gridV.push(-b, valScreen, 0, b, valScreen, 0);
        }
        
        const minZMath = -b * this.scale3D;
        const maxZMath = b * this.scale3D;
        const startIdxZ = Math.ceil(minZMath / step);
        const endIdxZ = Math.floor(maxZMath / step);

        if (Math.abs(ox) <= b && Math.abs(oy) <= b) {
            for(let i = startIdxZ; i <= endIdxZ; i++) {
                 const valMath = i * step;
                 if (Math.abs(valMath) < 1e-5 && step > 1e-6) continue;
                 const valScreen = valMath / this.scale3D;
                 if (Math.abs(valScreen) > b) continue;
                 tickV.push(ox, oy, valScreen, ox, oy - tickLen, valScreen);
                 this.cache3D.labels.push({x: ox, y: oy - tickLen*1.8, z: valScreen, text: formatNum(valMath)});
            }
            this.cache3D.labels.push({x: ox, y:oy, z:b+0.5, text: "Z"});
        }

        this.cache3D.ticks = { vbo: this.createBuffer(tickV), count: tickV.length/3 };
        this.cache3D.grid = { vbo: this.createBuffer(gridV), count: gridV.length/3 };
    }
generateQuadVertices(p1x, p1y, p2x, p2y, thickness) {
const dx = p2x - p1x;
const dy = p2y - p1y;
const len = Math.sqrt(dx * dx + dy * dy);
if (len === 0) return [];
const nx = dx / len;
const ny = dy / len;
const halfThickness = thickness / 2;
const offsetX = -ny * halfThickness;
const offsetY = nx * halfThickness;
return [
   p1x - offsetX, p1y - offsetY, p1x + offsetX, p1y + offsetY, p2x - offsetX, p2y - offsetY,
   p1x + offsetX, p1y + offsetY, p2x + offsetX, p2y + offsetY, p2x - offsetX, p2y - offsetY,
];
}

drawGridGL(cssWidth, cssHeight) {
    if (this.gridStyle === 'hidden') return;
    const gl = this.gl;
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep } = gridStepInfo;
    this.currentUnitStep = unitStep;
    const { x: offsetX, y: offsetY } = this.offset;
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const endXMath = Math.floor(maxXMath / unitStep + 1e-9) * unitStep;
    const endYMath = Math.floor(maxYMath / unitStep + 1e-9) * unitStep;
    const zeroThreshold = unitStep * 1e-9;
    const vertices = [];
    const gridThicknessMath = 2.0 / this.scale;
    
    switch (this.gridStyle) {
        case 'grid':
            for (let x = startXMath; x <= endXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
                if (this.showAxes && Math.abs(x) < zeroThreshold && Math.abs(offsetX + x * this.scale - cssWidth/2) < cssWidth/2 - 10) continue;
                vertices.push(...this.generateQuadVertices(x, minYMath - unitStep*2, x, maxYMath + unitStep*2, gridThicknessMath));
            }
            for (let y = startYMath; y <= endYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
                if (this.showAxes && Math.abs(y) < zeroThreshold && Math.abs(offsetY - y * this.scale - cssHeight/2) < cssHeight/2 - 10) continue;
                vertices.push(...this.generateQuadVertices(minXMath - unitStep*2, y, maxXMath + unitStep*2, y, gridThicknessMath));
            }
            break;
        case 'dots':
            const dotSize = 1.0 / this.scale;
            for (let x = startXMath; x <= endXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
                for (let y = startYMath; y <= endYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
                    vertices.push(x - dotSize, y - dotSize, x + dotSize, y - dotSize, x - dotSize, y + dotSize);
                    vertices.push(x + dotSize, y - dotSize, x + dotSize, y + dotSize, x - dotSize, y + dotSize);
                }
            }
            break;
        case 'polar':
            const numCircles = 20;
            const numSegments = 100;
            for (let i = 1; i <= numCircles; i++) {
                const radius = i * unitStep;
                let lastX = radius, lastY = 0;
                for (let j = 1; j <= numSegments; j++) {
                    const angle = (j / numSegments) * 2 * Math.PI;
                    const nextX = radius * Math.cos(angle);
                    const nextY = radius * Math.sin(angle);
                    vertices.push(...this.generateQuadVertices(lastX, lastY, nextX, nextY, gridThicknessMath));
                    lastX = nextX; lastY = nextY;
                }
            }
            break;
    }

    if (vertices.length === 0) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
    let gridColor = this.isDarkModeActive ? this.hsbToRgbaArray(0, 0, 35, 0) : this.hsbToRgbaArray(0, 0, 87.8, 0);
    gl.uniform4fv(this.uniformLocations.color, gridColor);
    const drawMode = this.gridStyle === 'dots' ? gl.TRIANGLES : gl.TRIANGLES;
    gl.drawArrays(drawMode, 0, vertices.length / 2);
}



drawAxesGL(cssWidth, cssHeight) {
    if (!this.showAxes) return;
    const gl = this.gl;
    const { x: offsetX, y: offsetY } = this.offset;
    const xVertices = [];
    const yVertices = [];
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const axisThicknessMath = 4.0 / this.scale;
    xVertices.push(...this.generateQuadVertices(minXMath - 1000/this.scale, 0, maxXMath + 1000/this.scale, 0, axisThicknessMath));
    yVertices.push(...this.generateQuadVertices(0, minYMath - 1000/this.scale, 0, maxYMath + 1000/this.scale, axisThicknessMath));
    gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
    gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
    gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
    const xAxisColor = [1.0, 0.0, 0.0, 1.0];
    gl.uniform4fv(this.uniformLocations.color, xAxisColor);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(xVertices), gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.TRIANGLES, 0, xVertices.length / 2);
    const yAxisColor = [0.0, 0.0, 1.0, 1.0];
    gl.uniform4fv(this.uniformLocations.color, yAxisColor);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(yVertices), gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.TRIANGLES, 0, yVertices.length / 2);
}


drawOrigin2D(cssWidth, cssHeight) {
const dpr = window.devicePixelRatio || 1;
const screenX = this.offset.x;
const screenY = this.offset.y;
if (screenX >= -10 && screenX <= cssWidth + 10 && screenY >= -10 && screenY <= cssHeight + 10) {
   this.axisCtx.save();
   this.axisCtx.scale(dpr, dpr);
   this.axisCtx.beginPath();
   this.axisCtx.arc(screenX, screenY, 6, 0, 2 * Math.PI);
   this.axisCtx.fillStyle = 'black';
   this.axisCtx.fill();
   this.axisCtx.restore();
}
}
 

 drawAxisNumbers(cssWidth, cssHeight) {
    if (!this.showAxes || !this.showAxisNumbers) {
        this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        return;
    }
    const dpr = window.devicePixelRatio || 1;
    this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
    this.axisCtx.save();
    this.axisCtx.scale(dpr, dpr);
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep, precision } = gridStepInfo;
    const { x: offsetX, y: offsetY } = this.offset;
    this.axisCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
   this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const yAxisScreenX = offsetX;
    const xAxisScreenY = offsetY;
    const originScreenX = this.offset.x;
    const originScreenY = this.offset.y;
    const originVisible = originScreenX >= -5 && originScreenX <= cssWidth + 5 && originScreenY >= -5 && originScreenY <= cssHeight + 5;
    const zeroTolerance = 1e-9; 

    this.axisCtx.textAlign = 'center';
    this.axisCtx.textBaseline = 'top';
    for (let x = startXMath; x <= maxXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
        if (Math.abs(x) < zeroTolerance && x !== 0) continue; 
        const screenX = offsetX + x * this.scale;
        if (screenX > 20 && screenX < cssWidth - 20) {
            let textY = xAxisScreenY + 8;
            if (textY < 20) textY = 20;
            if (textY > cssHeight - 20) textY = cssHeight - 20;
            const labelText = (Math.abs(x) < zeroTolerance) ? "0" : x.toFixed(precision);
            this.axisCtx.fillText(labelText, screenX, textY);
        }
    }

    this.axisCtx.textBaseline = 'middle';
    for (let y = startYMath; y <= maxYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
        if (Math.abs(y) < zeroTolerance && y !== 0) continue; 
        const screenY = offsetY - y * this.scale;
        if (screenY > 15 && screenY < cssHeight - 15) {
            if (originVisible && Math.abs(y) < zeroTolerance) continue; 
            let textX, align;
            const yLabelPadding = 8;
            if (yAxisScreenX < 40) { align = 'left'; textX = yAxisScreenX + yLabelPadding; if (textX < yLabelPadding) textX = yLabelPadding; }
            else if (yAxisScreenX > cssWidth - 25) { align = 'right'; textX = cssWidth - yLabelPadding; }
            else { align = 'right'; textX = yAxisScreenX - yLabelPadding; }
            this.axisCtx.textAlign = align;
            const labelText = (Math.abs(y) < zeroTolerance) ? "0" : y.toFixed(precision);
            this.axisCtx.fillText(labelText, textX, screenY);
        }
    }
    this.axisCtx.restore();
} 
isHiddenByCheckbox(entry) {
        
        const id = entry.name || entry.expr;
        for (const anno of this.annotations) {
            if (anno.type === 'checkbox' && anno.controlledNames && anno.controlledNames.includes(id)) {
                if (!anno.checked) return true;
            }
        }
        return false;
    }plotAllGeometryGL(cssWidth, cssHeight) {
        const geometryEntries = this.entries.filter(e => {
            const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || e.displayFrame === 0 || e.displayFrame === this.currentFrame;
            

            if (this.isHiddenByCheckbox(e)) return false;


            const isVisible = this.getEffectiveVisibility(e);
            

            if (!isVisible && !this.showHiddenGeo) return false;

            return e.type === 'geometry' && e.isMeaningful && isFrameVisible;
        });        
        if (geometryEntries.length === 0) return;
        const polygons = geometryEntries.filter(e => e.geometryType === 'polygon');
        const points = geometryEntries.filter(e => ['point', 'midpoint', 'intercept'].includes(e.geometryType));
        const otherGeometry = geometryEntries.filter(e => e.geometryType !== 'polygon' && !points.includes(e));
        
        otherGeometry.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
        polygons.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
        points.forEach(entry => this.plotSingleGeometryGL(entry, cssWidth, cssHeight));
    }

plotSingleGeometryGL(entry, cssWidth, cssHeight) {

        if (this.isHiddenByCheckbox(entry)) return;

        const gl = this.gl;
        const isHighlighted = this.highlightedObject === entry;


        const isEffectiveVisible = this.getEffectiveVisibility(entry);
        
        // 如果不可见，且“显示隐藏对象”开关未开启，则直接不画
        if (!isEffectiveVisible && !this.showHiddenGeo) return;

        let finalColor = entry.color;
        
        // 如果不可见但因“显示隐藏对象”而绘制，设置为半透明
        if (!isEffectiveVisible && this.showHiddenGeo) {
            finalColor = {...entry.color};
            finalColor.a = finalColor.a + (100 - finalColor.a) * 0.75;
        }

        if (entry.isSelected || !entry.webglVertices || isHighlighted) {
            const vertices = [];       
 const fillVertices = [];
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        let lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
        
        if (isHighlighted) {
            lineThicknessMath *= 2;
        }
        let pointRadiusMath = (entry.thickness + 2) / this.scale; 
            if (entry.isSelected) {
                pointRadiusMath *= 1.5;
            }

            switch (entry.geometryType) {
                case 'point': case 'midpoint': case 'intercept': case 'rotate': case 'reflect': case 'translate': {
                    const center_x = entry.x_val;
                    const center_y = entry.y_val;
                    const segments = 12;
                    for (let i = 0; i < segments; i++) {
                        const angle1 = (i / segments) * 2 * Math.PI;
                        const angle2 = ((i + 1) / segments) * 2 * Math.PI;
                        const x1 = center_x + pointRadiusMath * Math.cos(angle1);
                        const y1 = center_y + pointRadiusMath * Math.sin(angle1);
                        const x2 = center_x + pointRadiusMath * Math.cos(angle2);
                        const y2 = center_y + pointRadiusMath * Math.sin(angle2);
                        vertices.push(center_x, center_y, x1, y1, x2, y2);
                    }
                    break;
                }
                case 'segment':
                case 'vector': {
                    const {x_val: x1, y_val: y1} = entry.p1;
                    const {x_val: x2, y_val: y2} = entry.p2;
                    if (useQuads) vertices.push(...this.generateQuadVertices(x1, y1, x2, y2, lineThicknessMath));
                    else vertices.push(x1, y1, x2, y2);
                    if (entry.geometryType === 'vector') {
                        const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                        if (len > 0) {
                            const arrowSize = 10 / this.scale;
                            const dx = (x2-x1)/len, dy = (y2-y1)/len;
                            const ax1 = x2 - arrowSize * (dx * 0.866 - dy * 0.5);
                            const ay1 = y2 - arrowSize * (dy * 0.866 + dx * 0.5);
                            const ax2 = x2 - arrowSize * (dx * 0.866 + dy * 0.5);
                            const ay2 = y2 - arrowSize * (dy * 0.866 - dx * 0.5);
                            if (useQuads) {
                                vertices.push(...this.generateQuadVertices(x2, y2, ax1, ay1, lineThicknessMath));
                                vertices.push(...this.generateQuadVertices(x2, y2, ax2, ay2, lineThicknessMath));
                            } else {
                                vertices.push(x2, y2, ax1, ay1, x2, y2, ax2, ay2);
                            }
                        }
                    }
                    break;
                }
                case 'ray':
                case 'line':
                case 'perpendicularline':
                case 'parallelline':
                case 'anglebisector':
                    case 'fitline': case 'tangent':{
                    const {x_val: x1, y_val: y1} = entry.p1;
                    const {x: dx, y: dy} = entry.dir;
                    const minMathX = (-this.offset.x - 10) / this.scale;
                    const maxMathX = (cssWidth - this.offset.x + 10) / this.scale;
                    const minMathY = (this.offset.y - cssHeight - 10) / this.scale;
                    const maxMathY = (this.offset.y + 10) / this.scale;
                    let t_vals = [];

                    if (Math.abs(dx) > 1e-9) { 
                        t_vals.push((minMathX - x1)/dx, (maxMathX - x1)/dx);
                    }
                    if (Math.abs(dy) > 1e-9) { 
                        t_vals.push((minMathY - y1)/dy, (maxMathY - y1)/dy);
                    }
                    
                    if (t_vals.length === 0) break;

                    if (entry.geometryType === 'ray') {
                         t_vals.push(0);
                         t_vals = t_vals.filter(t => t >= -1e-9);
                    }

                    t_vals.sort((a,b) => a - b);

                    if (t_vals.length >= 2) {
                        const t_start = t_vals[0];
                        const t_end = t_vals[t_vals.length-1];
                        const start_pt = { x: x1 + t_start * dx, y: y1 + t_start * dy };
                        const end_pt = { x: x1 + t_end * dx, y: y1 + t_end * dy };
                        if (useQuads) vertices.push(...this.generateQuadVertices(start_pt.x, start_pt.y, end_pt.x, end_pt.y, lineThicknessMath));
                        else vertices.push(start_pt.x, start_pt.y, end_pt.x, end_pt.y);
                    }
                    break;
                }
case 'circle': {
                    const {x_val: cx, y_val: cy} = entry.center;
                    const r = entry.radius;
                    const segments = Math.max(36, Math.min(360, Math.floor(this.scale * r / 1.5)));
                    let last_x = cx + r, last_y = cy;
                    for (let i = 1; i <= segments; i++) {
                        const angle = (i / segments) * 2 * Math.PI;
                        const next_x = cx + r * Math.cos(angle);
                        const next_y = cy + r * Math.sin(angle);
                        if (useQuads) vertices.push(...this.generateQuadVertices(last_x, last_y, next_x, next_y, lineThicknessMath));
                        else vertices.push(last_x, last_y, next_x, next_y);
                        last_x = next_x; last_y = next_y;
                    }
                    break;
                }
                case 'circulararc': {
                    const { center, radius, startAngle } = entry;
                    let { endAngle } = entry;
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const arcAngle = endAngle - startAngle;
                    const segments = Math.max(2, Math.min(360, Math.floor(this.scale * radius * arcAngle / 1.5)));
                    
                    let last_x = center.x_val + radius * Math.cos(startAngle);
                    let last_y = center.y_val + radius * Math.sin(startAngle);

                    for (let i = 1; i <= segments; i++) {
                        const angle = startAngle + (i / segments) * arcAngle;
                        const next_x = center.x_val + radius * Math.cos(angle);
                        const next_y = center.y_val + radius * Math.sin(angle);
                        if (useQuads) vertices.push(...this.generateQuadVertices(last_x, last_y, next_x, next_y, lineThicknessMath));
                        else vertices.push(last_x, last_y, next_x, next_y);
                        last_x = next_x; last_y = next_y;
                    }
                    break;
                }
                case 'ellipse_ab': {
                    const { center, a, b, rotation } = entry;
                    if (!center || !a || !b || rotation === undefined) break;
                    
                    const segments = 200;
                    let last_pt = null;
                    
                    for(let i=0; i<=segments; i++) {
                        const t = (i/segments) * 2 * Math.PI;
                        const localX = a * Math.cos(t);
                        const localY = b * Math.sin(t);
                        const pt = {
                            x: center.x + localX * Math.cos(rotation) - localY * Math.sin(rotation),
                            y: center.y + localX * Math.sin(rotation) + localY * Math.cos(rotation)
                        };
                        if (last_pt) {
                            if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                            else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                        }
                        last_pt = pt;
                    }
                    break;
                }
                case 'ellipse':
                case 'hyperbola':
                case 'parabola':
                case 'polygon': {
                    if(entry.geometryType === 'polygon' && entry.points.length > 1) {
                    } else if (entry.geometryType === 'ellipse') {
                        const {x_val: f1x, y_val: f1y} = entry.f1;
                        const {x_val: f2x, y_val: f2y} = entry.f2;
                        const center = {x:(f1x+f2x)/2, y:(f1y+f2y)/2};
                        const c = Math.sqrt((f1x-f2x)**2 + (f1y-f2y)**2)/2;
                        const a = entry.dist_sum / 2;
                        if (a <= c) break;
                        const b = Math.sqrt(a*a - c*c);
                        const angle = Math.atan2(f2y-f1y, f2x-f1x);
                        const segments = 200; let last_pt = null;
                        for(let i=0; i<=segments; i++) {
                            const t = (i/segments) * 2 * Math.PI;
                            const localX = a * Math.cos(t), localY = b * Math.sin(t);
                            const pt = {
                                x: center.x + localX * Math.cos(angle) - localY * Math.sin(angle),
                                y: center.y + localX * Math.sin(angle) + localY * Math.cos(angle)
                            };
                            if (last_pt) {
                                if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                            }
                            last_pt = pt;
                        }
                    } else if (entry.geometryType === 'hyperbola') {
                        const { center, a, b, rotation } = entry;
                        const segments = 200;

                        const minMathX = (-this.offset.x - 20) / this.scale;
                        const maxMathX = (cssWidth - this.offset.x + 20) / this.scale;
                        const minMathY = (this.offset.y - cssHeight - 20) / this.scale;
                        const maxMathY = (this.offset.y + 20) / this.scale;
                        const cos_r = Math.cos(-rotation), sin_r = Math.sin(-rotation);

                        let max_local_abs_x = 0;
                        [minMathX, maxMathX].forEach(x => {
                            [minMathY, maxMathY].forEach(y => {
                                const relX = x - center.x;
                                const relY = y - center.y;
                                max_local_abs_x = Math.max(max_local_abs_x, Math.abs(relX * cos_r - relY * sin_r));
                            });
                        });
                        
                        let t_range = Math.acosh(Math.max(1, max_local_abs_x / a));
                        if (!Number.isFinite(t_range) || t_range < 2) t_range = 5;

                        for (let branch = -1; branch <= 1; branch += 2) {
                            let last_pt = null;
                            for (let i = 0; i <= segments; i++) {
                                const t = -t_range + (i / segments) * 2 * t_range;
                                const localX = branch * a * Math.cosh(t);
                                const localY = b * Math.sinh(t);
                                const pt = {
                                    x: center.x + localX * Math.cos(rotation) - localY * Math.sin(rotation),
                                    y: center.y + localX * Math.sin(rotation) + localY * Math.cos(rotation)
                                };
                                if (last_pt) {
                                    if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                    else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                                }
                                last_pt = pt;
                            }
                        }
                    } else if (entry.geometryType === 'parabola') {
                        const {x_val: fx, y_val: fy} = entry.focus;
                        const {x_val: p1x, y_val: p1y} = entry.directrix.p1;
                        const {x: dirx, y: diry} = entry.directrix.dir;
                        const p2x = p1x + dirx, p2y = p1y + diry;
                        const k = ((p2y-p1y)*(fx-p1x) - (p2x-p1x)*(fy-p1y)) / ((p2y-p1y)**2 + (p2x-p1x)**2);
                        const proj_x = fx - k*(p2y-p1y), proj_y = fy + k*(p2x-p1x);
                        const vertex = {x: (fx+proj_x)/2, y: (fy+proj_y)/2};
                        const p_dist = Math.sqrt((fx-vertex.x)**2 + (fy-vertex.y)**2);
                        const axis_angle = Math.atan2(fy-proj_y, fx-proj_x);
                        const segments = 200; const t_range = Math.max(5, 500/this.scale);
                        let last_pt = null;
                        for(let i=0; i<=segments; i++) {
                            const t = -t_range + (i / segments) * 2 * t_range;
                            const localX = t*t / (4*p_dist);
                            const localY = t;
                            const rotatedLocalX = localX * Math.cos(axis_angle) - localY * Math.sin(axis_angle);
                            const rotatedLocalY = localX * Math.sin(axis_angle) + localY * Math.cos(axis_angle);
                            const pt = {
                                x: vertex.x + rotatedLocalX,
                                y: vertex.y + rotatedLocalY
                            };
                             if (last_pt) {
                                if(useQuads) vertices.push(...this.generateQuadVertices(last_pt.x, last_pt.y, pt.x, pt.y, lineThicknessMath));
                                else vertices.push(last_pt.x, last_pt.y, pt.x, pt.y);
                            }
                            last_pt = pt;
                        }
                    }
                    break;
                }
            }
            entry.webglVertices = new Float32Array(vertices);
            entry.webglFillVertices = new Float32Array(fillVertices);
        }

        if (entry.webglFillVertices && entry.webglFillVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglFillVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            const fillAlpha = 100 - 0.5 * (100 - finalColor.a);
            const fillColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, fillAlpha);
            gl.uniform4fv(this.uniformLocations.color, fillColorArray);
            gl.drawArrays(gl.TRIANGLES, 0, entry.webglFillVertices.length / 2);
        }
        
        if (entry.webglVertices && entry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, entry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            
            let plotColorArray;
            if (isHighlighted) {
                const rootStyle = getComputedStyle(document.documentElement);
                const accentColor = rootStyle.getPropertyValue('--text-color-accent').trim();
                plotColorArray = this.cssColorToRgbaArray(accentColor);
            } else {
                plotColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
            }
            
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);
            const useQuads = this.lineWidth > 1.5;
const drawMode = ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(entry.geometryType) ? gl.TRIANGLES : (useQuads ? gl.TRIANGLES : gl.LINES);
             if (!useQuads && drawMode === gl.LINES) gl.lineWidth(1.5);
            gl.drawArrays(drawMode, 0, entry.webglVertices.length / 2);
        }
    }
cssColorToRgbaArray(colorString) {
    if (!colorString) return [0, 0, 0, 1];
    const tempDiv = document.createElement('div');
    tempDiv.style.color = colorString;
    document.body.appendChild(tempDiv);
    const computedColor = getComputedStyle(tempDiv).color;
    document.body.removeChild(tempDiv);
    const match = computedColor.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (match) {
        return [
            parseInt(match[1]) / 255,
            parseInt(match[2]) / 255,
            parseInt(match[3]) / 255,
            match[4] ? parseFloat(match[4]) : 1.0
        ];
    }
    return [0, 0, 0, 1];
} 
 drawAxisNumbers(cssWidth, cssHeight) {
    if (!this.showAxes || !this.showAxisNumbers) {
        this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
        return;
    }
    const dpr = window.devicePixelRatio || 1;
    this.axisCtx.clearRect(0, 0, this.axisCanvas.width, this.axisCanvas.height);
    this.axisCtx.save();
    this.axisCtx.scale(dpr, dpr);
    const gridStepInfo = this.calculateGridStep(cssWidth, cssHeight);
    const { unitStep, precision } = gridStepInfo;
    const { x: offsetX, y: offsetY } = this.offset;
    this.axisCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-number-color').trim() || '#333';
this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";
    const minXMath = (-offsetX) / this.scale;
    const maxXMath = (cssWidth - offsetX) / this.scale;
    const minYMath = (offsetY - cssHeight) / this.scale;
    const maxYMath = offsetY / this.scale;
    const startXMath = Math.ceil(minXMath / unitStep - 1e-9) * unitStep;
    const startYMath = Math.ceil(minYMath / unitStep - 1e-9) * unitStep;
    const yAxisScreenX = offsetX;
    const xAxisScreenY = offsetY;
    const originScreenX = this.offset.x;
    const originScreenY = this.offset.y;
    const originVisible = originScreenX >= -5 && originScreenX <= cssWidth + 5 && originScreenY >= -5 && originScreenY <= cssHeight + 5;
    const zeroTolerance = 1e-9; 

    this.axisCtx.textAlign = 'center';
    this.axisCtx.textBaseline = 'top';
    for (let x = startXMath; x <= maxXMath; x = parseFloat((x + unitStep).toPrecision(10))) {
        if (Math.abs(x) < zeroTolerance && x !== 0) continue; 
        const screenX = offsetX + x * this.scale;
        if (screenX > 20 && screenX < cssWidth - 20) {
            let textY = xAxisScreenY + 8;
            if (textY < 20) textY = 20;
            if (textY > cssHeight - 20) textY = cssHeight - 20;
            const labelText = (Math.abs(x) < zeroTolerance) ? "0" : x.toFixed(precision);
            this.axisCtx.fillText(labelText, screenX, textY);
        }
    }

    this.axisCtx.textBaseline = 'middle';
    for (let y = startYMath; y <= maxYMath; y = parseFloat((y + unitStep).toPrecision(10))) {
        if (Math.abs(y) < zeroTolerance && y !== 0) continue; 
        const screenY = offsetY - y * this.scale;
        if (screenY > 15 && screenY < cssHeight - 15) {
            if (originVisible && Math.abs(y) < zeroTolerance) continue; 
            let textX, align;
            const yLabelPadding = 8;
            if (yAxisScreenX < 40) { align = 'left'; textX = yAxisScreenX + yLabelPadding; if (textX < yLabelPadding) textX = yLabelPadding; }
            else if (yAxisScreenX > cssWidth - 25) { align = 'right'; textX = cssWidth - yLabelPadding; }
            else { align = 'right'; textX = yAxisScreenX - yLabelPadding; }
            this.axisCtx.textAlign = align;
            const labelText = (Math.abs(y) < zeroTolerance) ? "0" : y.toFixed(precision);
            this.axisCtx.fillText(labelText, textX, screenY);
        }
    }
    this.axisCtx.restore();
} 

drawGeometryLabels(cssWidth, cssHeight) {
        if (!this.showPointLabels) return;
        const dpr = window.devicePixelRatio || 1;
        this.axisCtx.save();
        this.axisCtx.scale(dpr, dpr);
        this.axisCtx.textBaseline = 'bottom';
        this.axisCtx.textAlign = 'left';
        this.axisCtx.font = "20px 'HarmonyOS_SC', Arial";

        const pointEntries = this.entries.filter(e => {
            const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || e.displayFrame === 0 || e.displayFrame === this.currentFrame;
            
            // 核心修改：增加复选框和有效可见性检查
            if (this.isHiddenByCheckbox(e)) return false;
            const isVisible = this.getEffectiveVisibility(e);
            
            // 只有当对象“有效可见”时才显示标签 (隐藏对象通常不显示标签，以免杂乱)
            // 如果你希望显示隐藏对象的标签，可以将 isVisible 改为 (isVisible || this.showHiddenGeo)
            return (e.type === 'geometry' && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(e.geometryType)) && 
            isVisible && 
            e.isMeaningful &&
            isFrameVisible &&
            Number.isFinite(e.x_val) &&
            Number.isFinite(e.y_val);
        });

        for (const entry of pointEntries) {      
const screenX = this.offset.x + entry.x_val * this.scale;
            const screenY = this.offset.y - entry.y_val * this.scale;

            if (screenX > -50 && screenX < cssWidth + 50 && screenY > -50 && screenY < cssHeight + 50) {
                let colorArray = this.hsbToRgbaArray(entry.color.h, entry.color.s, entry.color.b, entry.color.a);
                this.axisCtx.fillStyle = `rgba(${colorArray[0]*255}, ${colorArray[1]*255}, ${colorArray[2]*255}, ${colorArray[3]})`;
                this.axisCtx.fillText(entry.name, screenX + 6, screenY - 6);
            }
        }
        this.axisCtx.restore();
    }
drawPolygons2D(cssWidth, cssHeight) {
        const dpr = window.devicePixelRatio || 1;
        this.axisCtx.save();
        this.axisCtx.scale(dpr, dpr);
        
        const polygonEntries = this.entries.filter(e => {
    const isVisible = this.getEffectiveVisibility(e);
    return e.type === 'geometry' && 
    e.geometryType === 'polygon' && 
    (isVisible || this.showHiddenGeo) && 
    e.isMeaningful && 
    e.points && e.points.length > 2;
});

        for (const entry of polygonEntries) {
         let finalColor = entry.color; const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && this.showHiddenGeo) {

                finalColor = {...entry.color};
                finalColor.a = finalColor.a + (100 - finalColor.a) * 0.75;
            }

            const path = new Path2D();
            const p0 = entry.points[0];
            const screenX0 = this.offset.x + p0.x_val * this.scale;
            const screenY0 = this.offset.y - p0.y_val * this.scale;
            path.moveTo(screenX0, screenY0);

            for (let i = 1; i < entry.points.length; i++) {
                const p = entry.points[i];
                const screenX = this.offset.x + p.x_val * this.scale;
                const screenY = this.offset.y - p.y_val * this.scale;
                path.lineTo(screenX, screenY);
            }
            path.closePath();
            
            if (finalColor.a < 100) {
                const fillTransparency = 50 + 0.5 * finalColor.a;
                this.axisCtx.fillStyle = this.hsbToRgba(finalColor.h, finalColor.s, finalColor.b, fillTransparency);
                this.axisCtx.fill(path, 'evenodd');
            }

const isHighlighted = this.highlightedObject === entry;
if (isHighlighted) {
    const rootStyle = getComputedStyle(document.documentElement);
    this.axisCtx.strokeStyle = rootStyle.getPropertyValue('--text-color-accent').trim();
} else {
    this.axisCtx.strokeStyle = this.hsbToRgba(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
}

const currentThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
this.axisCtx.lineWidth = currentThickness * (isHighlighted ? 1.5 : 1);
this.axisCtx.stroke(path);
        }

        this.axisCtx.restore();
    }

draw() {
        if (this.is3DMode) {
            this.draw3D();
            return;
        }

        if (this.gl) this.gl.disable(this.gl.DEPTH_TEST);

        if (this.isTransformingCache) {
            const gl = this.gl;
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;

        const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
        let r = 1.0, g = 1.0, b_val = 1.0;
        const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
        if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
        } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
        gl.clearColor(r, g, b_val, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        ctx.save();
        const scaleFactor = this.scale / this.transformInitialState.scale;
        const tx = this.offset.x - this.transformInitialState.offset.x * scaleFactor;
        const ty = this.offset.y - this.transformInitialState.offset.y * scaleFactor;
        
        ctx.translate(tx * dpr, ty * dpr);
        ctx.scale(scaleFactor, scaleFactor);
        
        ctx.drawImage(this.offscreenCanvas, 0, 0);
        ctx.restore();
        return;
    }

    if ((this.isPanning || this.dragging || this.isSmoothPanningActive) && this.isUsingPanOptimization) {
        const gl = this.gl;
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;

        const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
        let r = 1.0, g = 1.0, b_val = 1.0;
        const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
        if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
        } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
        gl.clearColor(r, g, b_val, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        const dx = this.offset.x - this.panStartOffset.x;
        const dy = this.offset.y - this.panStartOffset.y;
        
        ctx.drawImage(this.offscreenCanvas, dx * dpr, dy * dpr);
        return;
    }

    const gl = this.gl; if (!gl) return;
    const container = this.canvasContainer;
    const cssWidth = container.clientWidth; const cssHeight = container.clientHeight;
    if (cssWidth <= 0 || cssHeight <= 0) return;
    const dpr = window.devicePixelRatio || 1;
    if (this.canvas.width !== cssWidth*dpr || this.canvas.height !== cssHeight*dpr) this.resizeCanvas();
    gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);

    const bgColorString = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg-color').trim();
    let r = 1.0, g = 1.0, b_val = 1.0;
    const rgbMatch = bgColorString.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
    if (rgbMatch) { r = parseInt(rgbMatch[1]) / 255; g = parseInt(rgbMatch[2]) / 255; b_val = parseInt(rgbMatch[3]) / 255;
    } else { let hex = bgColorString.startsWith('#') ? bgColorString.substring(1) : bgColorString; if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; if (hex.length === 6) { const parsedHex = parseInt(hex, 16); if (!isNaN(parsedHex)) { r = ((parsedHex>>16)&0xFF)/255; g = ((parsedHex>>8)&0xFF)/255; b_val = (parsedHex&0xFF)/255; }}}
    gl.clearColor(r, g, b_val, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (!this.shaderProgramLines) return;

    gl.useProgram(this.shaderProgramLines);
    gl.uniform2f(this.uniformLocations.canvasCssSize, cssWidth, cssHeight);
    gl.uniform2f(this.uniformLocations.viewOffset, this.offset.x, this.offset.y);
    gl.uniform1f(this.uniformLocations.viewScale, this.scale);
    
    this.drawGridGL(cssWidth, cssHeight);
    this.drawAxesGL(cssWidth, cssHeight);
    
    this.processImplicitBlocksOnGrid(cssWidth, cssHeight);

    this.entries.forEach(entry => {
        const isMath = entry.type === 'function';
        const isGeo = entry.type === 'geometry';
        
       
        const hiddenByCheckbox = this.isHiddenByCheckbox(entry);
        if (hiddenByCheckbox) return; // 如果被复选框关闭，彻底不画

        const isVisible = this.getEffectiveVisibility(entry);
        const shouldShow = isVisible || (isMath && this.showHiddenMath) || (isGeo && this.showHiddenGeo);

        const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || entry.displayFrame === 0 || entry.displayFrame === this.currentFrame;
if (entry.type === 'point_list' && shouldShow && isFrameVisible && !this.is3DMode) {
                this.plotPointListGL(entry, cssWidth, cssHeight);
            } else if (isMath && shouldShow && isFrameVisible && !entry.compilationError) {
                const is3DType = ['z', 'x3d', 'y3d', 'implicit3d', 'parametric3d'].includes(entry.plotType);
                if (is3DType && !this.overlayDrawingEnabled) return;

            
            let originalAlpha; const isVisible = this.getEffectiveVisibility(entry); if (!isVisible && this.showHiddenMath) { originalAlpha = entry.color.a;

                entry.color.a = 100 - (100 - originalAlpha) * 0.5;
            }
            
            if (entry.plotType === 'y' || entry.plotType === 'x') {
               if (entry.func) this.plotExplicitFunctionGL(entry, cssWidth, cssHeight);
           } else if (entry.plotType === 'parametric') {
               if (entry.funcX && entry.funcY) this.plotParametricFunctionGL(entry, cssWidth, cssHeight);
            }
            
        if (!isVisible && this.showHiddenMath) { 

                entry.color.a = originalAlpha;
            }
        }
    });

     this.implicitFillData.forEach((vertices, funcEntryOriginalIndex) => {
        const funcEntry = this.entries[funcEntryOriginalIndex];
if (this.isHiddenByCheckbox(funcEntry)) return;

 const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || funcEntry.displayFrame === 0 || funcEntry.displayFrame === this.currentFrame;
        const isVisible = this.getEffectiveVisibility(funcEntry); const shouldShow = (isVisible || (this.showHiddenMath && !isVisible)) && isFrameVisible;
        if (!funcEntry || !funcEntry.color || !shouldShow || vertices.length === 0) return;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
        
        let finalColor = funcEntry.color;
        if (!funcEntry.visible && this.showHiddenMath) {
            finalColor = {...funcEntry.color};
            finalColor.a = 100 - (100 - finalColor.a) * 0.5;
        }

        const fillAlpha = 100 - 0.5 * (100 - finalColor.a);
        const fillColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, fillAlpha);
        gl.uniform4fv(this.uniformLocations.color, fillColorArray);
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
    });

    const implicitVerticesByFunc = new Map();
    if (this.implictplotindex.length > 1) {
        for (let i = 0; i < this.implictplotindex.length - 1; i++) {
            const ip01 = this.implictplotindex[i]; const ip02 = this.implictplotindex[i + 1];
            if (ip01 === undefined || ip02 === undefined || ip01 >= ip02) continue;
            for (let j = ip01; j < ip02; j++) {
                const segment = this.implictplotdata[j]; if (!segment) continue;
                const [mX1, mY1, mX2, mY2, funcIdx] = segment;
                const entry = this.entries[funcIdx];
                if (!entry) continue;

                if (!implicitVerticesByFunc.has(funcIdx)) implicitVerticesByFunc.set(funcIdx, []);
                
                const currentThickness = this.highPerformancePlottingEnabled ? 1 : (entry.thickness || 3);
                const useQuadsForImplicit = currentThickness > 1.5;
                const lineThicknessMathImplicit = currentThickness / this.scale;

                if (useQuadsForImplicit) implicitVerticesByFunc.get(funcIdx).push(...this.generateQuadVertices(mX1, mY1, mX2, mY2, lineThicknessMathImplicit));
                else implicitVerticesByFunc.get(funcIdx).push(mX1, mY1, mX2, mY2);
            }
        }
    }

    implicitVerticesByFunc.forEach((vertices, funcEntryOriginalIndex) => {
        const funcEntry = this.entries[funcEntryOriginalIndex];
if (this.isHiddenByCheckbox(funcEntry)) return;

 const isFrameVisible = !this.showPlaybackControls || this.currentFrame === 0 || funcEntry.displayFrame === 0 || funcEntry.displayFrame === this.currentFrame;
        const isVisible = this.getEffectiveVisibility(funcEntry); const shouldShow = (isVisible || (this.showHiddenMath && !isVisible)) && isFrameVisible;
        if (!funcEntry || !funcEntry.color || !shouldShow || vertices.length === 0) return;

        gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);

        let finalColor = funcEntry.color;
        if (!funcEntry.visible && this.showHiddenMath) {
            finalColor = {...funcEntry.color};
            finalColor.a = 100 - (100 - finalColor.a) * 0.5;
        }

        let outlineAlpha;
        if (['>', '<'].includes(funcEntry.sign)) {
            outlineAlpha = 100 - 0.5 * (100 - finalColor.a);
        } else {
            outlineAlpha = finalColor.a;
        }
        const plotColorArray = this.hsbToRgbaArray(finalColor.h, finalColor.s, finalColor.b, finalColor.a);
        gl.uniform4fv(this.uniformLocations.color, plotColorArray);
        
        const currentThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
        const useQuadsForImplicit = currentThickness > 1.5;
        
        if (useQuadsForImplicit) gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
        else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, vertices.length / 2); }
    });

    this.plotAllGeometryGL(cssWidth, cssHeight);
    

    this.drawAxisNumbers(cssWidth, cssHeight);
    this.drawPolygons2D(cssWidth, cssHeight);
    this.drawOrigin2D(cssWidth, cssHeight);
    this.drawGeometryLabels(cssWidth, cssHeight);
    this.drawAnnotations();
    this.drawActiveTrajectory();
    this.drawVariableCards();
    this.drawPenStrokesGL();
} 


plotExplicitFunctionGL(funcEntry, cssWidth, cssHeight) {
        if (funcEntry.compilationError || !funcEntry.func || !funcEntry.color) return;
        const gl = this.gl;
        const entryThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
        const useQuads = entryThickness > 1.5;
        const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
        const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();
    
        if (!funcEntry.webglVertices) {
            const finalPointsForGL = [];
            const pixelStep = Math.max(0.005, 1 / this.explicitPrecisionStep);
            const bufferPixels = Math.max(50, Math.max(cssWidth, cssHeight) * 0.1);
            const { x: offsetX, y: offsetY } = this.offset;
            

            const isYType = funcEntry.plotType === 'y' || funcEntry.plotType === 'y3d';
            const isXType = funcEntry.plotType === 'x' || funcEntry.plotType === 'x3d';

            if (this.adaptivePlottingEnabled && (isYType || isXType)) {
                const collectedPoints = [];
                const slopeFactor = 0.1;
                const defaultPixelStep = pixelStep;
                const minPixelStep = defaultPixelStep / 16.0;
                const dependentAxis = isYType ? 'y' : 'x';
                
                let consecutiveInvalidCount = 0;
                let consecutiveOffscreenMonotonicCount = 0;
                let lastDerivativeSign = 0;
                const RESET_THRESHOLD = 30;
    
                if (isYType) {
                    let px = -bufferPixels;
                    while (px < cssWidth + bufferPixels) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try { 
                            if (funcEntry.plotType === 'y3d') {

                                y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                            }
                        } catch (e) { y_math = NaN; }
                        const isValid = Number.isFinite(y_math);
                        
                        if (isValid) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            consecutiveInvalidCount = 0;
                            
                            const screenY = offsetY - y_math * this.scale;
                            
                            const screenTop = -bufferPixels;
                            const screenBottom = cssHeight + bufferPixels;
                            const xAxisScreenY = this.offset.y;
                            let checkTop, checkBottom;
    
                            if (xAxisScreenY < screenTop) { 
                                checkTop = this.offset.y - 10 * this.scale;
                                checkBottom = screenBottom;
                            } else if (xAxisScreenY > screenBottom) { 
                                checkTop = screenTop;
                                checkBottom = this.offset.y + 10 * this.scale;
                            } else { 
                                checkTop = screenTop;
                                checkBottom = screenBottom;
                            }
                            const isOffscreen = screenY < checkTop || screenY > checkBottom;
    
                            const h = 0.0001 / this.scale;
                            let y_plus_h, y_minus_h;
                            if (funcEntry.plotType === 'y3d') {
                                y_plus_h = funcEntry.func(x_math + h, 0, this.variables, Math, advancedFuncsMap);
                                y_minus_h = funcEntry.func(x_math - h, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                y_plus_h = funcEntry.func(x_math + h, this.variables, Math, advancedFuncsMap);
                                y_minus_h = funcEntry.func(x_math - h, this.variables, Math, advancedFuncsMap);
                            }
    
                            if (Number.isFinite(y_plus_h) && Number.isFinite(y_minus_h)) {
                                const currentDerivativeSign = Math.sign(y_plus_h - y_minus_h);
                                if (isOffscreen && currentDerivativeSign !== 0 && currentDerivativeSign === lastDerivativeSign) {
                                    consecutiveOffscreenMonotonicCount++;
                                } else {
                                    consecutiveOffscreenMonotonicCount = 0;
                                }
                                lastDerivativeSign = currentDerivativeSign;
                            } else {
                                consecutiveOffscreenMonotonicCount = 0;
                                lastDerivativeSign = 0;
                            }
                        } else {
                            consecutiveInvalidCount++;
                            consecutiveOffscreenMonotonicCount = 0;
                            lastDerivativeSign = 0;
                        }
                        collectedPoints.push({ x: x_math, y: y_math, valid: isValid });
                        
                        let step = defaultPixelStep;
                        if (consecutiveInvalidCount < RESET_THRESHOLD && consecutiveOffscreenMonotonicCount < RESET_THRESHOLD) {
                            if (isValid) {
                                const h = 0.0001 / this.scale;
                                let y_plus_h, y_minus_h;
                                if (funcEntry.plotType === 'y3d') {
                                    y_plus_h = funcEntry.func(x_math + h, 0, this.variables, Math, advancedFuncsMap);
                                    y_minus_h = funcEntry.func(x_math - h, 0, this.variables, Math, advancedFuncsMap);
                                } else {
                                    y_plus_h = funcEntry.func(x_math + h, this.variables, Math, advancedFuncsMap);
                                    y_minus_h = funcEntry.func(x_math - h, this.variables, Math, advancedFuncsMap);
                                }

                                if (Number.isFinite(y_plus_h) && Number.isFinite(y_minus_h)) {
                                    const derivative = (y_plus_h - y_minus_h) / (2 * h);
                                    step = defaultPixelStep / (1 + slopeFactor * Math.abs(derivative));
                                    step = Math.max(step, minPixelStep);
                                }
                            }
                        }
                        px += step;
                    }
                } else { 
                    let py = -bufferPixels;
                    while (py < cssHeight + bufferPixels) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try { 
                            if (funcEntry.plotType === 'x3d') {
              
                                x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap); 
                            }
                        } catch (e) { x_math = NaN; }
                        const isValid = Number.isFinite(x_math);
    
                        if (isValid) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            consecutiveInvalidCount = 0;
    
                            const screenX = offsetX + x_math * this.scale;
                            
                            const screenLeft = -bufferPixels;
                            const screenRight = cssWidth + bufferPixels;
                            const yAxisScreenX = this.offset.x;
                            let checkLeft, checkRight;
    
                            if (yAxisScreenX < screenLeft) { 
                                checkLeft = this.offset.x + 10 * this.scale;
                                checkRight = screenRight;
                            } else if (yAxisScreenX > screenRight) { 
                                checkLeft = screenLeft;
                                checkRight = this.offset.x - 10 * this.scale;
                            } else { 
                                checkLeft = screenLeft;
                                checkRight = screenRight;
                            }
                            const isOffscreen = screenX < checkLeft || screenX > checkRight;
    
                            const h = 0.0001 / this.scale;
                            let x_plus_h, x_minus_h;
                            if (funcEntry.plotType === 'x3d') {
                                x_plus_h = funcEntry.func(y_math + h, 0, this.variables, Math, advancedFuncsMap);
                                x_minus_h = funcEntry.func(y_math - h, 0, this.variables, Math, advancedFuncsMap);
                            } else {
                                x_plus_h = funcEntry.func(y_math + h, this.variables, Math, advancedFuncsMap);
                                x_minus_h = funcEntry.func(y_math - h, this.variables, Math, advancedFuncsMap);
                            }
                            
                            if (Number.isFinite(x_plus_h) && Number.isFinite(x_minus_h)) {
                                const currentDerivativeSign = Math.sign(x_plus_h - x_minus_h);
                                if (isOffscreen && currentDerivativeSign !== 0 && currentDerivativeSign === lastDerivativeSign) {
                                    consecutiveOffscreenMonotonicCount++;
                                } else {
                                    consecutiveOffscreenMonotonicCount = 0;
                                }
                                lastDerivativeSign = currentDerivativeSign;
                            } else {
                                consecutiveOffscreenMonotonicCount = 0;
                                lastDerivativeSign = 0;
                            }
                        } else {
                            consecutiveInvalidCount++;
                            consecutiveOffscreenMonotonicCount = 0;
                            lastDerivativeSign = 0;
                        }
                        collectedPoints.push({ x: x_math, y: y_math, valid: isValid });
                        
                        let step = defaultPixelStep;
                        if (consecutiveInvalidCount < RESET_THRESHOLD && consecutiveOffscreenMonotonicCount < RESET_THRESHOLD) {
                            if (isValid) {
                                const h = 0.0001 / this.scale;
                                let x_plus_h, x_minus_h;
                                if (funcEntry.plotType === 'x3d') {
                                    x_plus_h = funcEntry.func(y_math + h, 0, this.variables, Math, advancedFuncsMap);
                                    x_minus_h = funcEntry.func(y_math - h, 0, this.variables, Math, advancedFuncsMap);
                                } else {
                                    x_plus_h = funcEntry.func(y_math + h, this.variables, Math, advancedFuncsMap);
                                    x_minus_h = funcEntry.func(y_math - h, this.variables, Math, advancedFuncsMap);
                                }
                                if (Number.isFinite(x_plus_h) && Number.isFinite(x_minus_h)) {
                                    const derivative = (x_plus_h - x_minus_h) / (2 * h);
                                    step = defaultPixelStep / (1 + slopeFactor * Math.abs(derivative));
                                    step = Math.max(step, minPixelStep);
                                }
                            }
                        }
                        py += step;
                    }
                }
    
                const segments = [];
                const breakTypes = [];
                let currentSegmentPoints = [];
                for (let i = 0; i < collectedPoints.length; i++) {
                    const p = collectedPoints[i];
                    const breakType = this._isAdaptiveBreakPoint(collectedPoints, i, dependentAxis);
                    
                    if (p.valid && !breakType) {
                        currentSegmentPoints.push(p);
                    }
    
                    if (!p.valid || breakType || i === collectedPoints.length - 1) {
                        if (currentSegmentPoints.length > 1) {
                            segments.push(currentSegmentPoints);
                            breakTypes.push(breakType || (!p.valid ? 'invalid' : null));
                        }
                        currentSegmentPoints = [];
                        if (p.valid && breakType) {
                            currentSegmentPoints.push(p);
                        }
                    }
                }
                
                segments.forEach((segment, segIndex) => {
                    const startsWithDiscontinuity = segIndex > 0;
                    const endsWithDiscontinuity = segIndex < segments.length - 1;
                    const reasonForStart = segIndex > 0 ? breakTypes[segIndex - 1] : null;
                    const reasonForEnd = breakTypes[segIndex];
                    
                    let canExtendStart = false;
                    if (this.adaptiveExtendEnabled && startsWithDiscontinuity && reasonForStart !== 'step') {
                        const prevSegment = segments[segIndex - 1];
                        if (prevSegment && prevSegment.length >= 2 && segment.length >= 2) {
                            const p_prev_last = prevSegment[prevSegment.length - 1];
                            const p_prev_penultimate = prevSegment[prevSegment.length - 2];
                            const p_curr_first = segment[0];
                            const p_curr_second = segment[1];
                            const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
                            const leftSlope = (p_prev_last[dependentAxis] - p_prev_penultimate[dependentAxis]) / (p_prev_last[independentAxis] - p_prev_penultimate[independentAxis]);
                            const rightSlope = (p_curr_second[dependentAxis] - p_curr_first[dependentAxis]) / (p_curr_second[independentAxis] - p_curr_first[independentAxis]);
                            const valueDiff = Math.abs(p_curr_first[dependentAxis] - p_prev_last[dependentAxis]);
                            if (Math.abs(leftSlope) > 20 && Math.abs(rightSlope) > 20 && valueDiff > 60) {
                                canExtendStart = true;
                            }
                        }
                    }
    
                    if (canExtendStart) {
                        const p_first = segment[0];
                        if (isYType) {
                            const slope_start = (segment[1].y - p_first.y) / (segment[1].x - p_first.x);
                            const start_extension_y = (slope_start > 0) ? (offsetY - cssHeight) / this.scale : offsetY / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_first.x, start_extension_y, p_first.x, p_first.y, lineThicknessMath));
                            else finalPointsForGL.push(p_first.x, start_extension_y, p_first.x, p_first.y);
                        } else {
                            const slope_start = (segment[1].x - p_first.x) / (segment[1].y - p_first.y);
                            const start_extension_x = (slope_start > 0) ? (-offsetX) / this.scale : (cssWidth - offsetX) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(start_extension_x, p_first.y, p_first.x, p_first.y, lineThicknessMath));
                            else finalPointsForGL.push(start_extension_x, p_first.y, p_first.x, p_first.y);
                        }
                    }
    
                    for (let i = 0; i < segment.length - 1; i++) {
                        const p1 = segment[i];
                        const p2 = segment[i+1];
                        if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(p1.x, p1.y, p2.x, p2.y, lineThicknessMath));
                        else finalPointsForGL.push(p1.x, p1.y, p2.x, p2.y);
                    }
    
                    let canExtendEnd = false;
                    if (this.adaptiveExtendEnabled && endsWithDiscontinuity && reasonForEnd !== 'step') {
                        const nextSegment = segments[segIndex + 1];
                        if (nextSegment && nextSegment.length >= 2 && segment.length >= 2) {
                            const p_curr_last = segment[segment.length - 1];
                            const p_curr_penultimate = segment[segment.length - 2];
                            const p_next_first = nextSegment[0];
                            const p_next_second = nextSegment[1];
                            const independentAxis = dependentAxis === 'y' ? 'x' : 'y';
                            const leftSlope = (p_curr_last[dependentAxis] - p_curr_penultimate[dependentAxis]) / (p_curr_last[independentAxis] - p_curr_penultimate[independentAxis]);
                            const rightSlope = (p_next_second[dependentAxis] - p_next_first[dependentAxis]) / (p_next_second[independentAxis] - p_next_first[independentAxis]);
                            const valueDiff = Math.abs(p_next_first[dependentAxis] - p_curr_last[dependentAxis]);
                            if (Math.abs(leftSlope) > 20 && Math.abs(rightSlope) > 20 && valueDiff > 60) {
                                canExtendEnd = true;
                            }
                        }
                    }
    
                    if (canExtendEnd) {
                        const p_last = segment[segment.length - 1];
                         if (isYType) {
                            const slope_end = (p_last.y - segment[segment.length - 2].y) / (p_last.x - segment[segment.length - 2].x);
                            const end_extension_y = (slope_end > 0) ? offsetY / this.scale : (offsetY - cssHeight) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_last.x, p_last.y, p_last.x, end_extension_y, lineThicknessMath));
                            else finalPointsForGL.push(p_last.x, p_last.y, p_last.x, end_extension_y);
                        } else {
                            const slope_end = (p_last.x - segment[segment.length - 2].x) / (p_last.y - segment[segment.length - 2].y);
                            const end_extension_x = (slope_end > 0) ? (cssWidth - offsetX) / this.scale : (-offsetX) / this.scale;
                            if(useQuads) finalPointsForGL.push(...this.generateQuadVertices(p_last.x, p_last.y, end_extension_x, p_last.y, lineThicknessMath));
                            else finalPointsForGL.push(p_last.x, p_last.y, end_extension_x, p_last.y);
                        }
                    }
                });
    
            } else if (this.autoBreakpointDetectionEnabled && (isYType || isXType)) {
                const collectedPoints = []; 
                if (isYType) {
                    for (let px = -bufferPixels; px < cssWidth + bufferPixels; px += pixelStep) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try {
                            if (funcEntry.plotType === 'y3d') y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            else y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                        } catch (e) { y_math = NaN; }
                        if (Number.isFinite(y_math)) this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                        collectedPoints.push({ x: x_math, y: y_math, val: y_math, valid: Number.isFinite(y_math) });
                    }
                } else { 
                    for (let py = -bufferPixels; py < cssHeight + bufferPixels; py += pixelStep) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try {
                            if (funcEntry.plotType === 'x3d') x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            else x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) { x_math = NaN; }
                        if (Number.isFinite(x_math)) this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                        collectedPoints.push({ x: x_math, y: y_math, val: x_math, valid: Number.isFinite(x_math) });
                    }
                }
    
                for (let i = 0; i < collectedPoints.length - 1; i++) {
                    const pCurr = collectedPoints[i];
                    const pNext = collectedPoints[i+1];
    
                    if (pCurr.valid && pNext.valid) {
                        let connect = true;
                        if (i >= 2 && (i + 1) < collectedPoints.length) { 
                            const pPrev = collectedPoints[i-1];
                            const pPrev2 = collectedPoints[i-2];
                            connect = !this._isBreakPoint(pNext.val, pCurr.val, pPrev.val, pPrev2.val);
                        }
                        
                        if (connect) {
                            if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(pCurr.x, pCurr.y, pNext.x, pNext.y, lineThicknessMath));
                            else finalPointsForGL.push(pCurr.x, pCurr.y, pNext.x, pNext.y);
                        }
                    }
                }
            } else { 
                if (isYType) {
                    let lastValidPoint = null;
                    for (let px = -bufferPixels; px < cssWidth + bufferPixels; px += pixelStep) {
                        const x_math = (px - offsetX) / this.scale;
                        let y_math = NaN;
                        try {
                            if (funcEntry.plotType === 'y3d') y_math = funcEntry.func(x_math, 0, this.variables, Math, advancedFuncsMap);
                            else y_math = funcEntry.func(x_math, this.variables, Math, advancedFuncsMap); 
                        } catch (e) { y_math = NaN; }
                        if (Number.isFinite(y_math)) {
                            this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                            const currentPoint = { x: x_math, y: y_math };
                            if (lastValidPoint) {
                                if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y, lineThicknessMath));
                                else finalPointsForGL.push(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y);
                            }
                            lastValidPoint = currentPoint;
                        } else lastValidPoint = null;
                    }
                } else { 
                    let lastValidPoint = null;
                    for (let py = -bufferPixels; py < cssHeight + bufferPixels; py += pixelStep) {
                        const y_math = (offsetY - py) / this.scale;
                        let x_math = NaN;
                        try {
                            if (funcEntry.plotType === 'x3d') x_math = funcEntry.func(y_math, 0, this.variables, Math, advancedFuncsMap);
                            else x_math = funcEntry.func(y_math, this.variables, Math, advancedFuncsMap);
                        } catch (e) { x_math = NaN; }
                        if (Number.isFinite(x_math)) {
                             this.plottedFunctionPoints.push({ x: x_math, y: y_math });
                             const currentPoint = { x: x_math, y: y_math };
                             if (lastValidPoint) {
                                if (useQuads) finalPointsForGL.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y, lineThicknessMath));
                                else finalPointsForGL.push(lastValidPoint.x, lastValidPoint.y, currentPoint.x, currentPoint.y);
                             }
                             lastValidPoint = currentPoint;
                        } else lastValidPoint = null;
                    }
                }
            }
            funcEntry.webglVertices = new Float32Array(finalPointsForGL);
        }
    
        if (funcEntry.webglVertices && funcEntry.webglVertices.length > 0) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, funcEntry.webglVertices, gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
            const plotColorArray = this.hsbToRgbaArray(funcEntry.color.h, funcEntry.color.s, funcEntry.color.b, funcEntry.color.a);
            gl.uniform4fv(this.uniformLocations.color, plotColorArray);
            if (useQuads) gl.drawArrays(gl.TRIANGLES, 0, funcEntry.webglVertices.length / 2);
            else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, funcEntry.webglVertices.length / 2); }
        }
    }

recalculateParametricCache(funcEntry) {
    if (!funcEntry.funcX || !funcEntry.funcY) return;
    const advancedFuncsMap = this.calcJSUtils.getAdvancedFuncsMap();
    funcEntry.cachedPoints = [];
    const numSteps = Math.max(2, Math.floor(this.explicitPrecisionStep * 100));
    const tStep = (this.tmax - this.tmin) / numSteps;
    const is3D = funcEntry.plotType === 'parametric3d';

    for (let i = 0; i <= numSteps; i++) {
       const t = this.tmin + i * tStep;
       let x_math = NaN, y_math = NaN;
       try {
           x_math = funcEntry.funcX(t, this.variables, Math, advancedFuncsMap);
           y_math = funcEntry.funcY(t, this.variables, Math, advancedFuncsMap);

           if (is3D && funcEntry.funcZ) {
               funcEntry.funcZ(t, this.variables, Math, advancedFuncsMap); 
           }
       } catch (e) {  }
       if (Number.isFinite(x_math) && Number.isFinite(y_math)) {
           const point = { x: x_math, y: y_math };
           funcEntry.cachedPoints.push(point);
           this.plottedFunctionPoints.push(point);
       }
       else if (funcEntry.cachedPoints.length > 0 && funcEntry.cachedPoints[funcEntry.cachedPoints.length-1] !== null) {
            funcEntry.cachedPoints.push(null);
       }
    }
    funcEntry.webglVertices = null;
}

plotParametricFunctionGL(funcEntry, cssWidth, cssHeight) {
    if (funcEntry.compilationError || !funcEntry.funcX || !funcEntry.funcY || !funcEntry.color) return;
    

    const gl = this.gl;
    const entryThickness = this.highPerformancePlottingEnabled ? 1 : (funcEntry.thickness || 3);
    const useQuads = entryThickness > 1.5;
    const lineThicknessMath = useQuads ? (entryThickness / this.scale) : (1.5 / this.scale);
    if (!funcEntry.webglVertices) {
       if (!funcEntry.cachedPoints || funcEntry.cachedPoints.length === 0) {
           this.recalculateParametricCache(funcEntry);
           if (!funcEntry.cachedPoints || funcEntry.cachedPoints.length === 0) return;
       }
       const points = [];
       let lastValidPoint = null;
       funcEntry.cachedPoints.forEach(p_math => {
           if (p_math === null) { lastValidPoint = null; return; }
           if (lastValidPoint) {
               if (useQuads) points.push(...this.generateQuadVertices(lastValidPoint.x, lastValidPoint.y, p_math.x, p_math.y, lineThicknessMath));
               else points.push(lastValidPoint.x, lastValidPoint.y, p_math.x, p_math.y);
           }
           lastValidPoint = p_math;
       });
       funcEntry.webglVertices = new Float32Array(points);
    }
    if (funcEntry.webglVertices && funcEntry.webglVertices.length > 0) {
       gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
       gl.bufferData(gl.ARRAY_BUFFER, funcEntry.webglVertices, gl.DYNAMIC_DRAW);
       gl.vertexAttribPointer(this.attributeLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
       gl.enableVertexAttribArray(this.attributeLocations.vertexPosition);
const isVisible = this.getEffectiveVisibility(funcEntry); let tempColor = { ...funcEntry.color }; if (!isVisible && this.showHiddenMath) { tempColor.a = 100 - (100 - tempColor.a) * 0.5; }

       const plotColorArray = this.hsbToRgbaArray(funcEntry.color.h, funcEntry.color.s, funcEntry.color.b, funcEntry.color.a);
       gl.uniform4fv(this.uniformLocations.color, plotColorArray);
       if (useQuads) gl.drawArrays(gl.TRIANGLES, 0, funcEntry.webglVertices.length / 2);
       else { gl.lineWidth(1.5); gl.drawArrays(gl.LINES, 0, funcEntry.webglVertices.length / 2); }
    }
}

processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, unitStep) {
        this.implicttempdata.length = 0;
        const cellSizeInPixels = unitStep * this.scale;
        this.implictjump = Math.ceil(cellSizeInPixels / this.implicitPrecisionStep);
        if (this.implictjump <= 0) this.implictjump = 1;
        const numPoints1D = this.implictjump + 1;
        const subCellStepMath = unitStep / this.implictjump;
        const cellMinXMath = cellCenterXMath - unitStep / 2;
        const cellMaxYMath = cellCenterYMath + unitStep / 2;
        

const implicitFunctions = this.entries.filter(e => 
            e.type === 'function' && 
            (e.plotType === 'implicit' || e.plotType === 'implicit3d' || e.plotType === 'z' || e.plotType === 'x3d' || e.plotType === 'y3d') && 
            e.func && !e.compilationError && (e.visible || this.showHiddenMath) &&
            (this.overlayDrawingEnabled || !['implicit3d', 'z', 'x3d', 'y3d'].includes(e.plotType))
        );

        if (implicitFunctions.length === 0) return;
       const baseMap = this.calcJSUtils.getAdvancedFuncsMap();
        const advancedFuncsMap = { ...baseMap };
        const originalPow = advancedFuncsMap.pow;
        advancedFuncsMap.pow = (a, b) => {
            if (a < 0 && Math.abs(b - Math.round(b)) > 1e-10) return NaN;
            return originalPow(a, b);
        };

        for (let iy_subgrid = 0; iy_subgrid < numPoints1D; iy_subgrid++) {
            const y_math_subgrid = cellMaxYMath - iy_subgrid * subCellStepMath;
            for (let ix_subgrid = 0; ix_subgrid < numPoints1D; ix_subgrid++) {
                const x_math_subgrid = cellMinXMath + ix_subgrid * subCellStepMath;
                for (const funcEntry of implicitFunctions) {
                    try {
                        let value = NaN;
                        if (funcEntry.plotType === 'implicit3d' || funcEntry.plotType === 'z') {
        
                            const z_val = 0;
                            if (funcEntry.plotType === 'z') {

                                value = funcEntry.func(x_math_subgrid, y_math_subgrid, z_val, this.variables, Math, advancedFuncsMap);
                            } else {
                                value = funcEntry.func(x_math_subgrid, y_math_subgrid, z_val, this.variables, Math, advancedFuncsMap);
                            }
                        } else if (funcEntry.plotType === 'x3d') {

                            const val = funcEntry.func(0, y_math_subgrid, 0, this.variables, Math, advancedFuncsMap);
                            value = x_math_subgrid - val;
                        } else if (funcEntry.plotType === 'y3d') {

                            const val = funcEntry.func(x_math_subgrid, 0, 0, this.variables, Math, advancedFuncsMap);
                            value = y_math_subgrid - val;
                        } else {

                            value = funcEntry.func(x_math_subgrid, y_math_subgrid, this.variables, Math, advancedFuncsMap);
                        }
                        this.implicttempdata.push(Number.isFinite(value) ? value : NaN);
                    } catch (e) { this.implicttempdata.push(NaN); }
                }
            }
        }
        
        const epsilon = 1e-9;
        for (let iy_cell = 0; iy_cell < this.implictjump; iy_cell++) {
            for (let ix_cell = 0; ix_cell < this.implictjump; ix_cell++) {
                const sub_x0 = cellMinXMath + ix_cell * subCellStepMath;

                const sub_y_top = cellMaxYMath - iy_cell * subCellStepMath;
                const sub_x1 = sub_x0 + subCellStepMath;
                const sub_y_bottom = sub_y_top - subCellStepMath;
                
                for (let funcIdx = 0; funcIdx < implicitFunctions.length; funcIdx++) {
                    const funcEntry = implicitFunctions[funcIdx];
                    const originalFuncEntryIndex = this.entries.indexOf(funcEntry);
                    const idx_v00 = (iy_cell * numPoints1D + ix_cell) * implicitFunctions.length + funcIdx;
                    const idx_v10 = (iy_cell * numPoints1D + (ix_cell + 1)) * implicitFunctions.length + funcIdx;
                    const idx_v01 = ((iy_cell + 1) * numPoints1D + ix_cell) * implicitFunctions.length + funcIdx;
                    const idx_v11 = ((iy_cell + 1) * numPoints1D + (ix_cell + 1)) * implicitFunctions.length + funcIdx;
                    
                    const v00 = this.implicttempdata[idx_v00]; 
                    const v10 = this.implicttempdata[idx_v10]; 
                    const v01 = this.implicttempdata[idx_v01]; 
                    const v11 = this.implicttempdata[idx_v11]; 

                    if (!Number.isFinite(v00) || !Number.isFinite(v10) || !Number.isFinite(v01) || !Number.isFinite(v11)) continue;

                    const lerp = (c1, c2, v1, v2) => { if (Math.abs(v1-v2)<epsilon) return NaN; return c1+(c2-c1)*(0-v1)/(v2-v1); };
                    const pA = { x: lerp(sub_x0, sub_x1, v00, v10), y: sub_y_top };
                    const pB = { x: sub_x1, y: lerp(sub_y_top, sub_y_bottom, v10, v11) };
                    const pC = { x: lerp(sub_x0, sub_x1, v01, v11), y: sub_y_bottom };
                    const pD = { x: sub_x0, y: lerp(sub_y_top, sub_y_bottom, v00, v01) };
                    const c00={x:sub_x0,y:sub_y_top}, c10={x:sub_x1,y:sub_y_top}, c11={x:sub_x1,y:sub_y_bottom}, c01={x:sub_x0,y:sub_y_bottom};

                    let outlineIndex=0; if(v00<0)outlineIndex|=1; if(v10<0)outlineIndex|=2; if(v11<0)outlineIndex|=4; if(v01<0)outlineIndex|=8;
                    

                    const effectiveSign = (funcEntry.plotType === 'z' || funcEntry.plotType === 'x3d' || funcEntry.plotType === 'y3d' || funcEntry.plotType === 'implicit3d') ? '=' : funcEntry.sign;

                    if (['=', '>=', '<='].includes(effectiveSign) && outlineIndex !== 0 && outlineIndex !== 15) {
                        let skipOutline = false;
                        if (this.autoBreakpointDetectionEnabled) {
                            const getValueFromTempData=(ix,iy)=>{if(ix>=0&&ix<numPoints1D&&iy>=0&&iy<numPoints1D){const v_idx=(iy*numPoints1D+ix)*implicitFunctions.length+funcIdx;return this.implicttempdata[v_idx];}return NaN;};
                            const sum_c=Math.abs(v01)+Math.abs(v11)+Math.abs(v00)+Math.abs(v10);
                            const v_outer=[getValueFromTempData(ix_cell,iy_cell+2),getValueFromTempData(ix_cell+1,iy_cell+2),getValueFromTempData(ix_cell,iy_cell-1),getValueFromTempData(ix_cell+1,iy_cell-1)];
                            if(v_outer.every(Number.isFinite)&&(v_outer.reduce((s,v)=>s+Math.abs(v),0)>sum_c*4||sum_c>this.implicitPrecisionStep*unitStep*1.4)) {
                                skipOutline = true;
                            }
                        }
                        if (!skipOutline) {
                            const addSegment = (p1, p2) => {
                                if (Number.isFinite(p1.x) && Number.isFinite(p1.y) && Number.isFinite(p2.x) && Number.isFinite(p2.y)) {
                                    this.implictplotdata.push([p1.x, p1.y, p2.x, p2.y, originalFuncEntryIndex]);

                                    this.plottedFunctionPoints.push(p1);
                                    this.plottedFunctionPoints.push(p2);
                                }
                            };
                            switch(outlineIndex){case 1:case 14:addSegment(pD,pA);break;case 2:case 13:addSegment(pA,pB);break;case 3:case 12:addSegment(pD,pB);break;case 4:case 11:addSegment(pB,pC);break;case 5:addSegment(pD,pA);addSegment(pB,pC);break;case 6:case 9:addSegment(pA,pC);break;case 7:case 8:addSegment(pD,pC);break;case 10:addSegment(pA,pB);addSegment(pD,pC);break;}
                        }
                    }
                    
                 if (['>', '>=', '<', '<='].includes(effectiveSign)) {
                        const fillPositive = ['>', '>='].includes(effectiveSign);
                        const strictEpsilon = 1e-9;
                        const test = (v) => {
                            if (fillPositive) {
                                return effectiveSign === '>' ? (v > strictEpsilon) : (v >= 0);
                            } else {
                                return effectiveSign === '<' ? (v < -strictEpsilon) : (v <= 0);
                            }
                        };
                        
                        let fillCase = 0;
                        if (test(v00)) fillCase |= 1;
                        if (test(v10)) fillCase |= 2;
                        if (test(v11)) fillCase |= 4;
                        if (test(v01)) fillCase |= 8;

                        if (fillCase === 0 || fillCase === 5 || fillCase === 10) {
                            continue;
                        }

                        if (!this.implicitFillData.has(originalFuncEntryIndex)) {
                            this.implicitFillData.set(originalFuncEntryIndex, []);
                        }
                        const fillData = this.implicitFillData.get(originalFuncEntryIndex);
                        
                        const addTri = (p1, p2, p3) => {
                            if ([p1, p2, p3].every(p => p && Number.isFinite(p.x) && Number.isFinite(p.y))) {
                                fillData.push(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                            }
                        };
                        const addQuad = (p1, p2, p3, p4) => {
                            addTri(p1, p2, p3);
                            addTri(p1, p3, p4);
                        };

                        switch (fillCase) {
                            case 1: addTri(c00, pA, pD); break;
                            case 2: addTri(pA, c10, pB); break;
                            case 3: addQuad(c00, c10, pB, pD); break;
                            case 4: addTri(pB, c11, pC); break;
                            case 6: addQuad(c10, c11, pC, pA); break;
                            case 7: addTri(c00, c10, pD); addTri(c10, c11, pD); addTri(c11, pC, pD); break;
                            case 8: addTri(pD, c01, pC); break;
                            case 9: addQuad(c01, c00, pA, pC); break;
                            case 11: addTri(c00, c10, pB); addTri(c00, pB, pC); addTri(c00, pC, c01); break;
                            case 12: addQuad(c01, c11, pB, pD); break;
                            case 13: addTri(c01, c11, pB); addTri(c01, pB, pA); addTri(c01, pA, c00); break;
                            case 14: addTri(c10, c11, c01); addTri(c10, c01, pD); addTri(c10, pD, pA); break;
                            case 15: addQuad(c00, c10, c11, c01); break;
                        }
                    }
                }
            }
        }
    }

updatePrecisionLabels() {
this.explicitPrecisionValueSpan.textContent = `值: ${parseFloat(this.explicitPrecisionSlider.options.value).toFixed(2)}`;
this.implicitPrecisionValueSpan.textContent = `值: ${parseFloat(this.implicitPrecisionSlider.options.value).toFixed(1)}`;
}

updateParametricRangeLabels() {
this.tminValueSpan.textContent = this.tmin.toFixed(4);
this.tmaxValueSpan.textContent = this.tmax.toFixed(4);
}

updatePreferredColorValueLabel() {
this.preferredColorValueSpan.textContent = `值: ${this.preferredColorValue}`;
}

updateIntegralPrecisionLabel() {
if (this.integralPrecisionValueSpan) {
this.integralPrecisionValueSpan.textContent = `值: ${this.integralNumSteps}`;
}
}

enterAnnotationMode(returnMode = null) {
        this.stopTracing();
        const fileNameDisplay = document.getElementById('file-name-display');
        if (fileNameDisplay) fileNameDisplay.style.display = 'none';
        
        const mainContentTitle = document.getElementById('main-content-title');
        if (mainContentTitle) mainContentTitle.style.display = 'none';

        this.previousUIMode = returnMode || this.currentUIMode;
        
        this.currentUIMode = 'annotation';
        this.cancelGeometryInteraction();
        this.annotationMenu.style.display = 'flex';
        
        const showSidebarBtn = document.getElementById('show-sidebar-btn');
        if (showSidebarBtn) showSidebarBtn.style.display = 'none';

        if (!document.body.classList.contains('sidebar-hidden')) {
            document.body.classList.add('sidebar-hidden');
            this.updateLayout();
        }
        
        this.setAnnotationMode('pen');
        this.selectedAnnotationIndex = -1;
        this._rebindAnnotationControlsToGlobalState();
        this.updateAnnotationEditMenu();
        
        this.updateTopBarLayout();
        this.requestDraw();
    }

exitAnnotationMode() {
        const targetMode = this.previousUIMode || 'plot';
        
        this.annotationMenu.style.display = 'none';
        document.body.classList.remove('sidebar-hidden');
        
        const showSidebarBtn = document.getElementById('show-sidebar-btn');
        if (showSidebarBtn) showSidebarBtn.style.display = '';

        this.setUIMode(targetMode);
        
        const geoBtn = this.geometryPanel.querySelector('.geo-btn[data-geo-type="annotation"]');
        if (geoBtn) geoBtn.classList.remove('active');

        this.selectedAnnotationIndex = -1;
        this.updateAnnotationEditMenu();
        
        this.updateLayout();
        this.updateTopBarLayout();
        this.updateOverlayPositions();
    }

setAnnotationMode(mode) {
    this.annotationState.mode = mode;
    const buttons = this.annotationMenu.querySelectorAll('.annotation-mode-switch-btn');
    buttons.forEach(btn => {
        btn.classList.toggle('active', btn.id === `annotation-${mode}-btn`);
    });


    if (mode === 'eraser') {
        this.selectedAnnotationIndex = -1;
    }

    this.updateAnnotationEditMenu();
    this.requestDraw();
}


handleAnnotationInteractionStart(e) {
        if (e.cancelable) e.preventDefault();
        const coords = this.getEventCoordinates(e);
        const mathCoords = {
            x: (coords.x - this.offset.x) / this.scale,
            y: (this.offset.y - coords.y) / this.scale
        };

        if (this.annotationState.mode === 'eraser') {
            this.annotationState.isDrawing = true;
            this.performEraserAction(coords);
        } else if (this.annotationState.mode === 'pen') {
            this.annotationState.isDrawing = true;
            this.annotationState.currentDrawingPath = [mathCoords];
        } else if (this.annotationState.mode === 'text') {
            const textContent = prompt("请输入文本内容:");
            if (textContent) {
                const textAnnotation = {
                    type: 'text',
                    content: textContent,
                    x: mathCoords.x,
                    y: mathCoords.y,
                    width: 8,
                    height: 3,
                    fontSize: this.annotationState.pen.fontSize,
                    color: { ...this.annotationState.pen.color }
                };
                this.annotations.push(textAnnotation);
                this.requestDraw();
            }
        } else if (this.annotationState.mode === 'image') {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';

            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.readAsDataURL(file);

                reader.onload = (loadEvent) => {
                    const base64Data = loadEvent.target.result;
                    const img = new Image();
                    img.onload = () => {
                        const defaultPixelWidth = this.canvas.width / window.devicePixelRatio * 0.25;
                        const aspectRatio = img.height / img.width;
                        const mathWidth = defaultPixelWidth / this.scale;
                        const mathHeight = mathWidth * aspectRatio;

                        const imageAnnotation = {
                            type: 'image',
                            src: base64Data,
                            img: img,
                            x: mathCoords.x,
                            y: mathCoords.y,
                            width: mathWidth,
                            height: mathHeight,
                            scaleX: 1,
                            scaleY: 1,
                            color: { h: 0, s: 0, b: 100, a: 0 }
                        };
                        this.annotations.push(imageAnnotation);
                        this.requestDraw();
                    };
                    img.src = base64Data;
                };
            };
            fileInput.click();
        } else if (this.annotationState.mode === 'pdf') {
            this._ensurePdfJsLoaded().then(() => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/pdf';
                fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async (loadEvent) => {
                    const dataUrl = loadEvent.target.result;
                    const base64Content = dataUrl.split(',')[1]; 
                    
                    const binaryString = window.atob(base64Content);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    try {
                        const pdf = await window.pdfjsLib.getDocument(bytes).promise;
                        const pdfAnnotation = {
                            type: 'pdf',
                            pdfDoc: pdf,
                            pdfData: bytes,        
                            pdfDataBase64: base64Content, 
                            page: 1,
                            totalPages: pdf.numPages,
                            x: mathCoords.x,
                            y: mathCoords.y,
                            width: 10,
                            height: 14,
                            scaleX: 1,
                            scaleY: 1,
                            color: { h: 0, s: 0, b: 100, a: 0 },
                            img: null
                        };
                        await this.renderPdfPage(pdfAnnotation);

                        if (pdfAnnotation.img) {
                            const aspectRatio = pdfAnnotation.img.height / pdfAnnotation.img.width;
                            const defaultWidth = 10;
                            pdfAnnotation.width = defaultWidth;
                            pdfAnnotation.height = defaultWidth * aspectRatio;
                        }

                        this.annotations.push(pdfAnnotation);
                        this.requestDraw();
                    } catch (error) {
                        console.error(error);
                        alert('PDF加载失败: ' + error.message);
                    }
                };
                reader.readAsDataURL(file);
            };
                fileInput.click();
            });
        } else if (this.annotationState.mode === 'audio') {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'audio/*';
            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (loadEvent) => {
                    const base64Data = loadEvent.target.result;
                    const audio = new Audio(base64Data);
                    const audioAnnotation = {
                        type: 'audio',
                        src: base64Data,
                        audioElem: audio,
                        x: mathCoords.x,
                        y: mathCoords.y,
                        width: 2,
                        height: 2,
                        scaleX: 1,
                        scaleY: 1,
                        color: { h: 200, s: 80, b: 90, a: 0 }, 
                        isPlaying: false
                    };

                    audio.addEventListener('ended', () => {
                        audioAnnotation.isPlaying = false;
                        this.requestDraw();
                    });
                    audio.addEventListener('timeupdate', () => {
                        if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === audioAnnotation) {
                            this.requestDraw();
                        }
                    });

                    this.annotations.push(audioAnnotation);
                    this.requestDraw();
                };
                reader.readAsDataURL(file);
            };
            fileInput.click();
        }
    } 


handleAnnotationInteractionMove(e) {
        if (e.cancelable) e.preventDefault();
        const coords = this.getEventCoordinates(e);
        
        if (this.annotationState.mode === 'eraser') {
            this.annotationState.currentPos = coords;
            if (this.annotationState.isDrawing) {
                this.performEraserAction(coords);
            }
            this.requestDraw();
        } else if (this.annotationState.isDrawing && this.annotationState.mode === 'pen') {
            const mathCoords = {
                x: (coords.x - this.offset.x) / this.scale,
                y: (this.offset.y - coords.y) / this.scale
            };
            this.annotationState.currentDrawingPath.push(mathCoords);
            this.requestDraw();
        }
    }

handleAnnotationInteractionEnd(e) {
        if (!this.annotationState.isDrawing) return;
        this.annotationState.isDrawing = false;
        
        if (this.annotationState.mode === 'eraser') {
            this.requestDraw();
            return;
        }

        if (this.annotationState.currentDrawingPath.length > 1) {
            const path = this.annotationState.currentDrawingPath;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);

            const penAnnotation = {
                type: 'pen',
                path: path.map(p => ({ x: p.x - minX, y: p.y - minY })),
                color: {...this.annotationState.pen.color},
                thickness: this.annotationState.pen.thickness,
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                scaleX: 1,
                scaleY: 1
            };
            this.annotations.push(penAnnotation);
        }
        this.annotationState.currentDrawingPath = [];
        this.requestDraw();
    }

    performEraserAction(screenCoords) {
        const eraserRadius = (this.annotationState.pen.thickness * this.scale) / 2;
        
        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const anno = this.annotations[i];
            if (anno.type !== 'pen' && anno.type !== 'text') continue;

            const screenX = this.offset.x + anno.x * this.scale;
            const screenY = this.offset.y - anno.y * this.scale;
            const screenW = anno.width * (anno.scaleX || 1) * this.scale;
            const screenH = anno.height * (anno.scaleY || 1) * this.scale;
            
            let hit = false;
            if (anno.type === 'text') {
                const closestX = Math.max(screenX, Math.min(screenCoords.x, screenX + screenW));
                const closestY = Math.max(screenY, Math.min(screenCoords.y, screenY + screenH));
                const distance = Math.hypot(screenCoords.x - closestX, screenCoords.y - closestY);
                if (distance < eraserRadius) hit = true;
            } else if (anno.type === 'pen') {
                for (let j = 0; j < anno.path.length - 1; j++) {
                    const p1 = {
                        x: screenX + anno.path[j].x * (anno.scaleX || 1) * this.scale,
                        y: screenY - anno.path[j].y * (anno.scaleY || 1) * this.scale
                    };
                    const p2 = {
                        x: screenX + anno.path[j+1].x * (anno.scaleX || 1) * this.scale,
                        y: screenY - anno.path[j+1].y * (anno.scaleY || 1) * this.scale
                    };
                    
                    const l2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2;
                    if (l2 === 0) continue;
                    let t = ((screenCoords.x - p1.x) * (p2.x - p1.x) + (screenCoords.y - p1.y) * (p2.y - p1.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    const dist = Math.hypot(screenCoords.x - (p1.x + t * (p2.x - p1.x)), screenCoords.y - (p1.y + t * (p2.y - p1.y)));
                    
                    if (dist < eraserRadius + (anno.thickness * this.scale / 2)) {
                        hit = true;
                        break;
                    }
                }
            }

            if (hit) {
                this.annotations.splice(i, 1);
            }
        }
    }


drawVariableCards() {
    if (this.is3DMode) return;

    const ctx = this.axisCtx;
    const dpr = window.devicePixelRatio || 1;
    ctx.save();
    ctx.scale(dpr, dpr);

    const roundRect = (x, y, w, h, r) => {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    };

    const isDark = this.isDarkModeActive;
    const bgColor = isDark ? "rgba(45, 45, 45, 0.8)" : "rgba(245, 245, 245, 0.8)";
    const textColor = isDark ? "#fff" : "#000";
    const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color-accent').trim();

    this.entries.forEach((entry, index) => {
        if (entry.type === 'variable' && entry.isEditableIndependent && entry.showOnPlot) {
            const x = this.offset.x + entry.cardX * this.scale;
            const y = this.offset.y - entry.cardY * this.scale;
            const w = entry.cardW;
            const h = entry.cardH;

            ctx.fillStyle = bgColor;
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = 10;
            roundRect(x, y, w, h, 15);
            ctx.fill();
            ctx.shadowBlur = 0;

           

            ctx.font = "bold 16px 'HarmonyOS_SC', Arial";
            ctx.fillStyle = textColor;
            ctx.textBaseline = "top";
            ctx.textAlign = "left";
            
            const displayValue = Number.isFinite(entry.value) ? entry.value.toFixed(4) : "NaN";
            ctx.fillText(`${entry.name} = ${displayValue}`, x + 15, y + 15);

            const btnRadius = 16;
            const btnX = x + w - 15 - btnRadius;
            const btnY = y + 15 + 8;
            
            ctx.fillStyle = isDark ? "rgba(80,80,80,0.5)" : "rgba(220,220,220,0.5)";
            ctx.beginPath();
            ctx.arc(btnX, btnY, btnRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = isDark ? "#fff" : "#333";
            if (entry.playState === 1) {
                const bw = 4, bh = 12;
                ctx.fillRect(btnX - 5, btnY - 6, bw, bh);
                ctx.fillRect(btnX + 1, btnY - 6, bw, bh);
            } else {
                ctx.beginPath();
                ctx.moveTo(btnX - 4, btnY - 7);
                ctx.lineTo(btnX + 6, btnY);
                ctx.lineTo(btnX - 4, btnY + 7);
                ctx.fill();
            }

            const sliderMargin = 15;
            const sliderY = y + 60;
            const sliderH = 6;
            const sliderW = w - sliderMargin * 2;
            const trackRadius = sliderH / 2;

            ctx.fillStyle = isDark ? "#555" : "#ccc";
            roundRect(x + sliderMargin, sliderY, sliderW, sliderH, trackRadius);
            ctx.fill();

            let norm = 0;
            if (Number.isFinite(entry.min) && Number.isFinite(entry.max) && entry.max > entry.min) {
                norm = Math.max(0, Math.min(1, (entry.value - entry.min) / (entry.max - entry.min)));
            }

            const fillW = sliderW * norm;
            if (fillW > 0) {
                ctx.fillStyle = accentColor;
                roundRect(x + sliderMargin, sliderY, fillW, sliderH, trackRadius);
                ctx.fill();
            }

            const knobX = x + sliderMargin + fillW;
            const knobY = sliderY + sliderH / 2;
            const knobR = 8;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(knobX, knobY, knobR, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 4;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    });

    ctx.restore();
}

showCheckboxSelectionModal() {

        const candidates = this.entries.filter(e => 
            (e.type === 'function' || e.type === 'geometry' || e.type === 'point_list') && 
            (e.name || e.expr)
        );

        if (candidates.length === 0) {
            alert("没有可控制的对象。");
            return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'checkbox-modal-overlay';
        
        let listHtml = candidates.map(e => {
            let typeDesc = '未知';
            if (e.type === 'point_list') typeDesc = '点列';
            else if (e.type === 'geometry') typeDesc = '几何';
            else if (e.type === 'function') {
                if (e.plotType === 'implicit' || e.plotType === 'implicit3d') typeDesc = '隐函数';
                else if (e.plotType === 'parametric' || e.plotType === 'parametric3d') typeDesc = '参数曲线';
                else typeDesc = '函数';
            }
            
            // 关键修改：使用 name 优先，没有 name 则使用 expr 作为显示和值
            const displayName = e.name || e.expr;
            const valueId = e.name || e.expr;

            return `
            <div class="checkbox-list-item">
                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;" title="${displayName}">
                    ${displayName} 
                    <span style="color:var(--text-color-subtle); font-size:0.8em;">(${typeDesc})</span>
                </span>
                <input type="checkbox" value="${valueId}" class="obj-selector">
            </div>
        `}).join('');

        overlay.innerHTML = `
            <div class="checkbox-modal">
                <h3>选择要控制的对象</h3>
                <div class="checkbox-list">${listHtml}</div>
                <div class="checkbox-modal-actions">
                    <button class="checkbox-modal-btn checkbox-cancel">取消</button>
                    <button class="checkbox-modal-btn checkbox-confirm">确定</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);

        overlay.querySelector('.checkbox-cancel').onclick = () => overlay.remove();
        overlay.querySelector('.checkbox-confirm').onclick = () => {
            const selected = Array.from(overlay.querySelectorAll('.obj-selector:checked')).map(cb => cb.value);
            if (selected.length === 0) {
                alert("请至少选择一个对象");
                return;
            }
            const name = prompt("请输入复选框名称:", "显示/隐藏");
            if (name) {
                this.createCheckboxAnnotation(name, selected);
            }
            overlay.remove();
        };
    }

createCheckboxAnnotation(name, controlledNames) {
    // 计算屏幕中心位置
    const cssWidth = this.canvas.clientWidth;
    const cssHeight = this.canvas.clientHeight;
    const x = (cssWidth / 2 - this.offset.x) / this.scale;
    const y = (this.offset.y - cssHeight / 2) / this.scale;

    const checkbox = {
        type: 'checkbox',
        name: name,
        controlledNames: controlledNames,
        checked: true,
        x: x,
        y: y,
        width: 150 / this.scale, // 预估宽度，绘制时会更新
        height: 40 / this.scale,
        color: { h: 0, s: 0, b: 0, a: 100 } // 颜色占位
    };
    this.annotations.push(checkbox);
    this.requestDraw();
}

drawAnnotations() {
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        ctx.save();
        ctx.scale(dpr, dpr);

        const roundRect = (ctx, x, y, width, height, radius) => {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
        };

        this.annotations.forEach((annotation, index) => {
      if (annotation.type === 'checkbox') {
        const screenX = this.offset.x + annotation.x * this.scale;
        const screenY = this.offset.y - annotation.y * this.scale;
        const width = 160; 
        const height = 40;
        
        annotation.width = width / this.scale;
        annotation.height = height / this.scale;

        ctx.save();
        
        const isDark = this.isDarkModeActive;
        // 背景颜色，稍微增加不透明度以弥补没有边框
        ctx.fillStyle = isDark ? "rgba(60, 60, 60, 0.95)" : "rgba(255, 255, 255, 0.95)";
        
        // 阴影效果替代边框，增加层次感
        ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
        ctx.shadowBlur = 6;
        ctx.shadowOffsetY = 2;

        const r = 10;
        ctx.beginPath();
        ctx.roundRect(screenX, screenY, width, height, r);
        ctx.fill();
        
        // 移除 ctx.stroke() 以去除外边框
        ctx.shadowBlur = 0; // 重置阴影以免影响后续绘制
        ctx.shadowOffsetY = 0;

        // 文字
        ctx.font = "bold 14px 'HarmonyOS_SC', Arial";
        ctx.fillStyle = isDark ? "#fff" : "#333";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        
        // 限制文字长度，防止与开关重叠
        const maxTextWidth = width - 60; 
        let text = annotation.name;
        if (ctx.measureText(text).width > maxTextWidth) {
             // 简单截断，实际可做更精细处理
             text = text.substring(0, 8) + "...";
        }
        ctx.fillText(text, screenX + 15, screenY + height / 2);

        // 开关
        const switchW = 40;
        const switchH = 22;
        const switchX = screenX + width - switchW - 15;
        const switchY = screenY + (height - switchH) / 2;
        
        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color-accent').trim();
        ctx.fillStyle = annotation.checked ? accentColor : (isDark ? "#555" : "#ccc");
        
        ctx.beginPath();
        ctx.roundRect(switchX, switchY, switchW, switchH, switchH/2);
        ctx.fill();

        // 开关圆钮
        const knobSize = 18;
        const knobX = annotation.checked ? (switchX + switchW - knobSize - 2) : (switchX + 2);
        const knobY = switchY + 2;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(knobX + knobSize/2, knobY + knobSize/2, knobSize/2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    } else if (annotation.type === 'pen') {
                ctx.save();
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;

                ctx.translate(screenX, screenY);

                ctx.beginPath();
                annotation.path.forEach((p, i) => {
                    const px = p.x * annotation.scaleX * this.scale;
                    const py = -p.y * annotation.scaleY * this.scale;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });

                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                ctx.strokeStyle = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;

                ctx.lineWidth = annotation.thickness * this.scale;

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.restore();

            } else if (annotation.type === 'text') {
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;

                const boxWidth = annotation.width * this.scale;
                const boxHeight = annotation.height * this.scale;

                ctx.save();
                ctx.beginPath();
                ctx.rect(screenX, screenY, boxWidth, boxHeight);
                ctx.clip();

                const pixelFontSize = annotation.fontSize * this.scale;
                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                const colorRgbaString = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;
                
                ctx.textBaseline = 'top';

                if (annotation.content.startsWith('<smart>')) {
                    const processedText = this._processSmartTextLogic(annotation.content);
                    this._drawSmartText(ctx, processedText, screenX, screenY, pixelFontSize, colorRgbaString, boxWidth);
                } else {
                    ctx.font = `${pixelFontSize}px 'HarmonyOS_SC', Arial`;
                    ctx.fillStyle = colorRgbaString;
                    const textContent = annotation.content;
                    const lineHeight = pixelFontSize * 1.2;
                    let currentY = screenY;

                    const paragraphs = annotation.content.split('\\n');
                    paragraphs.forEach(paragraph => {
                        let currentLine = '';
                        for (let i = 0; i < paragraph.length; i++) {
                            const char = paragraph[i];
                            const testLine = currentLine + char;
                            const metrics = ctx.measureText(testLine);
                            if (metrics.width > boxWidth && i > 0) {
                                ctx.fillText(currentLine, screenX, currentY);
                                currentY += lineHeight;
                                currentLine = char;
                            } else {
                                currentLine = testLine;
                            }
                        }
                        ctx.fillText(currentLine, screenX, currentY);
                        currentY += lineHeight;
                    });
                }

                ctx.restore();
            } else if (annotation.type === 'image' || annotation.type === 'pdf') {
                if (annotation.img) {
                    const screenX = this.offset.x + annotation.x * this.scale;
                    const screenY = this.offset.y - annotation.y * this.scale;

                    const w = annotation.width * annotation.scaleX * this.scale;
                    const h = annotation.height * annotation.scaleY * this.scale;

                    ctx.save();
                    // 圆角裁剪
                    roundRect(ctx, screenX, screenY, w, h, 15);
                    ctx.clip();

                    ctx.globalAlpha = 1.0 - (annotation.color.a / 100);
                    ctx.drawImage(annotation.img, screenX, screenY, w, h);
                    ctx.restore();
                }
            } else if (annotation.type === 'audio') {
                const screenX = this.offset.x + annotation.x * this.scale;
                const screenY = this.offset.y - annotation.y * this.scale;
                const w = annotation.width * annotation.scaleX * this.scale;
                const h = annotation.height * annotation.scaleY * this.scale;
                
                ctx.save();
                
                // 恢复为圆形背景图标
                const rgba = this.hsbToRgbaArray(annotation.color.h, annotation.color.s, annotation.color.b, annotation.color.a);
                const colorString = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;
                
                const cx = screenX + w/2;
                const cy = screenY + h/2;
                const r = Math.min(w, h)/2;

                ctx.fillStyle = colorString;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.fill();
                
                // 绘制扬声器图标
                ctx.fillStyle = 'white';
                ctx.globalAlpha = 1.0 - (annotation.color.a / 100); 
                
                const size = r; 
                ctx.beginPath();
                ctx.moveTo(cx - size/2, cy - size/2);
                ctx.lineTo(cx + size/2, cy);
                ctx.lineTo(cx - size/2, cy + size/2);
                ctx.fill();
                ctx.restore();
            }
        });

        if (this.annotationState.isDrawing && this.annotationState.currentDrawingPath.length > 1) {
            const path = this.annotationState.currentDrawingPath;
            ctx.beginPath();
            path.forEach((p, i) => {
                const screenX = this.offset.x + p.x * this.scale;
                const screenY = this.offset.y - p.y * this.scale;
                if (i === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
            });
            const rgba = this.hsbToRgbaArray(this.annotationState.pen.color.h, this.annotationState.pen.color.s, this.annotationState.pen.color.b, this.annotationState.pen.color.a);
            ctx.strokeStyle = `rgba(${rgba[0] * 255},${rgba[1] * 255},${rgba[2] * 255},${rgba[3]})`;

            ctx.lineWidth = this.annotationState.pen.thickness * this.scale;
            ctx.stroke();
        }

        if (this.selectedAnnotationIndex !== -1) {
            this.drawAnnotationSelectionBox(this.annotations[this.selectedAnnotationIndex]);
        }

        ctx.restore();
    }

_processSmartTextLogic(rawText) {
        let text = rawText.replace('<smart>', '');
        const maxIterations = 50;
        let iteration = 0;

        const getContextSymbols = () => {
            return new Set([
                ...this.calcJSUtils.calc1,
                ...this.calcJSUtils.calc3,
                ...this.calcJSUtils.advancedCustomFunctionNames,
                ...Object.keys(this.calcJSUtils.constants),
                ...this.entries.map(e => (e.key || e.name)),
                ...this.variables.keys()
            ].filter(Boolean).map(n => n.toLowerCase()));
        };

        while (iteration < maxIterations) {
            let changed = false;
            
            const valueMatch = text.match(/\{value\((.*?)\)\}/);
            if (valueMatch) {
                const expr = valueMatch[1];
                let val = NaN;
                try {
                    const contextSymbols = getContextSymbols();
                    const tokens = this.improvedTokenize(expr, contextSymbols);
                    val = this.evaluateExpressionWithCalcJS(tokens, Object.fromEntries(this.variables));
                } catch (e) { }
                const replacement = Number.isFinite(val) ? parseFloat(val.toPrecision(6)).toString() : 'NaN';
                text = text.replace(valueMatch[0], replacement);
                changed = true;
            }

            if (!changed) {
                const ifStart = text.indexOf('{if(');
                if (ifStart !== -1) {
                    let depth = 0;
                    let cursor = ifStart + 4; 
                    let condEnd = -1, thenEnd = -1, elseEnd = -1;
                    let condStr = '', thenStr = '', elseStr = '';

                    while (cursor < text.length) {
                        if (text.substring(cursor).startsWith('),then(') && depth === 0) {
                            condEnd = cursor;
                            cursor += 7; 
                            continue;
                        }
                        if (text.substring(cursor).startsWith('),else(') && depth === 0) {
                            thenEnd = cursor;
                            cursor += 7;
                            continue;
                        }
                        if (text[cursor] === ')' && text[cursor + 1] === '}' && depth === 0) {
                            elseEnd = cursor;
                            break;
                        }
                        
                        if (text[cursor] === '(') depth++;
                        if (text[cursor] === ')') depth--;
                        cursor++;
                    }

                    if (condEnd !== -1 && thenEnd !== -1 && elseEnd !== -1) {
                        condStr = text.substring(ifStart + 4, condEnd);
                        thenStr = text.substring(condEnd + 7, thenEnd);
                        elseStr = text.substring(thenEnd + 7, elseEnd);
                        const fullMatch = text.substring(ifStart, elseEnd + 2);

                        let condVal = NaN;
                        try {
                            const contextSymbols = getContextSymbols();
                            const tokens = this.improvedTokenize(condStr, contextSymbols);
                            condVal = this.evaluateExpressionWithCalcJS(tokens, Object.fromEntries(this.variables));
                        } catch (e) { }
                        
                        const replacement = (Number.isFinite(condVal) && condVal >= 0) ? thenStr : elseStr;
                        text = text.replace(fullMatch, replacement);
                        changed = true;
                    }
                }
            }

            if (!changed) break;
            iteration++;
        }
        return text;
    }
    _drawSmartText(ctx, text, x, y, fontSize, colorRgba, boxWidth) {
        const lines = text.split('\\n');
        const lineHeight = fontSize * 1.2;
        let currentY = y;

        lines.forEach(line => {
            let parts = line.split(/(\/[rbi])/g); 
            let currentX = x;
            let currentFontType = 'normal'; 

            let lineBuffer = []; 

            parts.forEach(part => {
                if (part === '/r') currentFontType = 'normal';
                else if (part === '/b') currentFontType = 'bold';
                else if (part === '/i') currentFontType = 'italic';
                else if (part !== '') {
                    lineBuffer.push({ text: part, type: currentFontType });
                }
            });

            
            lineBuffer.forEach(segment => {
                let fontPrefix = '';
                if (segment.type === 'bold') fontPrefix = 'bold ';
                else if (segment.type === 'italic') fontPrefix = 'italic ';
                
                ctx.font = `${fontPrefix}${fontSize}px 'HarmonyOS_SC', Arial`;
                ctx.fillStyle = colorRgba;
                
                const metrics = ctx.measureText(segment.text);
                
                if (currentX + metrics.width > x + boxWidth && currentX > x) {
                    currentX = x;
                    currentY += lineHeight;
                }
                
                ctx.fillText(segment.text, currentX, currentY);
                currentX += metrics.width;
            });

            currentY += lineHeight;
        });
    }

drawAnnotationSelectionBox(annotation) {
        const ctx = this.axisCtx;
        const screenX = this.offset.x + annotation.x * this.scale;
        const screenY = this.offset.y - annotation.y * this.scale;

        const roundRect = (ctx, x, y, width, height, radius) => {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
        };

        let screenWidth, screenHeight;
        let boxTopY;

        if (annotation.type === 'pen') {
            screenWidth = annotation.width * annotation.scaleX * this.scale;
            screenHeight = annotation.height * annotation.scaleY * this.scale;
            boxTopY = screenY - screenHeight;
        } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
            screenWidth = annotation.width * annotation.scaleX * this.scale;
            screenHeight = annotation.height * annotation.scaleY * this.scale;
            boxTopY = screenY;
        } else {
            screenWidth = annotation.width * this.scale;
            screenHeight = annotation.height * this.scale;
            boxTopY = screenY;
        }

        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(screenX, boxTopY, screenWidth, screenHeight);
        ctx.setLineDash([]);

        const handleSize = 8;
        const handles = {
            tl: { x: screenX, y: boxTopY },
            t: { x: screenX + screenWidth / 2, y: boxTopY },
            tr: { x: screenX + screenWidth, y: boxTopY },
            l: { x: screenX, y: boxTopY + screenHeight / 2 },
            r: { x: screenX + screenWidth, y: boxTopY + screenHeight / 2 },
            bl: { x: screenX, y: boxTopY + screenHeight },
            b: { x: screenX + screenWidth / 2, y: boxTopY + screenHeight },
            br: { x: screenX + screenWidth, y: boxTopY + screenHeight }
        };

        ctx.fillStyle = '#007bff';
        for (const key in handles) {
            const pos = handles[key];
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, handleSize / 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        if (annotation.type === 'pdf') {
            const btnSize = 36;
            const prevX = screenX + screenWidth / 2 - 40;
            const nextX = screenX + screenWidth / 2 + 10;
            const btnY = boxTopY + screenHeight + 25; 

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.arc(prevX + btnSize/2, btnY, btnSize/2, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(nextX + btnSize/2, btnY, btnSize/2, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('←', prevX + btnSize / 2, btnY + 1);
            ctx.fillText('→', nextX + btnSize / 2, btnY + 1);
            
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`${annotation.page}/${annotation.totalPages}`, screenX + screenWidth / 2, boxTopY + screenHeight + 15);
        }

        if (annotation.type === 'audio') {
            // 在图标下方绘制进度条控件
            const controlsY = boxTopY + screenHeight + 20; // 图标下方 20px
            const playSize = 24;
            // 播放按钮放在图标左下方对齐
            const playX = screenX + playSize/2; 
            
            // 播放/暂停按钮背景
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(playX, controlsY, playSize/2, 0, 2*Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            if (annotation.isPlaying) {
                const barW = 3;
                const barH = 10;
                const gap = 4;
                ctx.fillRect(playX - gap/2 - barW, controlsY - barH/2, barW, barH);
                ctx.fillRect(playX + gap/2, controlsY - barH/2, barW, barH);
            } else {
                const size = 10;
                ctx.beginPath();
                ctx.moveTo(playX - size/3, controlsY - size/2);
                ctx.lineTo(playX + size/1.5, controlsY);
                ctx.lineTo(playX - size/3, controlsY + size/2);
                ctx.fill();
            }
            
            // 进度条背景 (圆角矩形)
            const barX = playX + 20; // 按钮右侧
            const barY = controlsY - 4; // 垂直居中 (controlsY is center of play button, height 8 -> -4)
            // 宽度至少 100px，或者与图标宽度一致
            const barW = Math.max(120, screenWidth - 30); 
            const barH = 8;
            const barRadius = 4;
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            roundRect(ctx, barX, barY, barW, barH, barRadius);
            ctx.fill();
            
            // 进度条前景
            if (annotation.audioElem && annotation.audioElem.duration) {
                const progress = annotation.audioElem.currentTime / annotation.audioElem.duration;
                ctx.fillStyle = '#007bff';
                roundRect(ctx, barX, barY, barW * progress, barH, barRadius);
                ctx.fill();
            }
        }
    }

    updateAnnotationEditMenu() {
    const isEditing = this.selectedAnnotationIndex !== -1 && this.currentUIMode !== 'annotation';
    const annotation = isEditing ? this.annotations[this.selectedAnnotationIndex] : null;
    const currentMode = isEditing ? annotation.type : this.annotationState.mode;

    // 控制滑块显示的辅助函数
const updateSliderVisibility = (type) => {
        const groups = {
            h: document.getElementById('slider-group-h'),
            s: document.getElementById('slider-group-s'),
            b: document.getElementById('slider-group-b'),
            a: document.getElementById('slider-group-a'),
            thickness: document.getElementById('pen-thickness-group').closest('.slider-group'),
            size: document.getElementById('text-size-group').closest('.slider-group')
        };

        Object.values(groups).forEach(g => g && (g.style.display = 'flex'));
if (annotation && annotation.type === 'checkbox') {
        // 隐藏所有滑块
        Object.values(groups).forEach(g => g && (g.style.display = 'none'));
        

        this.annotationEditTextBtn.style.display = 'flex';
        

        this.annotationEditTextBtn.onclick = () => {
            this.editCheckboxControlledObjects(annotation);
        };
        
        // 确保显示删除按钮
        this.annotationDeleteBtn.style.display = 'flex';
        
        // 绑定删除按钮
        this.annotationDeleteBtn.onclick = () => {
             this.annotations.splice(this.selectedAnnotationIndex, 1);
             this.selectedAnnotationIndex = -1;
             this.updateAnnotationEditMenu();
             this.requestDraw();
        };

        // 确保菜单展开
        this.annotationMenu.style.display = 'flex';
        this.annotationMenu.classList.add('expanded');
        return; // 提前返回，跳过后续通用逻辑
    }
        if (type === 'image' || type === 'pdf' || type === 'audio') {
            if (groups.h) groups.h.style.display = 'none';
            if (groups.s) groups.s.style.display = 'none';
            if (groups.b) groups.b.style.display = 'none';
            if (groups.thickness) groups.thickness.style.display = 'none';
            if (groups.size) groups.size.style.display = 'none';
        } else if (type === 'text') {
            if (groups.thickness) groups.thickness.style.display = 'none';
        } else if (type === 'eraser') {

            if (groups.h) groups.h.style.display = 'none';
            if (groups.s) groups.s.style.display = 'none';
            if (groups.b) groups.b.style.display = 'none';
            if (groups.a) groups.a.style.display = 'none';
            if (groups.size) groups.size.style.display = 'none';
        } else {
            if (groups.size) groups.size.style.display = 'none';
        }
    };

    if (isEditing) {

        this.annotationMenu.style.display = 'flex';
        this.annotationMenu.classList.add('expanded'); 
        if (this.annotationColorBtn) {
            this.annotationColorBtn.style.display = 'none'; 
        }
        
        this._setupAnnotationEditControls(annotation);

        this.annotationModeSwitchBtns.forEach(btn => btn.style.display = 'none');
        this.annotationDeleteBtn.style.display = 'flex';
        this.annotationEditTextBtn.style.display = annotation.type === 'text' ? 'flex' : 'none';
        
        updateSliderVisibility(annotation.type);

    } else {
        // 批注/创建模式
        this.annotationDeleteBtn.style.display = 'none';
        this.annotationEditTextBtn.style.display = 'none';
        
        if (this.currentUIMode === 'annotation') {
            this.annotationMenu.style.display = 'flex';
            if (this.annotationColorBtn) {
                this.annotationColorBtn.style.display = 'flex';
                this.annotationColorBtn.classList.toggle('active', this.isAnnotationMenuExpanded);
            }
            this.annotationMenu.classList.toggle('expanded', this.isAnnotationMenuExpanded); // 恢复之前的折叠状态
            this.annotationModeSwitchBtns.forEach(btn => btn.style.display = 'flex');
            
            updateSliderVisibility(this.annotationState.mode);
        } else {
            this.annotationMenu.style.display = 'none';
        }
    }
    
    // 强制重绘滑块以适应布局变化
    requestAnimationFrame(() => {
        this.activeSliders.forEach(slider => slider.resizeCanvas && slider.resizeCanvas());
        Object.values(this.penColorSliders).forEach(slider => slider.resizeCanvas && slider.resizeCanvas());
        if(this.penThicknessSlider) this.penThicknessSlider.resizeCanvas();
        if(this.penFontSizeSlider) this.penFontSizeSlider.resizeCanvas();
    });
}
editCheckboxControlledObjects(checkboxAnno) {
        // 筛选所有有效的可控制对象
        const candidates = this.entries.filter(e => 
            (e.type === 'function' || e.type === 'geometry' || e.type === 'point_list') && 
            (e.name || e.expr)
        );

        if (candidates.length === 0) {
            alert("没有可控制的对象。");
            return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'checkbox-modal-overlay';
        
        // 生成列表，并根据 checkboxAnno.controlledNames 预选
        let listHtml = candidates.map(e => {
            let typeDesc = '未知';
            if (e.type === 'point_list') typeDesc = '点列';
            else if (e.type === 'geometry') typeDesc = '几何';
            else if (e.type === 'function') {
                if (e.plotType === 'implicit' || e.plotType === 'implicit3d') typeDesc = '隐函数';
                else if (e.plotType === 'parametric' || e.plotType === 'parametric3d') typeDesc = '参数曲线';
                else typeDesc = '函数';
            }
            
            const valueId = e.name || e.expr;
            const isChecked = checkboxAnno.controlledNames.includes(valueId) ? 'checked' : '';

            return `
            <div class="checkbox-list-item">
                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;" title="${valueId}">
                    ${valueId} 
                    <span style="color:var(--text-color-subtle); font-size:0.8em;">(${typeDesc})</span>
                </span>
                <input type="checkbox" value="${valueId}" class="obj-selector" ${isChecked}>
            </div>
        `}).join('');

        overlay.innerHTML = `
            <div class="checkbox-modal">
                <h3>编辑控制对象</h3>
                <div class="checkbox-list">${listHtml}</div>
                <div class="checkbox-modal-actions">
                    <button class="checkbox-modal-btn checkbox-cancel">取消</button>
                    <button class="checkbox-modal-btn checkbox-confirm">确定</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);

        overlay.querySelector('.checkbox-cancel').onclick = () => overlay.remove();
        overlay.querySelector('.checkbox-confirm').onclick = () => {
            const selected = Array.from(overlay.querySelectorAll('.obj-selector:checked')).map(cb => cb.value);
            
            // 更新复选框的控制列表
            checkboxAnno.controlledNames = selected;
            
            // 还可以顺便允许修改名称
            const newName = prompt("修改复选框名称 (留空保持不变):", checkboxAnno.name);
            if (newName && newName.trim() !== "") {
                checkboxAnno.name = newName;
            }
            
            this.requestDraw(); // 重绘以应用更改
            overlay.remove();
        };
    }

_setupAnnotationEditControls(annotation) {
        if (!annotation) return; if (annotation.type === 'checkbox') return;


        this.penColorSliders.h.setValue(annotation.color.h);
        this.penColorSliders.s.setValue(annotation.color.s);
        this.penColorSliders.b.setValue(annotation.color.b);
        this.penColorSliders.a.setValue(annotation.color.a);

        const thicknessGroup = document.getElementById('pen-thickness-group').closest('.slider-group');
        const textSizeGroup = document.getElementById('text-size-group').closest('.slider-group');

        if (annotation.type === 'pen') {
            if (thicknessGroup) thicknessGroup.style.display = 'flex';
            if (textSizeGroup) textSizeGroup.style.display = 'none';

            this.penThicknessSlider.setValue(annotation.thickness);
            this.penThicknessSlider.options.onInput = (e) => {
                annotation.thickness = e.target.options.value;
                this.requestDraw();
            };
            this.penThicknessSlider.draw();

        } else if (annotation.type === 'text') {
            if (thicknessGroup) thicknessGroup.style.display = 'none';
            if (textSizeGroup) textSizeGroup.style.display = 'flex';

            this.penFontSizeSlider.setValue(annotation.fontSize);
            this.penFontSizeSlider.options.onInput = (e) => {
                annotation.fontSize = e.target.options.value;
                this.requestDraw();
            };
            this.penFontSizeSlider.draw();
        } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
            if (thicknessGroup) thicknessGroup.style.display = 'none';
            if (textSizeGroup) textSizeGroup.style.display = 'none';
        }

        const rebindColorSlider = (slider, prop) => {
            slider.options.context = annotation.color;
            slider.options.onInput = (e) => {
                annotation.color[prop] = e.target.options.value;
                Object.values(this.penColorSliders).forEach(s => {
                    s.options.context = annotation.color;
                    s.draw();
                });
                this.requestDraw();
            };
            slider.draw();
        };

        rebindColorSlider(this.penColorSliders.h, 'h');
        rebindColorSlider(this.penColorSliders.s, 's');
        rebindColorSlider(this.penColorSliders.b, 'b');
        rebindColorSlider(this.penColorSliders.a, 'a');

        this.annotationDeleteBtn.onclick = () => {
            if (annotation.type === 'audio' && annotation.audioElem) {
                annotation.audioElem.pause();
            }
            this.annotations.splice(this.selectedAnnotationIndex, 1);
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        };

        this.annotationEditTextBtn.onclick = () => {
            const newText = prompt("编辑文本:", annotation.content);
            if (newText !== null) {
                annotation.content = newText;
                this.requestDraw();
            }
        };

        document.getElementById('annotation-exit-btn').onclick = () => {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        };
    }

findAnnotationAt(coords) {
        const result = { index: -1, handle: null };
        const hitPadding = 15;

        for (let i = this.annotations.length - 1; i >= 0; i--) {
            const annotation = this.annotations[i];
            const screenX = this.offset.x + annotation.x * this.scale;
            const screenY = this.offset.y - annotation.y * this.scale;

            let screenWidth, screenHeight;
            let drawYMin, drawYMax;

            if (annotation.type === 'pen') {
                screenWidth = annotation.width * annotation.scaleX * this.scale;
                screenHeight = annotation.height * annotation.scaleY * this.scale;
                drawYMin = screenY - screenHeight;
                drawYMax = screenY;
            } else if (annotation.type === 'image' || annotation.type === 'pdf' || annotation.type === 'audio') {
                screenWidth = annotation.width * annotation.scaleX * this.scale;
                screenHeight = annotation.height * annotation.scaleY * this.scale;
                drawYMin = screenY;
                drawYMax = screenY + screenHeight;
            } else {
                screenWidth = annotation.width * this.scale;
                screenHeight = annotation.height * this.scale;
                drawYMin = screenY;
                drawYMax = screenY + screenHeight;
            }

            if (this.selectedAnnotationIndex === i) {
                const handleSize = 20;

                const handles = {
                    tl: { x: screenX, y: drawYMin },
                    t: { x: screenX + screenWidth / 2, y: drawYMin },
                    tr: { x: screenX + screenWidth, y: drawYMin },
                    l: { x: screenX, y: drawYMin + screenHeight / 2 },
                    r: { x: screenX + screenWidth, y: drawYMin + screenHeight / 2 },
                    bl: { x: screenX, y: drawYMax },
                    b: { x: screenX + screenWidth / 2, y: drawYMax },
                    br: { x: screenX + screenWidth, y: drawYMax }
                };

                for (const key in handles) {
                    if (Math.hypot(coords.x - handles[key].x, coords.y - handles[key].y) <= handleSize) {
                        result.index = i;
                        result.handle = key;
                        return result;
                    }
                }
            }

            if (coords.x >= screenX - hitPadding &&
                coords.x <= screenX + screenWidth + hitPadding &&
                coords.y >= drawYMin - hitPadding &&
                coords.y <= drawYMax + hitPadding) {

                result.index = i;
                result.handle = 'move';
                return result;
            }
        }
        return result;
    }

 handleAnnotationResizeOrMove(e) {
    if (!this.annotationInteraction.type) return;
    if (e.cancelable) e.preventDefault();

    const coords = this.getEventCoordinates(e);
    const annotation = this.annotations[this.selectedAnnotationIndex];
    const dx_math = (coords.x - this.annotationInteraction.startX) / this.scale;
    const dy_math = -(coords.y - this.annotationInteraction.startY) / this.scale;
    
    const o = this.annotationInteraction.original;

    if (this.annotationInteraction.type === 'move') {
        annotation.x = o.x + dx_math;
        annotation.y = o.y + dy_math;
        this.requestDraw();
        return;
    }

    const handle = this.annotationInteraction.type;
    const minSize = 20 / this.scale;

    let new_w_math = (annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width;
    let new_x = o.x;

    if (handle.includes('l')) {
        new_x = o.x + dx_math;
        new_w_math = ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) - dx_math;
    }
    if (handle.includes('r')) {
        new_w_math = ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) + dx_math;
    }

    if (new_w_math < minSize) {
        if (handle.includes('l')) new_x = o.x + ((annotation.type === 'pen' || annotation.type === 'image') ? o.width * o.scaleX : o.width) - minSize;
        new_w_math = minSize;
    }
    
    annotation.x = new_x;
    if (annotation.type === 'pen' || annotation.type === 'image') {
        if (annotation.width > 1e-9) annotation.scaleX = new_w_math / annotation.width;
    } else {
        annotation.width = new_w_math;
    }

    if (annotation.type === 'pen') {
         const pen_orig_bottom = o.y;
         const pen_orig_top = o.y + (o.height * o.scaleY);
         
         if (handle.includes('t')) {
            const new_top = pen_orig_top + dy_math;
            let new_h = new_top - pen_orig_bottom;
            if (new_h < minSize) new_h = minSize;
            annotation.y = pen_orig_bottom;
            if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
         } else if (handle.includes('b')) {
            const new_bottom = pen_orig_bottom + dy_math;
            let new_h = pen_orig_top - new_bottom;
            if (new_h < minSize) {
                new_h = minSize;
                annotation.y = pen_orig_top - minSize;
            } else {
                annotation.y = new_bottom;
            }
            if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
         }
    } else {
        const obj_orig_top = o.y;
        const obj_orig_height = (annotation.type === 'image' ? o.height * o.scaleY : o.height);
        const obj_orig_bottom = o.y - obj_orig_height;

        if (handle.includes('t')) {
            const new_top = obj_orig_top + dy_math;
            let new_h = new_top - obj_orig_bottom;
            if (new_h < minSize) {
                 new_h = minSize;
                 annotation.y = obj_orig_bottom + minSize;
            } else {
                 annotation.y = new_top;
            }
            
            if (annotation.type === 'image') {
                 if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
            } else {
                 annotation.height = new_h;
            }

        } else if (handle.includes('b')) {
            const new_bottom = obj_orig_bottom + dy_math;
            let new_h = obj_orig_top - new_bottom;
            if (new_h < minSize) {
                new_h = minSize;
            }
            
            if (annotation.type === 'image') {
                 if (annotation.height > 1e-9) annotation.scaleY = new_h / annotation.height;
            } else {
                 annotation.height = new_h;
            }
        }
    }
    
    this.requestDraw();
}

stopTracing() {
        if (!this.traceState.active) return;
        
        if (this.traceState.path.length > 1) {
            let pointListStr = '/-/ ';
            for (let i = 0; i < this.traceState.path.length; i++) {
                const p = this.traceState.path[i];
                pointListStr += `(${p.x.toPrecision(6)},${p.y.toPrecision(6)})`;
            }
            this.addEntry(pointListStr);
            const newEntry = this.entries[this.entries.length - 1];
            if (newEntry && newEntry.type === 'point_list') {
                newEntry.color = { h: 0, s: 0, b: 0, a: 0 };
            }
        }

        this.traceState.active = false;
        this.traceState.targetName = null;
        this.traceState.path = [];
        document.getElementById('stop-trace-btn').style.display = 'none';
        this.hideInfoMessage();
        this.requestDraw();
    }

    drawActiveTrajectory() {
        if (!this.traceState.active || this.traceState.path.length < 2) return;
        
        const ctx = this.axisCtx;
        const dpr = window.devicePixelRatio || 1;
        ctx.save();
        ctx.scale(dpr, dpr);
        
        ctx.beginPath();
        const path = this.traceState.path;
        path.forEach((p, i) => {
            const screenX = this.offset.x + p.x * this.scale;
            const screenY = this.offset.y - p.y * this.scale;
            if (i === 0) ctx.moveTo(screenX, screenY);
            else ctx.lineTo(screenX, screenY);
        });
        
        ctx.strokeStyle = this.isDarkModeActive ? 'white' : 'black';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        
        ctx.restore();
    }


applyDarkMode(isDark) {
    const root = document.documentElement;
    if (isDark) {
        root.setAttribute('data-theme', 'dark');
        this.isDarkModeActive = true;
        if(this.preferredColorSlider) this.preferredColorSlider.value = 0;
        this.preferredColorValue = 0;
        this.updatePreferredColorValueLabel();
    } else {
        root.removeAttribute('data-theme');
        this.isDarkModeActive = false;
    }
    this.applyThemeColors(); 
    this.requestDraw();
}

getContrastingTextColor(bgColor, lightnessPercent, subtle = false) {
    if (lightnessPercent > 70) {
        return subtle ? '#777' : '#333';
    }

    return subtle ? '#ccc' : '#f0f0f0';
}

applyTransparency(isEnabled) {
    const sidebarBg = document.getElementById('sidebar-background');
    const isSidebarVisibleAndRelevant = !document.body.classList.contains('sidebar-hidden') && !this.isPortraitMode && sidebarBg;
    
    let sidebarWidthBefore = 0;
    if (isSidebarVisibleAndRelevant) {
        sidebarWidthBefore = sidebarBg.getBoundingClientRect().width;
    }

    const wasEnabled = this.isTransparencyEnabled;
    this.isTransparencyEnabled = isEnabled;
    
    const root = document.documentElement;
    if (isEnabled) {
        root.removeAttribute('data-transparency-enabled');
    } else {
        root.setAttribute('data-transparency-enabled', 'false');
    }

    this.applyThemeColors();

    if (isSidebarVisibleAndRelevant && wasEnabled !== isEnabled) {
        if (isEnabled) {
            this.offset.x += 400;
        } 
        else {
            this.offset.x -= 400;
        }
    }
    
    this.updateCanvasPosition();
    this.updateOverlayPositions();
    this.requestDraw();
}

applyThemeColors() {
    const root = document.documentElement;
    root.removeAttribute('data-theme-preferred-color-value');
    root.style.cssText = '';

    if (this.isDarkModeActive) {
        root.setAttribute('data-theme', 'dark');
    } else if (this.preferredColorValue === 0) {
        root.style.setProperty('--bg-color', '#ddd');
        root.style.setProperty('--sidebar-bg-color', '#f0f0f0');
        root.style.setProperty('--sidebar-border-color', '#ccc');
        root.style.setProperty('--entry-item-bg-color', '#f8f8f8');
        root.style.setProperty('--entry-item-hover-bg-color', '#efefef');
        root.style.setProperty('--entry-item-separator-color', '#c3c3c3');
        root.style.setProperty('--controls-border-color', '#eee');
        root.style.setProperty('--add-btn-bg-color', '#e0e0e0');
        root.style.setProperty('--add-btn-text-color', '#000000');
        root.style.setProperty('--text-color-default', '#333');
        root.style.setProperty('--text-color-subtle', '#555');
        root.style.setProperty('--text-color-error', '#cc0000');
        root.style.setProperty('--text-color-accent', '#007bff');
        root.style.setProperty('--variable-indicator-dependent-color', '#999999');
        root.style.setProperty('--variable-indicator-independent-paused-color', 'var(--text-color-accent)');
        root.style.setProperty('--variable-indicator-independent-playing-color', 'orange');
        root.style.setProperty('--canvas-bg-color', 'rgb(255, 255, 255)');
        root.style.setProperty('--input-range-track-bg', '#d3d3d3');
        root.style.setProperty('--overlay-bg-color', 'rgba(255, 255, 255, 0.85)');
        root.style.setProperty('--overlay-text-color', '#333');
        root.style.setProperty('--switch-off-bg-color', '#ccc');
        root.style.setProperty('--switch-on-bg-color', 'var(--text-color-accent)');
        root.style.setProperty('--axis-number-color', '#333');
        root.style.setProperty('--menu-bg-color', 'rgba(255, 255, 255, 0.95)');
        root.style.setProperty('--keyboard-bg-color', 'rgba(255, 255, 255, 0.95)');
    } else {
        const hue = (this.preferredColorValue / 100) * 360;
        root.setAttribute('data-theme-preferred-color-value', String(this.preferredColorValue));
        root.style.setProperty('--preferred-hue', String(hue));
        root.style.setProperty('--bg-color', `hsl(${hue}, 30%, 85%)`);
        root.style.setProperty('--sidebar-bg-color', `hsl(${hue}, 25%, 90%)`);
        root.style.setProperty('--sidebar-border-color', `hsl(${hue}, 20%, 75%)`);
        root.style.setProperty('--entry-item-bg-color', `hsl(${hue}, 25%, 92%)`);
        root.style.setProperty('--entry-item-hover-bg-color', `hsl(${hue}, 25%, 88%)`);
        root.style.setProperty('--entry-item-separator-color', `hsl(${hue}, 15%, 65%)`);
        root.style.setProperty('--controls-border-color', `hsl(${hue}, 20%, 88%)`);
        const addBtnBgColor = `hsl(${hue}, 40%, 65%)`;
        root.style.setProperty('--add-btn-bg-color', addBtnBgColor);
        root.style.setProperty('--add-btn-text-color', this.getContrastingTextColor(addBtnBgColor, 65));
        root.style.setProperty('--text-color-default', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85));
        root.style.setProperty('--text-color-subtle', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85, true));
        root.style.setProperty('--text-color-error', '#cc0000');
        const accentColor = `hsl(${hue}, 60%, 50%)`;
        root.style.setProperty('--text-color-accent', accentColor);
        root.style.setProperty('--variable-indicator-dependent-color', `hsl(${hue}, 15%, 60%)`);
        root.style.setProperty('--variable-indicator-independent-paused-color', accentColor);
        root.style.setProperty('--variable-indicator-independent-playing-color', 'orange');
        root.style.setProperty('--canvas-bg-color', 'rgb(255, 255, 255)'); 
        root.style.setProperty('--input-range-track-bg', `hsl(${hue}, 20%, 80%)`);
        const overlayBg = `hsla(${hue}, 30%, 95%, 0.85)`;
        root.style.setProperty('--overlay-bg-color', overlayBg);
        root.style.setProperty('--overlay-text-color', this.getContrastingTextColor(overlayBg, 95));
        root.style.setProperty('--switch-off-bg-color', `hsl(${hue}, 15%, 75%)`);
        root.style.setProperty('--switch-on-bg-color', `hsl(${hue}, 70%, 45%)`);
        root.style.setProperty('--axis-number-color', this.getContrastingTextColor(`hsl(${hue}, 30%, 85%)`, 85));
        root.style.setProperty('--menu-bg-color', `hsla(${hue}, 25%, 96%, 0.95)`);
        root.style.setProperty('--keyboard-bg-color', `hsla(${hue}, 25%, 96%, 0.95)`);
    }

    if (!this.isTransparencyEnabled) {
        const canvasBgColor = getComputedStyle(root).getPropertyValue('--canvas-bg-color').trim();
        document.body.style.backgroundColor = canvasBgColor;
    } else {
        document.body.style.backgroundColor = '';
    }

    this.canvas.style.background = getComputedStyle(root).getPropertyValue('--canvas-bg-color').trim();

    this.activeSliders.forEach(slider => {
        if (slider && typeof slider.draw === 'function') {
            slider.draw();
        }
    });

    if (this.explicitPrecisionSlider) this.explicitPrecisionSlider.draw();
    if (this.implicitPrecisionSlider) this.implicitPrecisionSlider.draw();
    if (this.integralPrecisionSlider) this.integralPrecisionSlider.draw();
    if (this.preferredColorSlider) this.preferredColorSlider.draw();

    this.updateEntryVariableValuesDisplay(); 
    this.requestDraw();
}




checkTouchSupport() {
    this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

updateTraceRecording(now) {
        if (!this.traceState.active || !this.traceState.targetName) return;
        if (now - this.traceState.lastRecordTime < 5) return; 

        const targetEntry = this.entries.find(e => e.name === this.traceState.targetName);
        if (targetEntry && targetEntry.isMeaningful) {
            const newPoint = {x: targetEntry.x_val, y: targetEntry.y_val};
            const lastPoint = this.traceState.path[this.traceState.path.length - 1];
            

            if (!lastPoint || Math.abs(newPoint.x - lastPoint.x) > 1e-6 || Math.abs(newPoint.y - lastPoint.y) > 1e-6) {
                this.traceState.path.push(newPoint);
                this.traceState.lastRecordTime = now;

                this.needsRedraw = true;
            }
        }
    }

    animationLoop(now) {
const deltaTime = now - this.lastAnimationTime;
this.updateTraceRecording(now);
this.lastAnimationTime = now;
this.frameCounter++;
if (now - this.lastFPSUpdateTime >= 1000) {
   this.fps = (this.frameCounter / (now - this.lastFPSUpdateTime)) * 1000;
   this.fpsDisplay.textContent = `FPS: ${this.fps.toFixed(0)}`;
   this.lastFPSUpdateTime = now;
   this.frameCounter = 0;
}
let animatedVarsChanged = false;

if (this.isFramePlaying) {
    this.frameAccumulator += deltaTime;
    const msPerFrame = 1000 / this.playbackFPS;
    if (this.frameAccumulator >= msPerFrame) {
        const framesToAdvance = Math.floor(this.frameAccumulator / msPerFrame);
        this.currentFrame += framesToAdvance;
        this.frameAccumulator -= framesToAdvance * msPerFrame;
        
        if (this.currentFrame >= this.totalFrames) {
            this.currentFrame = this.totalFrames;
            this.isFramePlaying = false;
            this.updateGlobalPlayState(); 
            this.updateEntryList();
        } else {
            const frameSliderContainer = document.getElementById('frame-slider-container');
            if (frameSliderContainer && frameSliderContainer.sliderInstance) {
                frameSliderContainer.sliderInstance.setValue(this.currentFrame);
            }
            const valSpan = document.querySelector('.frame-current-value');
            if (valSpan) valSpan.textContent = this.currentFrame;
        }
        this.needsRedraw = true;
    }
}

if (this.globalPlayState === 1) {
   this.entries.forEach(entry => {
       if (entry.type === 'variable' && entry.isEditableIndependent && entry.playState === 1) {
           let { value, min, max, step, playDirection, playMode = 0 } = entry;
           if (!Number.isFinite(min) || !Number.isFinite(max) || !Number.isFinite(step) || step <= 0 || min >= max) {
                entry.playState = 0; this.updateGlobalPlayState(); this.updateEntryList(); animatedVarsChanged = true; return;
           }
           if (!Number.isFinite(value)) { 
               value = (playDirection === 1 || playMode === 1 || playMode === 3) ? min : max; 
               entry.value = value; 
               animatedVarsChanged = true; 
           }
           
           const stepAmount = step * (deltaTime / 1000) * 100;
           let newValue;
           let newDirection = playDirection;
           let valueChanged = false;

           switch (playMode) {
               case 0:  
                   newValue = value + stepAmount * playDirection;
                   if (playDirection === 1) {
                       if (newValue >= max) { 
                           newValue = max; 
                           newDirection = -1; 
                       }
                   } else {
                       if (newValue <= min) { 
                           newValue = min; 
                           newDirection = 1; 
                       }
                   }
                   break;
               
               case 1:
                   entry.playDirection = 1; 
                   newValue = value + stepAmount;
                   if (newValue > max) {
                       newValue = min; 
                   }
                   break;

               case 2:
                   entry.playDirection = -1;
                   newValue = value - stepAmount;
                   if (newValue < min) {
                       newValue = max;
                   }
                   break;

               case 3:
                   entry.playDirection = 1; 
                   newValue = value + stepAmount;
                   if (newValue >= max) {
                       newValue = max;
                       entry.playState = 0; 
                       this.updateGlobalPlayState();
                       this.updateEntryList();
                   }
                   break;

               case 4: 
                   entry.playDirection = -1;
                   newValue = value - stepAmount;
                   if (newValue <= min) {
                       newValue = min;
                       entry.playState = 0;
                       this.updateGlobalPlayState();
                       this.updateEntryList();
                   }
                   break;
               
               default: 
                   newValue = value + stepAmount * playDirection;
                   if (newValue >= max || newValue <= min) newDirection = -playDirection;
                   break;
           }

           if (Math.abs(newValue - value) > 1e-9 || newDirection !== playDirection) {
              entry.value = newValue; 
              entry.playDirection = newDirection; 
              animatedVarsChanged = true;
           }
       }
   });
}
if (animatedVarsChanged) this.recalculateForAnimation();

if (this.isSmoothPanningActive) {
    const smoothDeltaTime = (now - this.lastSmoothPanTime) / 1000;
    this.lastSmoothPanTime = now;

    this.offset.x += this.smoothPanVelocity.x * smoothDeltaTime;
    this.offset.y += this.smoothPanVelocity.y * smoothDeltaTime;

    this.smoothPanVelocity.x *= (1 - this.accsmooth);
    this.smoothPanVelocity.y *= (1 - this.accsmooth);

    const velocityMagnitude = Math.sqrt(this.smoothPanVelocity.x * this.smoothPanVelocity.x + this.smoothPanVelocity.y * this.smoothPanVelocity.y);
    if (velocityMagnitude < 1) {
        this.isSmoothPanningActive = false;
        this.finalizePanInteraction(); 
    }
    this.needsRedraw = true;
} else if (this.isSmoothZoomingActive) {
    const zoomDecayFactor = 0.92;
    this.smoothZoomVelocity = 1.0 + (this.smoothZoomVelocity - 1.0) * zoomDecayFactor;

    const mouseX = this.smoothZoomTarget.x;
    const mouseY = this.smoothZoomTarget.y;
    const mouseXMath = (mouseX - this.offset.x) / this.scale;
    const mouseYMath = (this.offset.y - mouseY) / this.scale;
    let newScale = this.scale * this.smoothZoomVelocity;
    newScale = Math.min(this.maxScale, Math.max(this.minScale, newScale));
    this.offset.x = mouseX - mouseXMath * newScale;
    this.offset.y = mouseY + mouseYMath * newScale;
    this.scale = newScale;

    if (Math.abs(this.smoothZoomVelocity - 1.0) < 0.001) {
        this.isSmoothZoomingActive = false;
        this.handleZoomEnd();
    }
    this.needsRedraw = true;
}


if (this.needsRedraw) { this.draw(); this.needsRedraw = false; }
if (this.globalPlayState === 1 || this.needsRedraw || animatedVarsChanged || this.isResizingSidebar || this.isResizingSidebarTouch || this.isPanning || this.isZooming || this.isSmoothPanningActive || this.isSmoothZoomingActive) {
    this.rafId = requestAnimationFrame(this.animationLoop.bind(this));
} else {
    this.rafId = null;
}
}



requestDraw() {
        this.needsRedraw = true;
        if (!this.rafId) {
            this.lastAnimationTime = performance.now();
            this.rafId = requestAnimationFrame(this.animationLoop.bind(this));
        }
    }

updateGlobalPlayState() {
    const anyPlaying = this.isFramePlaying || this.entries.some(entry => entry.type === 'variable' && entry.isEditableIndependent && entry.playState === 1);
    const newGlobalPlayState = anyPlaying ? 1 : 0;

   if (this.globalPlayState !== newGlobalPlayState) {
            this.globalPlayState = newGlobalPlayState;
            if (this.globalPlayState === 1) {
                if(!this.lastAnimationTime) this.lastAnimationTime = performance.now();
                this.recalculateForAnimation();
                this.requestDraw();
            } else {
                if (this.isAnimatingWithPerformanceMode || this.isUsingLowPrecisionBuffer) { 
                    this.restoreOriginalPrecisions();
                    this.isAnimatingWithPerformanceMode = false;
                    this.isUsingLowPrecisionBuffer = false;
                }
                if (!(this.isPanning || this.dragging) && !this.isZooming && !this.isSmoothPanningActive) { 
                        const cssWidth = this.canvasContainer.clientWidth;
                        const cssHeight = this.canvasContainer.clientHeight;
                        this.processImplicitBlocksOnGrid(cssWidth, cssHeight);
                        if (this.performanceModeEnabled) {
                            this.cleanupUnusedCache(cssWidth, cssHeight);
                        }
                        this.recalculateAll(); 
                } else {
                        this.recalculateAll(); 
                }
            }
        }
    }

exportStateObject() {
        const userCustomFunctions = {};
        const userCalc3 = [];

        for (const funcName in this.calcJSUtils.customFunctions) {
            if (!this.builtinFuncNames.includes(funcName)) {
                userCustomFunctions[funcName] = this.calcJSUtils.customFunctions[funcName];
            }
        }
        this.calcJSUtils.calc3.forEach(funcName => {
            if (!this.builtinFuncNames.includes(funcName)) {
                userCalc3.push(funcName);
            }
        });
        const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        const customAdvancedFunctionsToSave = ADVANCED_FUNCTION_DEFINITIONS
            .filter(def => !defaultAdvancedFunctionNames.has(def.name))
            .map(def => ({
                name: def.name,
                params: def.params,
                bodyJsString: def.bodyJsString
            }));

        const serializableAnnotations = this.annotations.map(anno => {
            const savedAnno = { ...anno };
            delete savedAnno.img;
            delete savedAnno.audioElem;
            delete savedAnno.pdfDoc;
            
            if (anno.type === 'pdf') {

                delete savedAnno.pdfData;
                

                if (!savedAnno.pdfDataBase64 && anno.pdfData) {
                    savedAnno.pdfDataBase64 = this._uint8ArrayToBase64(anno.pdfData);
                }
            }
            return savedAnno;
        });

        const state = {
            entries: this.entries.map(entry => {
                const savedEntry = {
                    type: entry.type,
                    expr: entry.expr,
                    hasLargeOps: entry.hasLargeOps,
                    integralNumSteps: this.integralNumSteps,
                    displayFrame: entry.displayFrame || 0,
                };
                if (entry.type === 'function') {
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;
                    savedEntry.plotType = entry.plotType;

                    savedEntry.extendTo3D = entry.extendTo3D;
                    savedEntry.sliceAxis = entry.sliceAxis;
                    savedEntry.sliceVal = entry.sliceVal;

                    if (entry.plotType === 'implicit') {
                        savedEntry.sign = entry.sign;
                    }
                    if (entry.hasLargeOps) {
                        if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                            savedEntry.largeOpTokensX = entry.largeOpTokensX;
                            savedEntry.largeOpTokensY = entry.largeOpTokensY;
                            if (entry.plotType === 'parametric3d') {
                                savedEntry.largeOpTokensZ = entry.largeOpTokensZ;
                            }
                        } else {
                            savedEntry.largeOpTokens = entry.largeOpTokens;
                        }
                    } else {
                        if (entry.plotType === 'parametric' || entry.plotType === 'parametric3d') {
                            savedEntry.processedExprX = entry.processedExprX;
                            savedEntry.processedExprY = entry.processedExprY;
                            if (entry.plotType === 'parametric3d') {
                                savedEntry.processedExprZ = entry.processedExprZ;
                            }
                        } else {
                            savedEntry.processedExpr = entry.processedExpr;
                        }
                    }
                    if (entry.exprX_raw) savedEntry.exprX_raw = entry.exprX_raw;
                    if (entry.exprY_raw) savedEntry.exprY_raw = entry.exprY_raw;
                    if (entry.exprZ_raw) savedEntry.exprZ_raw = entry.exprZ_raw;

                } else if (entry.type === 'variable') {
                if (entry.isEditableIndependent) {
    savedEntry.showOnPlot = entry.showOnPlot;
    savedEntry.cardX = entry.cardX;
    savedEntry.cardY = entry.cardY;
    savedEntry.cardW = entry.cardW;
    savedEntry.cardH = entry.cardH;
}
                    if (entry.isEditableIndependent) {
                        savedEntry.value = entry.value;
                        savedEntry.min = entry.min;
                        savedEntry.max = entry.max;
                        savedEntry.step = entry.step;
                        savedEntry.playState = entry.playState;
                        savedEntry.playDirection = entry.playDirection;
                        savedEntry.playMode = entry.playMode;
                    } else {
                        savedEntry.value = entry.value;
                        if (entry.hasLargeOps) {
                            savedEntry.largeOpTokens = entry.largeOpTokens;
                        } else {
                            savedEntry.processedExpr = entry.processedExpr;
                        }
                    }
                    savedEntry.name = entry.name;
                    savedEntry.key = entry.key;
                    savedEntry.isEditableIndependent = entry.isEditableIndependent;

                } else if (entry.type === 'custom_function_definition') {
                    savedEntry.name = entry.name;
                    savedEntry.params = entry.params;
                    savedEntry.body = entry.body;
                } else if (entry.type === 'advanced_custom_function_definition') {
                    const defaultNames = ['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim'];
                    if (!defaultNames.includes(entry.name)) {
                        savedEntry.name = entry.name;
                        savedEntry.params = entry.params;
                        savedEntry.bodyJs = entry.bodyJs;
                    } else {
                        return null;
                    }
                } else if (entry.type === 'geometry') {
                    savedEntry.geometryType = entry.geometryType;
                    savedEntry.name = entry.name;
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;

                    if (entry.pointOnObject !== undefined) savedEntry.pointOnObject = entry.pointOnObject;
                    if (entry.onObjectName) savedEntry.onObjectName = entry.onObjectName;
                    if (entry.parameter_expr) savedEntry.parameter_expr = entry.parameter_expr;

                    if (entry.x_expr) savedEntry.x_expr = entry.x_expr;
                    if (entry.y_expr) savedEntry.y_expr = entry.y_expr;
                    if (entry.p1Name) savedEntry.p1Name = entry.p1Name;
                    if (entry.p2Name) savedEntry.p2Name = entry.p2Name;
                    if (entry.p3Name) savedEntry.p3Name = entry.p3Name;
                    if (entry.p4Name) savedEntry.p4Name = entry.p4Name;
                    if (entry.vertexName) savedEntry.vertexName = entry.vertexName;
                    if (entry.lineName) savedEntry.lineName = entry.lineName;
                    if (entry.l1Name) savedEntry.l1Name = entry.l1Name;
                    if (entry.l2Name) savedEntry.l2Name = entry.l2Name;
                    if (entry.pointName) savedEntry.pointName = entry.pointName;
                    if (entry.pointNames) savedEntry.pointNames = entry.pointNames;
                    if (entry.obj1Name) savedEntry.obj1Name = entry.obj1Name;
                    if (entry.obj2Name) savedEntry.obj2Name = entry.obj2Name;
                    if (entry.sign) savedEntry.sign = entry.sign;
                    if (entry.centerName) savedEntry.centerName = entry.centerName;
                    if (entry.pointOnCircleName) savedEntry.pointOnCircleName = entry.pointOnCircleName;
                    if (entry.radius_expr) savedEntry.radius_expr = entry.radius_expr;
                    if (entry.f1Name) savedEntry.f1Name = entry.f1Name;
                    if (entry.f2Name) savedEntry.f2Name = entry.f2Name;
                    if (entry.pName) savedEntry.pName = entry.pName;
                    if (entry.focusName) savedEntry.focusName = entry.focusName;
                    if (entry.directrixName) savedEntry.directrixName = entry.directrixName;
                    if (entry.rotatedPointName) savedEntry.rotatedPointName = entry.rotatedPointName;
                    if (entry.angle_expr) savedEntry.angle_expr = entry.angle_expr;
                    if (entry.axisName) savedEntry.axisName = entry.axisName;
                    if (entry.reflectedPointName) savedEntry.reflectedPointName = entry.reflectedPointName;
                    if (entry.vectorName) savedEntry.vectorName = entry.vectorName;
                    if (entry.translatedPointName) savedEntry.translatedPointName = entry.translatedPointName;
                    if (entry.dx_expr) savedEntry.dx_expr = entry.dx_expr; if (entry.dy_expr) savedEntry.dy_expr = entry.dy_expr; if (entry.a_expr) savedEntry.a_expr = entry.a_expr; if (entry.b_expr) savedEntry.b_expr = entry.b_expr; if (entry.startPointName) savedEntry.startPointName = entry.startPointName; if (entry.endPointName) savedEntry.endPointName = entry.endPointName; if (entry.conicName) savedEntry.conicName = entry.conicName;
                } else if (entry.type === 'constant') {
                    savedEntry.name = entry.name;
                    savedEntry.value = entry.value;
                    if (entry.hasLargeOps) {
                        savedEntry.largeOpTokens = entry.largeOpTokens;
                    } else {
                        savedEntry.processedExpr = entry.processedExpr;
                    }
                } else if (entry.type === 'point_list') {
                    savedEntry.color = entry.color;
                    savedEntry.thickness = entry.thickness;
                    savedEntry.visible = entry.visible;
                } else if (entry.type === 'text') {
                    savedEntry.name = entry.name;
                    savedEntry.content = entry.content;
                    savedEntry.color = entry.color;
                }
                savedEntry.dependencies = entry.dependencies;
                return savedEntry;
            }).filter(e => e !== null),
            name: this.filename,
            version: this.appVersion,
            calcJSCustomFunctions: userCustomFunctions,
            calcJScalc3: userCalc3,
            customAdvancedFunctions: customAdvancedFunctionsToSave,
            scale: this.scale,
            offsetX: this.offset.x,
            offsetY: this.offset.y,
            explicitPrecisionStep: this.explicitPrecisionStep,
            implicitPrecisionStep: this.implicitPrecisionStep,
            highPerformancePlottingEnabled: this.highPerformancePlottingEnabled,
            smoothPanningEnabled: this.smoothPanningEnabled,
            tmin: this.tmin,
            tmax: this.tmax,
            blocks01: Array.from(this.blocks01),
            geometrySnapEnabled: this.geometrySnapEnabled,
            preferredColorValue: this.preferredColorValue,
            originalExplicitPrecision: this.originalExplicitPrecision,
            originalImplicitPrecision: this.originalImplicitPrecision,
            autoBreakpointDetectionEnabled: this.autoBreakpointDetectionEnabled,
            annotations: serializableAnnotations,
            globalScript: document.getElementById('global-script-input').value,
            showPlaybackControls: this.showPlaybackControls,
            currentFrame: this.currentFrame,
            totalFrames: this.totalFrames,
            playbackFPS: this.playbackFPS
        };
        return state;
    }
 saveState() {
        const state = this.exportStateObject();
        const jsonString = JSON.stringify(state, (key, value) => {
            if (key === 'compiledFunc') return undefined;
            return value;
        }, 2);
        const blob = new Blob([jsonString], { type: 'text/plain' });
        const filename = `${this.filename}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }

    getScreenshot() {
        this.draw();
        
        const combinedCanvas = document.createElement('canvas');
        combinedCanvas.width = this.canvas.width;
        combinedCanvas.height = this.canvas.height;
        const ctx = combinedCanvas.getContext('2d');

        ctx.drawImage(this.canvas, 0, 0);

        ctx.drawImage(this.axisCanvas, 0, 0);

        return combinedCanvas.toDataURL('image/png');
    }

importStateObject(loadedState) {
    if (!loadedState || !Array.isArray(loadedState.entries)) {
        throw new Error('存档数据无效');
    }
    this.stopAllAudio();
    this.clearPlotData();
    this.categoryFilterMode = 0;
    this.updateCategoryButtonIcon();

    this.annotations = [];
    
    if (loadedState.name) {
        this.filename = loadedState.name;
    } else {
        const date = new Date();
        this.filename = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    }
    if (this.fileNameDisplay) this.fileNameDisplay.textContent = this.filename;
    this.entries.forEach(entry => entry.webglVertices = null);
    this.entries = [];

    const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
    const defaultDefinitions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => defaultAdvancedFunctionNames.has(def.name));
    ADVANCED_FUNCTION_DEFINITIONS.length = 0;
    Array.prototype.push.apply(ADVANCED_FUNCTION_DEFINITIONS, defaultDefinitions);

    if (loadedState.customAdvancedFunctions && Array.isArray(loadedState.customAdvancedFunctions)) {
        loadedState.customAdvancedFunctions.forEach(customFuncDef => {
            const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === customFuncDef.name);
            if (existingIndex !== -1) {
                ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = customFuncDef;
            } else {
                ADVANCED_FUNCTION_DEFINITIONS.push(customFuncDef);
            }
        });
    }

    this.initializeAdvancedCalcJSFunctions();
    this.calcJSUtils.customFunctions = loadedState.calcJSCustomFunctions || {};
    this.calcJSUtils.calc3 = loadedState.calcJScalc3 || [];
    this.initializeCalcJSBuiltinFunctions();

    this.showPlaybackControls = loadedState.showPlaybackControls || false;
    if (this.showPlaybackControlsToggle) this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
    this.currentFrame = loadedState.currentFrame || 0;
    this.totalFrames = loadedState.totalFrames || 100;
    this.playbackFPS = loadedState.playbackFPS || 10;

    loadedState.entries.forEach(loadedEntry => {
        try {
            const processedEntry = this.loadEntryData(loadedEntry);
            this.entries.push(processedEntry);
        } catch (e) {
            console.warn(`加载存档条目出错: ${e.message}`, loadedEntry);
        }
    });

    this.scale = loadedState.scale;
    this.offset.x = loadedState.offsetX;
    this.offset.y = loadedState.offsetY;
    this.explicitPrecisionStep = loadedState.explicitPrecisionStep ?? 2;
    this.implicitPrecisionStep = loadedState.implicitPrecisionStep ?? 5;
    this.originalExplicitPrecision = loadedState.originalExplicitPrecision ?? this.explicitPrecisionStep;
    this.originalImplicitPrecision = loadedState.originalImplicitPrecision ?? this.implicitPrecisionStep;
    this.highPerformancePlottingEnabled = loadedState.highPerformancePlottingEnabled ?? false;
    this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
    this.smoothPanningEnabled = loadedState.smoothPanningEnabled ?? false;
    this.smoothPanningToggle.checked = this.smoothPanningEnabled;
    this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;
    this.tmin = loadedState.tmin ?? -2 * Math.PI; this.tmax = loadedState.tmax ?? 2 * Math.PI;
    this.integralNumSteps = loadedState.integralNumSteps ?? 100;
    if (this.integralPrecisionSlider) this.integralPrecisionSlider.setValue(this.integralNumSteps, true);
    this.updateIntegralPrecisionLabel();
    this.updateParametricRangeLabels();
    this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep, true);
    this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep, true);
    this.updatePrecisionLabels();
    this.preferredColorValue = loadedState.preferredColorValue ?? 0;
    this.preferredColorSlider.setValue(this.preferredColorValue, true);
    this.updatePreferredColorValueLabel(); this.applyThemeColors();
    this.geometrySnapEnabled = loadedState.geometrySnapEnabled ?? true;
    if (this.geometrySnapToggle) this.geometrySnapToggle.checked = this.geometrySnapEnabled;

    this.autoBreakpointDetectionEnabled = loadedState.autoBreakpointDetectionEnabled ?? false;
    if (this.autoBreakpointDetectionToggle) this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;

    if (Array.isArray(loadedState.blocks01)) {
        this.blocks01.clear(); this.orderedBlocks01ForImplicitProcessing.length = 0;
        this.implictplotindex.length = 0; this.implictplotindex.push(0); this.implictplotdata.length = 0;
        const tempCssWidth = this.canvasContainer.clientWidth || this.canvas.width / (window.devicePixelRatio || 1);
        const tempCssHeight = this.canvasContainer.clientHeight || this.canvas.height / (window.devicePixelRatio || 1);
        const { unitStep: tempUnitStep } = this.calculateGridStep(tempCssWidth, tempCssHeight);
        if (Number.isFinite(tempUnitStep) && tempUnitStep > 0) {
            for (const coordKey of loadedState.blocks01) {
                if (!this.blocks01.has(coordKey)) {
                    this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
                    const parts = coordKey.split(',');
                    if (parts.length === 2) {
                        const cellCenterXMath = parseFloat(parts[0]); const cellCenterYMath = parseFloat(parts[1]);
                        if (Number.isFinite(cellCenterXMath) && Number.isFinite(cellCenterYMath)) this.processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, tempUnitStep);
                    }
                    this.implictplotindex.push(this.implictplotdata.length);
                }
            }
        }
    }

    this.globalScript = loadedState.globalScript || "";
    document.getElementById('global-script-input').value = this.globalScript;
    this.pen.segments = [];
    
    this.annotations = (loadedState.annotations || []).map(a => ({...a}));
    
    this.annotations.forEach(async anno => {
        if (anno.type === 'image' && anno.src) {
            const img = new Image();
            img.onload = () => { anno.img = img; this.requestDraw(); };
            img.src = anno.src;
        } else if (anno.type === 'audio' && anno.src) {
            const audio = new Audio(anno.src);
            anno.audioElem = audio;
            anno.isPlaying = false;
            audio.addEventListener('ended', () => {
                anno.isPlaying = false;
                this.requestDraw();
            });
            audio.addEventListener('timeupdate', () => {
                if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === anno) {
                    this.requestDraw(); 
                }
            });
        } else if (anno.type === 'pdf') {
            if (anno.pdfDataBase64) {
                anno.pdfData = this._base64ToUint8Array(anno.pdfDataBase64);
            }
            if (anno.pdfData) {
                this._restorePdfAnnotation(anno);
            }
        }
    });

    this.updateGlobalPlayState();
    this.recalculateAll();

    if (this.currentUIMode === 'code') this.updateCodeList();
}
loadJsOperator() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt';
    fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const fileContent = event.target.result;
                const newOpData = (new Function('return ' + fileContent))();

                if (!newOpData || typeof newOpData.name !== 'string' || !Array.isArray(newOpData.params) || typeof newOpData.bodyJsString !== 'string') {
                    throw new Error('文件内容不是有效的运算符定义对象。格式应为 { name: "...", params: [...], bodyJsString: "..." }');
                }

              
                newOpData.name = newOpData.name.toLowerCase();
                const { name, params, bodyJsString } = newOpData;
                
                params.forEach(param => {
                    if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                        throw new Error(`参数名 '${param}' 不是有效的JS标识符。`);
                    }
                });

                const finalOp = { name, params, bodyJsString };

                const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === name);
                if (existingIndex !== -1) {
                    ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = finalOp;
                } else {
                    ADVANCED_FUNCTION_DEFINITIONS.push(finalOp);
                }

                this.initializeAdvancedCalcJSFunctions();
                this.recalculateAll();
                this.updateCodeList();
                alert(`成功加载并更新/添加了JS运算符: ${name}`);

            } catch (error) {
                alert('加载js运算符失败: ' + error.message);
            }
        };
        reader.readAsText(file);
    };
    fileInput.click();
}
loadState(stateString) {
    try {
        const loadedState = JSON.parse(stateString);
        if (!loadedState || !Array.isArray(loadedState.entries) || typeof loadedState.scale !== 'number' || typeof loadedState.offsetX !== 'number' || typeof loadedState.offsetY !== 'number') {
            throw new Error('存档文件格式无效');
        }
        this.stopAllAudio();
        this.clearPlotData();

        this.annotations = [];

        if (loadedState.name) {
            this.filename = loadedState.name;
        } else {
            const date = new Date();
            this.filename = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
        }
        if (this.fileNameDisplay) this.fileNameDisplay.textContent = this.filename;
        this.entries.forEach(entry => entry.webglVertices = null);
        this.entries = [];


        const defaultAdvancedFunctionNames = new Set(['gamma', 'erf', 'erfc', 'elliptice', 'elliptick', 'sign', 'sgn', 'heaviside', 'fresnels', 'fresnelc', 'psi', 'lambertw', 'ltw', 'li', 'zeta', 'sinintegral', 'cosintegral', 'expintegral', 'pow', 'range', 'llim', 'ulim']);
        const defaultDefinitions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => defaultAdvancedFunctionNames.has(def.name));
        ADVANCED_FUNCTION_DEFINITIONS.length = 0;
        Array.prototype.push.apply(ADVANCED_FUNCTION_DEFINITIONS, defaultDefinitions);


        if (loadedState.customAdvancedFunctions && Array.isArray(loadedState.customAdvancedFunctions)) {
            loadedState.customAdvancedFunctions.forEach(customFuncDef => {
                const existingIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(def => def.name === customFuncDef.name);
                if (existingIndex !== -1) {
                    ADVANCED_FUNCTION_DEFINITIONS[existingIndex] = customFuncDef;
                } else {
                    ADVANCED_FUNCTION_DEFINITIONS.push(customFuncDef);
                }
            });
        }

        this.initializeAdvancedCalcJSFunctions();
        this.calcJSUtils.customFunctions = loadedState.calcJSCustomFunctions || {};
        this.calcJSUtils.calc3 = loadedState.calcJScalc3 || [];
        this.initializeCalcJSBuiltinFunctions();

        this.showPlaybackControls = loadedState.showPlaybackControls || false;
        if (this.showPlaybackControlsToggle) this.showPlaybackControlsToggle.checked = this.showPlaybackControls;
        this.currentFrame = loadedState.currentFrame || 0;
        this.totalFrames = loadedState.totalFrames || 100;
        this.playbackFPS = loadedState.playbackFPS || 10;

        loadedState.entries.forEach(loadedEntry => {
            try {
                const processedEntry = this.loadEntryData(loadedEntry);
                this.entries.push(processedEntry);
            } catch (e) {
                alert(`加载存档时发现无效或解析失败的条目 "${loadedEntry.expr || '未知表达式'}", 已跳过. Error: ${e.message}`);
            }
        });
        this.scale = loadedState.scale;
        this.offset.x = loadedState.offsetX; this.offset.y = loadedState.offsetY;
        this.explicitPrecisionStep = loadedState.explicitPrecisionStep ?? parseFloat(this.explicitPrecisionSlider.options.value);
        this.implicitPrecisionStep = loadedState.implicitPrecisionStep ?? 5;
        this.originalExplicitPrecision = loadedState.originalExplicitPrecision ?? this.explicitPrecisionStep;
        this.originalImplicitPrecision = loadedState.originalImplicitPrecision ?? this.implicitPrecisionStep;
        this.highPerformancePlottingEnabled = loadedState.highPerformancePlottingEnabled ?? false;
        this.highPerformancePlottingToggle.checked = this.highPerformancePlottingEnabled;
        this.smoothPanningEnabled = loadedState.smoothPanningEnabled ?? false;
        this.smoothPanningToggle.checked = this.smoothPanningEnabled;
        this.lineWidth = this.highPerformancePlottingEnabled ? 1 : 2;
        this.tmin = loadedState.tmin ?? -2 * Math.PI; this.tmax = loadedState.tmax ?? 2 * Math.PI;
        this.integralNumSteps = loadedState.integralNumSteps ?? 100;
        if (this.integralPrecisionSlider) this.integralPrecisionSlider.setValue(this.integralNumSteps, true);
        this.updateIntegralPrecisionLabel();
        this.updateParametricRangeLabels();
        this.explicitPrecisionSlider.setValue(this.explicitPrecisionStep, true);
        this.implicitPrecisionSlider.setValue(20 / this.implicitPrecisionStep, true);
        this.updatePrecisionLabels();
        this.preferredColorValue = loadedState.preferredColorValue ?? 0;
        this.preferredColorSlider.setValue(this.preferredColorValue, true);
        this.updatePreferredColorValueLabel(); this.applyThemeColors();
        this.geometrySnapEnabled = loadedState.geometrySnapEnabled ?? true;
        if (this.geometrySnapToggle) this.geometrySnapToggle.checked = this.geometrySnapEnabled;

        this.autoBreakpointDetectionEnabled = loadedState.autoBreakpointDetectionEnabled ?? false;
        if (this.autoBreakpointDetectionToggle) this.autoBreakpointDetectionToggle.checked = this.autoBreakpointDetectionEnabled;
        this.updateGlobalPlayState();

        if (Array.isArray(loadedState.blocks01) && this.globalPlayState === 0) {
            this.blocks01.clear(); this.orderedBlocks01ForImplicitProcessing.length = 0;
            this.implictplotindex.length = 0; this.implictplotindex.push(0); this.implictplotdata.length = 0;
            const tempCssWidth = this.canvasContainer.clientWidth || this.canvas.width / (window.devicePixelRatio || 1);
            const tempCssHeight = this.canvasContainer.clientHeight || this.canvas.height / (window.devicePixelRatio || 1);
            const { unitStep: tempUnitStep } = this.calculateGridStep(tempCssWidth, tempCssHeight);
            if (Number.isFinite(tempUnitStep) && tempUnitStep > 0) {
                for (const coordKey of loadedState.blocks01) {
                    if (!this.blocks01.has(coordKey)) {
                        this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
                        const parts = coordKey.split(',');
                        if (parts.length === 2) {
                            const cellCenterXMath = parseFloat(parts[0]); const cellCenterYMath = parseFloat(parts[1]);
                            if (Number.isFinite(cellCenterXMath) && Number.isFinite(cellCenterYMath)) this.processSingleBlockForImplicit(cellCenterXMath, cellCenterYMath, tempUnitStep);
                        }
                        this.implictplotindex.push(this.implictplotdata.length);
                    }
                }
            }
        }
        this.globalScript = loadedState.globalScript || "";
        document.getElementById('global-script-input').value = this.globalScript;
        this.pen.segments = [];
        
        // 使用浅拷贝，确保批注对象与存档数据对象分离
        this.annotations = (loadedState.annotations || []).map(a => ({...a}));
        
        this.annotations.forEach(async anno => {
            if (anno.type === 'image' && anno.src) {
                const img = new Image();
                img.onload = () => { anno.img = img; this.requestDraw(); };
                img.src = anno.src;
            } else if (anno.type === 'audio' && anno.src) {
                const audio = new Audio(anno.src);
                anno.audioElem = audio;
                anno.isPlaying = false;
                audio.addEventListener('ended', () => {
                    anno.isPlaying = false;
                    this.requestDraw();
                });
                audio.addEventListener('timeupdate', () => {
                    if (this.selectedAnnotationIndex !== -1 && this.annotations[this.selectedAnnotationIndex] === anno) {
                        this.requestDraw(); 
                    }
                });
            } else if (anno.type === 'pdf') {
                if (anno.pdfDataBase64) {
                    anno.pdfData = this._base64ToUint8Array(anno.pdfDataBase64);
                }
                if (anno.pdfData) {
                    this._restorePdfAnnotation(anno);
                }
            }
        });
        this.recalculateAll();
    } catch (error) { alert('加载存档失败: ' + error.message); }
}
loadEntryData(loadedEntry) {
        if (typeof loadedEntry.type !== 'string' || (loadedEntry.type !== 'advanced_custom_function_definition' && typeof loadedEntry.expr !== 'string') ) {
            throw new Error('条目缺少类型或表达式');
        }
        const entry = { ...loadedEntry }; 
        entry.expanded = entry.expanded === undefined ? false : entry.expanded;
        entry.sliderActive = entry.sliderActive === undefined ? false : entry.sliderActive;
        entry.compilationError = entry.compilationError || undefined;
        entry.webglVertices = null; 
        entry.thickness = loadedEntry.thickness || 3;
        entry.displayFrame = loadedEntry.displayFrame || 0;

        if (entry.type === 'function') {
            entry.color = entry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
            entry.visible = entry.visible !== undefined ? entry.visible : true;
            if (entry.plotType === 'parametric') {
               entry.cachedPoints = [];
            }
        } else if (entry.type === 'variable') {
            entry.name = entry.name || entry.key;
            if (entry.isEditableIndependent) {
               if (!Number.isFinite(entry.min) || !Number.isFinite(entry.max) || entry.min >= entry.max) {
                   const initialValue = Number.isFinite(entry.value) ? entry.value : 0; 
                   const absValue = Math.abs(initialValue);
                   entry.min = (initialValue === 0) ? -10 : -2 * absValue;
                   entry.max = (initialValue === 0) ? 10 : 2 * absValue;
                   if (entry.min >= entry.max) { entry.min = entry.max - 100; if (entry.min >= entry.max) entry.max = entry.min + 200; }
               }
               if (!Number.isFinite(entry.step) || entry.step <= 0) {
                   entry.step = (Number.isFinite(entry.max) && Number.isFinite(entry.min)) ? Math.abs(entry.max - entry.min) / 100 : 0.02;
                   if (!Number.isFinite(entry.step) || entry.step <= 0) entry.step = 0.02;
               }
               if (!Number.isFinite(entry.value)) entry.value = Number.isFinite(entry.min) ? entry.min : 0;
               if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
               if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
               entry.playState = entry.playState === 1 ? 1 : 0;
               entry.playDirection = entry.playDirection === -1 ? -1 : 1;
            } else { 
               entry.min = NaN; entry.max = NaN; entry.step = NaN;
               entry.playState = 0; entry.playDirection = 1;
            }
        } else if (entry.type === 'geometry') {
            const parsed = this.parseGeometryDefinition(entry.expr, -1);
            if (!parsed) {
                throw new Error(`Failed to re-parse geometry expression: ${entry.expr}`);
            }
            parsed.name = entry.name;
            parsed.color = entry.color;
            parsed.thickness = entry.thickness;
            parsed.visible = entry.visible;
            parsed.displayFrame = entry.displayFrame || 0;
            parsed.isMeaningful = false; 
            parsed.expanded = false; 
            return parsed;
        } else if (entry.type === 'constant') {
            entry.name = entry.name || this.autonameConstant();
            entry.value = NaN;  
        } else if (entry.type === 'custom_function_definition') {
            entry.params = entry.params || [];
            entry.body = entry.body || "";
        } else if (entry.type === 'advanced_custom_function_definition') {
           entry.params = entry.params || [];
           entry.bodyJs = entry.bodyJs || "";
           entry.expr = `${entry.name}(${entry.params.join(',')}) { /* JS body */ }`;
           if (!this.calcJSUtils.advancedCustomFunctions[entry.name]) {
               try {
                   const compiledFunc = new Function(...entry.params, entry.bodyJs);
                   this.calcJSUtils.advancedCustomFunctions[entry.name] = {
                       params: entry.params,
                       bodyJsString: entry.bodyJs,
                       compiledFunc: compiledFunc
                   };
                   if (!this.calcJSUtils.advancedCustomFunctionNames.includes(entry.name)) {
                       this.calcJSUtils.advancedCustomFunctionNames.push(entry.name);
                       this.calcJSUtils.advancedCustomFunctionNames.sort((a,b) => b.length - a.length);
                   }
               } catch (e) {
                   console.error(`编译加载的高级函数 ${entry.name} 时出错:`, e);
                   entry.compilationError = e.message;
               }
           }
        } else if (entry.type === 'point_list') {
            const parsed = this.parsePointList(entry.expr);
            Object.assign(entry, parsed);
            entry.color = loadedEntry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
            entry.visible = loadedEntry.visible !== undefined ? loadedEntry.visible : true;
            entry.thickness = loadedEntry.thickness || 3;
            entry.displayFrame = loadedEntry.displayFrame || 0;
        } else if (entry.type === 'text') {
            entry.name = entry.name || this.autonameText();
            entry.content = entry.content || "";
            entry.color = entry.color || { h: 0, s: 0, b: 60, a: 0 };
            entry.expanded = false;
        }
        return entry;
    }


loadBuiltinSave(index) {
    if (index < 0 || index >= BUILTINSAVINGSTRING.length) {
        alert("无效的示例存档索引。");
        return;
    }
    const stateString = BUILTINSAVINGSTRING[index];
    this.loadState(stateString);
}


loadEntryData(loadedEntry) {
if (typeof loadedEntry.type !== 'string' || (loadedEntry.type !== 'advanced_custom_function_definition' && typeof loadedEntry.expr !== 'string') ) {
throw new Error('条目缺少类型或表达式');
}
const entry = { ...loadedEntry }; 
entry.expanded = entry.expanded === undefined ? false : entry.expanded;
entry.sliderActive = entry.sliderActive === undefined ? false : entry.sliderActive;
entry.compilationError = entry.compilationError || undefined;
entry.webglVertices = null; 
entry.dependencies = entry.dependencies || [];
entry.hasLargeOps = entry.hasLargeOps || false;
entry.thickness = loadedEntry.thickness || 3;
entry.displayFrame = loadedEntry.displayFrame || 0;

if (entry.type === 'function') {
entry.color = entry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
entry.visible = entry.visible !== undefined ? entry.visible : true;

entry.extendTo3D = loadedEntry.extendTo3D !== undefined ? loadedEntry.extendTo3D : false;
entry.sliceAxis = loadedEntry.sliceAxis || 'none';
entry.sliceVal = loadedEntry.sliceVal !== undefined ? loadedEntry.sliceVal : 0;

if (entry.plotType === 'implicit') {
    entry.sign = entry.sign || '=';
}
if (entry.plotType === 'parametric') {
   entry.cachedPoints = [];
   if (!entry.exprX_raw && entry.processedExprX) entry.exprX_raw = entry.processedExprX; 
   if (!entry.exprY_raw && entry.processedExprY) entry.exprY_raw = entry.processedExprY; 
}
} else if (entry.type === 'variable') {
entry.name = entry.name || entry.key; 
if (entry.isEditableIndependent) {
   if (!Number.isFinite(entry.min) || !Number.isFinite(entry.max) || entry.min >= entry.max) {
       const initialValue = Number.isFinite(entry.value) ? entry.value : 0; 
       const absValue = Math.abs(initialValue);
       entry.min = (initialValue === 0) ? -10 : -2 * absValue;
       entry.max = (initialValue === 0) ? 10 : 2 * absValue;
       if (entry.min >= entry.max) { entry.min = entry.max - 100; if (entry.min >= entry.max) entry.max = entry.min + 200; }
   }
   if (!Number.isFinite(entry.step) || entry.step <= 0) {
       entry.step = (Number.isFinite(entry.max) && Number.isFinite(entry.min)) ? Math.abs(entry.max - entry.min) / 100 : 0.02;
       if (!Number.isFinite(entry.step) || entry.step <= 0) entry.step = 0.02;
   }
   if (!Number.isFinite(entry.value)) entry.value = Number.isFinite(entry.min) ? entry.min : 0;
   if (Number.isFinite(entry.min) && entry.value < entry.min) entry.value = entry.min;
   if (Number.isFinite(entry.max) && entry.value > entry.max) entry.value = entry.max;
   entry.playState = entry.playState === 1 ? 1 : 0;
   entry.playDirection = entry.playDirection === -1 ? -1 : 1;
   entry.playMode = loadedEntry.playMode !== undefined ? loadedEntry.playMode : 0;
entry.showOnPlot = loadedEntry.showOnPlot || false;
entry.cardX = loadedEntry.cardX !== undefined ? loadedEntry.cardX : 2; // 默认数学坐标 X
entry.cardY = loadedEntry.cardY !== undefined ? loadedEntry.cardY : 2; // 默认数学坐标 Y
entry.cardW = loadedEntry.cardW !== undefined ? loadedEntry.cardW : 220; // 宽高仍保持屏幕像素
entry.cardH = loadedEntry.cardH !== undefined ? loadedEntry.cardH : 110;
} else { 
   entry.min = NaN; entry.max = NaN; entry.step = NaN;
   entry.playState = 0; entry.playDirection = 1;
   entry.playMode = 0;
}
} else if (entry.type === 'geometry') {
    entry.isMeaningful = false; 
    entry.expanded = false;
} else if (entry.type === 'constant') {
    entry.name = entry.name || this.autonameConstant();
    entry.value = NaN;  
}
 else if (entry.type === 'custom_function_definition') {
entry.params = entry.params || [];
entry.body = entry.body || "";
} else if (entry.type === 'advanced_custom_function_definition') {
entry.params = entry.params || [];
entry.bodyJs = entry.bodyJs || "";
entry.expr = `${entry.name}(${entry.params.join(',')}) { /* JS body */ }`;
if (!this.calcJSUtils.advancedCustomFunctions[entry.name]) {
       try {
           const compiledFunc = new Function(...entry.params, entry.bodyJs);
           this.calcJSUtils.advancedCustomFunctions[entry.name] = {
               params: entry.params,
               bodyJsString: entry.bodyJs,
               compiledFunc: compiledFunc
           };
           if (!this.calcJSUtils.advancedCustomFunctionNames.includes(entry.name)) {
               this.calcJSUtils.advancedCustomFunctionNames.push(entry.name);
               this.calcJSUtils.advancedCustomFunctionNames.sort((a,b) => b.length - a.length);
           }
       } catch (e) {
           console.error(`编译加载的高级函数 ${entry.name} 时出错:`, e);
           entry.compilationError = e.message;
       }
   }
} else if (entry.type === 'point_list') {

        const parsed = this.parsePointList(entry.expr);
        Object.assign(entry, parsed);

        entry.color = loadedEntry.color || { h: Math.floor(Math.random() * 101), s: 100, b: 85, a: 0 };
        entry.visible = loadedEntry.visible !== undefined ? loadedEntry.visible : true;
        entry.thickness = loadedEntry.thickness || 3;
        entry.displayFrame = loadedEntry.displayFrame || 0;
    } else if (entry.type === 'text') {
    entry.name = entry.name || this.autonameText();
    entry.content = entry.content || "";
    entry.color = entry.color || { h: 0, s: 0, b: 60, a: 0 };
    entry.expanded = false;
}
return entry;
}

processImplicitBlocksOnGrid(cssWidth, cssHeight) {
if (this.isPanning && this.globalPlayState === 0 && !this.isSmoothPanningActive) return;
const { unitStep } = this.calculateGridStep(cssWidth, cssHeight);
if (!Number.isFinite(unitStep) || unitStep <= 0) return;
if (this.currentUnitStep === 0) this.currentUnitStep = unitStep;
const { x: offsetX, y: offsetY } = this.offset;
const keyPrecision = 6;
const minXMathVisible = (-offsetX) / this.scale; const maxXMathVisible = (cssWidth - offsetX) / this.scale;
const minYMathVisible = (offsetY - cssHeight) / this.scale; const maxYMathVisible = (offsetY) / this.scale;
const startCellX = Math.floor(minXMathVisible / unitStep) * unitStep;
const endCellXLoopLimit = Math.ceil(maxXMathVisible / unitStep) * unitStep;
const startCellY = Math.floor(minYMathVisible / unitStep) * unitStep;
const endCellYLoopLimit = Math.ceil(maxYMathVisible / unitStep) * unitStep;
for (let currentCellX = startCellX; currentCellX < endCellXLoopLimit; currentCellX += unitStep) {
for (let currentCellY = startCellY; currentCellY < endCellYLoopLimit; currentCellY += unitStep) {
   const centerXMath = currentCellX + unitStep / 2; const centerYMath = currentCellY + unitStep / 2;
   const coordKey = `${centerXMath.toFixed(keyPrecision)},${centerYMath.toFixed(keyPrecision)}`;
   if (!this.blocks01.has(coordKey)) {
       this.blocks01.add(coordKey); this.orderedBlocks01ForImplicitProcessing.push(coordKey);
       this.processSingleBlockForImplicit(centerXMath, centerYMath, unitStep);
       this.implictplotindex.push(this.implictplotdata.length);
   }
}
}
}

cleanupUnusedCache(cssWidth, cssHeight) {
if (!this.performanceModeEnabled || this.globalPlayState !== 0) return;
const { unitStep } = this.calculateGridStep(cssWidth, cssHeight);
if (!Number.isFinite(unitStep) || unitStep <= 0) return;
const { x: offsetX, y: offsetY } = this.offset;
const keyPrecision = 6; const bufferCells = 1;
const minXMathVisible = (-offsetX)/this.scale - bufferCells*unitStep; const maxXMathVisible = (cssWidth-offsetX)/this.scale + bufferCells*unitStep;
const minYMathVisible = (offsetY-cssHeight)/this.scale - bufferCells*unitStep; const maxYMathVisible = (offsetY)/this.scale + bufferCells*unitStep;
const visibleBlockKeys = new Set();
const startCellX = Math.floor(minXMathVisible/unitStep)*unitStep; const endCellXLoopLimit = Math.ceil(maxXMathVisible/unitStep)*unitStep;
const startCellY = Math.floor(minYMathVisible/unitStep)*unitStep; const endCellYLoopLimit = Math.ceil(maxYMathVisible/unitStep)*unitStep;
for (let cX = startCellX; cX < endCellXLoopLimit; cX += unitStep) {
for (let cY = startCellY; cY < endCellYLoopLimit; cY += unitStep) {
   const cXM = cX + unitStep/2; const cYM = cY + unitStep/2;
   visibleBlockKeys.add(`${cXM.toFixed(keyPrecision)},${cYM.toFixed(keyPrecision)}`);
}
}
const newOrdBlks = []; const newBlks01Set = new Set();
const newImpPlotData = []; const newImpPlotIdx = [0];
let blksRemoved = false; let curNewDataLen = 0;
for (let i=0; i < this.orderedBlocks01ForImplicitProcessing.length; i++) {
const curBlkKey = this.orderedBlocks01ForImplicitProcessing[i];
if (visibleBlockKeys.has(curBlkKey)) {
   newOrdBlks.push(curBlkKey); newBlks01Set.add(curBlkKey);
   const dataStartIdx = this.implictplotindex[i]; const dataEndIdx = this.implictplotindex[i+1];
   if (dataStartIdx !== undefined && dataEndIdx !== undefined && dataStartIdx < dataEndIdx) {
       const segment = this.implictplotdata.slice(dataStartIdx, dataEndIdx);
       newImpPlotData.push(...segment); curNewDataLen += segment.length;
   }
   newImpPlotIdx.push(curNewDataLen);
} else blksRemoved = true;
}
if (newImpPlotIdx.length === 1 && newOrdBlks.length > 0) {
if (newImpPlotIdx[0] !== newImpPlotData.length) { newImpPlotIdx[0] = 0; newImpPlotIdx[1] = newImpPlotData.length; }
}
if (blksRemoved) {
this.orderedBlocks01ForImplicitProcessing = newOrdBlks; this.blocks01 = newBlks01Set;
this.implictplotdata = newImpPlotData; this.implictplotindex = newImpPlotIdx;
}
}

drawDeveloperGridInfoGL(cssWidth, cssHeight) { }
drawBlocks01ListContentGL(cssWidth, cssHeight) { }


setUIMode(mode) {
        if (!mode) return;
        if (mode === 'file' || mode === 'settings' || mode === 'code') {
            this.stopTracing();
        }
          const sidebarBg = document.getElementById('sidebar-background');
        if (sidebarBg && !this.isPortraitMode && ['plot', 'geometry', 'code'].includes(this.currentUIMode) && !document.body.classList.contains('sidebar-hidden') && !sidebarBg.classList.contains('fullscreen')) {
             this.lastValidSidebarRight = sidebarBg.getBoundingClientRect().right;
        }

        if (this.selectedAnnotationIndex !== -1) {
            this.selectedAnnotationIndex = -1;
            this.updateAnnotationEditMenu();
            this.requestDraw();
        }

        const sidebar = document.getElementById('sidebar');

        const allPanels = {
            plot: document.getElementById('entry-list'),
            geometry: this.geometryPanel,
            code: this.codePanel,
            settings: document.getElementById('settings-panel'),
            file: document.getElementById('file-panel'),
            about: document.getElementById('about-panel'),
        };

        if (this.currentUIMode === mode && !document.body.classList.contains('sidebar-hidden')) {
            return;
        }
        
        document.body.classList.remove('sidebar-hidden');

        Object.values(allPanels).forEach(p => { if (p) p.style.display = 'none'; });

        if (allPanels[mode]) {
            allPanels[mode].style.display = (mode === 'geometry' || mode === 'code') ? 'flex' : 'block';
        } else {
            mode = 'plot';
            allPanels.plot.style.display = 'block';
        }
        
        this.currentUIMode = mode;
        
        const infoModes = ['settings', 'file', 'about', 'code'];
        if (this.isPortraitMode || infoModes.includes(mode)) {
            sidebar.classList.add('fullscreen');
            sidebarBg.classList.add('fullscreen');
        } else {
            sidebar.classList.remove('fullscreen');
            sidebarBg.classList.remove('fullscreen');
        }

        if (mode === 'geometry') {
            if (!this.geometryPanel.innerHTML) {
                this.populateGeometryPanel();
            }
            this.updateGeometryButtonColors();
       } else if (mode === 'code') {
            this.updateCodeList();
            this.hideCodeEditor();
            document.getElementById('global-script-view').style.display = 'none';
            const toggleBtn = document.getElementById('global-script-toggle-btn');
            toggleBtn.style.display = 'flex';
            toggleBtn.textContent = '全局脚本';
        } else {
            this.cancelGeometryInteraction();
        }
        
        this.updateLayout();
        
        setTimeout(() => {
            this.updateOverlayPositions();
            this.updateCanvasPosition();
            this.updateTopBarLayout(); 
        }, 250);

        if (typeof updateKeyboardToggleVisibility === 'function') {
            updateKeyboardToggleVisibility();
        }


        if (typeof window.updateInterfaceState === 'function') {
            window.updateInterfaceState();
        }
    }   
populateGeometryPanel() {
        this.geometryPanel.innerHTML = `
            <div id="geometry-interaction-prompt-container"></div>
            <div class="geo-category">
                <h3>点</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="point">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Im5vbmUiLz48cGF0aCBkPSJNMjMwLjA1LDE4OC44NDg0M2MzLjgsLTIuNSA5LjMsLTQuMyAxNS41LC00LjciIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjMyLjQ1LDE4NS42NDg0M2MwLC0yLjggMi4zLC01LjEgNS4xLC01LjFjMi44LDAgNS4xLDIuMyA1LjEsNS4xYzAsMi44IC0yLjMsNS4xIC01LjEsNS4xYy0yLjgsMC4xIC01LjEsLTIuMiAtNS4xLC01LjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDYuMDUsMTY5LjI0ODQzbDMuOSw5LjZoLTJsLTAuOCwtMi4yaC0zLjdsLTAuOCwyLjJoLTEuOWwzLjcsLTkuNnpNMjQ2LjQ1LDE3NS4wNDg0M2wtMS4zLC0zLjRsLTEuMiwzLjR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="点"></div>
                        <span class="geo-btn-text">点</span>
                    </div>
                    <div class="geo-btn" data-geo-type="intercept">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ2LjY1LDE3Mi43NWwtMTMuNSwxNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni44NSwxODcuMjVsLTEzLjIsLTE0LjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzQuNTUsMTgwLjI1YzAsLTIuOCAyLjMsLTUuMSA1LjEsLTUuMWMyLjgsMCA1LjEsMi4zIDUuMSw1LjFjMCwyLjggLTIuMyw1LjEgLTUuMSw1LjFjLTIuOCwwIC01LjEsLTIuMyAtNS4xLC01LjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="交点"></div>
                        <span class="geo-btn-text">交点</span>
                    </div>
                    <div class="geo-btn" data-geo-type="midpoint">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjMzLjE0NDY0LDE4Ny4ybDE0LjMsLTE0LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDMuMjgwMzUsMTczLjc1MzU4YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjUxOTY1LDE4Ni4yNDY0MmMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNi43MDg5OSwxNzkuOTEwNzJjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="中点"></div>
                        <span class="geo-btn-text">中点</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>线</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="segment">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ0LjEsMTc1LjhsLTguNiw5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQxLjQsMTc1LjJjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzIuNCwxODQuOGMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="线段"></div>
                        <span class="geo-btn-text">线段</span>
                    </div>
                    <div class="geo-btn" data-geo-type="ray">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ4LjE1LDE3MS41NWwtMTMuMiwxMy44IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQwLjg1LDE3NS43NWMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjMgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMS44NSwxODUuMzVjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS4zIC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="射线"></div>
                        <span class="geo-btn-text">射线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="line">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjMzLDE4Ny4ybDE0LjMsLTE0LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yNDEuNCwxNzUuMmMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzMi40LDE4NC44YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="直线"></div>
                        <span class="geo-btn-text">直线</span>
                    </div>
                </div>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="vector">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM1LjIxNzMyLDE4NS4zMTEwMmwxMS44NDEwOCwtMTIuMzM3OTIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzIuODQ1NzUsMTg0LjE1NTU3YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQyLjI4NDAxLDE3Mi43NDQ0M2g0LjI3MDE0IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQ3LjE1NDI1LDE3My4wNzM4OHY0LjQ4MzY1IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="向量"></div>
                        <span class="geo-btn-text">向量</span>
                    </div>
                    <div class="geo-btn" data-geo-type="parallelline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM2LjA1LDE5MC42NWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjI5LjY1LDE4NC4yNWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMwLjM0OTk5LDE3OS42NWMwLC0xLjcgMS40LC0zLjEgMy4xLC0zLjFjMS43LDAgMy4xLDEuNCAzLjEsMy4xYzAsMS43IC0xLjQsMy4xIC0zLjEsMy4xYy0xLjcsMCAtMy4xLC0xLjQgLTMuMSwtMy4xeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="平行线"></div>
                        <span class="geo-btn-text">平行线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="perpendicularline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjM1LjQxMTY2LDE4MS40NDkzNmwyLjQ3OTA2LC0yLjMxMzc5IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjQxLjc1LDE4Ny45bC0xMS45LC0xMS4xIiBzdHJva2U9IiM3OTc5NzkiLz48cGF0aCBkPSJNMjM1Ljg1LDE4N2wxNC4zLC0xNC45IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjM4LjM4NjUzLDE3OC44MDUwMmwyLjY0NDMzLDIuNDc5MDYiIHN0cm9rZT0iIzAwMDAwMCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="垂线"></div>
                        <span class="geo-btn-text">垂线</span>
                    </div>
                </div>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="anglebisector">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjQ2LjM2MDU5LDE3My44NDEyMmwtMTEuNTU1MDMsMTIuMDM5ODUiIHN0cm9rZT0iIzAwMDAwMCIvPjxwYXRoIGQ9Ik0yMzMuODMwOTUsMTg2LjMwMTI2aDEyLjYxNzQyIiBzdHJva2U9IiM3OTc5NzkiLz48cGF0aCBkPSJNMjMzLjU1MTYzLDE4Ni4yMTE4OHYtMTIuNTEzMTUiIHN0cm9rZT0iIzc5Nzk3OSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="角平分线"></div>
                        <span class="geo-btn-text">角平分线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="tangent">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM1LjUzMzgsMTgyLjY1Mzg3YzAsLTMuODg5NzkgMy4xNTMzLC03LjA0MzA5IDcuMDQzMDksLTcuMDQzMDljMy44ODk3OSwwIDcuMDQzMDksMy4xNTMzIDcuMDQzMDksNy4wNDMwOWMwLDMuODg5NzkgLTMuMTUzMyw3LjA0MzA5IC03LjA0MzA5LDcuMDQzMDljLTMuODg5NzksMCAtNy4wNDMwOSwtMy4xNTMzIC03LjA0MzA5LC03LjA0MzA5eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjM4MDAzLDE4NS4yMDMwNWwxNC4zLC0xNC45IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM1LjE5MDIzLDE3Ny45Mjk4NGMwLC0xLjQ3MDUzIDEuMTkyMSwtMi42NjI2MyAyLjY2MjYzLC0yLjY2MjYzYzEuNDcwNTMsMCAyLjY2MjYzLDEuMTkyMSAyLjY2MjYzLDIuNjYyNjNjMCwxLjQ3MDUzIC0xLjE5MjEsMi42NjI2MyAtMi42NjI2MywyLjY2MjYzYy0xLjQ3MDUzLDAgLTIuNjYyNjMsLTEuMTkyMSAtMi42NjI2MywtMi42NjI2M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="切线"></div>
                        <span class="geo-btn-text">切线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="trace">
                        <div class="geo-btn-icon">
                         <img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PHBhdGggZD0iTTIyMy43MzM5NywxOTYuMjY2MDN2LTMyLjUzMjA2aDMyLjUzMjA2djMyLjUzMjA2eiIgZmlsbC1vcGFjaXR5PSIwLjAwNzg0IiBmaWxsPSIjZmZmZmZmIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yNTAuNDY0MzYsMTcyLjU2NjA0YzAuMzAzMTcsMS4yMTI2OCAtMC45MDk1MSwxLjUxNTg1IC0wLjkwOTUxLDEuNTE1ODVsLTAuNTA2NDksMC4wNzg1Yy0xLjgxNTIzLDEuMDM3MjcgLTQuMTE4MDQsMi4zNzMyNiAtNi4yMDA5MSwzLjk2NjQzYzEuMzUyNywyLjIwNjY0IDIuMjg3NTIsNC42Nzk0OCAyLjY5ODU3LDcuMzE1MzdjMC43MDk3Nyw0LjU1MTQ0IC0wLjU2NTQsOC43OTQzNSAtNS43NTg4Niw4LjgzNjQ0Yy00LjEyODEzLC0xLjQyMDUyIC01Ljg2MDIsLTYuNTU0IC00LjQ4ODM0LC0xMC42Nzg4M2MwLjcyNjI5LC0yLjE4Mzc3IDIuMjk1MywtNC4xNTE2MiA0LjE5OTUsLTUuODg2ODljLTEuODQ1OTEsLTIuMzg0MjkgLTQuMjYxMDIsLTQuMjk2OCAtNy4yMDg4OSwtNS41NDc2MmMwLDAgLTEuMTQ4OTMsLTAuNDkyNCAtMC42NTY1MywtMS42NDEzM2MwLjQ5MjQsLTEuMTQ4OTMgMS42NDEzMywtMC42NTY1MyAxLjY0MTMzLC0wLjY1NjUzYzMuMjI4NjUsMS4zOTU2MiA2LjAyOTgyLDMuNTU0MjEgOC4xNTgwMiw2LjIzNjYzYzIuMTI4MzUsLTEuNjI5NTUgNC40MzgwNiwtMy4wMDcwMiA2LjM3NTc2LC00LjExNDI4bDEuMTQwNSwtMC4zMzMyNWMwLDAgMS4yMTI2OCwtMC4zMDMxNyAxLjUxNTg1LDAuOTA5NTF6TTI0MC44ODk1OSwxNzkuNzgwMDljLTEuNDY4MjcsMS4zODYyNyAtMi42NTUwNiwyLjkyNDAxIC0zLjIxMzMsNC41OTI4MmMtMC43ODUyNCwyLjM0NzQyIC0wLjEwNTY2LDYuNjI2OTcgMi41MTEzNCw3LjQzOGMzLjYxNjA2LDAuMDUzOTQgMy40Njk0MywtNC42NTQ4OSAyLjcxMzY2LC03LjI4MTE4Yy0wLjQ4Njc2LC0xLjY5MTQ4IC0xLjE1OTQyLC0zLjI4NTYyIC0yLjAxMTY5LC00Ljc0OTY0eiIgZmlsbD0iIzg0ODQ4NCIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48cGF0aCBkPSJNMjM0LjA5NDczLDE3My4zMjg3M2MwLC0xLjQ3MDUzIDEuMTkyMSwtMi42NjI2MyAyLjY2MjYzLC0yLjY2MjYzYzEuNDcwNTMsMCAyLjY2MjYzLDEuMTkyMSAyLjY2MjYzLDIuNjYyNjNjMCwxLjQ3MDUzIC0xLjE5MjEsMi42NjI2MyAtMi42NjI2MywyLjY2MjYzYy0xLjQ3MDUzLDAgLTIuNjYyNjMsLTEuMTkyMSAtMi42NjI2MywtMi42NjI2M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAzOjE2LjI2NjAzLS0+">
                        </div>
                        <span class="geo-btn-text">轨迹</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>圆锥曲线</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="circle_pr">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzEuNDUsMTgwLjZjMCwtNC41IDMuNywtOC4yIDguMiwtOC4yYzQuNSwwIDguMiwzLjcgOC4yLDguMmMwLDQuNSAtMy43LDguMiAtOC4yLDguMmMtNC41LDAgLTguMiwtMy42IC04LjIsLTguMnoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjM2LjU1MDAxLDE4MC43YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDIuMzUwMDEsMTc0LjNjMCwtMS43IDEuNCwtMy4xIDMuMSwtMy4xYzEuNywwIDMuMSwxLjQgMy4xLDMuMWMwLDEuNyAtMS40LDMuMSAtMy4xLDMuMWMtMS43LDAgLTMuMSwtMS40IC0zLjEsLTMuMXoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆(圆心与一点)"></div>
                        <span class="geo-btn-text">圆(圆心与一点)</span>
                    </div>
                    <div class="geo-btn" data-geo-type="circle_cr">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM2LjU1MDAxLDE4MC43YzAsLTEuNyAxLjQsLTMuMSAzLjEsLTMuMWMxLjcsMCAzLjEsMS40IDMuMSwzLjFjMCwxLjcgLTEuNCwzLjEgLTMuMSwzLjFjLTEuNywwIC0zLjEsLTEuNCAtMy4xLC0zLjF6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5LjgxMjY3LDE4MC43Njg3Mmg3LjE3NDk4IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjMxLjQ1LDE4MC42YzAsLTQuNSAzLjcsLTguMiA4LjIsLTguMmM0LjUsMCA4LjIsMy43IDguMiw4LjJjMCw0LjUgLTMuNyw4LjIgLTguMiw4LjJjLTQuNSwwIC04LjIsLTMuNiAtOC4yLC04LjJ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆(圆心与半径)"></div>
                        <span class="geo-btn-text">圆(圆心与半径)</span>
                    </div>
                     <div class="geo-btn" data-geo-type="circulararc">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yMzEuNzU0NDMsMTgwLjI0ODUyYzAsLTQuNTA2NDYgMy42NTMyMSwtOC4xNTk2OCA4LjE1OTY4LC04LjE1OTY4YzQuNTA2NDYsMCA4LjE1OTY4LDMuNjUzMjEgOC4xNTk2OCw4LjE1OTY4YzAsNC41MDY0NiAtMy42NTMyMSw4LjE1OTY4IC04LjE1OTY4LDguMTU5NjhjLTQuNTA2NDYsMCAtOC4xNTk2OCwtMy42NTMyMSAtOC4xNTk2OCwtOC4xNTk2OHoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjQ0Ljk4MTcsMTgwLjU5MjA5YzAsLTEuNDcwNTMgMS4xOTIxLC0yLjY2MjYzIDIuNjYyNjMsLTIuNjYyNjNjMS40NzA1MywwIDIuNjYyNjMsMS4xOTIxIDIuNjYyNjMsMi42NjI2M2MwLDEuNDcwNTMgLTEuMTkyMSwyLjY2MjYzIC0yLjY2MjYzLDIuNjYyNjNjLTEuNDcwNTMsMCAtMi42NjI2MywtMS4xOTIxIC0yLjY2MjYzLC0yLjY2MjYzeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48cGF0aCBkPSJNMjM1LjQwNTE0LDE3My40NzcyNmMxLjI5NTQsLTAuODY1NDkgMi44NTI0MSwtMS4zNzAxMSA0LjUyNzI3LC0xLjM3MDExYzQuNTA2NDYsMCA4LjE1OTY4LDMuNjUzMjEgOC4xNTk2OCw4LjE1OTY4YzAsMC4wNDQxOSAtMC4wMDAzNSwwLjA4ODMgLTAuMDAxMDUsMC4xMzIzMyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMzIuOTc1MjEsMTczLjU2NzNjMCwtMS40NzA1MyAxLjE5MjEsLTIuNjYyNjMgMi42NjI2MywtMi42NjI2M2MxLjQ3MDUzLDAgMi42NjI2MywxLjE5MjEgMi42NjI2MywyLjY2MjYzYzAsMS40NzA1MyAtMS4xOTIxLDIuNjYyNjMgLTIuNjYyNjMsMi42NjI2M2MtMS40NzA1MywwIC0yLjY2MjYzLC0xLjE5MjEgLTIuNjYyNjMsLTIuNjYyNjN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjxwYXRoIGQ9Ik0yMzcuMTE2MywxODAuMTEzMzVjMCwtMS40NzA1MyAxLjE5MjEsLTIuNjYyNjMgMi42NjI2MywtMi42NjI2M2MxLjQ3MDUzLDAgMi42NjI2MywxLjE5MjEgMi42NjI2MywyLjY2MjYzYzAsMS40NzA1MyAtMS4xOTIxLDIuNjYyNjMgLTIuNjYyNjMsMi42NjI2M2MtMS40NzA1MywwIC0yLjY2MjYzLC0xLjE5MjEgLTIuNjYyNjMsLTIuNjYyNjN6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="圆弧"></div>
                        <span class="geo-btn-text">圆弧</span>
                    </div>
                </div>
                 <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="ellipse">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yNTEuNTIxMDksMTgwLjU3NTdjMCw0LjY5MTMxIC01LjE1ODE2LDguNDk0MzYgLTExLjUyMTA4LDguNDk0MzZjLTYuMzYyOTIsMCAtMTEuNTIxMDgsLTMuODAzMDYgLTExLjUyMTA4LC04LjQ5NDM2YzAsLTQuNjkxMyA1LjE1ODE2LC04LjQ5NDM2IDExLjUyMTA5LC04LjQ5NDM2YzYuMzYyOTIsMCAxMS41MjEwOSwzLjgwMzA2IDExLjUyMTA5LDguNDk0MzZ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMy42OTc0OCwxODAuNTMwNDhjMCwtMS4wMDM5NSAwLjgyNjc4LC0xLjgzMDczIDEuODMwNzMsLTEuODMwNzNjMS4wMDM5NSwwIDEuODMwNzMsMC44MjY3OCAxLjgzMDczLDEuODMwNzNjMCwxLjAwMzk1IC0wLjgyNjc3LDEuODMwNzMgLTEuODMwNzMsMS44MzA3M2MtMS4wMDM5NSwwIC0xLjgzMDczLC0wLjgyNjc3IC0xLjgzMDczLC0xLjgzMDczeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQyLjYwMjk0LDE4MC42NDg2NmMwLC0xLjAwMzk1IDAuODI2NzgsLTEuODMwNzMgMS44MzA3MywtMS44MzA3M2MxLjAwMzk1LDAgMS44MzA3MywwLjgyNjc4IDEuODMwNzMsMS44MzA3M2MwLDEuMDAzOTUgLTAuODI2NzcsMS44MzA3MyAtMS44MzA3MywxLjgzMDczYy0xLjAwMzk1LDAgLTEuODMwNzMsLTAuODI2NzcgLTEuODMwNzMsLTEuODMwNzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yNDQuMDg4MDMsMTczLjM0NjQ5YzAsLTEuMzI1MjEgMS4wOTEzNCwtMi40MTY1NSAyLjQxNjU0LC0yLjQxNjU1YzEuMzI1MjEsMCAyLjQxNjU1LDEuMDkxMzQgMi40MTY1NSwyLjQxNjU1YzAsMS4zMjUyMSAtMS4wOTEzNCwyLjQxNjU0IC0yLjQxNjU1LDIuNDE2NTRjLTEuMzI1MjEsMCAtMi40MTY1NCwtMS4wOTEzMyAtMi40MTY1NCwtMi40MTY1NHoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="椭圆"></div>
                        <span class="geo-btn-text">椭圆</span>
                    </div>
                    <div class="geo-btn" data-geo-type="hyperbola">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzEuODE1MTEsMTcyLjMwMTM0YzMuMjUyNTEsMS4wOTA0NCA1LjYyMTc0LDQuMTc5MTEgNS42MjE3NCw3Ljc4MDA1YzAsMy43Mjk2NSAtMi41NDE2Miw2LjkwOTc1IC01Ljk3MzgyLDcuODg5MjUiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjQ4Ljc2NTA5LDE4Ny42MjMyOGMtMy4xNzI3MywtMS4xMTI0OSAtNS40NjcxNywtNC4xMTQ3NiAtNS40NjcxNywtNy43MzcxNmMwLC0zLjY4OTM4IDIuNDg3MDUsLTYuODQxMDMgNS44NjI5OCwtNy44NTY3NiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMjkuNzEzNDYsMTgwLjM0NTMzYzAsLTEuMDAzOTUgMC44MjY3OCwtMS44MzA3MyAxLjgzMDczLC0xLjgzMDczYzEuMDAzOTUsMCAxLjgzMDczLDAuODI2NzggMS44MzA3MywxLjgzMDczYzAsMS4wMDM5NSAtMC44MjY3OCwxLjgzMDczIC0xLjgzMDczLDEuODMwNzNjLTEuMDAzOTUsMCAtMS44MzA3MywtMC44MjY3OCAtMS44MzA3MywtMS44MzA3M3oiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTI0Ni42MjUwOSwxODAuMjY4MjRjMCwtMS4wMDM5NSAwLjgyNjc4LC0xLjgzMDczIDEuODMwNzMsLTEuODMwNzNjMS4wMDM5NSwwIDEuODMwNzMsMC44MjY3OCAxLjgzMDczLDEuODMwNzNjMCwxLjAwMzk1IC0wLjgyNjc4LDEuODMwNzMgLTEuODMwNzMsMS44MzA3M2MtMS4wMDM5NSwwIC0xLjgzMDczLC0wLjgyNjc4IC0xLjgzMDczLC0xLjgzMDczeiIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQzLjYxODkxLDE3NC4zMzI5N2MwLC0xLjExMTAzIDAuOTE0OTcsLTIuMDI2IDIuMDI2LC0yLjAyNmMxLjExMTAzLDAgMi4wMjYsMC45MTQ5NyAyLjAyNiwyLjAyNmMwLDEuMTExMDMgLTAuOTE0OTcsMi4wMjYgLTIuMDI2LDIuMDI2Yy0xLjExMTAzLDAgLTIuMDI2LC0wLjkxNDk3IC0yLjAyNiwtMi4wMjZ6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="双曲线"></div>
                        <span class="geo-btn-text">双曲线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="parabola">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ2LjI2OCwxODguMTk4NTFjLTQuMzk4MDEsLTAuMTE3MjcgLTcuOTc1NzMsLTMuNjczNjYgLTcuOTc1NzMsLTguMTk3MDFjMCwtNC41IDMuNywtOC4yIDguMiwtOC4yYzAuMDU1NTUsMCAwLjExMDk4LDAuMDAwNTcgMC4xNjYyOCwwLjAwMTY5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzMuMzQxNDYsMTcyLjExNDYxdjE2LjAxMjM2IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjQxLjYzNDgzLDE4MC4xOTkxM2MwLC0xLjAwMzk1IDAuODI2NzgsLTEuODMwNzMgMS44MzA3MywtMS44MzA3M2MxLjAwMzk1LDAgMS44MzA3MywwLjgyNjc4IDEuODMwNzMsMS44MzA3M2MwLDEuMDAzOTUgLTAuODI2NzgsMS44MzA3MyAtMS44MzA3MywxLjgzMDczYy0xLjAwMzk1LDAgLTEuODMwNzMsLTAuODI2NzggLTEuODMwNzMsLTEuODMwNzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="抛物线"></div>
                        <span class="geo-btn-text">抛物线</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>度量</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="length">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48cGF0aCBkPSJNMjM2LjAwMDAxLDE4My44bDguNiwtOSIgc3Ryb2tlPSIjNzk3OTc5Ii8+PHBhdGggZD0iTTI0Mi4zLDE3Mi42bDUsNC43IiBzdHJva2U9IiMwMDAwMDAiLz48cGF0aCBkPSJNMjM3LjcsMTg3LjRsLTUsLTQuNyIgc3Ryb2tlPSIjMDAwMDAwIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="长度"></div>
                        <span class="geo-btn-text">长度</span>
                    </div>
                    <div class="geo-btn" data-geo-type="angle">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ5LjAwMDYxLDE4My40NjE3N2wtMTQuMDk4ODYsMC4yNTE3N2wxMC44MjU5MSwtMTEuMzI5NDQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzAuOTk5MzksMTgzLjcxMzU0YzAsLTIuMTQwMDEgMS43NjIzNiwtMy45MDIzNiAzLjkwMjM2LC0zLjkwMjM2YzIuMTQwMDEsMCAzLjkwMjM2LDEuNzYyMzYgMy45MDIzNiwzLjkwMjM2YzAsMi4xNDAwMSAtMS43NjIzNiwzLjkwMjM2IC0zLjkwMjM2LDMuOTAyMzZjLTIuMTQwMDEsMCAtMy45MDIzNiwtMS43NjIzNiAtMy45MDIzNiwtMy45MDIzNnoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="角度"></div>
                        <span class="geo-btn-text">角度</span>
                    </div>
                    <div class="geo-btn" data-geo-type="area">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTIzMi43MDU5NywxODYuMzc2NDdoMTQuNDUzMzQiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0Ny4yOTQwMywxNzMuNjIzNTN2MTIuNzUyOTUiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMi43NjE4NCwxODYuNDAwODdsMTMuNjM4NjIsLTEyLjgwMTc0IiBzdHJva2Utd2lkdGg9IjIuNSIvPjxwYXRoIGQ9Ik0yMzcuNzcyNDMsMTgzLjA1ODExbDEuOTc4NzgsMi41MTg0NCIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTI0MC42NTA2NSwxODAuMzU5NzhsMy4yMzgsNS4yMTY3NyIgc3Ryb2tlLXdpZHRoPSIyIi8+PHBhdGggZD0iTTI0My4xNjkwOSwxNzYuNzYybDMuMjM3OTksNS4wMzY4OSIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="面积"></div>
                        <span class="geo-btn-text">面积</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>判定</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="isparallel">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzYuMjQ1NTMsMTkwLjA0NDNsMTMuNTkyMTgsLTE0LjE2MjQ4IiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTIzMC4xNjIyOSwxODMuOTYxMDlsMTMuNTkyMTgsLTE0LjE2MjQ4IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0OS44Mzc3MSwxNzYuMDM4OTFsLTEzLjU5MjE4LDE0LjE2MjQ4IiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0My43NTQ1MSwxNjkuOTU1N2wtMTMuNTkyMTgsMTQuMTYyNDgiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjM2LjM5Mjc4LDE3My44OTMyN2gzLjExNjQ2IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIvPjxwYXRoIGQ9Ik0yMzkuNzA0MDIsMTc0LjQ3NzZ2Mi45MjE2OSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="平行"></div>
                        <span class="geo-btn-text">平行</span>
                    </div>
                    <div class="geo-btn" data-geo-type="isperpendicular">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48ZyBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIj48cGF0aCBkPSJNMjM4Ljg3NDIzLDE4MS4xOTMzbDEuODc4NzQsLTIuNDkyMzciLz48cGF0aCBkPSJNMjQxLjMzNzcxLDE3OC44OTc0MWwyLjMzNjYsMS43NjEzMiIvPjwvZz48cGF0aCBkPSJNMjQ1LjcyNTAyLDE4Ny41MTQ0bC0xNS44NzA3NywtMTEuNjAxODMiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48cGF0aCBkPSJNMjUwLjE0NTc1LDE3MS45MjIxN2wtMTEuMjAxNzMsMTYuMTU1NjYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyLjUiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="垂直"></div>
                        <span class="geo-btn-text">垂直</span>
                    </div>
                    <div class="geo-btn" data-geo-type="isconcyclic">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxnPjxwYXRoIGQ9Ik0yMzIuMjg2NzMsMTc5LjY3ODg0YzAsLTQuNSAzLjcsLTguMiA4LjIsLTguMmM0LjUsMCA4LjIsMy43IDguMiw4LjJjMCw0LjUgLTMuNyw4LjIgLTguMiw4LjJjLTQuNSwwIC04LjIsLTMuNiAtOC4yLC04LjJ6IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41Ii8+PHBhdGggZD0iTTI0My45MzY2LDE3My43Mzk2NWMwLC0xLjExNjMyIDAuOTE5MzMsLTIuMDM1NjUgMi4wMzU2NiwtMi4wMzU2NWMxLjExNjMyLDAgMi4wMzU2NSwwLjkxOTMzIDIuMDM1NjUsMi4wMzU2NWMwLDEuMTE2MzIgLTAuOTE5MzMsMi4wMzU2NSAtMi4wMzU2NSwyLjAzNTY1Yy0xLjExNjMyLDAgLTIuMDM1NjYsLTAuOTE5MzMgLTIuMDM1NjYsLTIuMDM1NjV6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Ik0yMzEuMzEzMjcsMTc1Ljg3MDc0YzAsLTEuMTE2MzIgMC45MTkzMywtMi4wMzU2NSAyLjAzNTY2LC0yLjAzNTY1YzEuMTE2MzIsMCAyLjAzNTY1LDAuOTE5MzMgMi4wMzU2NSwyLjAzNTY1YzAsMS4xMTYzMiAtMC45MTkzMiwyLjAzNTY1IC0yLjAzNTY1LDIuMDM1NjVjLTEuMTE2MzIsMCAtMi4wMzU2NiwtMC45MTkzMyAtMi4wMzU2NiwtMi4wMzU2NXoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTTIzMy42NDkyOCwxODYuMTk4NzJjMCwtMS4xMTYzMiAwLjkxOTMzLC0yLjAzNTY1IDIuMDM1NjUsLTIuMDM1NjVjMS4xMTYzMiwwIDIuMDM1NjUsMC45MTkzMiAyLjAzNTY1LDIuMDM1NjVjMCwxLjExNjMyIC0wLjkxOTMzLDIuMDM1NjUgLTIuMDM1NjUsMi4wMzU2NWMtMS4xMTYzMiwwIC0yLjAzNTY1LC0wLjkxOTMzIC0yLjAzNTY1LC0yLjAzNTY1eiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNMjQzLjE1NzU3LDE4Ni40ODU1MWMwLC0xLjExNjMyIDAuOTE5MzMsLTIuMDM1NjUgMi4wMzU2NSwtMi4wMzU2NWMxLjExNjMyLDAgMi4wMzU2NSwwLjkxOTMzIDIuMDM1NjUsMi4wMzU2NWMwLDEuMTE2MzIgLTAuOTE5MzMsMi4wMzU2NSAtMi4wMzU2NSwyLjAzNTY1Yy0xLjExNjMyLDAgLTIuMDM1NjUsLTAuOTE5MzMgLTIuMDM1NjUsLTIuMDM1NjV6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="共圆"></div>
                        <span class="geo-btn-text">共圆</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>变换</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="rotate">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjM2LjE1OTc1LDE4MS4yNTk0MmMxLjc0MDczLDEuMzgxMDcgMi44ODg0OSwzLjQ4MzQxIDIuOTc0NDcsNS44MzgyIiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzQuNTAzMjgsMTg3LjUyNzMxbDEzLjQ3ODAyLC0wLjE5NTMzIiBmaWxsPSJub25lIiBzdHJva2U9IiNhZmFmYWYiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM5LjU4MTk2LDE3NC4wNDkyOGwtNi40NDYwMSwxMC45Mzg2OSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjYWZhZmFmIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0NC41MjYzOCwxODYuOTUzOThjMCwtMS42MjA0NSAxLjMzNDQ5LC0yLjk1NDk0IDIuOTU0OTQsLTIuOTU0OTRjMS42MjA0NSwwIDIuOTU0OTQsMS4zMzQ0OSAyLjk1NDk0LDIuOTU0OTRjMCwxLjYyMDQ1IC0xLjMzNDQ5LDIuOTU0OTQgLTIuOTU0OTQsMi45NTQ5NGMtMS42MjA0NSwwIC0yLjk1NDk0LC0xLjMzNDQ5IC0yLjk1NDk0LC0yLjk1NDk0eiIgZmlsbD0iIzc5Nzk3OSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTIzNi45ODY0LDE3Mi45Njc5OWMwLC0xLjYyMDQ1IDEuMzM0NDksLTIuOTU0OTQgMi45NTQ5NCwtMi45NTQ5NGMxLjYyMDQ1LDAgMi45NTQ5NCwxLjMzNDQ5IDIuOTU0OTQsMi45NTQ5NGMwLDEuNjIwNDUgLTEuMzM0NDksMi45NTQ5NCAtMi45NTQ5NCwyLjk1NDk0Yy0xLjYyMDQ1LDAgLTIuOTU0OTQsLTEuMzM0NDkgLTIuOTU0OTQsLTIuOTU0OTR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI5LjU2MzczLDE4Ny4wMzIwMWMwLC0xLjYyMDQ1IDEuMzM0NDksLTIuOTU0OTQgMi45NTQ5NCwtMi45NTQ5NGMxLjYyMDQ1LDAgMi45NTQ5NCwxLjMzNDQ5IDIuOTU0OTQsMi45NTQ5NGMwLDEuNjIwNDUgLTEuMzM0NDksMi45NTQ5NCAtMi45NTQ5NCwyLjk1NDk0Yy0xLjYyMDQ1LDAgLTIuOTU0OTQsLTEuMzM0NDkgLTIuOTU0OTQsLTIuOTU0OTR6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTYuMjY2MDI5NjM3NTcxOTY6MTYuMjY2MDI5NjM3NTcxOTYtLT4=" alt="旋转"></div>
                        <span class="geo-btn-text">旋转</span>
                    </div>
                    <div class="geo-btn" data-geo-type="reflect">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQ1LjUyMzg5LDE4MC4wNTkwOGMwLC0xLjY1NTk4IDEuMzYzNzUsLTMuMDE5NzMgMy4wMTk3MywtMy4wMTk3M2MxLjY1NTk4LDAgMy4wMTk3MywxLjM2Mzc1IDMuMDE5NzMsMy4wMTk3M2MwLDEuNjU1OTggLTEuMzYzNzUsMy4wMTk3MyAtMy4wMTk3MywzLjAxOTczYy0xLjY1NTk4LDAgLTMuMDE5NzMsLTEuMzYzNzUgLTMuMDE5NzMsLTMuMDE5NzN6IiBmaWxsPSIjNzk3OTc5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI4LjQzNjY1LDE4MC4xMzg4MmMwLC0xLjY1NTk4IDEuMzYzNzUsLTMuMDE5NzMgMy4wMTk3MywtMy4wMTk3M2MxLjY1NTk4LDAgMy4wMTk3MywxLjM2Mzc1IDMuMDE5NzMsMy4wMTk3M2MwLDEuNjU1OTggLTEuMzYzNzUsMy4wMTk3MyAtMy4wMTk3MywzLjAxOTczYy0xLjY1NTk4LDAgLTMuMDE5NzMsLTEuMzYzNzUgLTMuMDE5NzMsLTMuMDE5NzN6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjM5Ljg3MjMzLDE3MS40MTY1MXYxNy4xNjY5OCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzk3OTc5IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjE2LjI2NjAyOTYzNzU3MTk2OjE2LjI2NjAyOTYzNzU3MTk2LS0+" alt="对称"></div>
                        <span class="geo-btn-text">对称</span>
                    </div>
                    <div class="geo-btn" data-geo-type="translate">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48ZyBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxwYXRoIGQ9Ik0yMzQuMTM2MDYsMTg1LjYxNTM1bDExLjMyMTc2LC0xMS4xMTIxIi8+PHBhdGggZD0iTTI0MS44OTM1NiwxNzQuMjkzNTloMy43NzM5MiIvPjxwYXRoIGQ9Ik0yNDUuNjY3NDgsMTc0LjUwMzI1djQuMTkzMjQiLz48L2c+PHBhdGggZD0iTTI0NC4wNjA0MiwxNzMuODc3OTJjMCwtMS4zNzIxIDEuMTI5OTcsLTIuNTAyMDYgMi41MDIwNiwtMi41MDIwNmMxLjM3MjEsMCAyLjUwMjA2LDEuMTI5OTcgMi41MDIwNiwyLjUwMjA2YzAsMS4zNzIxIC0xLjEyOTk3LDIuNTAyMDYgLTIuNTAyMDYsMi41MDIwNmMtMS4zNzIxLDAgLTIuNTAyMDYsLTEuMTI5OTcgLTIuNTAyMDYsLTIuNTAyMDZ6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMwLjkzNTQ1LDE4Ni4xMjIwOGMwLC0xLjM3MjEgMS4xMjk5NywtMi41MDIwNiAyLjUwMjA2LC0yLjUwMjA2YzEuMzcyMSwwIDIuNTAyMDYsMS4xMjk5NyAyLjUwMjA2LDIuNTAyMDZjMCwxLjM3MjEgLTEuMTI5OTcsMi41MDIwNiAtMi41MDIwNiwyLjUwMjA2Yy0xLjM3MjEsMCAtMi41MDIwNiwtMS4xMjk5NyAtMi41MDIwNiwtMi41MDIwNnoiIGZpbGw9IiM3OTc5NzkiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="平移"></div>
                        <span class="geo-btn-text">平移</span>
                    </div>
                </div>
            </div>
            <div class="geo-category">
                <h3>其他</h3>
                <div class="geo-btn-row">
                    <div class="geo-btn" data-geo-type="polygon">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ3LjU5Mzg4LDE3OS44NDczMWwtMy44OTM1Miw3LjM3NzIxbC0xMC4wNDEyLC0xLjIyOTUzbC0xLjIyOTUzLC05LjAxNjU4bDkuMDE2NTgsLTQuNzEzMjJsNS4zMjc5OCw1LjMyNzk5IiBmaWxsPSJub25lIiBzdHJva2U9IiM3OTc5NzkiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjM4Ljk4OTIyLDE3Mi4yMzM1NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQ1LjIxODc2LDE3OC40NjMwOGMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQwLjk5NzI1LDE4Ny43NjY0NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMxLjI0Mjg0LDE4NS43OTkwOWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjI5Ljg5MDI1LDE3Ni42NTk0NWMwLC0xLjM0MTA4IDEuMTA0NDIsLTIuNDQ1NSAyLjQ0NTUsLTIuNDQ1NWMxLjM0MTA4LDAgMi40NDU1LDEuMTA0NDIgMi40NDU1LDIuNDQ1NWMwLDEuMzQxMDggLTEuMTA0NDIsMi40NDU1IC0yLjQ0NTUsMi40NDU1Yy0xLjM0MTA4LDAgLTIuNDQ1NSwtMS4xMDQ0MiAtMi40NDU1LC0yLjQ0NTV6IiBmaWxsPSIjNTI1MjUyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="多边形"></div>
                        <span class="geo-btn-text">多边形</span>
                    </div>
                    <div class="geo-btn" data-geo-type="fitline">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIzMi41MzIwNiIgaGVpZ2h0PSIzMi41MzIwNiIgdmlld0JveD0iMCwwLDMyLjUzMjA2LDMyLjUzMjA2Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjczMzk3LC0xNjMuNzMzOTcpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjMuNzMzOTcsMTk2LjI2NjAzdi0zMi41MzIwNmgzMi41MzIwNnYzMi41MzIwNnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48Zz48cGF0aCBkPSJNMjQwLjgzNTYyLDE3My44ODQyNmMwLC0wLjgzOTE2IDAuNjkxMDcsLTEuNTMwMjQgMS41MzAyNCwtMS41MzAyNGMwLjgzOTE2LDAgMS41MzAyNCwwLjY5MTA4IDEuNTMwMjQsMS41MzAyNGMwLDAuODM5MTYgLTAuNjkxMDgsMS41MzAyNCAtMS41MzAyNCwxLjUzMDI0Yy0wLjgzOTE2LDAgLTEuNTMwMjQsLTAuNjkxMDcgLTEuNTMwMjQsLTEuNTMwMjR6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjMzLjMwNDYyLDE4Ni40ODE4NWwxNS4yMjc4NCwtMTIuMTM4MTMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc5Nzk3OSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0yMzYuMDIwODEsMTc3Ljk2MTQyYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzEuNDY3NTQsMTgxLjkwNzgyYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yMzcuODk4NDUsMTg2LjExNTc1YzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0yNDMuODA2MzEsMTgxLjQzMTcxYzAsLTAuODM5MTYgMC42OTEwNywtMS41MzAyNCAxLjUzMDI0LC0xLjUzMDI0YzAuODM5MTYsMCAxLjUzMDI0LDAuNjkxMDggMS41MzAyNCwxLjUzMDI0YzAsMC44MzkxNiAtMC42OTEwOCwxLjUzMDI0IC0xLjUzMDI0LDEuNTMwMjRjLTAuODM5MTYsMCAtMS41MzAyNCwtMC42OTEwNyAtMS41MzAyNCwtMS41MzAyNHoiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjwvZz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNi4yNjYwMjk2Mzc1NzE5NjoxNi4yNjYwMjk2Mzc1NzE5Ni0tPg==" alt="拟合直线"></div>
                        <span class="geo-btn-text">拟合直线</span>
                    </div>
                    <div class="geo-btn" data-geo-type="annotation">
                        <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI2MC4xNDc5MiIgaGVpZ2h0PSI2MC4xNDc5MiIgdmlld0JveD0iMCwwLDYwLjE0NzkyLDYwLjE0NzkyIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjA5LjkyNjA0LC0xNDkuOTI2MDQpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMDkuOTI2MDQsMjEwLjA3Mzk2di02MC4xNDc5Mmg2MC4xNDc5MnY2MC4xNDc5MnoiIGZpbGwtb3BhY2l0eT0iMC4wMDc4NCIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI0My4wOTI5NywxNjQuNzMyMjljMC42NzI2NiwtMC4wODE4NiAxLjM1OTU3LC0wLjA0NjcxIDEuOTc2NTEsMC4xNDUzMmMwLjYxNjk3LDAuMTkyMDMgMS4yMTUzMywwLjQ3NTM4IDEuNzEwOTYsMC44ODk5NWMwLjQ5NTYzLDAuNDE0NTYgMC45MzYzNCwwLjg2NTUxIDEuMjc0MjgsMS40NDc2M2MwLjMzNzk3LDAuNTgyMTQgMC41MzMyMywxLjIxMTI5IDAuNjE1MDcsMS44ODM5NWMwLjA4MTg1LDAuNjcyNjYgMC4wNDMxNiwxLjMzMDMxIC0wLjE0ODksMS45NDcyOGMtMC4xOTIwNiwwLjYxNjk1IC0wLjQ3NTM4LDEuMjE1MzMgLTAuOTE1NjMsMS43NDM3NWwtMTMuMjQ3NjQsMTYuOTg1OTJjLTAuMzg1MzIsMC40OTIwOSAtMC44NDY5LDAuODQ1MDEgLTEuNDQzMjcsMS4wNjYwMWwtNi41NTMwNSwyLjQ4OTE0Yy0wLjA1ODUxLDAuMDA3MSAtMC4wODQxNywwLjAzOTk0IC0wLjExMzQzLDAuMDQzNDljLTAuMDI5MjUsMC4wMDM1NSAtMC4wODc3NSwwLjAxMDY5IC0wLjE0NjIyLDAuMDE3NzljLTAuMjkyNDUsMC4wMzU2IC0wLjU2OTk0LC0wLjA0OTM5IC0wLjc5OTU1LC0wLjIyOTE4Yy0wLjIyOTY1LC0wLjE3OTggLTAuMzc4NjQsLTAuNDI4ODEgLTAuNDE0MjMsLTAuNzIxMjZjLTAuMDA3MTQsLTAuMDU4NDcgLTAuMDE0MjQsLTAuMTE2OTggLTAuMDE3NzksLTAuMTQ2MjNjLTAuMDAzNTUsLTAuMDI5MjUgLTAuMDEwNjgsLTAuMDg3NzUgMC4wMTUwMywtMC4xMjA1M2wwLjkwNzAxLC02LjkzNjYzYzAuMDI2NDYsLTAuMjcwMzMgMC4xMDc4NiwtMC41NzcwMyAwLjIyMjA0LC0wLjg1ODAxYzAuMTE0MjIsLTAuMjgxMDEgMC4yNjEyMywtMC41MzYzMiAwLjQ0MTAzLC0wLjc2NTk2bDEzLjI0NzYzLC0xNi45ODU5MWMwLjQxMTAxLC0wLjUyNDg4IDAuODk0NzEsLTAuOTM5OSAxLjQ3Njg2LC0xLjI3Nzg3YzAuNTgyMTQsLTAuMzM3OTcgMS4yNjk4NCwtMC41NDAzMyAxLjkxMzI3LC0wLjYxODY2ek0yNDMuMzU5ODUsMTY2LjkyNTdjLTAuMzUwOTQsMC4wNDI3IC0wLjcyNDA1LDAuMTQ3NDggLTEuMDI3OTQsMC4zMzI4NWMtMC4zMDM5MiwwLjE4NTM3IC0wLjYwMDY5LDAuNDI5MjQgLTAuODMxOTEsMC43MjQ0OWwtMTMuMjQ0MDgsMTcuMDE1MTZjLTAuMTI4NDIsMC4xNjQwNCAtMC4xOTQ4MywwLjM1MDE1IC0wLjIzMTk0LDAuNTMyNzZsLTAuNjU2MTYsNS4wOTU2Nmw0Ljg1MTYzLC0xLjgzNjg5YzAuMTk3NiwtMC4wODMzOCAwLjMzMzE3LC0wLjE4ODk1IDAuNDkwODQsLTAuMzU2NTVsMTMuMjUxMTUsLTE2Ljk1NjY1YzAuMjMxMTgsLTAuMjk1MjMgMC40MDAzMiwtMC42MTI2MiAwLjUwMzg0LC0wLjk4MTM1YzAuMTAzNTIsLTAuMzY4NzMgMC4xMTkzLC0wLjcyNjg1IDAuMDc2NiwtMS4wNzc3N2MtMC4wNDYyOCwtMC4zODAyIC0wLjE0NzQ0LC0wLjcyNDAzIC0wLjMzNjQsLTEuMDU3MjJjLTAuMTg4OTUsLTAuMzMzMTcgLTAuNDI5MjQsLTAuNjAwNjkgLTAuNjkxNjgsLTAuODA2MjFjLTAuMjYyNDQsLTAuMjA1NTIgLTAuNjA5MDgsLTAuMzcxMDcgLTAuOTUyMTYsLTAuNTA3MzljLTAuMzQzMDUsLTAuMTM2MzIgLTAuODIxNjYsLTAuMTY3MTIgLTEuMjAxODcsLTAuMTIwODd6IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMjQzLjMxNDQxLDE4NC44MDA3OWg3LjAwNTU0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI0Ni44MTcxOCwxODYuMzcwOTlsLTIuNDE1Nyw4LjY5NjUzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI1NS4xMzM1OSwxODkuNjg1NTFsLTQuOTUyMTksLTAuMTIwNzkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMjUzLjMzOTU4LDE4Ni44NTQxM2wtMi4yOTQ5Miw4LjIxMzM5IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTI1MS4xNjU0NSwxOTUuMzA5MWgzLjAxOTYzIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MzAuMDczOTYxOTI2NjA3NjE6MzAuMDczOTYxOTI2NjA3NzIzLS0+" alt="批注"></div>
                        <span class="geo-btn-text">批注</span>
                    </div>
                </div>

                <div class="geo-btn-row">
<div class="geo-btn" data-geo-type="checkbox"> <div class="geo-btn-icon"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC43Njk0NSIgaGVpZ2h0PSIyMS4wODE3OCIgdmlld0JveD0iMCwwLDIwLjc2OTQ1LDIxLjA4MTc4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5LjYxNTI3LC0xNjkuNDU5MTEpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjkuNjE1MjcsMTkwLjU0MDg5di0yMS4wODE3OGgyMC43Njk0NXYyMS4wODE3OHoiIGZpbGwtb3BhY2l0eT0iMC4wMzEzNyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9Ik5hTiIvPjxwYXRoIGQ9Ik0yNDcuNDIwNTgsMTgyLjc1NTQ0Yy0wLjE0OTcxLDEuOTg1MDUgLTEuODAwMzMsMy41Mjg4OCAtMy43ODE5NSwzLjQ4ODRjLTAuMDE2MjYsLTAuMDAwMzMgLTAuMDMyNDksLTAuMDAwNzcgLTAuMDQ4NzMsLTAuMDAxM2wtNy4yNzY0MiwwLjAwMTJjLTAuMDI1MTQsMC4wMDAxIC0wLjA1MDMxLC0wLjAwMDA1IC0wLjA3NTU1LC0wLjAwMDQ3Yy0yLjA1MzMyLC0wLjAzMzYzIC0zLjY5MTA2LC0xLjc1MzgzIC0zLjY1ODAyLC0zLjg0MjJjMC4wMDAyOCwtMC4wMTY1MyAwLjAwMDYzLC0wLjAzMzA1IDAuMDAxMSwtMC4wNDk1NmwwLjAwMDksLTAuMTIxNDdsMC4wNDcwNiwtNC4xNTYwNWwwLjAwNDI4LC0wLjU4MDU3YzAuMDAwMywtMC4wMjU1NSAwLjAwMDg1LC0wLjA1MTE2IDAuMDAxNjcsLTAuMDc2ODJjMC4wNjU1LC0yLjA4NzU4IDEuNzgyNTQsLTMuNzI1ODkgMy44MzUwOSwtMy42NTkyNGMwLjAxNjI2LDAuMDAwNTMgMC4wMzI0OSwwLjAwMTE3IDAuMDQ4NzIsMC4wMDE5bDcuMTA1MTUsLTAuMDAyNjJjMC4wMjUxNCwtMC4wMDA0MSAwLjA1MDMxLC0wLjAwMDU0IDAuMDc1NTUsLTAuMDAwNDZjMi4wNTM1NSwwLjAwODkzIDMuNzExMiwxLjcwOTMgMy43MDI0NiwzLjc5NzkxYy0wLjAwMDA2LDAuMDE2NTUgLTAuMDAwMjMsMC4wMzMwNiAtMC4wMDA1MywwLjA0OTU4bDAuMDAwMzMsMC4wNzYyNXoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzkyOTI5MiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48cGF0aCBkPSJNMjM3LjgzNzY2LDE4Mi4xODU2MWMtMC4wMTg4NCwwLjAwMDQzIC0wLjAzNzczLDAuMDAwNjUgLTAuMDU2NjgsMC4wMDA2NWMtMS4zNDIyNSwwIC0yLjQzMDM1LC0xLjA4ODExIC0yLjQzMDM1LC0yLjQzMDM2YzAsLTEuMzQyMjUgMS4wODgxLC0yLjQzMDM2IDIuNDMwMzUsLTIuNDMwMzZjMC4wMTg5NSwwIDAuMDM3ODQsMC4wMDAyMiAwLjA1NjY4LDAuMDAwNjVsNC4zNjEwNywwLjAwNzgyYzAuMDE4ODUsLTAuMDAwMDQgMC4wMzc3NCwwLjAwMDE1IDAuMDU2NjgsMC4wMDA1NWMxLjM0MTk1LDAuMDI4NDQgMi40MDY3NiwxLjEzOTM0IDIuMzc4MzIsMi40ODEyOWMtMC4wMjg0NCwxLjM0MTk1IC0xLjEzOTM0LDIuNDA2NzcgLTIuNDgxMjksMi4zNzgzM2MtMC4wMTg5NCwtMC4wMDA0IC0wLjAzNzgzLC0wLjAwMTAyIC0wLjA1NjY1LC0wLjAwMTg1eiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjOTI5MjkyIiBzdHJva2Utd2lkdGg9IjEuMiIvPjxwYXRoIGQ9Ik0yNDAuNjYyNTYsMTc5Ljc1MjZjMCwtMC43MzQ0OSAwLjU5NTQyLC0xLjMyOTkxIDEuMzI5OTEsLTEuMzI5OTFjMC43MzQ0OSwwIDEuMzI5OTEsMC41OTU0MiAxLjMyOTkxLDEuMzI5OTFjMCwwLjczNDQ5IC0wLjU5NTQyLDEuMzI5OTEgLTEuMzI5OTEsMS4zMjk5MWMtMC43MzQ0OSwwIC0xLjMyOTkxLC0wLjU5NTQyIC0xLjMyOTkxLC0xLjMyOTkxeiIgZmlsbD0iIzkyOTI5MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxMC4zODQ3MjczMDg1MzgwMDQ6MTAuNTQwODg4NjIxNDQ4Mzc0LS0+" style="filter: var(--icon-filter);"></div> <span class="geo-btn-text">复选框</span> </div>

  </div>
            </div>
        `;
    }
    


updateGeometryButtonColors() {
        const buttons = this.geometryPanel.querySelectorAll('.geo-btn');
        const isDark = document.documentElement.hasAttribute('data-theme');
        const hue = this.preferredColorValue;
        
        buttons.forEach(button => {

            const textColor = isDark ? '#e0e0e0' : '#222';
            button.style.color = textColor;
        });
    }



    
cancelGeometryInteraction() {
    this.geometryInteractionState.active = false;
    this.geometryInteractionState.type = null;
    this.updateGeometryInteractionUI();
    const activeButton = this.geometryPanel.querySelector('.geo-btn.active');
    if (activeButton) activeButton.classList.remove('active');
    if (this.highlightedObject) {
        this.highlightedObject = null;
        this.requestDraw();
    }
    this.hideInfoMessage();
}

showInfoMessage(text, duration = null) {
    if (!this.infoDisplay) return;
    clearTimeout(this.infoDisplayTimeout);
    this.infoDisplay.textContent = text;
    this.infoDisplay.classList.add('show');
    if (duration) {
        this.infoDisplayTimeout = setTimeout(() => {
            this.hideInfoMessage();
        }, duration);
    }
}

hideInfoMessage() {
    if (!this.infoDisplay) return;
    clearTimeout(this.infoDisplayTimeout);
    this.infoDisplay.classList.remove('show');
}

    updateGeometryInteractionUI() {
        let promptElement = document.getElementById('geometry-interaction-prompt');

        if (!promptElement) {
            promptElement = document.createElement('div');
            promptElement.id = 'geometry-interaction-prompt';
            document.body.appendChild(promptElement);
        }

        if (this.geometryInteractionState.active) {
            promptElement.textContent = this.geometryInteractionState.prompt;
            setTimeout(() => promptElement.classList.add('show'), 10);
        } else {
            if (promptElement) {
                promptElement.classList.remove('show');
            }
        }
    }

    autonamePoint() {
        const existingNames = new Set(this.entries.map(e => e.name).filter(Boolean).map(n => n.toUpperCase()));
        for (let i = 0; i < 26; i++) {
            const name = String.fromCharCode(65 + i);
            if (!existingNames.has(name)) return name;
        }
        for (let j = 1; j < 100; j++) {
             for (let i = 0; i < 26; i++) {
                const name = String.fromCharCode(65 + i) + j;
                if (!existingNames.has(name)) return name;
            }
        }
        return 'P' + Date.now();
    }

    autonameMidpoint() {
        return this.autonameByPrefix('m');
    }

    autonameByPrefix(prefix) {
        const existingNames = new Set(this.entries.map(e => e.name).filter(Boolean).map(n => n.toLowerCase()));
        for (let i = 1; i < 1000; i++) {
            const name = prefix + i;
            if (!existingNames.has(name.toLowerCase())) {
                return name;
            }
        }
        return prefix + Date.now();
    }
    findObjectNearClick(coords, maxDist = 10) {
        let closestPoint = { object: null, dist: maxDist };
        let closestOther = { object: null, dist: maxDist };
        const mathX = (coords.x - this.offset.x) / this.scale;
        const mathY = (this.offset.y - coords.y) / this.scale;

this.entries.forEach(entry => {
        if (!entry.isMeaningful || !entry.visible || entry.type !== 'geometry') return;

        let dist = Infinity;
       const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

        if (['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(entry.geometryType)) {
            const screenX = this.offset.x + entry.x_val * this.scale;
            const screenY = this.offset.y - entry.y_val * this.scale;
            dist = Math.hypot(coords.x - screenX, coords.y - screenY);
            if (dist < closestPoint.dist) {
                closestPoint = { object: entry, dist };
            }
        } else if (lineLike.includes(entry.geometryType)) {                const { p1, p2 } = entry;
                if (!p1 || !p2) return;
                const { x_val: x1, y_val: y1 } = p1;
                const { x_val: x2, y_val: y2 } = p2;
                const dx = x2 - x1, dy = y2 - y1;
                const lenSq = dx*dx + dy*dy;
                let t = 0;
                if (lenSq > 1e-9) {
                    t = ((mathX - x1) * dx + (mathY - y1) * dy) / lenSq;
                }
                let onObject = true;
                if (entry.geometryType === 'segment' || entry.geometryType === 'vector') {
                    if (t < -1e-9 || t > 1 + 1e-9) onObject = false;
                } else if (entry.geometryType === 'ray') {
                    if (t < -1e-9) onObject = false;
                }
                if (onObject) {
                    const closestX = x1 + t * dx;
                    const closestY = y1 + t * dy;
                    dist = Math.hypot(mathX - closestX, mathY - closestY) * this.scale;
                }
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            } else if (entry.geometryType === 'circle') {
                const { center, radius } = entry;
                if (!center || !radius) return;
                const distToCenter = Math.hypot(mathX - center.x_val, mathY - center.y_val);
                dist = Math.abs(distToCenter - radius) * this.scale;
                if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
} else if (entry.geometryType === 'ellipse' || entry.geometryType === 'ellipse_ab') {
                const { center, a, b, rotation } = entry;
                if (!center || !a || !b) return;
                const relX = mathX - center.x;
                const relY = mathY - center.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = (localX / a)**2 + (localY / b)**2 - 1;
                const gradMag = 2 * Math.hypot(localX/(a*a), localY/(b*b));
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }            } else if (entry.geometryType === 'hyperbola') {
                const { center, a, b, rotation } = entry;
                if (!center || !a || !b) return;
                const relX = mathX - center.x;
                const relY = mathY - center.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = (localX / a)**2 - (localY / b)**2 - 1;
                const gradMag = 2 * Math.hypot(localX/(a*a), -localY/(b*b));
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            } else if (entry.geometryType === 'parabola') {
                const { vertex, p, rotation } = entry;
                if (!vertex || !p) return;
                const relX = mathX - vertex.x;
                const relY = mathY - vertex.y;
                const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                const val = localY**2 - 4 * p * localX;
                const gradMag = Math.hypot(-4*p, 2*localY);
                dist = gradMag > 1e-9 ? Math.abs(val) / gradMag * this.scale : Infinity;
                 if (dist < closestOther.dist) {
                    closestOther = { object: entry, dist };
                }
            }  else if (entry.geometryType === 'circulararc') {
                const { center, radius, startAngle, endAngle } = entry;
                if (!center || !radius) return;
                const distToCenter = Math.hypot(mathX - center.x_val, mathY - center.y_val);
                const dist = Math.abs(distToCenter - radius) * this.scale;
                
                if (dist < closestOther.dist) {
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    let sA = startAngle;
                    let eA = endAngle;
                    if (eA < sA) eA += 2 * Math.PI;
                    
                    let checkAngle = angle;
                    while (checkAngle < sA - 1e-9) checkAngle += 2 * Math.PI;
                    while (checkAngle > sA + 2 * Math.PI - 1e-9) checkAngle -= 2 * Math.PI;

                    if (checkAngle <= eA + 1e-9) {
                        closestOther = { object: entry, dist };
                    }
                  }
                }
        });
        
        if (closestPoint.object) {
            return closestPoint.object;
        }
        return closestOther.object;
    }
        updateCodeList() {
        const listContainer = document.getElementById('code-entry-list');
        if (!listContainer) return;

        const userDefinedFunctions = ADVANCED_FUNCTION_DEFINITIONS.filter(def => !this.defaultAdvancedFunctionNames.has(def.name));

        listContainer.innerHTML = userDefinedFunctions.map((def, index) => {
            const originalIndex = ADVANCED_FUNCTION_DEFINITIONS.findIndex(d => d.name === def.name);
            const truncatedParams = def.params.join(', ').length > 20 ? def.params.join(', ').substring(0, 17) + '...' : def.params.join(', ');
            
            return `
                <div class="entry-item advanced_custom_function_definition-item" data-index="${originalIndex}">
                    <div class="entry-main-row">
                        <div class="entry-text-area">
                            <div>${def.name}(${truncatedParams})</div>
                        </div>
                        <div class="entry-actions-new">
                            <span class="action-btn code-edit-btn" title="编辑"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI4Ljc3NzExIiBoZWlnaHQ9IjEwLjQzODc5IiB2aWV3Qm94PSIwLDAsOC43NzcxMSwxMC40Mzg3OSI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzNS42MDUxMiwtMTc0Ljc4NDM5KSI+PGcgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjQyLjE2NjE0LDE3NS4wODIxOWMwLjIzMTExLC0wLjAyODEzIDAuNDY3MTIsLTAuMDE2MDUgMC42NzkwOSwwLjA0OTkzYzAuMjExOTgsMC4wNjU5OCAwLjQxNzU2LDAuMTYzMzMgMC41ODc4NSwwLjMwNTc3YzAuMTcwMjksMC4xNDI0MyAwLjMyMTcxLDAuMjk3MzcgMC40Mzc4MiwwLjQ5NzM4YzAuMTE2MTIsMC4yMDAwMSAwLjE4MzIxLDAuNDE2MTggMC4yMTEzMywwLjY0NzI5YzAuMDI4MTIsMC4yMzExMSAwLjAxNDgzLDAuNDU3MDcgLTAuMDUxMTYsMC42NjkwNWMtMC4wNjU5OSwwLjIxMTk3IC0wLjE2MzMzLDAuNDE3NTYgLTAuMzE0NTksMC41OTkxMmwtNC41NTE2Myw1LjgzNjAzYy0wLjEzMjM5LDAuMTY5MDcgLTAuMjkwOTgsMC4yOTAzMyAtMC40OTU4OCwwLjM2NjI2bC0yLjI1MTUsMC44NTUyMmMtMC4wMjAxLDAuMDAyNDQgLTAuMDI4OTIsMC4wMTM3MiAtMC4wMzg5NywwLjAxNDk0Yy0wLjAxMDA1LDAuMDAxMjIgLTAuMDMwMTUsMC4wMDM2NyAtMC4wNTAyNCwwLjAwNjExYy0wLjEwMDQ4LDAuMDEyMjMgLTAuMTk1ODIsLTAuMDE2OTcgLTAuMjc0NzEsLTAuMDc4NzRjLTAuMDc4OSwtMC4wNjE3OCAtMC4xMzAwOSwtMC4xNDczMyAtMC4xNDIzMiwtMC4yNDc4MWMtMC4wMDI0NSwtMC4wMjAwOSAtMC4wMDQ4OSwtMC4wNDAxOSAtMC4wMDYxMSwtMC4wNTAyNGMtMC4wMDEyMiwtMC4wMTAwNSAtMC4wMDM2NywtMC4wMzAxNSAwLjAwNTE2LC0wLjA0MTQxbDAuMzExNjMsLTIuMzgzMjljMC4wMDkwOSwtMC4wOTI4OCAwLjAzNzA2LC0wLjE5ODI2IDAuMDc2MjksLTAuMjk0OGMwLjAzOTI0LC0wLjA5NjU1IDAuMDg5NzUsLTAuMTg0MjcgMC4xNTE1MywtMC4yNjMxN2w0LjU1MTYzLC01LjgzNjAzYzAuMTQxMjEsLTAuMTgwMzQgMC4zMDc0MSwtMC4zMjI5MyAwLjUwNzQyLC0wLjQzOTA1YzAuMjAwMDEsLTAuMTE2MTIgMC40MzYyOSwtMC4xODU2NSAwLjY1NzM2LC0wLjIxMjU2ek0yNDIuMjU3ODIsMTc1LjgzNThjLTAuMTIwNTgsMC4wMTQ2NyAtMC4yNDg3NywwLjA1MDY3IC0wLjM1MzE4LDAuMTE0MzZjLTAuMTA0NDIsMC4wNjM2OSAtMC4yMDYzOSwwLjE0NzQ4IC0wLjI4NTgzLDAuMjQ4OTJsLTQuNTUwNDEsNS44NDYwOGMtMC4wNDQxMiwwLjA1NjM2IC0wLjA2Njk0LDAuMTIwMzEgLTAuMDc5NjksMC4xODMwNWwtMC4yMjU0NCwxLjc1MDc3bDEuNjY2OTMsLTAuNjMxMTJjMC4wNjc4OSwtMC4wMjg2NSAwLjExNDQ3LC0wLjA2NDkyIDAuMTY4NjQsLTAuMTIyNWw0LjU1Mjg0LC01LjgyNTk4YzAuMDc5NDMsLTAuMTAxNDQgMC4xMzc1NCwtMC4yMTA0OCAwLjE3MzExLC0wLjMzNzE3YzAuMDM1NTcsLTAuMTI2NjkgMC4wNDA5OSwtMC4yNDk3MyAwLjAyNjMyLC0wLjM3MDNjLTAuMDE1OSwtMC4xMzA2MyAtMC4wNTA2NiwtMC4yNDg3NiAtMC4xMTU1OCwtMC4zNjMyNGMtMC4wNjQ5MiwtMC4xMTQ0NyAtMC4xNDc0OCwtMC4yMDYzOSAtMC4yMzc2NSwtMC4yNzdjLTAuMDkwMTcsLTAuMDcwNjEgLTAuMjA5MjcsLTAuMTI3NDkgLTAuMzI3MTQsLTAuMTc0MzNjLTAuMTE3ODcsLTAuMDQ2ODQgLTAuMjgyMzEsLTAuMDU3NDIgLTAuNDEyOTQsLTAuMDQxNTN6Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6NC4zOTQ4Nzc5ODQ1NTI2MDg6NS4yMTU2MTA0MzU2MDg1OTYtLT4=" style="width:18px; height:18px;"></span>
                            <span class="action-btn code-download-btn" title="下载"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI3LjEyODQ3IiBoZWlnaHQ9IjguOTk3OTciIHZpZXdCb3g9IjAsMCw3LjEyODQ3LDguOTk3OTciPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzYuNDM1NzYsLTE3NS41MDEwMSkiPjxnIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjM1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCI+PGc+PHBhdGggZD0iTTI0MC4wNTY2NSwxNzYuMTc2MDJ2NS4zODE5MSIvPjxwYXRoIGQ9Ik0yMzguMzU3MTEsMTc5Ljk3MTY4bDEuNTg2MjUsMi4xNTI3NiIvPjxwYXRoIGQ9Ik0yNDEuNjQyOTEsMTc5Ljk3MTY4bC0xLjU4NjI1LDIuMTUyNzYiLz48cGF0aCBkPSJNMjM3LjExMDc3LDE4My44MjM5OWg1Ljc3ODQ3Ii8+PC9nPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjMuNTY0MjM0OTk5OTk5OTk2NTo0LjQ5ODk4NTAwMDAwMDAwNS0tPg==" style="width:18px; height:18px;"></span>
                            <span class="action-btn code-delete-btn" title="删除"><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMC4wMDYzNiIgaGVpZ2h0PSIxMC42MTM2OCIgdmlld0JveD0iMCwwLDEwLjAwNjM2LDEwLjYxMzY4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjM0Ljk5NjgyLC0xNzQuNjkzMTYpIj48ZyBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yNDQuNzUzMTgsMTc2LjUyMDUzYzAsMC4wNzU5MSAtMC4wMTY4NywwLjEyNjUzIC0wLjA0MjE4LDAuMTc3MTNjLTAuMDI1MzEsMC4wNTA2MSAtMC4wNjc0OCwwLjA3NTkxIC0wLjEwOTY1LDAuMDkyNzhjLTAuMDQyMTcsMC4wMTY4NyAtMC4xMDEyMiwwLjAzMzc1IC0wLjE1MTg0LDAuMDQyMThjLTAuMDUwNjEsMC4wMDg0MyAtMC4xMDk2NiwwLjAwODQzIC0wLjE3NzEzLDAuMDA4NDNjLTAuMDMzNzQsMCAtMC4wNjc0OCwwIC0wLjEwMTIxLDBjLTAuMDMzNzQsMCAtMC4wNTkwNSwwIC0wLjA5Mjc5LDBsLTAuODE4Miw3LjEwMjM1Yy0wLjAxNjg3LDAuMTYwMjcgLTAuMDY3NDgsMC4zMDM2NiAtMC4xMzQ5NiwwLjQzODYzYy0wLjA2NzQ4LDAuMTM0OTYgLTAuMTY4NywwLjI1MzA2IC0wLjI3ODM2LDAuMzU0MjhjLTAuMTA5NjUsMC4xMDEyMiAtMC4yNDQ2MiwwLjE3NzEzIC0wLjM4ODAxLDAuMjM2MThjLTAuMTQzMzksMC4wNTkwNCAtMC4yOTUyMywwLjA4NDM1IC0wLjQ1NTUsMC4wODQzNWgtNC4wMDY2N2MtMC4xNjAyNywwIC0wLjMxMjEsLTAuMDI1MzEgLTAuNDU1NDksLTAuMDg0MzVjLTAuMTQzMzksLTAuMDU5MDQgLTAuMjY5OTIsLTAuMTM0OTYgLTAuMzg4MDIsLTAuMjM2MThjLTAuMTE4MDksLTAuMTAxMjIgLTAuMjAyNDMsLTAuMjE5MzEgLTAuMjc4MzYsLTAuMzU0MjhjLTAuMDc1OTIsLTAuMTM0OTYgLTAuMTE4MSwtMC4yODY4IC0wLjEzNDk2LC0wLjQzODYzbC0wLjgxODIxLC03LjEwMjM1Yy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjAzMzc0LDAgLTAuMDY3NDgsMCAtMC4xMDEyMiwwYy0wLjA1OTA0LDAgLTAuMTA5NjUsMCAtMC4xNjg3LC0wLjAwODQzYy0wLjA1OTA0LC0wLjAwODQzIC0wLjEwOTY1LC0wLjAyNTMxIC0wLjE1MTg0LC0wLjA0MjE4Yy0wLjA0MjE3LC0wLjAxNjg3IC0wLjA4NDM2LC0wLjA1OTA0IC0wLjEwOTY2LC0wLjEwMTIxYy0wLjAyNTMxLC0wLjA0MjE3IC0wLjA0MjE4LC0wLjEwMTIyIC0wLjA0MjE4LC0wLjE2ODdjMCwtMC4wODQzNSAwLjAzMzc1LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk1LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzloMi44NzYzN2MwLjAzMzc0LC0wLjE3NzEzIDAuMTAxMjIsLTAuMzQ1ODQgMC4xOTQwMSwtMC41MDYxMWMwLjA5Mjc5LC0wLjE2MDI3IDAuMjE5MzEsLTAuMjg2NzkgMC4zNTQyOCwtMC40MDQ4OGMwLjEzNDk2LC0wLjExODEgMC4yOTUyMywtMC4yMDI0NCAwLjQ2MzkzLC0wLjI2MTQ5YzAuMTY4NywtMC4wNTkwNCAwLjM0NTg0LC0wLjA5Mjc5IDAuNTMxNCwtMC4wOTI3OWMwLjE4NTU4LDAgMC4zNjI3MSwwLjAzMzc0IDAuNTMxNDEsMC4wOTI3OWMwLjE2ODcsMC4wNTkwNCAwLjMyODk2LDAuMTUxODQgMC40NjM5MiwwLjI2MTQ5YzAuMTM0OTYsMC4xMDk2NSAwLjI2MTQ5LDAuMjQ0NjIgMC4zNTQyOCwwLjQwNDg4YzAuMDkyNzksMC4xNjAyNyAwLjE2MDI3LDAuMzIwNTMgMC4xOTQwMSwwLjUwNjExaDIuODc2MzdjMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMTM0OTYsMC4xMzQ5NiAwLjEzNDk2LDAuMjE5MzF6TTI0My40NDU3NiwxNzYuODQxMDdoLTYuODgzMDRsMC44MDk3Nyw3LjAzNDg3YzAuMDE2ODcsMC4xNjg3IDAuMDg0MzYsMC4yOTUyMyAwLjIwMjQ0LDAuNDA0ODhjMC4xMTgwOSwwLjEwOTY1IDAuMjYxNDksMC4xNTE4MyAwLjQyMTc1LDAuMTUxODNoNC4wMDY2N2MwLjA3NTkyLDAgMC4xNTE4NCwtMC4wMTY4NyAwLjIyNzc1LC0wLjA0MjE3YzAuMDc1OTIsLTAuMDI1MzEgMC4xMzQ5NiwtMC4wNjc0OCAwLjE5NDAxLC0wLjExODFjMC4wNTkwNCwtMC4wNTA2MSAwLjEwMTIyLC0wLjEwOTY2IDAuMTM0OTYsLTAuMTc3MTNjMC4wMzM3NCwtMC4wNjc0OCAwLjA1OTA0LC0wLjE0MzM5IDAuMDY3NDgsLTAuMjE5MzF6TTIzOC43Mzg5OCwxODIuMjE0MjJ2LTMuMTYzMTZjMCwtMC4wODQzNSAwLjAzMzc0LC0wLjE2MDI3IDAuMDkyNzksLTAuMjE5MzFjMC4wNTkwNCwtMC4wNTkwNCAwLjEzNDk2LC0wLjA5Mjc5IDAuMjE5MzEsLTAuMDkyNzljMC4wODQzNiwwIDAuMTYwMjcsMC4wMzM3NCAwLjIxOTMxLDAuMDkyNzljMC4wNTkwNCwwLjA1OTA0IDAuMDkyNzksMC4xMzQ5NiAwLjA5Mjc5LDAuMjE5MzF2My4xNjMxNmMwLDAuMDg0MzUgLTAuMDMzNzQsMC4xNjAyNyAtMC4wOTI3OSwwLjIxOTMxYy0wLjA1OTA0LDAuMDU5MDQgLTAuMTM0OTYsMC4wOTI3OSAtMC4yMTkzMSwwLjA5Mjc5Yy0wLjA4NDM2LDAgLTAuMTYwMjcsLTAuMDMzNzUgLTAuMjE5MzEsLTAuMDkyNzljLTAuMDU5MDQsLTAuMDU5MDQgLTAuMDkyNzksLTAuMTM0OTYgLTAuMDkyNzksLTAuMjE5MzF6TTIzOS4xMTAxMiwxNzYuMjA4NDVoMS43ODgyNGMtMC4wMzM3NCwtMC4wOTI3OCAtMC4wNzU5MiwtMC4xODU1NyAtMC4xMzQ5NiwtMC4yNjE0OWMtMC4wNTkwNCwtMC4wNzU5MSAtMC4xMjY1MiwtMC4xNDMzOSAtMC4yMTA4OCwtMC4yMDI0NGMtMC4wODQzNiwtMC4wNTkwNCAtMC4xNjg3LC0wLjEwMTIyIC0wLjI1MzA2LC0wLjEyNjUzYy0wLjA4NDM2LC0wLjAyNTMxIC0wLjE4NTU3LC0wLjA0MjE3IC0wLjI5NTIzLC0wLjA0MjE3Yy0wLjEwOTY1LDAgLTAuMjAyNDQsMC4wMTY4NyAtMC4yOTUyMywwLjA0MjE3Yy0wLjA5Mjc5LDAuMDI1MzEgLTAuMTc3MTMsMC4wNzU5MSAtMC4yNTMwNiwwLjEyNjUzYy0wLjA3NTkyLDAuMDUwNjEgLTAuMTUxODQsMC4xMjY1MiAtMC4yMTA4OCwwLjIwMjQ0Yy0wLjA1OTA0LDAuMDc1OTEgLTAuMTAxMjIsMC4xNjAyNyAtMC4xMzQ5NiwwLjI2MTQ5ek0yNDAuNjM2ODcsMTgyLjIxNDIydi0zLjE2MzE2YzAsLTAuMDg0MzUgMC4wMzM3NCwtMC4xNjAyNyAwLjA5Mjc5LC0wLjIxOTMxYzAuMDU5MDQsLTAuMDU5MDQgMC4xMzQ5NiwtMC4wOTI3OSAwLjIxOTMxLC0wLjA5Mjc5YzAuMDg0MzYsMCAwLjE2MDI3LDAuMDMzNzQgMC4yMTkzMSwwLjA5Mjc5YzAuMDU5MDQsMC4wNTkwNCAwLjA5Mjc5LDAuMTM0OTYgMC4wOTI3OSwwLjIxOTMxdjMuMTYzMTZjMCwwLjA4NDM1IC0wLjAzMzc1LDAuMTYwMjcgLTAuMDkyNzksMC4yMTkzMWMtMC4wNTkwNCwwLjA1OTA0IC0wLjEzNDk1LDAuMDkyNzkgLTAuMjE5MzEsMC4wOTI3OWMtMC4wODQzNiwwIC0wLjE2MDI3LC0wLjAzMzc1IC0wLjIxOTMxLC0wLjA5Mjc5Yy0wLjA1OTA0LC0wLjA1OTA0IC0wLjA5Mjc5LC0wLjEzNDk2IC0wLjA5Mjc5LC0wLjIxOTMxeiIvPjwvZz48L2c+PC9zdmc+PCEtLXJvdGF0aW9uQ2VudGVyOjUuMDAzMTc5OTk5OTk5OTU4OjUuMzA2ODQwMDAwMDAwMDIyLS0+" style="width:18px; height:18px;"></span>
                        </div>
                    </div>
                </div>`;
        }).join('');
    }

    handleCodeListClick(e) {
        const item = e.target.closest('.entry-item');
        if (!item) return;
        const index = parseInt(item.dataset.index, 10);

        if (e.target.closest('.code-edit-btn')) {
            this.showCodeEditor(index);
        } else if (e.target.closest('.code-download-btn')) {
            this.downloadSingleOperator(index);
        } else if (e.target.closest('.code-delete-btn')) {
            this.deleteCustomOperator(index);
        }
    }

    showCodeEditor(index) {
        this.currentCodeEditIndex = index;
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        const nameInput = document.getElementById('code-editor-name');
        const paramsInput = document.getElementById('code-editor-params');
        const bodyTextarea = document.getElementById('code-editor-body');

        if (index === -1) {
            nameInput.value = '';
            paramsInput.value = '';
            bodyTextarea.value = 'return input;';
            document.getElementById('main-content-title').textContent = "新建";
        } else {
            const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
            nameInput.value = operator.name;
            paramsInput.value = operator.params.map(p => `'${p}'`).join(', ');
            bodyTextarea.value = operator.bodyJsString.trim();
            document.getElementById('main-content-title').textContent = "编辑";
        }

        listView.style.display = 'none';
        editorView.style.display = 'flex';
        document.getElementById('global-script-toggle-btn').style.display = 'none'; 
    }

    hideCodeEditor() {
        this.currentCodeEditIndex = -1;
        const listView = document.getElementById('code-list-view');
        const editorView = document.getElementById('code-editor-view');
        listView.style.display = 'flex';
        editorView.style.display = 'none';
        document.getElementById('main-content-title').textContent = "代码";
        document.getElementById('global-script-toggle-btn').style.display = 'flex';
    }
    
    _formatOperatorToString(name, paramsStr, bodyStr) {
        const paramsArray = paramsStr.split(',').map(p => p.trim().replace(/['"]/g, '')).filter(p => p);
        const formattedParams = JSON.stringify(paramsArray);
        return `{
    name: '${name}',
    params: ${formattedParams},
    bodyJsString: \`
${bodyStr}
    \`
}`;
    }

saveCodeFromEditor() {
        let name = document.getElementById('code-editor-name').value.trim();
        const paramsStr = document.getElementById('code-editor-params').value;
        const bodyJsString = document.getElementById('code-editor-body').value;


        if (name) name = name.toLowerCase();

        if (!name || !/^[a-zA-Z_][\w]*$/.test(name)) {
            alert("名称无效。");
            return;
        }
        if (this.defaultAdvancedFunctionNames.has(name) && (this.currentCodeEditIndex === -1 || ADVANCED_FUNCTION_DEFINITIONS[this.currentCodeEditIndex].name !== name)) {
            alert(`名称 "${name}" 是一个内置函数，无法覆盖。`);
            return;
        }

        const params = paramsStr.split(',').map(p => p.trim().replace(/['"]/g, '')).filter(p => p);
        for(const param of params) {
            if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param)) {
                alert(`变量名 "${param}" 无效。`);
                return;
            }
        }

        const newOperator = { name, params, bodyJsString };

        if (this.currentCodeEditIndex === -1) { 
            ADVANCED_FUNCTION_DEFINITIONS.push(newOperator);
        } else { 
            ADVANCED_FUNCTION_DEFINITIONS[this.currentCodeEditIndex] = newOperator;
        }

        this.initializeAdvancedCalcJSFunctions();
        this.recalculateAll();
        this.updateCodeList();
        this.hideCodeEditor();
    }
    downloadCodeFromEditor() {
        const name = document.getElementById('code-editor-name').value.trim();
        const paramsStr = document.getElementById('code-editor-params').value;
        const bodyStr = document.getElementById('code-editor-body').value;
        if (!name) {
            alert("名称不能为空。");
            return;
        }
        const fileContent = this._formatOperatorToString(name, paramsStr, bodyStr);
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const filename = `jscalc_${name}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }
    
    downloadSingleOperator(index) {
        const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
        const paramsStr = operator.params.map(p => `'${p}'`).join(', ');
        const fileContent = this._formatOperatorToString(operator.name, paramsStr, operator.bodyJsString);
        const blob = new Blob([fileContent], { type: 'text/plain' });
        const filename = `jscalc_${operator.name}.txt`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 100);
    }
_uint8ArrayToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        const CHUNK_SIZE = 32768; // 32KB 分块
        
        // 使用数组收集，避免频繁的字符串拼接导致的内存压力和性能问题
        const chunks = [];
        for (let i = 0; i < len; i += CHUNK_SIZE) {
            const chunk = bytes.subarray(i, Math.min(i + CHUNK_SIZE, len));
            chunks.push(String.fromCharCode.apply(null, chunk));
        }
        return window.btoa(chunks.join(''));
    }

   _base64ToUint8Array(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    }

_ensurePdfJsLoaded() {
        if (window.pdfjsLib) return Promise.resolve();
        if (this._pdfJsLoadingPromise) return this._pdfJsLoadingPromise;
        this._pdfJsLoadingPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
            script.onload = () => {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                resolve();
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
        return this._pdfJsLoadingPromise;
    }
    async _restorePdfAnnotation(anno) {
        try {
            await this._ensurePdfJsLoaded();
            anno.pdfDoc = await window.pdfjsLib.getDocument(anno.pdfData).promise;
            await this.renderPdfPage(anno);
        } catch (e) {
            console.error("PDF restore failed:", e);
        }
    }

stopAllAudio() {
        this.annotations.forEach(anno => {
            if (anno.type === 'audio' && anno.audioElem) {
                anno.audioElem.pause();
                anno.audioElem.currentTime = 0;
                anno.isPlaying = false;
            }
        });
    }

    async renderPdfPage(annotation) {
        if (!annotation.pdfDoc) return;
        try {
            const page = await annotation.pdfDoc.getPage(annotation.page);
            const viewport = page.getViewport({ scale: 2 }); 
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport: viewport }).promise;
            
            const img = new Image();
            img.onload = () => {
                annotation.img = img;
                this.requestDraw();
            };
            img.src = canvas.toDataURL();
        } catch (e) {
            console.error(e);
        }
    }
    deleteCustomOperator(index) {
        const operator = ADVANCED_FUNCTION_DEFINITIONS[index];
        if (confirm(`确定要删除运算符 "${operator.name}" 吗？所有依赖于它的条目也将被删除。`)) {
            const operatorName = operator.name;
            ADVANCED_FUNCTION_DEFINITIONS.splice(index, 1);
            
            const indicesToDelete = new Set();
            this.entries.forEach((entry, i) => {
                if (entry.dependencies && entry.dependencies.includes(operatorName.toLowerCase())) {
                    indicesToDelete.add(i);
                }
            });

            const sortedIndices = Array.from(indicesToDelete).sort((a, b) => b - a);
            sortedIndices.forEach(idx => this.entries.splice(idx, 1));
            
            this.initializeAdvancedCalcJSFunctions();
            this.recalculateAll();
            this.updateCodeList();
        }
    }

        handleGeometryButtonClick(type) {
        if (this.geometryInteractionState.active && this.geometryInteractionState.type === type) {
            this.cancelGeometryInteraction();
            return;
        }

if (type === 'annotation') {
            this.enterAnnotationMode();
            return;
        }

if (type === 'checkbox') { this.showCheckboxSelectionModal(); return; }

        this.cancelGeometryInteraction();

const interactions = {
            'point': { clicks: 1, prompt: '在绘图区点击以添加一个点' },
            'intercept': { clicks: 2, prompt: '请选择第一个对象' },
            'midpoint': { clicks: 2, prompt: '请选择第一个点' },
            'segment': { clicks: 2, prompt: '请选择线段的第一个端点' },
            'ray': { clicks: 2, prompt: '请选择射线的起点' },
            'line': { clicks: 2, prompt: '请选择直线上的第一个点' },
            'vector': { clicks: 2, prompt: '请选择向量的起点' },
            'circle_pr': { clicks: 2, prompt: '请选择圆心' },
            'circle_cr': { clicks: 1, prompt: '请选择圆心' },
            'circulararc': { clicks: 3, prompt: '请选择圆心' },
            'parallelline': { clicks: 2, prompt: '请选择一条线' },
            'perpendicularline': { clicks: 2, prompt: '请选择一条线' },
            'anglebisector': { clicks: 3, prompt: '请选择第一个点 (边上)' },
            'ellipse': { clicks: 3, prompt: '请选择第一个焦点' },
            'hyperbola': { clicks: 3, prompt: '请选择第一个焦点' },
            'parabola': { clicks: 2, prompt: '请选择焦点' },
            'polygon': { clicks: Infinity, prompt: '请选择第一个顶点' },
            'length': { clicks: 2, prompt: '请选择第一个点' },
            'angle': { clicks: 3, prompt: '请选择第一个点 (边上)' },
            'area': { clicks: Infinity, prompt: '请选择第一个顶点' },
            'isparallel': { clicks: 2, prompt: '请选择第一条线' },
            'isperpendicular': { clicks: 2, prompt: '请选择第一条线' },
            'isconcyclic': { clicks: 4, prompt: '请选择第一个点' },
            'rotate': { clicks: 2, prompt: '请选择旋转中心' },
            'reflect': { clicks: 2, prompt: '请选择对称轴或对称中心' },
            'translate': { clicks: 2, prompt: '请选择一个向量或射线' },
            'fitline': { clicks: Infinity, prompt: '请选择第一个点' },
            'tangent': { clicks: 2, prompt: '请选择一个圆锥曲线' },
       'trace': { clicks: 1, prompt: '请选择要追踪轨迹的点' },
        };


        if (interactions[type] && interactions[type].clicks > 0) {
            this.geometryInteractionState = {
                active: true,
                type: type,
                prompt: interactions[type].prompt,
                clicksNeeded: interactions[type].clicks,
                pointsSelected: [],
                objectsSelected: [],
                dx_expr: null, 
                dy_expr: null,
            };
            this.updateGeometryInteractionUI();
            const button = this.geometryPanel.querySelector(`.geo-btn[data-geo-type="${type}"]`);
            if (button) button.classList.add('active');
        } else {
             alert('此功能尚未实现。');
        }
    }
    
       handleGeometryClick(e) {
    this.highlightedObject = null;
    this.hideInfoMessage();

    const coords = this.getEventCoordinates(e);
        const mathX = (coords.x - this.offset.x) / this.scale;
        const mathY = (this.offset.y - coords.y) / this.scale;

        const state = this.geometryInteractionState;


        const selectOrCreatePoint = () => {
            let selectedPointName = '';
            const clickedObject = this.findObjectNearClick(coords);
            
            if (clickedObject && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(clickedObject.geometryType)) {
                selectedPointName = clickedObject.name;
            } else {
                const newPointName = this.autonamePoint();
                let definition = '';
                 if (clickedObject && !['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    let param = 0;
                    const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

                    if (lineLike.includes(clickedObject.geometryType)) {
                        const { p1 } = clickedObject;
                        const dir_vec = clickedObject.dir_vec || clickedObject.dir;
                        const lenSq = dir_vec.x**2 + dir_vec.y**2;
                        if (lenSq > 1e-9) {
                            param = ((mathX - p1.x_val) * dir_vec.x + (mathY - p1.y_val) * dir_vec.y) / lenSq;
                        }
} else if (clickedObject.geometryType === 'circle') {
                    const { center } = clickedObject;
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'ellipse' || clickedObject.geometryType === 'ellipse_ab') {
                    const { center, a, b, rotation } = clickedObject;
                    const relX = mathX - center.x;
                    const relY = mathY - center.y;
                    const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                    const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                    let angle = Math.atan2(localY / b, localX / a);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'hyperbola') {                        const { center, b, rotation, f1, f2 } = clickedObject;
                        const d1 = Math.hypot(mathX - f1.x_val, mathY - f1.y_val);
                        const d2 = Math.hypot(mathX - f2.x_val, mathY - f2.y_val);
                        const branch_sign = Math.sign(d1 - d2) || 1;
                        const relY = mathY - center.y;
                        const localY = (mathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        let t = Math.asinh(localY / b);

                        const magic_offset = 100000;
                        let param_to_store = t;
                        if (branch_sign === -1) {
                           param_to_store = t - magic_offset;
                        }
                        param = param_to_store;
                    } else if (clickedObject.geometryType === 'parabola') {
                        const { vertex, rotation } = clickedObject;
                        const relX = mathX - vertex.x;
                        const relY = mathY - vertex.y;
                        const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        param = localY;
} else if (clickedObject.geometryType === 'circulararc') {
                        const { center } = clickedObject;
                        let click_angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                        let { startAngle, endAngle } = clickedObject;
                        
                        if (endAngle < startAngle) endAngle += 2 * Math.PI;
                        
                        let angleDiff = click_angle - startAngle;
                        while (angleDiff < -1e-9) angleDiff += 2 * Math.PI;
                        while (angleDiff >= 2 * Math.PI - 1e-9) angleDiff -= 2 * Math.PI;

                        const arcSpan = endAngle - startAngle;

                        if (angleDiff >= -1e-9 && angleDiff <= arcSpan + 1e-9) {
                            let param = angleDiff / arcSpan;
                            param = Math.max(0, Math.min(1, param)); 
                            definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                        } else {
                            definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                        }
                    }
                    definition = `point(${newPointName},${clickedObject.name},${param.toPrecision(8)})`;
                } else {
                    definition = `point(${newPointName},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                }
                this.addEntry(definition);
                selectedPointName = newPointName;
            }
            return selectedPointName;
        };

        switch (state.type) {
            case 'point': {
                const clickedObject = this.findObjectNearClick(coords);
                const name = this.autonamePoint();
                let definition = '';

                if (clickedObject && !['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    let param = 0;
                    const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];

                    if (lineLike.includes(clickedObject.geometryType)) {
                        const { p1 } = clickedObject;
                        const dir_vec = clickedObject.dir_vec || clickedObject.dir;
                        const lenSq = dir_vec.x**2 + dir_vec.y**2;
                        if (lenSq > 1e-9) {
                            param = ((mathX - p1.x_val) * dir_vec.x + (mathY - p1.y_val) * dir_vec.y) / lenSq;
                        }
} else if (clickedObject.geometryType === 'circle') {
                    const { center } = clickedObject;
                    let angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'ellipse' || clickedObject.geometryType === 'ellipse_ab') {
                    const { center, a, b, rotation } = clickedObject;
                    const relX = mathX - center.x;
                    const relY = mathY - center.y;
                    const localX = relX * Math.cos(-rotation) - relY * Math.sin(-rotation);
                    const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                    let angle = Math.atan2(localY / b, localX / a);
                    if (angle < 0) angle += 2 * Math.PI;
                    param = angle / (2 * Math.PI);
                } else if (clickedObject.geometryType === 'hyperbola') {                        const { center, b, rotation, f1, f2 } = clickedObject;
                        const d1 = Math.hypot(mathX - f1.x_val, mathY - f1.y_val);
                        const d2 = Math.hypot(mathX - f2.x_val, mathY - f2.y_val);
                        const branch_sign = Math.sign(d1 - d2) || 1;
                        
                        const relY = mathY - center.y;
                        const localY = (mathX - center.x) * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        let t = Math.asinh(localY / b);
                        
                        const magic_offset = 100000;
                        let param_to_store = t;
                        if (branch_sign === -1) {
                            param_to_store = t - magic_offset;
                        }
                        param = param_to_store;

                    } else if (clickedObject.geometryType === 'parabola') {
                        const { vertex, rotation } = clickedObject;
                        const relX = mathX - vertex.x;
                        const relY = mathY - vertex.y;
                        const localY = relX * Math.sin(-rotation) + relY * Math.cos(-rotation);
                        param = localY;
                    } else if (clickedObject.geometryType === 'circulararc') {
                        const { center } = clickedObject;
                        let click_angle = Math.atan2(mathY - center.y_val, mathX - center.x_val);
                        let { startAngle, endAngle } = clickedObject;
                        
                        if (endAngle < startAngle) endAngle += 2 * Math.PI;
                        if (click_angle < startAngle) click_angle += 2 * Math.PI;

                        if (click_angle >= startAngle - 1e-9 && click_angle <= endAngle + 1e-9) {
                            let param = (click_angle - startAngle) / (endAngle - startAngle);
                            param = Math.max(0, Math.min(1, param)); 
                            definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                        } else {

                            definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                        }
                    }
                    
                    definition = `point(${name},${clickedObject.name},${param.toPrecision(8)})`;
                } else {
                    definition = `point(${name},${mathX.toPrecision(6)},${mathY.toPrecision(6)})`;
                }
                
                if (definition) {
                    this.addEntry(definition);
                }
                this.cancelGeometryInteraction();
                break;
            }
case 'intercept': {
                const clickedObject = this.findObjectNearClick(coords);

                if (!clickedObject || ['point', 'midpoint', 'intercept'].includes(clickedObject.geometryType)) {
                    alert('请选择一条线、圆或圆锥曲线。');
                    this.cancelGeometryInteraction();
                    return;
                }

                this.highlightedObject = clickedObject;
                this.showInfoMessage(`选中：${clickedObject.name}`);
                this.requestDraw();

                state.pointsSelected.push(clickedObject.name);
                state.clicksNeeded--;

                if (state.clicksNeeded > 0) {
                    state.prompt = `已选择 ${clickedObject.name}. 请选择第二个对象`;
                    this.updateGeometryInteractionUI();
                } else {
                    const obj1Name = state.pointsSelected[0];
                    const obj2Name = state.pointsSelected[1];

                    const obj1 = this.entries.find(e => e.name === obj1Name);
                    const obj2 = this.entries.find(e => e.name === obj2Name);

                    if (!obj1 || !obj2) {
                        alert('错误: 找不到所选对象。');
                        this.cancelGeometryInteraction();
                        return;
                    }
                    
                    const type1 = obj1.geometryType;
                    const type2 = obj2.geometryType;

                    const isLineLike = (t) => ['segment','ray','line','vector','perpendicularline','parallelline','anglebisector', 'fitline', 'tangent'].includes(t);
                    const isCircle = (t) => ['circle', 'circulararc'].includes(t);
                    const isConic = (t) => ['ellipse', 'hyperbola', 'parabola', 'ellipse_ab'].includes(t);

                    const hasTwoSolutions = 
                        (isLineLike(type1) && isCircle(type2)) ||
                        (isCircle(type1) && isLineLike(type2)) ||
                        (isCircle(type1) && isCircle(type2)) ||
                        (isLineLike(type1) && isConic(type2)) ||
                        (isConic(type1) && isLineLike(type2));

                    if (hasTwoSolutions) {
                        const name1 = this.autonamePoint();
                        this.addEntry(`intercept(${name1},${obj1Name},${obj2Name},1)`);
                        const name2 = this.autonamePoint();
                        this.addEntry(`intercept(${name2},${obj1Name},${obj2Name},-1)`);
                    } else {
                        const name = this.autonamePoint();
                        this.addEntry(`intercept(${name},${obj1Name},${obj2Name})`);
                    }
                    this.cancelGeometryInteraction();
                }
                break;
                        }            case 'midpoint': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = '已选择 ' + selectedPointName + '. 请选择第二个点';
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameMidpoint();
                        this.addEntry(`midpoint(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'segment':
            case 'ray':
            case 'line':
            case 'vector': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        const prompts = { 'segment': '请选择线段的终点', 'ray': '请选择射线上的另一点', 'line': '请选择直线上的另一点', 'vector': '请选择向量的终点' };
                        state.prompt = `已选择 ${selectedPointName}. ${prompts[state.type]}`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type[0]);
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'perpendicularline':
            case 'parallelline': {
                if (state.objectsSelected.length === 0) {
                   const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
    this.highlightedObject = clickedObject;
    this.showInfoMessage(`选中：${clickedObject.name}`);
    this.requestDraw();
    state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择线 ${clickedObject.name}. 请选择一个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        alert('请先选择一条线。');
                        this.cancelGeometryInteraction();
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonameByPrefix(state.type[0]);
                        this.addEntry(`${state.type}(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'anglebisector': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择顶点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择顶点 ${selectedPointName}. 请选择第三个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('l');
                        this.addEntry(`anglebisector(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'circle_pr': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择圆心 ${selectedPointName}. 请选择圆上的一点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('c');
                        this.addEntry(`circle(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'circle_cr': {
                const centerName = selectOrCreatePoint();
                if (centerName) {
                    const radiusExpr = prompt("请输入圆的半径 (可以是表达式):");
                    if (radiusExpr !== null && radiusExpr.trim() !== "") {
                        const name = this.autonameByPrefix('c');
                        this.addEntry(`circle(${name},${centerName},${radiusExpr})`);
                    }
                }
                this.cancelGeometryInteraction();
                break;
            }
            case 'ellipse':
            case 'hyperbola': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    const typeName = state.type === 'ellipse' ? '椭圆' : '双曲线';
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择第一个焦点 ${selectedPointName}. 请选择第二个焦点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择第二个焦点 ${selectedPointName}. 请选择${typeName}上的一点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type[0].toUpperCase());
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'parabola': {
                if (state.pointsSelected.length === 0) {
                    const focusName = selectOrCreatePoint();
                    if (focusName) {
                        state.pointsSelected.push(focusName);
                        state.clicksNeeded--;
                        state.prompt = `已选择焦点 ${focusName}. 请选择准线`;
                        this.updateGeometryInteractionUI();
                    }
                } else { 
const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
    this.highlightedObject = clickedObject;
    this.showInfoMessage(`选中：${clickedObject.name}`);
    this.requestDraw();
    state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        const name = this.autonameByPrefix('P');
                        this.addEntry(`parabola(${name},${state.pointsSelected[0]},${state.objectsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    } else {
                        alert('请选择一条线作为准线。');
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'polygon': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 2 && selectedPointName === state.pointsSelected[0]) {
                     
                        const name = this.autonameByPrefix('p');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`polygon(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个顶点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            } 
                        case 'fitline': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 1 && selectedPointName === state.pointsSelected[0]) {
                        const name = this.autonameByPrefix('l');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`fitline(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            }
             case 'circulararc': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择圆心 ${selectedPointName}. 请选择圆弧起始点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择起始点 ${selectedPointName}. 请选择圆弧终点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('arc');
                        this.addEntry(`circulararc(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }

case 'tangent': {
if (state.objectsSelected.length === 0) {
const clickedObject = this.findObjectNearClick(coords);
const conicLike = ['circle', 'ellipse', 'hyperbola', 'parabola', 'circulararc', 'ellipse_ab'];
if (clickedObject && conicLike.includes(clickedObject.geometryType)) {
this.highlightedObject = clickedObject;
this.showInfoMessage(`选中：${clickedObject.name}`);
this.requestDraw();
state.objectsSelected.push(clickedObject.name);
state.clicksNeeded--;
state.prompt = `已选择 ${clickedObject.name}. 请选择一个点`;
this.updateGeometryInteractionUI();
} else {
alert('请选择一个圆锥曲线或圆弧。');
this.cancelGeometryInteraction();
}
} else {
const selectedPointName = selectOrCreatePoint();
if (selectedPointName) {
state.pointsSelected.push(selectedPointName);
state.clicksNeeded--;
const name1 = this.autonameByPrefix('t');
this.addEntry(`tangent(${name1},${state.objectsSelected[0]},${state.pointsSelected[0]},1)`);
const name2 = this.autonameByPrefix('t');
this.addEntry(`tangent(${name2},${state.objectsSelected[0]},${state.pointsSelected[0]},-1)`);
this.cancelGeometryInteraction();
}
}
break;
}
        
case 'trace': {
                const clickedObject = this.findObjectNearClick(coords);
                if (clickedObject && ['point', 'midpoint', 'intercept', 'rotate', 'reflect', 'translate'].includes(clickedObject.geometryType)) {
                    this.highlightedObject = clickedObject;
                    this.showInfoMessage(`开始录制轨迹：${clickedObject.name}`);
                    this.requestDraw();
                    
                    this.traceState.active = true;
                    this.traceState.targetName = clickedObject.name;
                    this.traceState.path = [{x: clickedObject.x_val, y: clickedObject.y_val}];
                    this.traceState.lastRecordTime = 0;
                    
                    document.getElementById('stop-trace-btn').style.display = 'flex';
                    this.cancelGeometryInteraction();
                } else {
                     alert('请选择一个点。');
                     this.cancelGeometryInteraction();
                }
                break;
            }

            case 'isparallel':
            case 'isperpendicular': {
                const clickedObject = this.findObjectNearClick(coords);
const lineLike = ['segment', 'ray', 'line', 'vector', 'perpendicularline', 'parallelline', 'anglebisector', 'fitline', 'tangent'];
                if (clickedObject && lineLike.includes(clickedObject.geometryType)) {
                    this.highlightedObject = clickedObject;
                    this.showInfoMessage(`选中：${clickedObject.name}`);
                    this.requestDraw();

                    state.objectsSelected.push(clickedObject.name);
                    state.clicksNeeded--;

                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择线 ${clickedObject.name}. 请选择第二条线`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix(state.type);
                        this.addEntry(`${state.type}(${name},${state.objectsSelected[0]},${state.objectsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                } else {
                    alert('请选择一条线。');
                    this.cancelGeometryInteraction();
                }
                break;
            }
            case 'isconcyclic': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择 ${state.pointsSelected.length} 个点. 请选择下一个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('isconcyclic');
                        this.addEntry(`${state.type}(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]},${state.pointsSelected[3]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }case 'length': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择第二个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('l');
                        this.addEntry(`length(${name},${state.pointsSelected[0]},${state.pointsSelected[1]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'angle': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded === 2) {
                        state.prompt = `已选择点 ${selectedPointName}. 请选择顶点`;
                        this.updateGeometryInteractionUI();
                    } else if (state.clicksNeeded === 1) {
                        state.prompt = `已选择顶点 ${selectedPointName}. 请选择第三个点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const name = this.autonameByPrefix('a');
                        this.addEntry(`angle(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${state.pointsSelected[2]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'area': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    if (state.pointsSelected.length > 2 && selectedPointName === state.pointsSelected[0]) {
                     
                        const name = this.autonameByPrefix('s');
                        const pointList = state.pointsSelected.join(',');
                        this.addEntry(`area(${name},${state.pointsSelected.length},${pointList})`);
                        this.cancelGeometryInteraction();
                    } else if (state.pointsSelected.includes(selectedPointName)) {
                        state.prompt = `点 ${selectedPointName} 已被选择。请选择一个新点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    } else {
                        state.pointsSelected.push(selectedPointName);
                        state.prompt = `已选择 ${state.pointsSelected.length} 个顶点。请选择下一个点，或点击起始点 ${state.pointsSelected[0]} 结束。`;
                        this.updateGeometryInteractionUI();
                    }
                }
                break;
            }
            case 'rotate': {
                const selectedPointName = selectOrCreatePoint();
                if (selectedPointName) {
                    state.pointsSelected.push(selectedPointName);
                    state.clicksNeeded--;
                    if (state.clicksNeeded > 0) {
                        state.prompt = `已选择旋转中心 ${selectedPointName}. 请选择要旋转的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const angleStr = prompt("请输入旋转角度(度):", "90");
                        const angle = parseFloat(angleStr);
                        if (angleStr !== null && Number.isFinite(angle)) {
                            const name = this.autonamePoint();
                            this.addEntry(`rotate(${name},${state.pointsSelected[0]},${state.pointsSelected[1]},${angleStr})`);
                        }
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'reflect': {
                if (state.objectsSelected.length === 0) {
                    const clickedObject = this.findObjectNearClick(coords);
                    if (clickedObject) {
                        this.highlightedObject = clickedObject;
                        this.showInfoMessage(`选中：${clickedObject.name}`);
                        this.requestDraw();
                        state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择 ${clickedObject.name}. 请选择要作用的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        alert('请选择一个点或一条线作为对称基准。');
                        this.cancelGeometryInteraction();
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonamePoint();
                        this.addEntry(`reflect(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
            case 'translate': {
                if (state.objectsSelected.length === 0 && state.dx_expr === null) {
                    const clickedObject = this.findObjectNearClick(coords);
                    const vectorLike = ['vector', 'ray'];
                    if (clickedObject && vectorLike.includes(clickedObject.geometryType)) {
                        this.highlightedObject = clickedObject;
                        this.showInfoMessage(`选中：${clickedObject.name}`);
                        this.requestDraw();
                        state.objectsSelected.push(clickedObject.name);
                        state.clicksNeeded--;
                        state.prompt = `已选择向量 ${clickedObject.name}. 请选择要平移的点`;
                        this.updateGeometryInteractionUI();
                    } else {
                        const dxStr = prompt("未选择向量。请输入平移的 dx 值:", "1");
                        if (dxStr !== null) {
                            const dyStr = prompt("请输入平移的 dy 值:", "1");
                            if (dyStr !== null) {
                                state.dx_expr = dxStr;
                                state.dy_expr = dyStr;
                                state.clicksNeeded--;
                                state.prompt = `平移量为 (${dxStr}, ${dyStr}). 请选择要平移的点`;
                                this.updateGeometryInteractionUI();
                            } else {
                                this.cancelGeometryInteraction();
                            }
                        } else {
                            this.cancelGeometryInteraction();
                        }
                    }
                } else {
                    const selectedPointName = selectOrCreatePoint();
                    if (selectedPointName) {
                        state.pointsSelected.push(selectedPointName);
                        state.clicksNeeded--;
                        const name = this.autonamePoint();
                        if (state.objectsSelected.length > 0) {
                            this.addEntry(`translate(${name},${state.objectsSelected[0]},${state.pointsSelected[0]})`);
                        } else {
                            this.addEntry(`translate(${name},${state.pointsSelected[0]},${state.dx_expr},${state.dy_expr})`);
                        }
                        this.cancelGeometryInteraction();
                    }
                }
                break;
            }
        }
    }

}
let archInstance = null;

document.addEventListener('DOMContentLoaded', () => {
    const mainContentTitle = document.getElementById('main-content-title');
    const sidebarNavButtons = document.getElementById('sidebar-nav-buttons');
    const navBtnPlot = document.getElementById('nav-btn-plot');
    const navBtnGeometry = document.getElementById('nav-btn-geometry');
    const navBtnAbout = document.getElementById('nav-btn-about');
    const navBtnFile = document.getElementById('nav-btn-file');
    const navBtnSettings = document.getElementById('nav-btn-settings');
    const navBtnCollapse = document.getElementById('nav-btn-collapse');
    const showSidebarBtn = document.getElementById('show-sidebar-btn');
    const navBtnCode = document.getElementById('nav-btn-code');

    const keyboardToggleBtn = document.getElementById('keyboard-toggle-btn');
    const keyboardToggleContainer = document.getElementById('keyboard-toggle-container');
    const keyboard = document.getElementById('keyboard');
    const keyboardPageBtns = keyboard.querySelectorAll('.keyboard-page-btn');
    const keyboardContentPages = keyboard.querySelectorAll('.keyboard-page-content');
    const keyboardInputDisplay = document.getElementById('keyboard-input-display');
    const keyboardInputPromptBtn = document.getElementById('keyboard-input-prompt-btn');
    const keyboardCopyBtn = document.getElementById('keyboard-copy-btn');
    const keyboardPasteBtn = document.getElementById('keyboard-paste-btn');
    const kbdDynamicOps = keyboard.querySelectorAll('.kbd-dynamic-op');
    const allKeyboardKeys = keyboard.querySelectorAll('.keyboard-page-content .btn');

    const keyboardShiftBtn = document.getElementById('keyboard-shift-btn'); 
const kbdPage3SwitchKeys = keyboard.querySelectorAll('.kbd-p3-switch');

    const kbdCharKeys = keyboard.querySelectorAll('#keyboard-page-3 .kbd-char'); 
    const keyboardPage2ShiftBtn = document.getElementById('keyboard-page2-shift-btn'); 
    const kbdCharPage2Keys = keyboard.querySelectorAll('#keyboard-page-2 .kbd-char-page2'); 
    const newFileBtn = document.getElementById('new-file-btn');
    const loadFileBtnMenu = document.getElementById('load-file-btn'); 
    const saveFileBtnMenu = document.getElementById('save-file-btn'); 

    let isKeyboardOpen = false;
    let keyboardSubmitCallback = null;
    let currentKeyboardPage = 1;
    let keyboardBuffer = "";
    let cursorPosition = 0;
    let isShiftActive = false; 
    let isPage2ShiftActive = false; 
    let keyboardInputStringForarch = "";

    const page2ShiftMapping = {
        "sin(": { shiftedText: "max", shiftedKey: "max(" },
        "cos(": { shiftedText: "min", shiftedKey: "min(" },
        "tan(": { shiftedText: "root", shiftedKey: "root(" },
        "cot(": { shiftedText: "beta", shiftedKey: "beta(" },
        "sec(": { shiftedText: "zeta", shiftedKey: "zeta(" },
        "csc(": { shiftedText: "erf", shiftedKey: "erf(" },
        "asin(": { shiftedText: "erfc", shiftedKey: "erfc(" },
        "acos(": { shiftedText: "lambertw", shiftedKey: "lambertw(" },
        "atan(": { shiftedText: "sinintegral", shiftedKey: "sinintegral(" },
        "acot(": { shiftedText: "cosintegral", shiftedKey: "cosintegral(" },
        "asec(": { shiftedText: "expintegral", shiftedKey: "expintegral(" },
        "acsc(": { shiftedText: "li", shiftedKey: "li(" },
        "sinh(": { shiftedText: "psi", shiftedKey: "psi(" },
        "cosh(": { shiftedText: "fresnels", shiftedKey: "fresnels(" },
        "tanh(": { shiftedText: "fresnelc", shiftedKey: "fresnelc(" },
        "coth(": { shiftedText: "elliptick", shiftedKey: "elliptick(" },
        "sech(": { shiftedText: "elliptice", shiftedKey: "elliptice(" },
        "csch(": { shiftedText: "heaviside", shiftedKey: "heaviside(" },
        "asinh(": { shiftedText: "normdist", shiftedKey: "normdist(" },
        "acosh(": { shiftedText: "tdist", shiftedKey: "tdist(" },
        "atanh(": { shiftedText: "chisqdist", shiftedKey: "chisqdist(" },
        "acoth(": { shiftedText: "lognormdist", shiftedKey: "lognormdist(" },
        "asech(": { shiftedText: "gammadist", shiftedKey: "gammadist(" },
        "acsch(": { shiftedText: "diffat", shiftedKey: "diffat(" },
    };


    function updateShiftButtonVisual() { 
        if(!keyboardShiftBtn) return;
        if (isShiftActive) keyboardShiftBtn.classList.add('active-shift');
        else keyboardShiftBtn.classList.remove('active-shift');
    }

    function updateKeyboardCharKeysCase() { 
        kbdCharKeys.forEach(keyBtn => { 
            const baseChar = keyBtn.getAttribute('data-original-key') || keyBtn.dataset.key; 
            keyBtn.textContent = isShiftActive ? baseChar.toUpperCase() : baseChar.toLowerCase(); 
        });
    }

    function updatePage3ShiftVisual() {
        kbdPage3SwitchKeys.forEach(btn => {
            if (isShiftActive && currentKeyboardPage === 3) {
                btn.textContent = btn.dataset.shiftKey;
                btn.dataset.key = btn.dataset.shiftKey;
            } else {
                btn.textContent = btn.dataset.originalKey;
                btn.dataset.key = btn.dataset.originalKey;
            }
        });
    }

    function updatePage2ShiftButtonVisual() {
        if (!keyboardPage2ShiftBtn) return;
        if (isPage2ShiftActive) keyboardPage2ShiftBtn.classList.add('active-shift');
        else keyboardPage2ShiftBtn.classList.remove('active-shift');
    }

    function updateKeyboardPage2CharKeysAndDataKeys() {
        const isPortrait = document.body.classList.contains('portrait-mode');
        const portraitAbbreviations = {
            "lambertw": "ltw", "sinintegral": "si", "cosintegral": "ci",
            "expintegral": "ei", "fresnels": "sfn", "fresnelc": "cfn",
            "elliptick": "kint", "elliptice": "eint", "heaviside": "heav",
            "normdist": "norm", "chisqdist": "chisq", "lognormdist": "lognm",
            "gammadist": "gmdst"
        };

        kbdCharPage2Keys.forEach(keyBtn => {
            const originalKey = keyBtn.getAttribute('data-original-key');
            const originalText = keyBtn.getAttribute('data-original-text');
            if (isPage2ShiftActive && page2ShiftMapping[originalKey]) {
                const shiftedInfo = page2ShiftMapping[originalKey];
                keyBtn.dataset.key = shiftedInfo.shiftedKey;
                
                if (isPortrait && portraitAbbreviations[shiftedInfo.shiftedText]) {
                    keyBtn.textContent = portraitAbbreviations[shiftedInfo.shiftedText];
                } else {
                    keyBtn.textContent = shiftedInfo.shiftedText;
                }
            } else {
                keyBtn.textContent = originalText;
                keyBtn.dataset.key = originalKey;
            }
        });

        if (kbdDynamicOps.length >= 3) {
            if (isPage2ShiftActive) {
                kbdDynamicOps[0].textContent = "sum"; kbdDynamicOps[0].dataset.key = "sum(";
                kbdDynamicOps[1].textContent = "prod"; kbdDynamicOps[1].dataset.key = "prod(";
                kbdDynamicOps[2].textContent = "int"; kbdDynamicOps[2].dataset.key = "int(";
            } else {
                kbdDynamicOps[0].textContent = "range"; kbdDynamicOps[0].dataset.key = "range(";
                kbdDynamicOps[1].textContent = "llim"; kbdDynamicOps[1].dataset.key = "llim(";
                kbdDynamicOps[2].textContent = "ulim"; kbdDynamicOps[2].dataset.key = "ulim(";
            }
        }
    }
    
    function escapeHtml(unsafe) {
        return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function updateKeyboardInputDisplay() {
        let displayHTML = "";
        for (let i = 0; i < keyboardBuffer.length; i++) {
            if (i === cursorPosition) {
                displayHTML += '<span class="cursor"></span>';
            }
            displayHTML += `<span class="char-span" data-index="${i}">${escapeHtml(keyboardBuffer[i])}</span>`;
        }
        if (cursorPosition === keyboardBuffer.length) {
            displayHTML += '<span class="cursor"></span>';
        }
        keyboardInputDisplay.innerHTML = displayHTML || '<span class="cursor"></span>';
        const cursorEl = keyboardInputDisplay.querySelector('.cursor');
        if (cursorEl) {
            cursorEl.scrollIntoView({ behavior: 'smooth', inline: 'nearest', block: 'nearest' });
        }
    }

    function setActiveKeyboardPage(pageNumberStr) {
        currentKeyboardPage = parseInt(pageNumberStr);
        keyboardPageBtns.forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.kpage) === currentKeyboardPage) btn.classList.add('active');
        });
        keyboardContentPages.forEach(page => {
            page.classList.remove('active');
            if (page.id === `keyboard-page-${currentKeyboardPage}`) page.classList.add('active');
        });
        isShiftActive = false; updateShiftButtonVisual(); updateKeyboardCharKeysCase();updatePage3ShiftVisual();
        isPage2ShiftActive = false; updatePage2ShiftButtonVisual(); updateKeyboardPage2CharKeysAndDataKeys();
    }

    function updateKeyboardToggleVisibility() {
        if (!archInstance) return;
        
        const container = document.getElementById('keyboard-toggle-container');
        if (!container) return;

        // 条件 1: 必须处于“绘图”模式
        const isPlotMode = archInstance.currentUIMode === 'plot';
        
        // 条件 2: 侧栏必须是“展开”状态 (body 标签上没有 sidebar-hidden 类)
        const isSidebarExpanded = !document.body.classList.contains('sidebar-hidden');

        // 条件 3: 键盘必须是“关闭”状态
        // (虽然层级调整了，但在输入时隐藏新建按钮是标准交互体验，也能防止误触)
        const isKeyboardClosed = !isKeyboardOpen;

        // 综合判定：同时满足三个条件才显示
        if (isPlotMode && isSidebarExpanded && isKeyboardClosed) {
            // 强制使用 flex 布局以保持横向排列
            container.style.setProperty('display', 'flex', 'important');
        } else {
            // 强制隐藏
            container.style.setProperty('display', 'none', 'important');
        }
    }
    window.updateKeyboardToggleVisibility = updateKeyboardToggleVisibility;


    function openKeyboard(initialValue = "", callback = null) { 
        isKeyboardOpen = true;
        keyboard.classList.add('open');
        keyboardBuffer = String(initialValue); 
        keyboardSubmitCallback = callback; 
        cursorPosition = keyboardBuffer.length; 
        keyboardInputStringForarch = ""; 
        
        isShiftActive = false; updateShiftButtonVisual(); updateKeyboardCharKeysCase();updatePage3ShiftVisual();
        isPage2ShiftActive = false; updatePage2ShiftButtonVisual(); updateKeyboardPage2CharKeysAndDataKeys();
        setActiveKeyboardPage(1);
        updateKeyboardInputDisplay();
        updateKeyboardToggleVisibility();
    }

    function closeKeyboard(submit = false) {
        isKeyboardOpen = false;
        keyboard.classList.remove('open');

        if (submit) {
            if (keyboardSubmitCallback) {
                keyboardSubmitCallback(keyboardBuffer);
            } else if (archInstance && archInstance.editingEntryIndex !== -1) {
                archInstance.applyEditToEntry(keyboardBuffer);
            } else if (archInstance && keyboardBuffer.trim() !== "") {
                archInstance.addEntry(keyboardBuffer);
            }
        }
        
        keyboardSubmitCallback = null; 
        if (archInstance) archInstance.editingEntryIndex = -1;
        keyboardBuffer = "";
        keyboardInputStringForarch = "";

        isShiftActive = false;
        updatePage3ShiftVisual();
        isPage2ShiftActive = false;
        updateKeyboardToggleVisibility();
    }

    function toggleKeyboard() {
        if (isKeyboardOpen) closeKeyboard(false);
        else openKeyboard(); 
    }


    window.globalOpenKeyboardForEdit = function(initialValue) {
        openKeyboard(initialValue); 
    };
    window.globalOpenKeyboardForValue = function(initialValue, callback) {
        openKeyboard(initialValue, callback);
    };


    try {
        archInstance = new ArchEngine();
    } catch (error) {
        console.error("绘图程序初始化错误: ", error);
        alert("绘图程序初始化错误，请检查控制台");
    }

    class StageController {
        constructor(archEngine) {
            this.engine = archEngine;
            this.workspaces = [];
            this.activeWorkspaceId = null;
            this.container = document.getElementById('stage-manager-container');
            this.toggleBtn = document.getElementById('stage-mode-toggle-btn');
            this.addButton = null;
            this.domElements = new Map(); 
            

            this.scrollOffset = 0;
            this.maxScrollOffset = 0;
            

            this.touchStartY = 0;
            this.lastScrollOffset = 0;


            const initialId = 'ws-' + Date.now();
            this.workspaces.push({
                id: initialId,
                name: this.engine.filename,
                data: null, 
                image: null 
            });
            this.activeWorkspaceId = initialId;

            this.setupUI();
        }

        setupUI() {
          
            this.toggleBtn.innerHTML = '<img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMC4wNDk0IiBoZWlnaHQ9IjIwLjA0OTQiIHZpZXdCb3g9IjAsMCwyMC4wNDk0LDIwLjA0OTQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMjkuOTc1MywtMTY5Ljk3NTMpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxwYXRoIGQ9Ik0yMjkuOTc1MywxOTAuMDI0N3YtMjAuMDQ5NGgyMC4wNDk0djIwLjA0OTR6IiBmaWxsLW9wYWNpdHk9IjAuMDMxMzciIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIi8+PHBhdGggZD0iTTI0NC40NjA0MiwxODQuMTMxMTVjMS4wMzU0OSwtMC4zNTc4OSAxLjc4OTc2LC0xLjM0NDc4IDEuODEyOTgsLTIuNTIxMTRjMC4wMDAzNSwtMC4wMTg0NSAwLjAwMDU1LC0wLjAzNjg2IDAuMDAwNTUsLTAuMDU1MjRsLTAuMDIxNzksLTUuMDk5NDNjMC4wMDAyMSwtMC4wMTE4NyAwLjAwMDMzLC0wLjAyMzc1IDAuMDAwMzgsLTAuMDM1NjVjMC4wMDYyOSwtMS41MDE5NyAtMS4xODU3NywtMi43MjQ3NSAtMi42NjI1MywtMi43MzExN2MtMC4wMTgxNSwtMC4wMDAwNyAtMC4wMzYyNSwwLjAwMDAzIC0wLjA1NDMzLDAuMDAwMzJsLTUuMTA5NDgsMC4wMDE4NmMtMC4wMTE2NiwtMC4wMDA1MyAtMC4wMjMzMywtMC4wMDA5OSAtMC4wMzUwMywtMC4wMDEzN2MtMS4wMDYzOCwtMC4wMzI2NyAtMS45MDA2MSwwLjUwNDYxIC0yLjM4MjcxLDEuMzI1NjZsMC40NDQ2MSwwLjkyMjEiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48cGF0aCBkPSJNMjQxLjY2ODM3LDE3NS43MjU5YzAuMDE4MDgsLTAuMDAwMjkgMC4wMzYxOCwtMC4wMDAzOSAwLjA1NDMzLC0wLjAwMDMyYzEuNDc2NzYsMC4wMDY0MiAyLjY2ODgyLDEuMjI5MiAyLjY2MjUzLDIuNzMxMTdjLTAuMDAwMDUsMC4wMTE5IC0wLjAwMDE3LDAuMDIzNzggLTAuMDAwMzgsMC4wMzU2NWwwLjAyMTc5LDUuMDk5NDNjMCwwLjAxODM4IC0wLjAwMDIsMC4wMzY3OSAtMC4wMDA1NSwwLjA1NTI0Yy0wLjAyOTY0LDEuNTAxNjkgLTEuMjUwNiwyLjY5NDYxIC0yLjcyNzEsMi42NjQ0NWMtMC4wMTE3LC0wLjAwMDI0IC0wLjAyMzM3LC0wLjAwMDU1IC0wLjAzNTA0LC0wLjAwMDk0bC01LjIzMjY1LDAuMDAwODZjLTAuMDE4MDgsMC4wMDAwNyAtMC4wMzYxOCwtMC4wMDAwNCAtMC4wNTQzMywtMC4wMDAzNGMtMS40NzY1OSwtMC4wMjQxOSAtMi42NTQzNCwtMS4yNjEyMiAtMi42MzA1NywtMi43NjMwM2MwLjAwMDIsLTAuMDExODkgMC4wMDA0NSwtMC4wMjM3NyAwLjAwMDc5LC0wLjAzNTY0bDAuMDM3NTYsLTUuMDk5MzVjMC4wMDAyMiwtMC4wMTgzOCAwLjAwMDYxLC0wLjAzNjc5IDAuMDAxMiwtMC4wNTUyNGMwLjA0NzEsLTEuNTAxMjMgMS4yODE4NywtMi42NzkzNyAyLjc1NzkxLC0yLjYzMTQ1YzAuMDExNywwLjAwMDM4IDAuMDIzMzcsMC4wMDA4NCAwLjAzNTAzLDAuMDAxMzd6IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PC9nPjwvZz48L3N2Zz48IS0tcm90YXRpb25DZW50ZXI6MTAuMDI0NzAwNDQ0Nzc2MTAxOjEwLjAyNDcwMDQ0NDc3NjEzLS0+" style="width:20px;height:20px;">';

this.toggleBtn.addEventListener('click', () => {
                if (this.engine.currentUIMode === 'annotation') {
                    this.engine.exitAnnotationMode();
                }
                
                if (this.engine.selectedAnnotationIndex !== -1) {
                    this.engine.selectedAnnotationIndex = -1;
                    this.engine.updateAnnotationEditMenu(); 
                    this.engine.requestDraw(); 
                }
                this.enterStageMode();
            });
            
            // 绑定鼠标滚轮事件
            this.container.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
            
            // 绑定触摸事件以支持手指滑动
            this.container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
            this.container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });

            this.addButton = document.createElement('div');
            this.addButton.className = 'sm-add-btn';
            this.addButton.innerHTML = '+';
            this.addButton.title = '新建绘图';
            this.addButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.addNewWorkspace();
            });
            this.container.appendChild(this.addButton);
            
            const hint = document.createElement('div');
            hint.className = 'sm-hint';
            hint.innerText = '点击右侧窗口返回全屏，点击左侧缩略图切换';
            this.container.appendChild(hint);
        }

        
        handleWheel(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            e.preventDefault();
            this.scrollOffset -= e.deltaY;
            this.applyScrollLimits();
            this.updateLayout();
        }

        handleTouchStart(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            if (e.touches.length > 0) {
                this.touchStartY = e.touches[0].clientY;
                this.lastScrollOffset = this.scrollOffset;
            }
        }

        handleTouchMove(e) {
            if (!document.body.classList.contains('stage-mode-active')) return;
            e.preventDefault();
            if (e.touches.length > 0) {
                const currentY = e.touches[0].clientY;
                const deltaY = currentY - this.touchStartY;
                

                this.scrollOffset = this.lastScrollOffset + deltaY;
                this.applyScrollLimits();
                this.updateLayout();
            }
        }

        applyScrollLimits() {

            if (this.scrollOffset > 0) this.scrollOffset = 0;
            if (this.scrollOffset < this.maxScrollOffset) this.scrollOffset = this.maxScrollOffset;
        }

    saveCurrentState() {
            const currentWS = this.workspaces.find(w => w.id === this.activeWorkspaceId);
            if (currentWS) {
                currentWS.data = this.engine.exportStateObject();
                currentWS.name = this.engine.filename;
                currentWS.image = this.engine.getScreenshot();

                currentWS.mode3d = this.engine.is3DMode;
            }
        }
          enterStageMode() {
            this.engine.stopTracing();
            this.saveCurrentState();
            this.syncDomElements(); 
            

            const currentWS = this.workspaces.find(w => w.id === this.activeWorkspaceId);
            const activeEl = this.domElements.get(this.activeWorkspaceId);
            if (activeEl && currentWS && currentWS.image) {
                activeEl.style.backgroundImage = `url(${currentWS.image})`;
                activeEl.style.backgroundColor = '#333';

                const spans = activeEl.querySelectorAll('span:not(.sm-name-label)');
                spans.forEach(s => s.remove());
            }

            if (activeEl) {
                activeEl.style.transition = 'none';
                activeEl.style.transform = 'translate3d(0, 0, 0) rotateY(0deg) scale(1)';
                activeEl.style.width = '100%';
                activeEl.style.height = '100%';
                activeEl.style.left = '0';
                activeEl.style.top = '0';
                activeEl.style.opacity = '1';
                
                activeEl.offsetHeight;
                activeEl.style.transition = ''; 
            }

            document.body.classList.add('stage-mode-active');
            
            requestAnimationFrame(() => {
                this.updateLayout();
            });
        }

        exitStageMode(targetId) {
            const targetWS = this.workspaces.find(w => w.id === targetId);
            if (!targetWS) return;

            this.activeWorkspaceId = targetId;
            
            const activeEl = this.domElements.get(targetId);
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            if (activeEl) {
                activeEl.style.transform = `translate3d(0px, 0px, 0) rotateY(0deg) scale(1)`;
                activeEl.style.width = `${w}px`;
                activeEl.style.height = `${h}px`;
                activeEl.style.left = '0px';
                activeEl.style.top = '0px';
                activeEl.style.zIndex = 1000;
            }

            this.workspaces.forEach(ws => {
                if (ws.id !== targetId) {
                    const el = this.domElements.get(ws.id);
                    if (el) {
                        const currentY = el.dataset.targetY || 0;
                        el.style.transform = `translate3d(-300px, ${currentY}px, 0) rotateY(25deg) scale(0.8)`;
                        el.style.opacity = '0';
                    }
                }
            });

          setTimeout(() => {

                this.engine.is3DMode = !!targetWS.mode3d;
this.engine.stopAllAudio();


                if (targetWS.data) {
                    this.engine.importStateObject(targetWS.data);
                    this.engine.categoryFilterMode = 0;
                this.engine.updateCategoryButtonIcon();
                } else {
                    this.engine.clearAllEntries();
                    this.engine.filename = targetWS.name;
                    this.engine.scale = 50;
                    this.engine.centerCanvas(); 
                    if(this.engine.fileNameDisplay) this.engine.fileNameDisplay.textContent = this.engine.filename;
                    this.engine.recalculateAll();
                }


                const viewModeCircle = document.getElementById('view-mode-toggle-circle');
                if (viewModeCircle) {
                    viewModeCircle.textContent = this.engine.is3DMode ? "2D" : "3D";
                }

                const navBtnGeometry = document.getElementById('nav-btn-geometry');
                if (navBtnGeometry) {
                    navBtnGeometry.style.display = this.engine.is3DMode ? 'none' : 'flex';
                }

                
                if (this.engine.is3DMode && this.engine.currentUIMode === 'geometry') {
                    this.engine.setUIMode('plot');
                    const navBtnPlot = document.getElementById('nav-btn-plot');
                    if (navBtnPlot && navBtnGeometry) {
                        navBtnGeometry.classList.remove('selected');
                        navBtnPlot.classList.add('selected');
                    }
                }

                if (this.engine.is3DMode) {
                    this.engine.recalculate3D();
                }
                this.engine.requestDraw();

                document.body.classList.remove('stage-mode-active');
            }, 500);
        }
        
        addNewWorkspace() {
            const newId = 'ws-' + Date.now();
            const date = new Date();
            const name = `Arch Graph ${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}-${this.workspaces.length + 1}`;
            
            this.workspaces.push({
                id: newId,
                name: name,
                data: null,
                image: NEW_WORKSPACE_THUMBNAIL_BASE64 || null 
            });
            
            this.syncDomElements();
            this.scrollOffset = 0;
            this.activeWorkspaceId = newId;
            
            const newEl = this.domElements.get(newId);
            if (newEl) {
                newEl.style.transition = 'none';
                newEl.style.transform = 'translate3d(100%, 0, 0) scale(0.8)';
                newEl.offsetHeight;
                newEl.style.transition = '';
            }

            this.updateLayout();
        }

        removeWorkspace(id) {
            if (this.workspaces.length <= 1) {
                alert("至少保留一个工作区");
                return;
            }

            const el = this.domElements.get(id);
            if (el) {
                el.style.transform = 'scale(0)';
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 300);
                this.domElements.delete(id);
            }

            const index = this.workspaces.findIndex(w => w.id === id);
            if (index !== -1) {
                this.workspaces.splice(index, 1);
            }

            if (this.activeWorkspaceId === id) {
                this.activeWorkspaceId = this.workspaces[this.workspaces.length - 1].id;
            }

            this.updateLayout();
        }

 syncDomElements() {
            this.workspaces.forEach(ws => {
                let el = this.domElements.get(ws.id);
                
                if (!el) {
                    el = document.createElement('div');
                    el.className = 'sm-window';
                    el.id = ws.id;

                    const closeBtn = document.createElement('div');
                    closeBtn.className = 'sm-close-btn';
                    closeBtn.title = '关闭';
                    closeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeWorkspace(ws.id);
                    });
                    el.appendChild(closeBtn);

                    const label = document.createElement('div');
                    label.className = 'sm-name-label';
                    el.appendChild(label);

                    el.addEventListener('click', () => {
                        if (this.activeWorkspaceId === ws.id) {
                            this.exitStageMode(ws.id);
                        } else {
                            this.activeWorkspaceId = ws.id;
                            this.updateLayout();
                        }
                    });
                    
                    el.style.width = '0px'; 
                    el.style.height = '0px';

                    this.container.appendChild(el);
                    this.domElements.set(ws.id, el);
                }

                const label = el.querySelector('.sm-name-label');
                if (label) label.innerText = ws.name;

              const bgImage = ws.image || NEW_WORKSPACE_THUMBNAIL_BASE64; 
        el.style.background = '';
        
        if (bgImage) {
            el.style.backgroundImage = `url(${bgImage})`;
            el.style.backgroundColor = '#333';
            
         
            el.style.backgroundSize = 'cover'; 
            
            el.style.backgroundPosition = 'center center';
            el.style.backgroundRepeat = 'no-repeat';
            
       
            const spans = el.querySelectorAll('span:not(.sm-name-label)');
            spans.forEach(s => s.remove());
        } else {
        
            el.style.background = 'linear-gradient(135deg, #2b2b2b 0%, #1a1a1a 100%)';
      
        
                }
            });
        }

        updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            const activeWidth = w * 0.65;
            const activeHeight = h * 0.65;
            const activeLeft = w * 0.28; 
            const activeTop = (h - activeHeight) / 2;

            const thumbDisplayWidth = 220;
            const thumbDisplayHeight = 160;
            const thumbLeft = 40;
            const thumbGap = 30;
            
            const thumbnails = this.workspaces.filter(ws => ws.id !== this.activeWorkspaceId);
            
            const availableHeight = h; 
            const totalContentHeight = thumbnails.length * (thumbDisplayHeight + thumbGap) + thumbGap + 100;
            
            if (totalContentHeight > availableHeight) {
                this.maxScrollOffset = -(totalContentHeight - availableHeight);
            } else {
                this.maxScrollOffset = 0;
                this.scrollOffset = 0;
            }
            
            let startThumbTop = (h - (thumbnails.length * (thumbDisplayHeight + thumbGap) - thumbGap)) / 2;
            if (this.maxScrollOffset < 0) {
                 startThumbTop = 100; 
            }

            this.workspaces.forEach((ws) => {
                const el = this.domElements.get(ws.id);
                if (!el) return;

                if (ws.id === this.activeWorkspaceId) {
                    el.className = 'sm-window stage-center';
                    el.style.width = `${activeWidth}px`;
                    el.style.height = `${activeHeight}px`;
                    el.style.transform = `translate3d(${activeLeft}px, ${activeTop}px, 0) rotateY(0deg) scale(1)`;
                    el.style.opacity = '1';
                    
                    el.dataset.targetX = activeLeft;
                    el.dataset.targetY = activeTop;
                } else {
                    el.className = 'sm-window stage-thumbnail';
                    
                    const index = thumbnails.findIndex(t => t.id === ws.id);
                    const targetTop = startThumbTop + index * (thumbDisplayHeight + thumbGap) + this.scrollOffset;
                    
                    el.style.width = `${thumbDisplayWidth}px`;
                    el.style.height = `${thumbDisplayHeight}px`;
                    
                    el.style.transform = `translate3d(${thumbLeft}px, ${targetTop}px, 0) rotateY(25deg) scale(0.9)`;
                    
                    if (targetTop < -200 || targetTop > h + 200) {
                        el.style.opacity = '0';
                        el.style.pointerEvents = 'none';
                    } else {
                        el.style.opacity = '1';
                        el.style.pointerEvents = 'auto';
                    }
                    
                    el.dataset.targetY = targetTop;
                }
            });
        }
    }

    const stageController = new StageController(archInstance);

    kbdCharPage2Keys.forEach(keyBtn => {
        keyBtn.setAttribute('data-original-key', keyBtn.dataset.key);
        keyBtn.setAttribute('data-original-text', keyBtn.textContent);
    });

    const portraitNavToggleBtn = document.getElementById('portrait-nav-toggle-btn');
    const portraitResizeHandle = document.getElementById('portrait-resize-handle');

    if (portraitResizeHandle && archInstance) {
        portraitResizeHandle.addEventListener('mousedown', e => archInstance.startSidebarResize(e));
        portraitResizeHandle.addEventListener('touchstart', e => archInstance.startSidebarResizeTouch(e), { passive: false });
    }
    
    if (portraitNavToggleBtn) {
        portraitNavToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sidebarNavButtons.classList.toggle('nav-visible');
            keyboardToggleContainer.classList.toggle('hidden-by-nav');
            portraitNavToggleBtn.classList.toggle('active');
            if (portraitNavToggleBtn.classList.contains('active')) {
                portraitNavToggleBtn.style.display = 'none';
            }
        });
    }

function updateInterfaceState() {
        if (!archInstance) return;
        window.updateInterfaceState = updateInterfaceState;

        sidebarNavButtons.querySelectorAll('.sidebar-nav-btn').forEach(btn => btn.classList.remove('selected'));
        
        let titleText = null;
        const mode = archInstance.currentUIMode;

        const modeToButtonMap = {
            plot: { btn: navBtnPlot, title: "绘图" },
            geometry: { btn: navBtnGeometry, title: "几何" },
            code: { btn: navBtnCode, title: "代码"},
            settings: { btn: navBtnSettings, title: "设置" },
            file: { btn: navBtnFile, title: "文件" },
            about: { btn: navBtnAbout, title: "关于" }
        };

        if (modeToButtonMap[mode]) {
            modeToButtonMap[mode].btn.classList.add('selected');
            titleText = modeToButtonMap[mode].title;
        }

        if (mainContentTitle) {
            if (titleText && !document.body.classList.contains('sidebar-hidden')) {
                mainContentTitle.textContent = titleText;
                mainContentTitle.style.display = 'block';
            } else {
                mainContentTitle.style.display = 'none';
            }
        }
        updateKeyboardToggleVisibility();
    }
    
function handleNavClick(mode) {
        if (archInstance && archInstance.currentUIMode === 'annotation') {
             archInstance.exitAnnotationMode();
        }

        if (isKeyboardOpen) closeKeyboard();
        archInstance.setUIMode(mode);
        updateInterfaceState();
        updateKeyboardToggleVisibility();

        if (archInstance && archInstance.isPortraitMode) {
            document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
            document.getElementById('keyboard-toggle-container').classList.remove('hidden-by-nav');
            const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
            portraitBtn.classList.remove('active');
            portraitBtn.style.display = 'flex';
        }
    }

    navBtnPlot.addEventListener('click', () => handleNavClick('plot'));
    navBtnGeometry.addEventListener('click', () => handleNavClick('geometry'));
    navBtnSettings.addEventListener('click', () => handleNavClick('settings'));
    navBtnFile.addEventListener('click', () => handleNavClick('file'));
    navBtnAbout.addEventListener('click', () => handleNavClick('about'));
    navBtnCode.addEventListener('click', () => handleNavClick('code'));

    navBtnCollapse.addEventListener('click', () => {
        if (isKeyboardOpen) closeKeyboard();
        document.body.classList.add('sidebar-hidden');
        archInstance.updateLayout(); 
        updateInterfaceState();
        if (archInstance && archInstance.isPortraitMode) {
            const portraitBtn = document.getElementById('portrait-nav-toggle-btn');
            portraitBtn.style.display = 'flex';
            portraitBtn.classList.remove('active');
            document.getElementById('sidebar-nav-buttons').classList.remove('nav-visible');
        }
    });

    showSidebarBtn.addEventListener('click', () => {
        document.body.classList.remove('sidebar-hidden');
        archInstance.updateLayout();
        updateInterfaceState();
    });

    keyboardToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleKeyboard(); });
    keyboardPageBtns.forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); setActiveKeyboardPage(btn.dataset.kpage); }); });
    keyboardInputPromptBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const userInput = prompt("请输入算式:", keyboardBuffer);
        if (userInput !== null) { 
            keyboardBuffer = userInput; 
            cursorPosition = keyboardBuffer.length; 
            updateKeyboardInputDisplay(); 
        }
    });

    keyboardInputDisplay.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = keyboardInputDisplay.getBoundingClientRect();
        const clickX = e.clientX - rect.left + keyboardInputDisplay.scrollLeft;
        const charSpans = Array.from(keyboardInputDisplay.querySelectorAll('.char-span'));
        let newCursorPos = keyboardBuffer.length;
        if (charSpans.length === 0) {
            newCursorPos = 0;
        } else {
             for (let i = 0; i < charSpans.length; i++) {
                const span = charSpans[i];
                const spanMidX = span.offsetLeft - keyboardInputDisplay.scrollLeft + span.offsetWidth / 2;
                 if (clickX < spanMidX) {
                    newCursorPos = i;
                    break;
                }
            }
        }
        cursorPosition = newCursorPos;
        updateKeyboardInputDisplay();
    });

    if (keyboardCopyBtn) {
        keyboardCopyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (navigator.clipboard) {
                navigator.clipboard.writeText(keyboardBuffer).then(() => {
                    const originalHTML = keyboardCopyBtn.innerHTML;
                    keyboardCopyBtn.textContent = "已复制";
                    setTimeout(() => keyboardCopyBtn.innerHTML = originalHTML, 1000);
                }).catch(err => {
                    console.error('Could not copy text: ', err);
                    alert("复制失败，请检查浏览器权限");
                });
            } else {
                alert("当前浏览器不支持剪贴板API");
            }
        });
    }

    if (keyboardPasteBtn) {
        keyboardPasteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (navigator.clipboard) {
                navigator.clipboard.readText().then(text => {
                    if (text) {
                        keyboardBuffer = text;
                        cursorPosition = keyboardBuffer.length;
                        updateKeyboardInputDisplay();
                    }
                }).catch(err => {
                    console.error('Failed to read clipboard contents: ', err);
                     alert("粘贴失败，请检查浏览器权限");
                });
            } else {
                 alert("当前浏览器不支持剪贴板API");
            }
        });
    }

    function handleVirtualKeyPress(keyBtn) {
        const keyValue = keyBtn.dataset.key; 
        if (keyValue === 'del') { 
            if (cursorPosition > 0) { 
               keyboardBuffer = keyboardBuffer.substring(0, cursorPosition - 1) + keyboardBuffer.substring(cursorPosition); 
               cursorPosition--; 
            }
        } else if (keyValue === 'enter') { 
            closeKeyboard(true); 
        } else if (keyValue === '←') { 
            if (cursorPosition > 0) cursorPosition--; 
        } else if (keyValue === '→') { 
            if (cursorPosition < keyboardBuffer.length) cursorPosition++; 
        } else if (keyValue === 'shift' && keyBtn.id === 'keyboard-shift-btn') { 
            isShiftActive = !isShiftActive; 
            updateShiftButtonVisual(); 
            updateKeyboardCharKeysCase(); 
             updatePage3ShiftVisual();
        } else if (keyValue === 'shift_page2' && keyBtn.id === 'keyboard-page2-shift-btn') { 
            isPage2ShiftActive = !isPage2ShiftActive;
            updatePage2ShiftButtonVisual();
            updateKeyboardPage2CharKeysAndDataKeys();
        } else {
            let charToInsert = keyValue;
            if (keyValue === '×') charToInsert = '*'; 
            if (keyValue === '÷') charToInsert = '/';
            if (keyBtn.classList.contains('kbd-char') && currentKeyboardPage === 3) {
                 const originalKeyForPage3 = keyBtn.getAttribute('data-original-key') || keyBtn.dataset.key;
                 charToInsert = isShiftActive ? originalKeyForPage3.toUpperCase() : originalKeyForPage3.toLowerCase();
            }
            keyboardBuffer = keyboardBuffer.substring(0, cursorPosition) + charToInsert + keyboardBuffer.substring(cursorPosition);
            cursorPosition += charToInsert.length;
        }
        updateKeyboardInputDisplay();
    }
    
    allKeyboardKeys.forEach(keyBtn => { keyBtn.addEventListener('click', (e) => { e.stopPropagation(); handleVirtualKeyPress(keyBtn); }); });

    document.addEventListener('keydown', (event) => {
        if (!isKeyboardOpen) return; 
        let handled = true; const key = event.key;
        if (key === 'Backspace') { 
            if (cursorPosition > 0) { 
               keyboardBuffer = keyboardBuffer.substring(0, cursorPosition - 1) + keyboardBuffer.substring(cursorPosition); 
               cursorPosition--; 
            }
        } else if (key === 'Enter') { 
            keyboardInputStringForarch = keyboardBuffer; 
            closeKeyboard(true); 
        } else if (key === 'ArrowLeft') { 
            if (cursorPosition > 0) cursorPosition--; 
        } else if (key === 'ArrowRight') { 
            if (cursorPosition < keyboardBuffer.length) cursorPosition++; 
        } else if (key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) { 
            keyboardBuffer = keyboardBuffer.substring(0, cursorPosition) + key + keyboardBuffer.substring(cursorPosition); 
            cursorPosition += key.length; 
        } else {
            handled = false;
        }
        if (handled) { 
            event.preventDefault(); 
            updateKeyboardInputDisplay(); 
        }
    });

document.addEventListener('keydown', (event) => {
        if (!archInstance || isKeyboardOpen) return;
        

        if (event.shiftKey && event.code === 'Space') {
            const isPlotMode = archInstance.currentUIMode === 'plot';
            const isSidebarVisible = !document.body.classList.contains('sidebar-hidden');
            if (isPlotMode && isSidebarVisible) {
                event.preventDefault(); // 防止页面滚动
                toggleKeyboard();
                return;
            }
        }
        if (event.shiftKey && (event.key === 'R' || event.key === 'r')) {
             if (archInstance.is3DMode) {
                archInstance.camera3D = { rho: 40, theta: Math.PI/4, phi: Math.PI/3 };
                archInstance.center3D = { x: 0, y: 0, z: 0 };
                archInstance.offset3D = { x: 0, y: 0 };
                archInstance.scale3D = 1.0;
                archInstance.bounds3D = 8;
                archInstance.recalculate3D();
            } else {
                archInstance.scale = 100; 
                archInstance.centerCanvas();
            }
            archInstance.clearPlotData();
            archInstance.requestDraw();
            event.preventDefault();
            return;
        }

        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

        const panAmount = 20;
        const zoomFactor = 1.1;
        let handled = false;


        if (archInstance.is3DMode) {
             const moveStep = panAmount / archInstance.scale3D; 
             switch (event.key) {
                case 's': archInstance.offset3D.y -= moveStep*0.04; handled = true; break;
                case 'w': archInstance.offset3D.y += moveStep*0.04; handled = true; break;
                case 'd': archInstance.offset3D.x += moveStep*0.04; handled = true; break;
                case 'a': archInstance.offset3D.x -= moveStep*0.04; handled = true; break;
                
                case 'ArrowUp': 
                    archInstance.scale3D *= zoomFactor;
                    if (archInstance.scale3D > 100.0) archInstance.scale3D = 100.0;
                    handled = true;
                    break;
                case 'ArrowDown': 
                    archInstance.scale3D /= zoomFactor;
                    if (archInstance.scale3D < 0.001) archInstance.scale3D = 0.001;
                    handled = true;
                    break;
            }
             if (handled) {
                event.preventDefault();
                archInstance.recalculate3D();
                archInstance.requestDraw();
            }
        } 

        else {
            switch (event.key) {
                case 's': archInstance.offset.y -= panAmount; handled = true; break;
                case 'w': archInstance.offset.y += panAmount; handled = true; break;
                case 'd': archInstance.offset.x -= panAmount; handled = true; break;
                case 'a': archInstance.offset.x += panAmount; handled = true; break;
                
                case 'ArrowUp': {
                    const cssWidth = archInstance.canvas.clientWidth;
                    const cssHeight = archInstance.canvas.clientHeight;
                    const centerX = cssWidth / 2; const centerY = cssHeight / 2;
                    const centerXMath = (centerX - archInstance.offset.x) / archInstance.scale;
                    const centerYMath = (archInstance.offset.y - centerY) / archInstance.scale;
                    let newScale = archInstance.scale * zoomFactor;
                    newScale = Math.min(archInstance.maxScale, Math.max(archInstance.minScale, newScale));
                    archInstance.offset.x = centerX - centerXMath * newScale;
                    archInstance.offset.y = centerY + centerYMath * newScale;
                    archInstance.scale = newScale;
                    handled = true;
                    break;
                }
                case 'ArrowDown': {
                    const cssWidth = archInstance.canvas.clientWidth;
                    const cssHeight = archInstance.canvas.clientHeight;
                    const centerX = cssWidth / 2; const centerY = cssHeight / 2;
                    const centerXMath = (centerX - archInstance.offset.x) / archInstance.scale;
                    const centerYMath = (archInstance.offset.y - centerY) / archInstance.scale;
                    let newScale = archInstance.scale / zoomFactor;
                    newScale = Math.min(archInstance.maxScale, Math.max(archInstance.minScale, newScale));
                    archInstance.offset.x = centerX - centerXMath * newScale;
                    archInstance.offset.y = centerY + centerYMath * newScale;
                    archInstance.scale = newScale;
                    handled = true;
                    break;
                }
            }
            if (handled) {
                event.preventDefault();
                archInstance.clearPlotData();
                archInstance.requestDraw();
            }
        }
    });


    document.addEventListener('click', (e) => {
        const isSidebarNav = e.target.closest('#sidebar-nav-buttons');
        const isKeyboardToggle = e.target.closest('#keyboard-toggle-container');
        const isEditEntryButton = e.target.closest('.edit-btn');

        const isValueTrigger = e.target.closest('.frame-current-value') || 
                               e.target.closest('.frame-total-value') || 
                               e.target.closest('.frame-fps-value') || 
                               e.target.closest('.display-frame-value') ||
                               e.target.closest('.slice-val-value') || 
                               e.target.closest('#explicit-precision-value') ||
                               e.target.closest('#implicit-precision-value') ||
                               e.target.closest('#integral-precision-value') ||
                               e.target.closest('#preferred-color-value') ||
                               e.target.closest('#tmin-value') ||
                               e.target.closest('#tmax-value') ||
                               e.target.closest('.slider-min-value') || 
                               e.target.closest('.slider-max-value') || 
                               e.target.closest('.slider-step-value');

        if (isSidebarNav || isKeyboardToggle || isEditEntryButton || isValueTrigger) {
            return;
        }
        
        const targetIsSidebarRelated = e.target.closest('#sidebar') || e.target.closest('#sidebar-background');
        const targetIsKeyboardRelated = keyboard.contains(e.target);

        if (isKeyboardOpen && !targetIsKeyboardRelated) {
            const isTapOnKeyboardInput = e.target === keyboardInputDisplay || keyboardInputDisplay.contains(e.target);
            if (!isTapOnKeyboardInput) {
                closeKeyboard(false); 
            }
        }
    });

if (newFileBtn && archInstance) {
        newFileBtn.addEventListener('click', () => {
            archInstance.entries = []; archInstance.variables.clear();

            archInstance.annotations = [];
            archInstance.calcJSUtils.customFunctions = {}; archInstance.calcJSUtils.calc3 = [];
            ADVANCED_FUNCTION_DEFINITIONS.length = 22; 
            archInstance.initializeAdvancedCalcJSFunctions();
            archInstance.initializeCalcJSBuiltinFunctions(); 
            archInstance.recalculateAll();
            handleNavClick('plot');
        });
    }

    if (loadFileBtnMenu && archInstance) {
        loadFileBtnMenu.addEventListener('click', () => { 
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = re => {
                        archInstance.loadState(re.target.result);
                        handleNavClick('plot');
                    };
                    reader.readAsText(file);
                }
            };
            fileInput.click();
        }); 
    }
    
    if (saveFileBtnMenu && archInstance) {
        saveFileBtnMenu.addEventListener('click', () => { 
            archInstance.saveState(); 
            handleNavClick(archInstance.currentUIMode);
        }); 
    }

    updateKeyboardInputDisplay();
    updateInterfaceState();
});

</script>
</body>
</html>